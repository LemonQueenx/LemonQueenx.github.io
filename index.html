<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="乘风破浪">
<meta property="og:type" content="website">
<meta property="og:title" content="立夏">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="立夏">
<meta property="og:description" content="乘风破浪">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="立夏">
<meta name="twitter:description" content="乘风破浪">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>立夏</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">立夏</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-窝">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            窝
          </a>
        </li>
      
        
        <li class="menu-item menu-item-签">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-类">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-档">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-于">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/26/frame/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lemon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/background10.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="立夏">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/26/frame/" itemprop="url">frame</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-26T19:22:28+08:00">
                2020-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/3）前端-周边/" itemprop="url" rel="index">
                    <span itemprop="name">3）前端 - 周边</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/22/ts/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lemon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/background10.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="立夏">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/22/ts/" itemprop="url">ts</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-22T12:02:11+08:00">
                2020-07-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/1）前端-基础/" itemprop="url" rel="index">
                    <span itemprop="name">1）前端 - 基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第一节、-准备"><a href="#第一节、-准备" class="headerlink" title="第一节、 准备"></a><font color="#FF69B4">第一节、 准备</font></h1><h2 id="一、-安装"><a href="#一、-安装" class="headerlink" title="一、 安装"></a>一、 安装</h2><p>  npm install -g typescript<br>  tsc greeter.ts</p>
<h2 id="二、引入TS"><a href="#二、引入TS" class="headerlink" title="二、引入TS"></a>二、引入TS</h2><h3 id="React-amp-webpack"><a href="#React-amp-webpack" class="headerlink" title="React&amp;webpack"></a>React&amp;webpack</h3><blockquote>
<p>这里我们只学习TypeScript和React还有webpack怎样结合在一起使用。<br>现在cra已经可以支持ts了，npx create-react-app my-app –typescript。<br>不过，我们还是可以自己来搭建一遍。</p>
</blockquote>
<h4 id="初始化项目结构"><a href="#初始化项目结构" class="headerlink" title="初始化项目结构"></a>初始化项目结构</h4><p>例如，我们先初始化一个下面这样的项目结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">project/</span><br><span class="line">├─ dist/</span><br><span class="line">└─ src/</span><br><span class="line">   └─ components/</span><br></pre></td></tr></table></figure></p>
<p>  mkdir project<br>  cd project<br>  mkdir src<br>  cd src<br>  mkdir components<br>  cd ..</p>
<p>Webpack会帮助我们生成dist目录。</p>
<h4 id="初始化工程"><a href="#初始化工程" class="headerlink" title="初始化工程"></a>初始化工程</h4><p>  npm init</p>
<h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><p>  npm install -g webpack<br>  npm install –save react react-dom @types/react @types/react-dom</p>
<ul>
<li>使用@types/前缀表示我们额外要获取React和React-DOM的声明文件。 通常当你导入像 “react”这样的路径，它会查看react包； 然而，并不是所有的包都包含了声明文件，所以TypeScript还会查看 @types/react包。 你会发现我们以后将不必在意这些。</li>
</ul>
<p>  npm install –save-dev typescript awesome-typescript-loader source-map-loader</p>
<ul>
<li>awesome-typescript-loader可以让Webpack使用TypeScript的标准配置文件 tsconfig.json编译TypeScript代码。<br>source-map-loader使用TypeScript输出的sourcemap文件来告诉webpack何时生成自己的sourcemaps。 这就允许你在调试最终生成的文件时就好像在调试TypeScript源码一样。</li>
</ul>
<h4 id="添加TypeScript配置文件"><a href="#添加TypeScript配置文件" class="headerlink" title="添加TypeScript配置文件"></a>添加TypeScript配置文件</h4><blockquote>
<p>我们想将TypeScript文件整合到一起 - 这包括我们写的源码和必要的声明文件。</p>
<p>我们需要创建一个tsconfig.json文件，它包含了输入文件列表以及编译选项。 在工程根目录下新建文件 tsconfig.json文件，添加以下内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"compilerOptions"</span>:</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"outDir"</span>: <span class="string">"./dist/"</span>,</span><br><span class="line">      <span class="string">"sourceMap"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">"noImplicitAny"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">"module"</span>: <span class="string">"commonjs"</span>,</span><br><span class="line">      <span class="string">"target"</span>: <span class="string">"es5"</span>,</span><br><span class="line">      <span class="string">"lib"</span>: [<span class="string">"es6"</span>, <span class="string">"es2015"</span>, <span class="string">"dom"</span>, <span class="string">"es2015.promise"</span>],</span><br><span class="line">      <span class="string">"jsx"</span>: <span class="string">"react"</span></span><br><span class="line">    &#125;,</span><br><span class="line">  <span class="string">"include"</span>: [ <span class="string">"./src/**/*"</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>可以看官方文档中有关<a href="https://www.tslang.cn/docs/handbook/tsconfig-json.html" target="_blank" rel="noopener">tsconfig.json</a>更多的配置说明。</p>
<h4 id="写些代码"><a href="#写些代码" class="headerlink" title="写些代码"></a>写些代码</h4><p>src/components/Hello.tsx<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import * as React from <span class="string">"react"</span>;</span><br><span class="line"><span class="built_in">export</span> interface HelloProps &#123;</span><br><span class="line">  compiler: string;</span><br><span class="line">  framework: string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">export</span> const Hello = (props: HelloProps) =&gt; &lt;h1&gt;Hello from &#123;props.compiler&#125; and &#123;props.framework&#125;!&lt;/h1&gt;;</span><br><span class="line"></span><br><span class="line">这个例子使用了无状态的功能组件，我们可以让它更像一点类。</span><br><span class="line"></span><br><span class="line">import * as React from <span class="string">"react"</span>;</span><br><span class="line"><span class="built_in">export</span> interface HelloProps &#123; compiler: string; framework: string; &#125;</span><br><span class="line"></span><br><span class="line">// <span class="string">'HelloProps'</span> describes the shape of props.</span><br><span class="line">// State is never <span class="built_in">set</span> so we use the <span class="string">'&#123;&#125;'</span> <span class="built_in">type</span>.</span><br><span class="line"><span class="built_in">export</span> class Hello extends React.Component&lt;HelloProps, &#123;&#125;&gt; &#123;</span><br><span class="line">  <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &lt;h1&gt;Hello from &#123;this.props.compiler&#125; and &#123;this.props.framework&#125;!&lt;/h1&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>src/index.tsx<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import * as React from <span class="string">"react"</span>;</span><br><span class="line">import * as ReactDOM from <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line">import &#123; Hello &#125; from <span class="string">"./components/Hello"</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Hello compiler=<span class="string">"TypeScript"</span> framework=<span class="string">"React"</span> /&gt;,</span><br><span class="line">    document.getElementById(<span class="string">"example"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>index.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Hello React!&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Dependencies --&gt;</span><br><span class="line">    &lt;script src=&quot;./node_modules/react/umd/react.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;./node_modules/react-dom/umd/react-dom.development.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Main --&gt;</span><br><span class="line">    &lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="创建一个webpack配置文件"><a href="#创建一个webpack配置文件" class="headerlink" title="创建一个webpack配置文件"></a>创建一个webpack配置文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: <span class="string">"./src/index.tsx"</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">"bundle.js"</span>,</span><br><span class="line">    path: __dirname + <span class="string">"/dist"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line"></span><br><span class="line">  // Enable sourcemaps <span class="keyword">for</span> debugging webpack<span class="string">'s output.</span></span><br><span class="line"><span class="string">  devtool: "source-map",</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  resolve: &#123;</span></span><br><span class="line"><span class="string">    // Add '</span>.ts<span class="string">' and '</span>.tsx<span class="string">' as resolvable extensions.</span></span><br><span class="line"><span class="string">    extensions: [".ts", ".tsx", ".js", ".json"]</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  module: &#123;</span></span><br><span class="line"><span class="string">    rules: [</span></span><br><span class="line"><span class="string">      // All files with a '</span>.ts<span class="string">' or '</span>.tsx<span class="string">' extension will be handled by '</span>awesome-typescript-loader<span class="string">'.</span></span><br><span class="line"><span class="string">      &#123; test: /\.tsx?$/, loader: "awesome-typescript-loader" &#125;,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      // All output '</span>.js<span class="string">' files will have any sourcemaps re-processed by '</span><span class="built_in">source</span>-map-loader<span class="string">'.</span></span><br><span class="line"><span class="string">      &#123; enforce: "pre", test: /\.js$/, loader: "source-map-loader" &#125;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // When importing a module whose path matches one of the following, just</span></span><br><span class="line"><span class="string">  // assume a corresponding global variable exists and use that instead.</span></span><br><span class="line"><span class="string">  // This is important because it allows us to avoid bundling all of our</span></span><br><span class="line"><span class="string">  // dependencies, which allows browsers to cache those libraries between builds.</span></span><br><span class="line"><span class="string">  externals: &#123;</span></span><br><span class="line"><span class="string">    "react": "React",</span></span><br><span class="line"><span class="string">    "react-dom": "ReactDOM"</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure>
<p>可以在<a href="https://webpack.js.org/concepts" target="_blank" rel="noopener">这里</a>了解更多如何配置webpack。</p>
<h4 id="执行webpack"><a href="#执行webpack" class="headerlink" title="执行webpack"></a>执行webpack</h4><p>执行webpack，在浏览器里打开index.html，工程应该已经可以用了！ 你可以看到页面上显示着“Hello from TypeScript and React!”</p>
<h1 id="第二节、-TS手册"><a href="#第二节、-TS手册" class="headerlink" title="第二节、 TS手册"></a><font color="#FF69B4">第二节、 TS手册</font></h1><h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> isDone: boolean = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> decLiteral: number = 6;</span><br><span class="line"><span class="built_in">let</span> hexLiteral: number = 0xf00d;</span><br><span class="line"><span class="built_in">let</span> binaryLiteral: number = 0b1010;</span><br><span class="line"><span class="built_in">let</span> octalLiteral: number = 0o744;</span><br></pre></td></tr></table></figure>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> name: string = <span class="string">"bob"</span>;</span><br><span class="line">// 还支持模版字符串，反引号包围（ `），并且以<span class="variable">$&#123; expr &#125;</span>这种形式嵌入表达式</span><br></pre></td></tr></table></figure>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> list: number[] = [1, 2, 3];</span><br><span class="line"><span class="built_in">let</span> list: Array&lt;number&gt; = [1, 2, 3]; // 数组泛型</span><br></pre></td></tr></table></figure>
<h3 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 Tuple"></a>元组 Tuple</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Declare a tuple <span class="built_in">type</span></span><br><span class="line"><span class="built_in">let</span> x: [string, number];</span><br><span class="line"></span><br><span class="line">x = [<span class="string">'hello'</span>, 10]; // OK</span><br><span class="line"></span><br><span class="line">x = [10, <span class="string">'hello'</span>]; // Error</span><br></pre></td></tr></table></figure>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>enum类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p>
<p>默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1开始编号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;Red, Green, Blue&#125;</span><br><span class="line">let c: Color = Color.Green;   // 1</span><br></pre></td></tr></table></figure></p>
<p>或者，全部都采用手动赋值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;Red = 1, Green, Blue&#125;</span><br><span class="line">let c: Color = Color.Green;</span><br></pre></td></tr></table></figure></p>
<p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;Red = 1, Green = 2, Blue = 4&#125;</span><br><span class="line">let c: Color = Color.Green;</span><br><span class="line"></span><br><span class="line">enum Color &#123;Red = 1, Green, Blue&#125;</span><br><span class="line">let colorName: string = Color[2];</span><br><span class="line"></span><br><span class="line">console.log(colorName);  // 显示&apos;Green&apos;因为上面代码里它的值是2</span><br></pre></td></tr></table></figure></p>
<h3 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h3><p>它允许你在编译时可选择地包含或移除类型检查。</p>
<h3 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h3><p>某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function warnUser(): void &#123;</span><br><span class="line">    console.log(&quot;This is my warning message&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let unusable: void = undefined;</span><br></pre></td></tr></table></figure></p>
<h3 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h3><p>TypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null。 和 void相似，它们的本身的类型用处不是很大：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Not much else we can assign to these variables!</span><br><span class="line">let u: undefined = undefined;</span><br><span class="line">let n: null = null;</span><br></pre></td></tr></table></figure></p>
<p>默认情况下null和undefined是所有类型的子类型。 就是说你可以把 null和undefined赋值给number类型的变量。</p>
<h3 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h3><p>never类型表示的是那些永不存在的值的类型。 例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never类型，当它们被永不为真的类型保护所约束时。</p>
<p>never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never。</p>
<p>下面是一些返回never类型的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 返回never的函数必须存在无法达到的终点</span><br><span class="line">function error(message: string): never &#123;</span><br><span class="line">    throw new Error(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。使用object类型，就可以更好的表示像Object.create这样的API。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">declare function create(o: object | null): void;</span><br><span class="line"></span><br><span class="line">create(&#123; prop: 0 &#125;); // OK</span><br><span class="line">create(null); // OK</span><br><span class="line"></span><br><span class="line">create(42); // Error</span><br><span class="line">create(&quot;string&quot;); // Error</span><br><span class="line">create(false); // Error</span><br><span class="line">create(undefined); // Error</span><br></pre></td></tr></table></figure></p>
<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。</p>
<p>类型断言有两种形式，是“尖括号”和as语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let someValue: any = &quot;this is a string&quot;;</span><br><span class="line">let strLength: number = (&lt;string&gt;someValue).length;</span><br><span class="line"></span><br><span class="line">let someValue: any = &quot;this is a string&quot;;</span><br><span class="line">let strLength: number = (someValue as string).length;</span><br></pre></td></tr></table></figure></p>
<p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有 as语法断言是被允许的。</p>
<h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><h3 id="var-声明"><a href="#var-声明" class="headerlink" title="var 声明"></a>var 声明</h3><p>1、 使用的是函数作用域。<br>2、 重复声明同一变量不报错，容易引发bug。<br>3、 存在变量声明提升<br>4、 捕获变量怪异：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  setTimeout(function() &#123; console.log(i); &#125;, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通常，可以这样解决：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  // capture the current state of &apos;i&apos;</span><br><span class="line">  // by invoking a function with its current value</span><br><span class="line">  (function(i) &#123;</span><br><span class="line">      setTimeout(function() &#123; console.log(i); &#125;, 0);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是也可以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  setTimeout(function() &#123; console.log(i); &#125;, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="let-声明"><a href="#let-声明" class="headerlink" title="let 声明"></a>let 声明</h3><p>1、使用的是词法作用域或块作用域。块作用域变量在包含它们的块或for循环之外是不能访问的。<br>2、不可重复声明。<br>3、不存在变量声明提升。</p>
<p>在catch语句里声明的变量也具有同样的作用域规则。</p>
<h3 id="const-声明"><a href="#const-声明" class="headerlink" title="const 声明"></a>const 声明</h3><p>它们拥有与 let相同的作用域规则，但是不能对它们重新赋值。</p>
<h3 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h3><p>解构数组、<br>解构对象：属性重命名、默认值、函数声明、展开</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>TypeScript的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</p>
<h3 id="可选属性："><a href="#可选属性：" class="headerlink" title="可选属性： ?"></a>可选属性： ?</h3><h3 id="只读属性-readonly"><a href="#只读属性-readonly" class="headerlink" title="只读属性: readonly"></a>只读属性: readonly</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface SquareConfig &#123;</span><br><span class="line">  color?: string;</span><br><span class="line">  readonly v: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ReadonlyArray"><a href="#ReadonlyArray" class="headerlink" title="ReadonlyArray"></a>ReadonlyArray<t></t></h3><p>TypeScript具有ReadonlyArray<t>类型，它与Array<t>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let a: number[] = [1, 2, 3, 4];</span><br><span class="line">let ro: ReadonlyArray&lt;number&gt; = a;</span><br><span class="line">ro[0] = 12; // error!</span><br><span class="line">ro.push(5); // error!</span><br><span class="line">ro.length = 100; // error!</span><br><span class="line">a = ro; // error!</span><br></pre></td></tr></table></figure></t></t></p>
<h3 id="额外的属性检查"><a href="#额外的属性检查" class="headerlink" title="额外的属性检查"></a>额外的属性检查</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface SquareConfig &#123;</span><br><span class="line">  color?: string;</span><br><span class="line">  width?: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createSquare(config: SquareConfig): &#123; color: string; area: number &#125; &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let mySquare = createSquare(&#123; colour: &quot;red&quot;, width: 100 &#125;); // 直接编译器就飘红报错了error</span><br></pre></td></tr></table></figure>
<p>想避开这种额外的属性检查，可以:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 1. 类型断言</span><br><span class="line">let mySquare = createSquare(&#123; width: 100, opacity: 0.5 &#125; as SquareConfig);</span><br><span class="line"></span><br><span class="line">// 2. 字符串索引签名</span><br><span class="line">interface SquareConfig &#123;</span><br><span class="line">  color?: string;</span><br><span class="line">  width?: number;</span><br><span class="line">  [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3. 将这个对象赋值给一个另一个变量</span><br><span class="line">//    因为 squareOptions不会经过额外属性检查，所以编译器不会报错。</span><br><span class="line">let squareOptions = &#123; colour: &quot;red&quot;, width: 100 &#125;;</span><br><span class="line">let mySquare = createSquare(squareOptions);</span><br></pre></td></tr></table></figure></p>
<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface SearchFunc &#123;</span><br><span class="line">  (<span class="built_in">source</span>: string, subString: string): boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> mySearch: SearchFunc = <span class="keyword">function</span>(sou: string, sub: string) &#123;</span><br><span class="line">  <span class="built_in">let</span> result = source.search(subString);</span><br><span class="line">  <span class="built_in">return</span> result &gt; -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h3><p>TypeScript支持两种索引签名：字符串和数字。<br>可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。</p>
<h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><h4 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface ClockInterface &#123;</span><br><span class="line">  currentTime: Date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Clock implements ClockInterface &#123;</span><br><span class="line">  currentTime: Date;</span><br><span class="line">  constructor(h: number, m: number) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类静态部分与实例部分的区别"><a href="#类静态部分与实例部分的区别" class="headerlink" title="类静态部分与实例部分的区别"></a>类静态部分与实例部分的区别</h4><p>当操作类和接口的时候，要知道类是具有两个类型的：静态部分的类型和实例的类型。 constructor存在于类的静态部分，所以不在检查的范围内。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">interface ClockConstructor &#123;</span><br><span class="line">  new (hour: number, minute: number): ClockInterface;</span><br><span class="line">&#125;</span><br><span class="line">interface ClockInterface &#123;</span><br><span class="line">  tick();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface &#123;</span><br><span class="line">  return new ctor(hour, minute);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DigitalClock implements ClockInterface &#123;</span><br><span class="line">  constructor(h: number, m: number) &#123; &#125;</span><br><span class="line">  tick() &#123;</span><br><span class="line">    console.log(&quot;beep beep&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class AnalogClock implements ClockInterface &#123;</span><br><span class="line">  constructor(h: number, m: number) &#123; &#125;</span><br><span class="line">  tick() &#123;</span><br><span class="line">    console.log(&quot;tick tock&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let digital = createClock(DigitalClock, 12, 17);</span><br><span class="line">let analog = createClock(AnalogClock, 7, 32);</span><br></pre></td></tr></table></figure></p>
<h3 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h3><p>和类一样，接口也可以相互继承。 一个接口还可以继承多个接口，创建出多个接口的合成接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface Shape &#123;</span><br><span class="line">  color: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface PenStroke &#123;</span><br><span class="line">  penWidth: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Square extends Shape, PenStroke &#123;</span><br><span class="line">  sideLength: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let square = &lt;Square&gt;&#123;&#125;;</span><br><span class="line">square.color = &quot;blue&quot;;</span><br><span class="line">square.sideLength = 10;</span><br><span class="line">square.penWidth = 5.0;</span><br></pre></td></tr></table></figure></p>
<h3 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h3><p>没懂</p>
<h3 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h3><p>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的private和protected成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。</p>
<p>当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系。 例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Control &#123;</span><br><span class="line">  private state: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface SelectableControl extends Control &#123;</span><br><span class="line">  select(): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Button extends Control implements SelectableControl &#123;</span><br><span class="line">  select() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TextBox extends Control &#123;</span><br><span class="line">  select() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 错误：“Image”类型缺少“state”属性。</span><br><span class="line">class Image implements SelectableControl &#123;</span><br><span class="line">  select() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Location &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>这个例子展示了最基本的继承：类从基类中继承了属性和方法。 这里， Dog是一个 派生类，它派生自 Animal 基类，通过 extends关键字。 派生类通常被称作 <strong>子类</strong>，基类通常被称作 <strong>超类</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  move(distanceInMeters: number = 0) &#123;</span><br><span class="line">    console.log(`Animal moved $&#123;distanceInMeters&#125;m.`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">  bark() &#123;</span><br><span class="line">    console.log(&apos;Woof! Woof!&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const dog = new Dog();</span><br><span class="line">dog.bark();</span><br><span class="line">dog.move(10);</span><br><span class="line">dog.bark();</span><br></pre></td></tr></table></figure></p>
<p>派生类包含了一个构造函数，它 必须调用 super()，它会执行基类的构造函数。 而且，在构造函数里访问 this的属性之前，我们 一定要调用 super()。 这个是TypeScript强制执行的一条重要规则。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  constructor(theName: string) &#123; this.name = theName; &#125;</span><br><span class="line">  move(distanceInMeters: number = 0) &#123;</span><br><span class="line">    console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Snake extends Animal &#123;</span><br><span class="line">  constructor(name: string) &#123; super(name); &#125;</span><br><span class="line">  move(distanceInMeters = 5) &#123;</span><br><span class="line">    console.log(&quot;Slithering...&quot;);</span><br><span class="line">    super.move(distanceInMeters);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Horse extends Animal &#123;</span><br><span class="line">  constructor(name: string) &#123; super(name); &#125;</span><br><span class="line">  move(distanceInMeters = 45) &#123;</span><br><span class="line">    console.log(&quot;Galloping...&quot;);</span><br><span class="line">    super.move(distanceInMeters);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let sam = new Snake(&quot;Sammy the Python&quot;);</span><br><span class="line">let tom: Animal = new Horse(&quot;Tommy the Palomino&quot;);</span><br><span class="line"></span><br><span class="line">sam.move();</span><br><span class="line">tom.move(34);</span><br></pre></td></tr></table></figure></p>
<h3 id="公共，私有与受保护的修饰符"><a href="#公共，私有与受保护的修饰符" class="headerlink" title="公共，私有与受保护的修饰符"></a>公共，私有与受保护的修饰符</h3><p>在TypeScript里，成员都默认为 public。<br>当成员被标记成 private时，它就不能在声明它的类的外部访问。<br>protected修饰符与 private修饰符的行为很相似，但有一点不同， protected成员在派生类中仍然可以访问。</p>
<h3 id="readonly修饰符"><a href="#readonly修饰符" class="headerlink" title="readonly修饰符"></a>readonly修饰符</h3><p>你可以使用 readonly关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Octopus &#123;</span><br><span class="line">  readonly name: string;</span><br><span class="line">  readonly numberOfLegs: number = 8;</span><br><span class="line">  constructor (theName: string) &#123;</span><br><span class="line">    this.name = theName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let dad = new Octopus(&quot;Man with the 8 strong legs&quot;);</span><br><span class="line">dad.name = &quot;Man with the 3-piece suit&quot;; // 错误! name 是只读的.</span><br></pre></td></tr></table></figure></p>
<h3 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h3><p>TypeScript支持通过getters/setters来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。</p>
<h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Grid &#123;</span><br><span class="line">  static origin = &#123; x: 0, y: 0 &#125;;</span><br><span class="line">  calculateDistanceFromOrigin(point: &#123; x: number; y: number; &#125;) &#123;</span><br><span class="line">    let xDist = (point.x - Grid.origin.x);</span><br><span class="line">    let yDist = (point.y - Grid.origin.y);</span><br><span class="line">    return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;</span><br><span class="line">  &#125;</span><br><span class="line">  constructor(public scale: number) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let grid1 = new Grid(1.0);  // 1x scale</span><br><span class="line">let grid2 = new Grid(5.0);  // 5x scale</span><br><span class="line"></span><br><span class="line">console.log(grid1.calculateDistanceFromOrigin(&#123; x: 10, y: 10 &#125;));</span><br><span class="line">console.log(grid2.calculateDistanceFromOrigin(&#123; x: 10, y: 10 &#125;));</span><br></pre></td></tr></table></figure>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><blockquote>
<p>抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。</p>
<p>abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法。</p>
<p>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。 两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含 abstract关键字并且可以包含访问修饰符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">abstract class Department &#123;</span><br><span class="line">  constructor(public name: string) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printName(): void &#123;</span><br><span class="line">    console.log(&apos;Department name: &apos; + this.name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  abstract printMeeting(): void; // 必须在派生类中实现</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AccountingDepartment extends Department &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super(&apos;Accounting and Auditing&apos;); // 在派生类的构造函数中必须调用 super()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printMeeting(): void &#123;</span><br><span class="line">    console.log(&apos;The Accounting Department meets each Monday at 10am.&apos;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  generateReports(): void &#123;</span><br><span class="line">    console.log(&apos;Generating accounting reports...&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let department: Department; // 允许创建一个对抽象类型的引用</span><br><span class="line">department = new Department(); // 错误: 不能创建一个抽象类的实例</span><br><span class="line">department = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值</span><br><span class="line">department.printName();</span><br><span class="line">department.printMeeting();</span><br><span class="line">department.generateReports(); // 错误: 方法在声明的抽象类中不存在</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><h4 id="把类当做接口使用"><a href="#把类当做接口使用" class="headerlink" title="把类当做接口使用"></a>把类当做接口使用</h4><p>类定义会创建两个东西：类的实例类型和一个构造函数。 因为类可以创建出类型，所以你能够在允许使用接口的地方使用类。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数类型-1"><a href="#函数类型-1" class="headerlink" title="函数类型"></a>函数类型</h3><h4 id="为函数定义类型"><a href="#为函数定义类型" class="headerlink" title="为函数定义类型"></a>为函数定义类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function add(x: number, y: number): number &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myAdd = function(x: number, y: number): number &#123; return x + y; &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="书写完整函数类型"><a href="#书写完整函数类型" class="headerlink" title="书写完整函数类型"></a>书写完整函数类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let myAdd: (baseValue: number, increment: number) =&gt; number = function(x: number, y: number): number &#123; return x + y; &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="推断类型"><a href="#推断类型" class="headerlink" title="推断类型"></a>推断类型</h4><p>尝试这个例子的时候，你会发现如果你在赋值语句的一边指定了类型但是另一边没有类型的话，TypeScript编译器会自动识别出类型</p>
<h3 id="可选参数和默认参数"><a href="#可选参数和默认参数" class="headerlink" title="可选参数和默认参数"></a>可选参数和默认参数</h3><p>参数名旁使用 ?实现可选参数的功能。可选参数必须跟在必须参数后面。</p>
<h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>省略号（ …）</p>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function identity&lt;T&gt;(arg: T): T &#123;</span><br><span class="line">  return arg;</span><br><span class="line">&#125;</span><br><span class="line">let output = identity&lt;string&gt;(&quot;myString&quot;);  // type of output will be &apos;string&apos;</span><br><span class="line">let output = identity(&quot;myString&quot;);</span><br><span class="line"></span><br><span class="line">function handleChange&lt;T&gt;(fieldValue: T, index: number, field: string): void &#123; ... &#125;</span><br><span class="line">handleChange&lt;number&gt;(fieldValue, index, field);</span><br></pre></td></tr></table></figure>
<p>注意我们没必要使用尖括号（&lt;&gt;）来明确地传入类型；编译器可以查看myString的值，然后把T设置为它的类型。</p>
<h3 id="使用泛型变量"><a href="#使用泛型变量" class="headerlink" title="使用泛型变量"></a>使用泛型变量</h3><h3 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h3><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class GenericNumber&lt;T&gt; &#123;</span><br><span class="line">    zeroValue: T;</span><br><span class="line">    add: (x: T, y: T) =&gt; T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myGenericNumber = new GenericNumber&lt;number&gt;();</span><br><span class="line">myGenericNumber.zeroValue = 0;</span><br><span class="line">myGenericNumber.add = function(x, y) &#123; return x + y; &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Lengthwise &#123;</span><br><span class="line">  length: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123;</span><br><span class="line">  console.log(arg.length);  // Now we know it has a .length property, so no more error</span><br><span class="line">  return arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在泛型里使用类类型"><a href="#在泛型里使用类类型" class="headerlink" title="在泛型里使用类类型"></a>在泛型里使用类类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class BeeKeeper &#123;</span><br><span class="line">  hasMask: boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ZooKeeper &#123;</span><br><span class="line">  nametag: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Animal &#123;</span><br><span class="line">  numLegs: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bee extends Animal &#123;</span><br><span class="line">  keeper: BeeKeeper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Lion extends Animal &#123;</span><br><span class="line">  keeper: ZooKeeper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createInstance&lt;A extends Animal&gt;(c: new () =&gt; A): A &#123;</span><br><span class="line">  return new c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createInstance(Lion).keeper.nametag;  // typechecks!</span><br><span class="line">createInstance(Bee).keeper.hasMask;   // typechecks!</span><br></pre></td></tr></table></figure>
<h2 id="枚举-1"><a href="#枚举-1" class="headerlink" title="枚举"></a>枚举</h2><h3 id="数字枚举"><a href="#数字枚举" class="headerlink" title="数字枚举"></a>数字枚举</h3><p>默认是从0开始<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">  Up = 1,</span><br><span class="line">  Down,</span><br><span class="line">  Left,</span><br><span class="line">  Right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Direction.Left  // 3</p>
<h3 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">  Up = &quot;UP&quot;,</span><br><span class="line">  Down = &quot;DOWN&quot;,</span><br><span class="line">  Left = &quot;LEFT&quot;,</span><br><span class="line">  Right = &quot;RIGHT&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异构枚举"><a href="#异构枚举" class="headerlink" title="异构枚举"></a>异构枚举</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum BooleanLikeHeterogeneousEnum &#123;</span><br><span class="line">  No = 0,</span><br><span class="line">  Yes = &quot;YES&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除非你真的想要利用JavaScript运行时的行为，否则不建议这样做。</p>
<h3 id="计算和常量成员"><a href="#计算和常量成员" class="headerlink" title="计算和常量成员"></a>计算和常量成员</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">enum FileAccess &#123;</span><br><span class="line">  // constant members</span><br><span class="line">  None,</span><br><span class="line">  Read    = 1 &lt;&lt; 1,</span><br><span class="line">  Write   = 1 &lt;&lt; 2,</span><br><span class="line">  ReadWrite  = Read | Write,</span><br><span class="line">  // computed member</span><br><span class="line">  G = &quot;123&quot;.length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  0: &quot;None&quot;</span><br><span class="line">  2: &quot;Read&quot;</span><br><span class="line">  3: &quot;G&quot;</span><br><span class="line">  4: &quot;Write&quot;</span><br><span class="line">  6: &quot;ReadWrite&quot;</span><br><span class="line">  G: 3</span><br><span class="line">  None: 0</span><br><span class="line">  Read: 2</span><br><span class="line">  ReadWrite: 6</span><br><span class="line">  Write: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="外部枚举"><a href="#外部枚举" class="headerlink" title="外部枚举"></a>外部枚举</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">declare const enum Enum &#123;</span><br><span class="line">  A = 3,</span><br><span class="line">  B,</span><br><span class="line">  C = 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Enum.A   // 3</span><br><span class="line">Enum.B   // 4</span><br><span class="line">Enum.C   // 2</span><br></pre></td></tr></table></figure>
<h2 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h2><h3 id="交叉类型（Intersection-Types）-amp"><a href="#交叉类型（Intersection-Types）-amp" class="headerlink" title="交叉类型（Intersection Types） &amp;"></a>交叉类型（Intersection Types） &amp;</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function extend&lt;T, U&gt;(first: T, second: U): T &amp; U &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型保护与区分类型（Type-Guards-and-Differentiating-Types）"><a href="#类型保护与区分类型（Type-Guards-and-Differentiating-Types）" class="headerlink" title="类型保护与区分类型（Type Guards and Differentiating Types） |"></a>类型保护与区分类型（Type Guards and Differentiating Types） |</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function padLeft(value: string, padding: string | number) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类型兼容性"><a href="#类型兼容性" class="headerlink" title="类型兼容性"></a>类型兼容性</h2><h2 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h2><h3 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Easing = &quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;;</span><br></pre></td></tr></table></figure>
<h3 id="数字字面量类型"><a href="#数字字面量类型" class="headerlink" title="数字字面量类型"></a>数字字面量类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function rollDie(): 1 | 2 | 3 | 4 | 5 | 6 &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h2><p>自ECMAScript 2015起，symbol成为了一种新的原生类型，就像number和string一样。</p>
<p>symbol类型的值是通过Symbol构造函数创建的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let sym1 = Symbol();</span><br><span class="line"></span><br><span class="line">let sym2 = Symbol(&quot;key&quot;); // 可选的字符串key</span><br></pre></td></tr></table></figure></p>
<p>Symbols是不可改变且唯一的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let sym2 = Symbol(&quot;key&quot;);</span><br><span class="line">let sym3 = Symbol(&quot;key&quot;);</span><br><span class="line"></span><br><span class="line">sym2 === sym3; // false, symbols是唯一的</span><br></pre></td></tr></table></figure></p>
<p>像字符串一样，symbols也可以被用做对象属性的键。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let sym = Symbol();</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line">  [sym]: &quot;value&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(obj[sym]); // &quot;value&quot;</span><br></pre></td></tr></table></figure></p>
<p>Symbols也可以与计算出的属性名声明相结合来声明对象的属性和类成员。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const getClassNameSymbol = Symbol();</span><br><span class="line"></span><br><span class="line">class C &#123;</span><br><span class="line">  [getClassNameSymbol]()&#123;</span><br><span class="line">  return &quot;C&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let c = new C();</span><br><span class="line">let className = c[getClassNameSymbol](); // &quot;C&quot;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Symbol.hasInstance<br>方法，会被instanceof运算符调用。构造器对象用来识别一个对象是否是其实例。</p>
<p>Symbol.isConcatSpreadable<br>布尔值，表示当在一个对象上调用Array.prototype.concat时，这个对象的数组元素是否可展开。</p>
<p>Symbol.iterator<br>方法，被for-of语句调用。返回对象的默认迭代器。</p>
<p>Symbol.match<br>方法，被String.prototype.match调用。正则表达式用来匹配字符串。</p>
<p>Symbol.replace<br>方法，被String.prototype.replace调用。正则表达式用来替换字符串中匹配的子串。</p>
<p>Symbol.search<br>方法，被String.prototype.search调用。正则表达式返回被匹配部分在字符串中的索引。</p>
<p>Symbol.species<br>函数值，为一个构造函数。用来创建派生对象。</p>
<p>Symbol.split<br>方法，被String.prototype.split调用。正则表达式来用分割字符串。</p>
<p>Symbol.toPrimitive<br>方法，被ToPrimitive抽象操作调用。把对象转换为相应的原始值。</p>
<p>Symbol.toStringTag<br>方法，被内置方法Object.prototype.toString调用。返回创建对象时默认的字符串描述。</p>
<p>Symbol.unscopables<br>对象，它自己拥有的属性会被with作用域排除在外。</p>
</blockquote>
<h2 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h2><p>当一个对象实现了Symbol.iterator属性时，我们认为它是可迭代的。 一些内置的类型如 Array，Map，Set，String，Int32Array，Uint32Array等都已经实现了各自的Symbol.iterator。 对象上的 Symbol.iterator函数负责返回供迭代的值。</p>
<h3 id="for-of-语句"><a href="#for-of-语句" class="headerlink" title="for..of 语句"></a>for..of 语句</h3><p>1) for..of和for..in均可迭代一个列表；但是用于迭代的值却不同，for..in迭代的是对象的 键 的列表，而for..of则迭代对象的键对应的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let list = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line"></span><br><span class="line">for (let i in list) &#123;</span><br><span class="line">  console.log(i); // &quot;0&quot;, &quot;1&quot;, &quot;2&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let i of list) &#123;</span><br><span class="line">  console.log(i); // &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2) 另一个区别是for..in可以操作任何对象；它提供了查看对象属性的一种方法。 但是 for..of关注于迭代对象的值。内置对象Map和Set已经实现了Symbol.iterator方法，让我们可以访问它们保存的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let pets = new Set([&quot;Cat&quot;, &quot;Dog&quot;, &quot;Hamster&quot;]);</span><br><span class="line">pets[&quot;species&quot;] = &quot;mammals&quot;;</span><br><span class="line"></span><br><span class="line">for (let pet in pets) &#123;</span><br><span class="line">  console.log(pet); // &quot;species&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let pet of pets) &#123;</span><br><span class="line">  console.log(pet); // &quot;Cat&quot;, &quot;Dog&quot;, &quot;Hamster&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><h2 id="命名空间和模块"><a href="#命名空间和模块" class="headerlink" title="命名空间和模块"></a>命名空间和模块</h2><h2 id="模块解析"><a href="#模块解析" class="headerlink" title="模块解析"></a>模块解析</h2><h2 id="声明合并"><a href="#声明合并" class="headerlink" title="声明合并"></a>声明合并</h2><h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><h2 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h2><h2 id="三斜线指令"><a href="#三斜线指令" class="headerlink" title="三斜线指令"></a>三斜线指令</h2><h2 id="JavaScript文件类型检查模块"><a href="#JavaScript文件类型检查模块" class="headerlink" title="JavaScript文件类型检查模块"></a>JavaScript文件类型检查模块</h2><h1 id="第三节、-声明文件"><a href="#第三节、-声明文件" class="headerlink" title="第三节、 声明文件"></a><font color="#FF69B4">第三节、 声明文件</font></h1><h1 id="第四节、-项目配置"><a href="#第四节、-项目配置" class="headerlink" title="第四节、 项目配置"></a><font color="#FF69B4">第四节、 项目配置</font></h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/19/redux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lemon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/background10.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="立夏">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/19/redux/" itemprop="url">redux</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-19T15:49:41+08:00">
                2020-05-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/2）前端-框架/" itemprop="url" rel="index">
                    <span itemprop="name">2）前端 - 框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a><font color="#8A2BE2">一、介绍</font></h1><p>redux是一个可预测的状态管理容器。<br>开发体验好（redux-devtools），轻量(2KB)，也支持除了react之外的其他UI库一起用。</p>
<blockquote>
<p>我理解redux是自己维护一套数据（状态，store）：action是描述将要改变某个数据，reducer是根据state和action来返回一个新的state，同步到store中。</p>
<p>通过dispatch方法派发action，通过provider顶层组件把store同步到所有组件。</p>
</blockquote>
<h2 id="1、动机"><a href="#1、动机" class="headerlink" title="1、动机"></a><font color="#BA55D3">1、动机</font></h2><p>随着js单页应用的日趋复杂，js要管理越来越多的状态，难管理难预测。</p>
<h2 id="2、三大原则"><a href="#2、三大原则" class="headerlink" title="2、三大原则"></a><font color="#BA55D3">2、三大原则</font></h2><ol>
<li>单一数据源<br>整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。</li>
<li>State 是只读的<br>唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。</li>
<li>使用纯函数来执行修改<br>为了描述 action 如何改变 state tree ，你需要编写 reducers。</li>
</ol>
<h2 id="4、生态系统"><a href="#4、生态系统" class="headerlink" title="4、生态系统"></a><font color="#BA55D3">4、生态系统</font></h2><p><a href="https://www.redux.org.cn/docs/introduction/Ecosystem.html" target="_blank" rel="noopener">生态系统</a></p>
<ol>
<li>与不同框架绑定</li>
<li>Reducers<blockquote>
<p>组合 Reducer<br>Reducer 结构<br>高阶 Reducers</p>
</blockquote>
</li>
<li>Actions</li>
<li>工具集<blockquote>
<p>reduxjs、<font color="#0f0">reselect</font>等</p>
</blockquote>
</li>
<li>Store<blockquote>
<p>更改订阅 / 批处理 / 持久化</p>
</blockquote>
</li>
<li>不可变（Immutable）数据<blockquote>
<p>数据结构:facebook/<font color="#0f0">immutable-js</font> 、 rtfeldman/seamless-immutable 、 planttheidea/crio 、 aearly/icepick<br>不可变更新（Immutable Update）实用程序<br>Immutable/Redux 互操作: gajus/<font color="#0f0">redux-immutable</font>、 eadmundo/redux-seamless-immutable</p>
</blockquote>
</li>
<li>副作用（Side Effects）<blockquote>
<p>广泛使用: gaearon/redux-thunk 、  redux-saga/<font color="#0f0">redux-saga</font> 、 redux-observable/redux-observable 、 redux-loop/redux-loop 、<br>Promises: acdlite/redux-promise 、 lelandrichardson/redux-pack</p>
</blockquote>
</li>
<li>中间件<blockquote>
<p>Networks and Sockets: svrcekmichal/redux-axios-middleware<br>异步行为:  wyze/<font color="#0f0">redux-debounce</font> 符合 FSA 标准的 Redux 中间件可以实现 action 的防抖。<br>分析<br>实体和集合</p>
</blockquote>
</li>
<li>组件 state 和封装</li>
<li>开发者工具<blockquote>
<p>Debuggers and Viewers: reduxjs/<font color="#0f0">redux-devtools</font> 、 zalmoxisus/redux-devtools-extension 、 infinitered/reactotron<br>开发者工具监视器<br>日志<br>突变检测</p>
</blockquote>
</li>
<li>测试</li>
<li>路由</li>
<li>Forms<blockquote>
<p>ReactTraining/<font color="#0f0">react-router-redux</font>: 保持 state 与路由同步<br>等等</p>
</blockquote>
</li>
<li>更高级别的抽象<blockquote>
<p>社区公约</p>
</blockquote>
</li>
</ol>
<p><br><br><br><br><br><br><br></p>
<h1 id="二、基础"><a href="#二、基础" class="headerlink" title="二、基础"></a><font color="#8A2BE2">二、基础</font></h1>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">视图   ---&gt;     Action构建函数    ---&gt;    Action对象    ---&gt;    Store.dispatch   </span><br><span class="line">  |                                                                 |</span><br><span class="line">  |                                                                 |</span><br><span class="line">刷新视图     &lt;---    Store       &lt;---      新的状态     &lt;---    reducer函数</span><br></pre></td></tr></table></figure>
<h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a><font color="#BA55D3">Action</font></h2><p><strong>Action 创建函数</strong> 是生成 <strong>action</strong> 的方法。</p>
<p>actions 描述了有某件事情发生了这一事实，并没有描述应用如何更新 state。</p>
<h2 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a><font color="#BA55D3">Reducer</font></h2><p>Reducers 指定了应用状态的变化如何响应 actions 并发送到 store 的。</p>
<ul>
<li><p>纯函数<br>只要传入参数相同，返回计算得到的下一个 state 就一定相同。没有特殊情况、没有副作用，没有 API 请求、没有变量修改，单纯执行计算。</p>
</li>
<li><p>combineReducers()工具类</p>
</li>
</ul>
<h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a><font color="#BA55D3">Store</font></h2><p>Redux 应用只有一个单一的 store</p>
<h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a><font color="#BA55D3">数据流</font></h2><ul>
<li>严格的单向数据流是 Redux 架构的设计核心。</li>
</ul>
<p>Redux 应用中数据的生命周期遵循下面 4 个步骤：</p>
<ol>
<li>调用 store.dispatch(action)。</li>
<li>Redux store 调用传入的 reducer 函数。</li>
<li>根 reducer 应该把多个子 reducer 输出合并成一个单一的 state 树。</li>
<li>Redux store 保存了根 reducer 返回的完整 state 树。</li>
</ol>
<h2 id="示例：Todo-List"><a href="#示例：Todo-List" class="headerlink" title="示例：Todo List"></a><font color="#BA55D3">示例：Todo List</font></h2><p>action   创建函数、对象<br>reducer  combineReducers<br>store    createStore<br>provider store</p>
<p>connect  mapStateToProps  mapDispatchToProps  PropsType</p>
<p><br><br><br><br><br><br><br><br><br></p>
<h1 id="三、高级"><a href="#三、高级" class="headerlink" title="三、高级"></a><font color="#8A2BE2">三、高级</font></h1><h2 id="异步-Action"><a href="#异步-Action" class="headerlink" title="异步 Action"></a><font color="#BA55D3">异步 Action</font></h2><ul>
<li><p><strong>Action</strong></p>
<blockquote>
<p>当调用异步 API 时，有两个非常关键的时刻：发起请求的时刻，和接收到响应的时刻（也可能是超时）。</p>
<p>这两个时刻都可能会更改应用的 state；为此，你需要 dispatch 普通的同步 action。一般情况下，每个 API 请求都需要 dispatch 至少三种 action：</p>
<p>一种通知 reducer 请求开始的 action。</p>
<p>对于这种 action，reducer 可能会切换一下 state 中的 isFetching 标记。以此来告诉 UI 来显示加载界面。</p>
<p>一种通知 reducer 请求成功的 action。</p>
<p>对于这种 action，reducer 可能会把接收到的新数据合并到 state 中，并重置 isFetching。UI 则会隐藏加载界面，并显示接收到的数据。</p>
<p>一种通知 reducer 请求失败的 action。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; type: &apos;FETCH_POSTS_REQUEST&apos; &#125;</span><br><span class="line">&#123; type: &apos;FETCH_POSTS_FAILURE&apos;, error: &apos;Oops&apos; &#125;</span><br><span class="line">&#123; type: &apos;FETCH_POSTS_SUCCESS&apos;, response: &#123; ... &#125; &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>同步 Action 创建函数（Action Creator）</strong></p>
</li>
<li><strong>设计 state 结构</strong></li>
<li><strong>处理 Action</strong></li>
<li><strong>异步 action 创建函数</strong></li>
</ul>
<h2 id="异步数据流"><a href="#异步数据流" class="headerlink" title="异步数据流"></a><font color="#BA55D3">异步数据流</font></h2><h2 id="Middleware"><a href="#Middleware" class="headerlink" title="Middleware"></a><font color="#BA55D3">Middleware</font></h2><h2 id="搭配-React-Router"><a href="#搭配-React-Router" class="headerlink" title="搭配 React Router"></a><font color="#BA55D3">搭配 React Router</font></h2><ul>
<li><p>安装 React Router、配置后备(fallback) URL、配置 Express、配置 WebpackDevServer</p>
</li>
<li><p>连接 React Router 和 Redux 应用</p>
<blockquote>
<p>也许你想将 ‘#’ 从 URL 中移除（例如：<a href="http://localhost:3000/#/?_k=4sbb0i）。" target="_blank" rel="noopener">http://localhost:3000/#/?_k=4sbb0i）。</a> 你需要从 React Router 导入 browserHistory 来实现：<br>  import { Router, Route, browserHistory } from ‘react-router’;<br>  然后将它传给 &lt; Router /&gt; 来移除 URL 中的 ‘#’：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Router, Route, browserHistory &#125; from <span class="string">'react-router'</span>;</span><br><span class="line">import createHistory from <span class="string">'history/createBrowserHistory'</span>;</span><br><span class="line"></span><br><span class="line">const <span class="built_in">history</span> = createHistory();</span><br><span class="line"></span><br><span class="line">&lt;Router <span class="built_in">history</span> = &#123; <span class="built_in">history</span> &#125;&gt;</span><br><span class="line">  &lt;Route path=<span class="string">"/(:filter)"</span> component=&#123;App&#125; /&gt;</span><br><span class="line">&lt;/Router&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>通过 React Router 导航<br>React Router 提供了 <link> 来实现导航功能。</p>
</li>
<li><p>从 URL 中读取数据</p>
</li>
</ul>
<p>npm install redux-thunk redux-logger cross-fetch –save</p>
<p>参考：<a href="http://cn.redux.js.org/" target="_blank" rel="noopener">http://cn.redux.js.org/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/22/前端试题集锦（基础）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lemon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/background10.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="立夏">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/22/前端试题集锦（基础）/" itemprop="url">前端试题集锦（基础）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-22T10:04:00+08:00">
                2020-03-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/4）积累/" itemprop="url" rel="index">
                    <span itemprop="name">4）积累</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、-HTML相关"><a href="#一、-HTML相关" class="headerlink" title="一、 HTML相关"></a>一、 HTML相关</h2><h3 id="1、-常⻅见标签类型以及用法以及-meta-中常⻅见属性的含义"><a href="#1、-常⻅见标签类型以及用法以及-meta-中常⻅见属性的含义" class="headerlink" title="1、 常⻅见标签类型以及用法以及 meta 中常⻅见属性的含义"></a>1、 常⻅见标签类型以及用法以及 meta 中常⻅见属性的含义</h3><p>【<a href="https://www.runoob.com/tags/html-reference.html】" target="_blank" rel="noopener">https://www.runoob.com/tags/html-reference.html】</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--...--&gt;   	定义注释</span><br><span class="line">&lt;!DOCTYPE&gt;   	定义文档类型</span><br><span class="line">&lt;a&gt;	          定义超文本链接</span><br><span class="line">&lt;abbr&gt;   	    定义缩写</span><br><span class="line">&lt;acronym&gt;	    定义只取首字母的缩写，不支持HTML5</span><br><span class="line">&lt;address&gt;	    定义文档作者或拥有者的联系信息</span><br><span class="line">&lt;applet&gt;	    HTML5中不赞成使用。定义嵌入的 applet。</span><br><span class="line">&lt;area&gt;	      定义图像映射内部的区域</span><br><span class="line">&lt;article&gt;     定义一个文章区域 <span class="comment">#New	</span></span><br><span class="line">&lt;aside&gt;       定义页面的侧边栏内容 <span class="comment">#New	</span></span><br><span class="line">&lt;audio&gt;New   	定义音频内容</span><br><span class="line">&lt;b&gt;	          定义文本粗体</span><br><span class="line">&lt;base&gt;   	    定义页面中所有链接的默认地址或默认目标。</span><br><span class="line">&lt;basefont&gt;  	HTML5不支持，不赞成使用。定义页面中文本的默认字体、颜色或尺寸。</span><br><span class="line">&lt;bdi&gt;         允许您设置一段文本，使其脱离其父元素的文本方向设置。 <span class="comment">#New	</span></span><br><span class="line">&lt;bdo&gt;	        定义文字方向</span><br><span class="line">&lt;big&gt;	        定义大号文本，HTML5不支持</span><br><span class="line">&lt;blockquote&gt;	定义长的引用</span><br><span class="line">&lt;body&gt;	      定义文档的主体</span><br><span class="line">&lt;br&gt;	        定义换行</span><br><span class="line">&lt;button&gt;	    定义一个点击按钮</span><br><span class="line">&lt;canvas&gt;      定义图形，比如图表和其他图像,标签只是图形容器，您必须使用脚本来绘制图形 <span class="comment">#New	</span></span><br><span class="line">&lt;caption&gt;    	定义表格标题</span><br><span class="line">&lt;center&gt;	    HTML5不支持，不赞成使用。定义居中文本。</span><br><span class="line">&lt;cite&gt;	      定义引用(citation)</span><br><span class="line">&lt;code&gt;	      定义计算机代码文本</span><br><span class="line">&lt;col&gt;	        定义表格中一个或多个列的属性值</span><br><span class="line">&lt;colgroup&gt;   	定义表格中供格式化的列组</span><br><span class="line">&lt;<span class="built_in">command</span>&gt;     定义命令按钮，比如单选按钮、复选框或按钮 <span class="comment">#New	</span></span><br><span class="line">&lt;datalist&gt;    定义选项列表。请与 input 元素配合使用该元素，来定义 input 可能的值。 <span class="comment">#New	</span></span><br><span class="line">&lt;dd&gt;	        定义列表中项目的描述</span><br><span class="line">&lt;del&gt;	        定义被删除文本</span><br><span class="line">&lt;details&gt;     用于描述文档或文档某个部分的细节 <span class="comment">#New	</span></span><br><span class="line">&lt;dfn&gt;	        定义项目</span><br><span class="line">&lt;dialog&gt;      定义对话框，比如提示框 <span class="comment">#New	</span></span><br><span class="line">&lt;dir&gt;       	HTML5不支持，不赞成使用。定义目录列表。</span><br><span class="line">&lt;div&gt;       	定义文档中的节</span><br><span class="line">&lt;dl&gt;	        定义列表详情</span><br><span class="line">&lt;dt&gt;	        定义列表中的项目</span><br><span class="line">&lt;em&gt;	        定义强调文本</span><br><span class="line">&lt;embed&gt;       定义嵌入的内容，比如插件。 <span class="comment">#New	</span></span><br><span class="line">&lt;fieldset&gt;   	定义围绕表单中元素的边框</span><br><span class="line">&lt;figcaption&gt;  定义&lt;figure&gt; 元素的标题 <span class="comment">#New	</span></span><br><span class="line">&lt;figure&gt;      规定独立的流内容（图像、图表、照片、代码等等）。 <span class="comment">#New	</span></span><br><span class="line">&lt;font&gt;      	HTML5不支持，不赞成使用。定义文字的字体、尺寸和颜色。</span><br><span class="line">&lt;footer&gt;      定义 section 或 document 的页脚。 <span class="comment">#New	</span></span><br><span class="line">&lt;form&gt;	      定义了HTML文档的表单</span><br><span class="line">&lt;frame&gt;     	定义框架集的窗口或框架</span><br><span class="line">&lt;frameset&gt;	  定义框架集</span><br><span class="line">&lt;h1&gt; to &lt;h6&gt;	定义 HTML 标题</span><br><span class="line">&lt;head&gt;      	定义关于文档的信息</span><br><span class="line">&lt;header&gt;      定义了文档的头部区域 <span class="comment">#New	</span></span><br><span class="line">&lt;hr&gt;        	定义水平线</span><br><span class="line">&lt;html&gt;      	定义 HTML 文档</span><br><span class="line">&lt;i&gt;	          定义斜体字</span><br><span class="line">&lt;iframe&gt;	    定义内联框架</span><br><span class="line">&lt;img&gt;	        定义图像</span><br><span class="line">&lt;input&gt;	      定义输入控件</span><br><span class="line">&lt;ins&gt;	        定义被插入文本</span><br><span class="line">&lt;kbd&gt;	        定义键盘文本</span><br><span class="line">&lt;keygen&gt;      规定用于表单的密钥对生成器字段。 <span class="comment">#New	</span></span><br><span class="line">&lt;label&gt;	      定义 input 元素的标注</span><br><span class="line">&lt;legend&gt;	    定义 fieldset 元素的标题。</span><br><span class="line">&lt;li&gt;	        定义列表的项目</span><br><span class="line">&lt;link&gt;	      定义文档与外部资源的关系</span><br><span class="line">&lt;map&gt;	        定义图像映射</span><br><span class="line">&lt;mark&gt;        定义带有记号的文本。请在需要突出显示文本时使用 &lt;m&gt; 标签。 <span class="comment">#New	</span></span><br><span class="line">&lt;menu&gt;	      不赞成使用。定义菜单列表。</span><br><span class="line">&lt;meta&gt;	      定义关于 HTML 文档的元信息。</span><br><span class="line">&lt;meter&gt;       定义度量衡。仅用于已知最大和最小值的度量。 <span class="comment">#New	</span></span><br><span class="line">&lt;nav&gt;         定义导航链接的部分 <span class="comment">#New	</span></span><br><span class="line">&lt;noframes&gt;	  定义针对不支持框架的用户的替代内容。HTML5不支持</span><br><span class="line">&lt;noscript&gt;    定义针对不支持客户端脚本的用户的替代内容。</span><br><span class="line">&lt;object&gt;	    定义内嵌对象</span><br><span class="line">&lt;ol&gt;	        定义有序列表。</span><br><span class="line">&lt;optgroup&gt;	  定义选择列表中相关选项的组合。</span><br><span class="line">&lt;option&gt;	    定义选择列表中的选项。</span><br><span class="line">&lt;output&gt;      定义不同类型的输出，比如脚本的输出。 <span class="comment">#New	</span></span><br><span class="line">&lt;p&gt;	          定义段落。</span><br><span class="line">&lt;param&gt;	      定义对象的参数。</span><br><span class="line">&lt;pre&gt;	        定义预格式文本。</span><br><span class="line">&lt;progress&gt;    定义运行中的进度（进程）。 <span class="comment">#New	</span></span><br><span class="line">&lt;q&gt;	          定义短的引用。</span><br><span class="line">&lt;rp&gt;&lt;rp&gt;      标签在 ruby 注释中使用，以定义不支持 ruby 元素的浏览器所显示的内容。 <span class="comment">#New	</span></span><br><span class="line">&lt;rt&gt;&lt;rt&gt;      标签定义字符（中文注音或字符）的解释或发音。 <span class="comment">#New	</span></span><br><span class="line">&lt;ruby&gt;&lt;ruby&gt;  标签定义 ruby 注释（中文注音或字符）。 <span class="comment">#New	</span></span><br><span class="line">&lt;s&gt;	          不赞成使用。定义加删除线的文本。</span><br><span class="line">&lt;samp&gt;	      定义计算机代码样本。</span><br><span class="line">&lt;script&gt;	    定义客户端脚本。</span><br><span class="line">&lt;section&gt;&lt;section&gt; 标签定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。 <span class="comment">#New	</span></span><br><span class="line">&lt;select&gt;	     定义选择列表（下拉列表）。</span><br><span class="line">&lt;small&gt;	       定义小号文本。</span><br><span class="line">&lt;<span class="built_in">source</span>&gt;&lt;<span class="built_in">source</span>&gt; 标签为媒介元素（比如 &lt;video&gt; 和 &lt;audio&gt;）定义媒介资源。 <span class="comment">#New	</span></span><br><span class="line">&lt;span&gt;	       定义文档中的节。</span><br><span class="line">&lt;strike&gt;	     HTML5不支持，不赞成使用。定义加删除线文本。</span><br><span class="line">&lt;strong&gt;	     定义强调文本。</span><br><span class="line">&lt;style&gt;	       定义文档的样式信息。</span><br><span class="line">&lt;sub&gt;	         定义下标文本。</span><br><span class="line">&lt;summary&gt;&lt;summary&gt; 标签包含 details 元素的标题，<span class="string">"details"</span> 元素用于描述有关文档或文档片段的详细信息。 <span class="comment">#New	</span></span><br><span class="line">&lt;sup&gt;	         定义上标文本。</span><br><span class="line">&lt;table&gt;        定义表格。</span><br><span class="line">&lt;tbody&gt;	       定义表格中的主体内容。</span><br><span class="line">&lt;td&gt;	         定义表格中的单元。</span><br><span class="line">&lt;textarea&gt;	   定义多行的文本输入控件。</span><br><span class="line">&lt;tfoot&gt;	       定义表格中的表注内容（脚注）。</span><br><span class="line">&lt;th&gt;	         定义表格中的表头单元格。</span><br><span class="line">&lt;thead&gt;	       定义表格中的表头内容。</span><br><span class="line">&lt;time&gt;         定义日期或时间，或者两者。 <span class="comment">#New	</span></span><br><span class="line">&lt;title&gt;	       定义文档的标题。</span><br><span class="line">&lt;tr&gt;	         定义表格中的行。</span><br><span class="line">&lt;track&gt;&lt;track&gt; 标签为诸如 video 元素之类的媒介规定外部文本轨道。 <span class="comment">#New	</span></span><br><span class="line">&lt;tt&gt;	         定义打字机文本。</span><br><span class="line">&lt;u&gt;	           不赞成使用。定义下划线文本。</span><br><span class="line">&lt;ul&gt;	         定义无序列表。</span><br><span class="line">&lt;var&gt;	         定义文本的变量部分。</span><br><span class="line">&lt;video&gt;&lt;video&gt; 标签定义视频，比如电影片段或其他视频流。 <span class="comment">#New	</span></span><br><span class="line">&lt;wbr&gt;          规定在文本中的何处适合添加换行符。 <span class="comment">#New</span></span><br></pre></td></tr></table></figure>
<p>meta标签相关学习：HTML中的meta标签常用属性及其作用总结</p>
<h3 id="2、-块级元素、内联元素相关分类"><a href="#2、-块级元素、内联元素相关分类" class="headerlink" title="2、 块级元素、内联元素相关分类"></a>2、 块级元素、内联元素相关分类</h3><blockquote>
<p>各自的特点：</p>
<ol>
<li>块元素的特点：<br> a.占满整行<br> b.可以通过css改变宽高以及内外边距<br> d.可以容纳内联元素和其他块元素。</li>
<li>内联元素的特点：<br> a.不占满整行<br> b.内容决定宽高，不可以通过css改变宽高以及内外边距<br> d.内联元素只能容纳文本或者其他内联元素。</li>
</ol>
</blockquote>
<blockquote>
<p>常见的块元素：<br>  div p ul ol form  table h1 - h6 hr address  blockquote  center  dir dl fieldset isindex menu noframes noscript pre<br>  常见的内联元素：<br>  span input textarea a img label  sup strong sub u tt select br strike i abbr var  acronym  b  bdo  big  cite  code  dfn  em  font kbd q s samp small<br>  块级元素和内联元素之间的转换：</p>
<ol>
<li>display：block/inline-block/inline/none;</li>
<li>float<br>当把行内元素设置完float:left/right后，该行内元素的display属性会被赋予block值，且拥有浮动特性。行内元素去除了之间的莫名空白。</li>
<li>position<br>当为行内元素进行定位时，position:absolute与position:fixed.都会使得原先的行内元素变为块级元素。</li>
</ol>
</blockquote>
<h3 id="3、-DOM-Document-Object-Model-文档对象模型"><a href="#3、-DOM-Document-Object-Model-文档对象模型" class="headerlink" title="3、 DOM(Document Object Model) 文档对象模型"></a>3、 DOM(Document Object Model) 文档对象模型</h3><ul>
<li><p>DOM的全称是Document Object Model，文档对象模型。</p>
</li>
<li><p>DOM如何创建<br>它本质上是一种尝试将HTML文档的结构和内容转换为可供各种程序使用的对象模型。<br>DOM的对象结构由所谓的“节点树”表示。 它之所以被称为树是因为它可以被认为是具有单个父茎的树，其分枝成几个子枝，每个子枝可以具有叶子。 在这种情况下，父“stem”是根元素，子“branches”是嵌套元素，“leaves”是元素中的内容。</p>
</li>
</ul>
<ol>
<li><p>当HTML无效时<br> DOM是有效HTML文档的接口。 在创建DOM的过程中，浏览器可以纠正HTML代码中的一些无效。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">我们以此HTML文档为例：</span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    Hello, world!</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">该文档缺少和元素，这是有效HTML的要求。 如果我们查看生成的DOM树，我们将看到这已得到纠正：</span><br><span class="line">html</span><br><span class="line">    head</span><br><span class="line">    body</span><br><span class="line">        Hello, world!</span><br></pre></td></tr></table></figure>
</li>
<li><p>当JavaScript修改了DOM</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;&lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">    &lt;p style=&quot;display: none;&quot;&gt;How are you?&lt;/p&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">上面的DOM结构将包含 &lt;p&gt; 元素</span><br><span class="line">html</span><br><span class="line">    head</span><br><span class="line">    body</span><br><span class="line">        h1</span><br><span class="line">            Hello, world!</span><br><span class="line">        p</span><br><span class="line">            How are you?</span><br></pre></td></tr></table></figure>
<ul>
<li>使用:: before和:: after选择器创建的伪元素构成CSSOM和渲染树的一部分，但在技术上不是DOM的一部分。 这是因为DOM仅由源HTML文档构建，不包括应用于元素的样式。<br>尽管伪元素不是DOM的一部分，但它们仍在我们的devtools元素检查器中。<br>这就是为什么伪元素不能被Javascript直接获取到的原因，因为伪元素不是DOM的一部分。</li>
</ul>
</li>
</ol>
<blockquote>
<p>参考: <a href="https://juejin.im/post/5c01e2b051882518eb1f785a" target="_blank" rel="noopener">https://juejin.im/post/5c01e2b051882518eb1f785a</a><br>      <a href="https://blog.csdn.net/qq_29663071/article/details/50982822" target="_blank" rel="noopener">https://blog.csdn.net/qq_29663071/article/details/50982822</a></p>
</blockquote>
<h3 id="4、H5-带来了哪些新标签、新特性"><a href="#4、H5-带来了哪些新标签、新特性" class="headerlink" title="4、H5 带来了哪些新标签、新特性"></a>4、H5 带来了哪些新标签、新特性</h3><h4 id="1-常用新标签"><a href="#1-常用新标签" class="headerlink" title="1) 常用新标签"></a>1) 常用新标签</h4>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;header&gt; 语义 :定义页面的头部 页眉&lt;/header&gt;</span><br><span class="line">&lt;nav&gt; 语义 :定义导航栏 &lt;/nav&gt; </span><br><span class="line">&lt;footer&gt; 语义: 定义 页面底部 页脚&lt;/footer&gt;</span><br><span class="line">&lt;article&gt; 语义: 定义文章&lt;/article&gt;</span><br><span class="line">&lt;section&gt; 语义： 定义区域&lt;/section&gt;</span><br><span class="line">&lt;aside&gt; 语义： 定义其所处内容之外的内容 侧边&lt;/aside&gt;</span><br></pre></td></tr></table></figure>
<h4 id="2-datalist-标签定义选项列表。请与-input-元素配合使用该元素"><a href="#2-datalist-标签定义选项列表。请与-input-元素配合使用该元素" class="headerlink" title="2) datalist 标签定义选项列表。请与 input 元素配合使用该元素"></a>2) datalist 标签定义选项列表。请与 input 元素配合使用该元素</h4>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; value=&quot;请输入明星&quot; list=&quot;star&quot;/&gt;</span><br><span class="line">&lt;datalist id=&quot;star&quot;&gt;</span><br><span class="line">  &lt;option value=&quot;刘德华&quot;&gt;刘德华&lt;/option&gt;</span><br><span class="line">  &lt;option value=&quot;刘若英&quot;&gt;刘若英&lt;/option&gt;</span><br><span class="line">  &lt;option value=&quot;刘晓庆&quot;&gt;刘晓庆&lt;/option&gt;</span><br><span class="line">  &lt;option value=&quot;戚薇&quot;&gt;戚薇&lt;/option&gt;</span><br><span class="line">  &lt;option value=&quot;戚继光&quot;&gt;戚继光&lt;/option&gt;</span><br><span class="line">&lt;/datalist&gt;</span><br></pre></td></tr></table></figure>
<p>  <input type="text" value="请输入明星" list="star"><br>  <datalist id="star"><br>    <option value="刘德华">刘德华</option><br>    <option value="刘若英">刘若英</option><br>    <option value="刘晓庆">刘晓庆</option><br>    <option value="戚薇">戚薇</option><br>    <option value="戚继光">戚继光</option><br>  </datalist></p>
<h4 id="3-fieldset-元素可将表单内的相关元素分组，打包-legend-搭配使用"><a href="#3-fieldset-元素可将表单内的相关元素分组，打包-legend-搭配使用" class="headerlink" title="3) fieldset 元素可将表单内的相关元素分组，打包 legend 搭配使用"></a>3) fieldset 元素可将表单内的相关元素分组，打包 legend 搭配使用</h4>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;fieldset&gt;</span><br><span class="line">  &lt;legend&gt;用户登录&lt;/legend&gt;</span><br><span class="line">  标题</span><br><span class="line">  用户名: &lt;input type=&quot;text&quot; /&gt;</span><br><span class="line">  密　码: &lt;input type=&quot;password&quot; /&gt;</span><br><span class="line">&lt;/fieldset&gt;</span><br></pre></td></tr></table></figure>
<p>  <fieldset><br>    <legend>用户登录</legend><br>    标题<br>    用户名: <input type="text"><br>    密　码: <input type="password"><br>  </fieldset><br><br></p>
<h4 id="4-新增的input-type属性值"><a href="#4-新增的input-type属性值" class="headerlink" title="4) 新增的input type属性值"></a>4) 新增的input type属性值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入邮箱格式 email**** &lt;input type=&quot;email&quot; /&gt;</span><br><span class="line">输入手机号码格式 tel**** &lt;input type=&quot;tel&quot; /&gt;</span><br><span class="line">输入url格式 url**** &lt;input type=&quot;url&quot; /&gt;</span><br><span class="line">输入数字格式 number**** &lt;input type=&quot;number&quot; /&gt;</span><br><span class="line">搜索框（体现语义化） search**** &lt;input type=&quot;search&quot; /&gt;</span><br><span class="line">自由拖动滑块 range**** &lt;input type=&quot;range&quot; /&gt;</span><br><span class="line">小时分钟 time**** &lt;input type=&quot;time&quot; /&gt;</span><br><span class="line">年月日 date**** &lt;input type=&quot;date&quot; /&gt;</span><br><span class="line">时间 datetime**** &lt;input type=&quot;datetime&quot; /&gt;</span><br><span class="line">月年month**** &lt;input type=&quot;month&quot; /&gt;</span><br><span class="line">星期 年 week**** &lt;input type=&quot;week&quot; /&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>常用新属性<br>占位符 当用户输入的时候 里面的文字消失 删除所有文字，自动返回 placeholder<strong><strong> <input type="text" placeholder="请输入用户名"><br>规定当页面加载时 input 元素应该自动获得焦点 autofocus</strong></strong> <figure class="highlight bash"><figcaption><span><input type< span></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">多文件上传 multiple**** &lt;input <span class="built_in">type</span>=<span class="string">"file"</span> multiple /&gt;</span><br><span class="line">规定表单是否应该启用自动完成功能 有2个值，一个是on 一个是off on 代表记录已经输入的值 1.autocomplete 首先需要提交按钮 &lt;br /&gt;2.这个表单您必须给他名字autocomplete****</span><br><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> autocomplete=<span class="string">"off"</span> /&gt;</span><br><span class="line">必填项 内容不能为空 required**** &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> required /&gt;</span><br><span class="line">规定激活（使元素获得焦点）元素的快捷键 采用 alt + s的形式 accesskey**** &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> accesskey=<span class="string">"s"</span> /&gt;</span><br><span class="line"></span><br><span class="line">输入邮箱格式 email**** &lt;input <span class="built_in">type</span>=<span class="string">"email"</span> /&gt;</span><br><span class="line">输入手机号码格式 tel**** &lt;input <span class="built_in">type</span>=<span class="string">"tel"</span> /&gt;</span><br><span class="line">输入url格式 url**** &lt;input <span class="built_in">type</span>=<span class="string">"url"</span> /&gt;</span><br><span class="line">输入数字格式 number**** &lt;input <span class="built_in">type</span>=<span class="string">"number"</span> /&gt;</span><br><span class="line">搜索框（体现语义化） search**** &lt;input <span class="built_in">type</span>=<span class="string">"search"</span> /&gt;</span><br><span class="line">自由拖动滑块 range**** &lt;input <span class="built_in">type</span>=<span class="string">"range"</span> /&gt;</span><br><span class="line">小时分钟 time**** &lt;input <span class="built_in">type</span>=<span class="string">"time"</span> /&gt;</span><br><span class="line">年月日 date**** &lt;input <span class="built_in">type</span>=<span class="string">"date"</span> /&gt;</span><br><span class="line">时间 datetime**** &lt;input <span class="built_in">type</span>=<span class="string">"datetime"</span> /&gt;</span><br><span class="line">月年month**** &lt;input <span class="built_in">type</span>=<span class="string">"month"</span> /&gt;</span><br><span class="line">星期 年 week**** &lt;input <span class="built_in">type</span>=<span class="string">"week"</span> /&gt;</span><br><span class="line">常用新属性 (占位符 当用户输入的时候 里面的文字消失 删除所有文字，自动返回)placeholder**** &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> placeholder=<span class="string">"请输入用户名"</span> /&gt;</span><br><span class="line">规定当页面加载时 input 元素应该自动获得焦点 autofocus**** &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> autofocus /&gt;</span><br><span class="line">多文件上传 multiple**** &lt;input <span class="built_in">type</span>=<span class="string">"file"</span> multiple /&gt;</span><br><span class="line">规定表单是否应该启用自动完成功能 有2个值，一个是on 一个是off on 代表记录已经输入的值 1.autocomplete 首先需要提交按钮 &lt;br /&gt;2.这个表单您必须给他名字autocomplete****</span><br><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> autocomplete=<span class="string">"off"</span> /&gt;</span><br><span class="line">必填项 内容不能为空 required**** &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> required /&gt;</span><br><span class="line">规定激活（使元素获得焦点）元素的快捷键 采用 alt + s的形式 accesskey**** &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> accesskey=<span class="string">"s"</span> /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#### 5) 多媒体标签</span></span><br><span class="line">- embed：标签定义嵌入的内容</span><br><span class="line">  embed可以用来插入各种多媒体，格式可以是 Midi、Wav、AIFF、AU、MP3等等。url为音频或视频文件及其路径，可以是相对路径或绝对路径。</span><br><span class="line"></span><br><span class="line">- 多媒体 audio</span><br><span class="line">  autoplay 自动播放</span><br><span class="line">  controls 是否显不默认播放控件</span><br><span class="line">  loop 循环播放 如果这个属性不写 默认播放一次 loop 或者 loop = “loop” 表示无限循环</span><br><span class="line">  由于版权等原因，不同的浏览器可支持播放的格式是不一样的</span><br><span class="line">  &lt;<span class="built_in">source</span>\&gt; 标签允许您规定可替换的视频/音频文件供浏览器根据它对媒体类型或者编解码器的支持进行选择</span><br><span class="line"></span><br><span class="line">- 多媒体 video</span><br><span class="line">  autoplay 自动播放</span><br><span class="line">  controls 是否显示默认播放控件</span><br><span class="line">  loop 循环播放</span><br><span class="line">  width 设置播放窗口宽度</span><br><span class="line">  height 设置播放窗口的高度</span><br><span class="line">  由于版权等原因，不同的浏览器可支持播放的格式是不一样的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#### 6) CSS3 新增选择器</span></span><br><span class="line"><span class="comment">##### 6.1)  结构(位置)伪类选择器（CSS3)</span></span><br><span class="line">:first-child :选取属于其父元素的首个子元素的指定选择器</span><br><span class="line">:last-child :选取属于其父元素的最后一个子元素的指定选择器</span><br><span class="line">:nth-child(n) ： 匹配属于其父元素的第 N 个子元素，不论元素的类型</span><br><span class="line">:nth-last-child(n) ：选择器匹配属于其元素的第 N 个子元素的每个元素，不论元素的类型，从最后一个子元素开始计数。n 可以是数字、关键词或公式</span><br><span class="line"></span><br><span class="line"><span class="comment">##### 6.2) 属性选择器</span></span><br></pre></td></tr></table></figure></p>
<p>  div[class^=font] {   # class^=font 表示 font 开始位置就行了</p>
<pre><code>color: pink;
</code></pre><p>  }<br>  div[class$=footer] { # class$=footer 表示 footer 结束位置就行了</p>
<pre><code>color: skyblue;
</code></pre><p>  }<br>  div[class<em>=tao] { # class</em>=tao *= 表示tao 在任意位置都可以</p>
<pre><code>color: green;
</code></pre><p>  }</p>
<p>  <div class="font12">属性选择器</div><br>  <div class="font12">属性选择器</div><br>  <div class="font24">属性选择器</div><br>  <div class="font24">属性选择器</div><br>  <div class="font24">属性选择器</div><br>  <div class="24font">属性选择器123</div><br>  <div class="sub-footer">属性选择器footer</div><br>  <div class="jd-footer">属性选择器footer</div><br>  <div class="news-tao-nav">属性选择器</div><br>  <div class="news-tao-header">属性选择器</div><br>  <div class="tao-header">属性选择器</div></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  &lt;style&gt;</span><br><span class="line">    div[class^=font] &#123;</span><br><span class="line">      color: pink;</span><br><span class="line">    &#125;</span><br><span class="line">    div[class$=footer] &#123;</span><br><span class="line">      color: skyblue;</span><br><span class="line">    &#125;</span><br><span class="line">    div[class*=tao] &#123;</span><br><span class="line">      color: green;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line"></span><br><span class="line">  &lt;div class = &quot;font12&quot;&gt;属性选择器&lt;/div&gt;</span><br><span class="line">  &lt;div class = &quot;font12&quot;&gt;属性选择器&lt;/div&gt;</span><br><span class="line">  &lt;div class = &quot;font24&quot;&gt;属性选择器&lt;/div&gt;</span><br><span class="line">  &lt;div class = &quot;font24&quot;&gt;属性选择器&lt;/div&gt;</span><br><span class="line">  &lt;div class = &quot;font24&quot;&gt;属性选择器&lt;/div&gt;</span><br><span class="line">  &lt;div class = &quot;24font&quot;&gt;属性选择器123&lt;/div&gt;</span><br><span class="line">  &lt;div class = &quot;sub-footer&quot;&gt;属性选择器footer&lt;/div&gt;</span><br><span class="line">  &lt;div class = &quot;jd-footer&quot;&gt;属性选择器footer&lt;/div&gt;</span><br><span class="line">  &lt;div class = &quot;news-tao-nav&quot;&gt;属性选择器&lt;/div&gt;</span><br><span class="line">  &lt;div class = &quot;news-tao-header&quot;&gt;属性选择器&lt;/div&gt;</span><br><span class="line">  &lt;div class = &quot;tao-header&quot;&gt;属性选择器&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">##### 6.3) 伪元素选择器（CSS3)</span><br><span class="line">E::first-letter文本的第一个单词或字（如中文、日文、韩文等）</span><br><span class="line">E::first-line 文本第一行；</span><br><span class="line">E::selection 可改变选中文本的样式；</span><br><span class="line">E::before和E::after</span><br><span class="line">在E元素内部的开始位置和结束位创建一个元素，该元素为行内元素，且必须要结合content属性使用。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>div::before {<br> content:”开始”;<br>}<br>div::after {<br> content:”结束”;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* E:after、E:before 在旧版本里是伪元素，CSS3的规范里“:”用来表示伪类，“::”用来表示伪元素，但是在高版本浏览器下E:after、E:before会被自动识别为E::after、E::before，这样做的目的是用来做兼容处理。</span><br><span class="line">注意: 伪元素:before和:after添加的内容默认是inline元素**；这个两个伪元素的content属性，表示伪元素的内容,设置:before和:after时必须设置其content属性，否则伪元素就不起作用。</span><br><span class="line"></span><br><span class="line">##### 6.4) border-box，设置计算盒子大小的方式。</span><br><span class="line">可以分成两种情况：</span><br><span class="line">  1. box-sizing: content-box; 盒子大小为 width + padding + border content-box:此值为其默认值，其让元素维持W3C的标准Box Mode</span><br><span class="line">  2. box-sizing: border-box;  盒子大小为 width 就是说 padding 和 border 是包含到width里面的</span><br><span class="line">  注：上面的标注的width指的是CSS属性里设置的width: length，content的值是会自动调整的。</span><br><span class="line"></span><br><span class="line">##### 6.5)  transition</span><br><span class="line">transition: 要过渡的属性 花费时间 运动曲线 何时开始; 如果有多组属性变化，还是用逗号隔开。</span><br><span class="line">- transition-property 规定应用过渡的 CSS 属性的名称。</span><br><span class="line">- transition-duration 定义过渡效果花费的时间。默认是 0。</span><br><span class="line">- transition-timing-function 规定过渡效果的时间曲线。默认是 &quot;ease&quot;。</span><br><span class="line">- transition-delay 规定过渡效果何时开始。默认是 0。</span><br><span class="line"></span><br><span class="line">如果想要所有的属性都变化过渡， 写一个all 就可以</span><br><span class="line"></span><br><span class="line">##### 6.6) 2D变形 transform</span><br><span class="line">- 移动 translate(x, y)水平方向和垂直方向同时移动（也就是X轴和Y轴同时移动） translateX(x)仅水平方向移动（X轴移动） translateY(Y)仅垂直方向移动（Y轴移动）</span><br><span class="line">- 缩放 scale(X,Y)使元素水平方向和垂直方向同时缩放（也就是X轴和Y轴同时缩放） scaleX(x)元素仅水平方向缩放（X轴缩放） scaleY(y)元素仅垂直方向缩放（Y轴缩放）</span><br><span class="line">- 旋转 rotate(deg), 可以对元素进行旋转，正值为顺时针，负值为逆时针；</span><br><span class="line">- transform-origin可以调整元素转换变形的原点</span><br><span class="line">- 倾斜 skew(deg, deg)</span><br><span class="line"></span><br><span class="line">##### 6.7) 3D变形 transform</span><br><span class="line">- rotatex():沿着x轴进行旋转 x左边是负的，右边是正的</span><br><span class="line">- rotateY():沿着y轴进行旋转 y 上面是负的， 下面是正的</span><br><span class="line">- rotateZ():沿着z轴进行旋转 z 里面是负的， 外面是正的</span><br><span class="line">- translate3d(x,y,z)</span><br><span class="line">[注意]其中，x和y可以是长度值，也可以是百分比，百分比是相对于其本身元素水平方向的宽度和垂直方向的高度和；z只能设置长度值</span><br><span class="line"></span><br><span class="line">backface-visibility:backface-visibility 属性定义当元素不面向屏幕时是否可见</span><br><span class="line"></span><br><span class="line">##### 6.8) 动画 animation</span><br><span class="line">animation:动画名称 动画时间 运动曲线 何时开始 播放次数 是否反方向;</span><br><span class="line">@keyframes 动画名称 &#123;</span><br><span class="line"> from&#123; 开始位置 &#125;  0%</span><br><span class="line"> to&#123; 结束 &#125;  100%</span><br><span class="line">&#125;</span><br><span class="line">animation-iteration-count:infinite; 无限循环播放</span><br><span class="line">animation-play-state:paused; 暂停动画&quot;</span><br><span class="line"></span><br><span class="line">参考：http://www.w3school.com.cn/html5/index.asp</span><br><span class="line">参考：http://www.w3school.com.cn/css3/index.asp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 5、DHTML的掌握 到 HTML5 API盘点</span><br><span class="line">一、简介</span><br><span class="line">DHTML 不是 W3C 标准</span><br><span class="line">DHTML 指动态 HTML（Dynamic HTML）。</span><br><span class="line">DHTML 不是由万维网联盟（W3C）规定的标准。DHTML 是一个营销术语 - 被网景公司（Netscape）和微软公司用来描述 4.x 代浏览器应当支持的新技术。</span><br><span class="line">DHTML 是一种用来创建动态站点的技术组合物。</span><br><span class="line">对大多数人来说，DHTML 意味着 HTML 4.0、样式表以及 JavaScript 的结合物。</span><br><span class="line">W3C 曾讲过：“动态HTML是一个被某些厂商用来描述可使文档动态性更强的HTML、样式表以及脚本的结合物的术语。”</span><br><span class="line">So, 这个题目有点老。。。那我们来介绍下html5吧。。。</span><br><span class="line"></span><br><span class="line">HTML5简介</span><br><span class="line">HTML5是HTML最新的修订版本，2014年10月由万维网联盟（W3C）完成标准制定。</span><br><span class="line"></span><br><span class="line">HTML5的设计目的是为了在移动设备上支持多媒体。</span><br><span class="line"></span><br><span class="line">HTML5 简单易学。</span><br><span class="line"></span><br><span class="line">HTML5 是如何起步的？</span><br><span class="line">HTML5 是 W3C 与 WHATWG 合作的结果，WHATWG 指 Web Hypertext Application Technology Working Group。</span><br><span class="line"></span><br><span class="line">WHATWG 致力于 web 表单和应用程序，而 W3C 专注于 XHTML 2.0。在 2006 年，双方决定进行合作，来创建一个新版本的 HTML。</span><br><span class="line"></span><br><span class="line">HTML5 中的一些有趣的新特性：</span><br><span class="line"></span><br><span class="line">1、用于绘画的 canvas 元素</span><br><span class="line"></span><br><span class="line">2、用于媒介回放的 video 和 audio 元素</span><br><span class="line"></span><br><span class="line">3、对本地离线存储的更好的支持</span><br><span class="line"></span><br><span class="line">4、新的特殊内容元素，比如 article、footer、header、nav、section</span><br><span class="line"></span><br><span class="line">5、新的表单控件，比如 calendar、date、time、email、url、search</span><br><span class="line"></span><br><span class="line">下面介绍一下常用的html api</span><br><span class="line">1、Canvas</span><br><span class="line">Canvas本质上是一个位图画步。</span><br><span class="line">使用canvas编程，首先要获取其上下文（context）。接着在上下文中执行动作，最后将这些动作应用到上下文中。可以将canvas的这种编辑方式想象成数据库事务：开发人员先发起一个事务，然后执行某些操作，最后提交事务。</span><br><span class="line"></span><br><span class="line">html</span><br><span class="line"></span><br><span class="line">&lt;canvas id=&quot;diagonal&quot; style=&quot;border:1px solid;&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">js</span><br><span class="line"></span><br><span class="line">function drawDiagonal()&#123;</span><br><span class="line">     //取的canvas元素及其绘图上下文</span><br><span class="line">     var canvas = document.getElementById(‘diagonal’);</span><br><span class="line">     var context = canvas.getContext(&apos;2d&apos;);</span><br><span class="line"> </span><br><span class="line">     // 用绝对坐标来创建一条路径</span><br><span class="line">     context.beginPath();</span><br><span class="line">     context.moveTo(70,140);</span><br><span class="line">     context.lineTo(140,70);</span><br><span class="line"> </span><br><span class="line">     // 将这条线绘制到canvas上</span><br><span class="line">     context.stroke();</span><br><span class="line">&#125;</span><br><span class="line">window.addEventListener(&apos;load&apos;,drawDiagonal,true);</span><br><span class="line">2、Audio和Video</span><br><span class="line">html5中的多媒体支持。</span><br><span class="line"></span><br><span class="line">&lt;audio id=&quot;clickSound&quot;&gt;</span><br><span class="line">    &lt;source src=&quot;a.ogg&quot;&gt;</span><br><span class="line">    &lt;source src=&quot;b.mp3&quot;&gt;</span><br><span class="line">&lt;/audio&gt;</span><br><span class="line"> </span><br><span class="line">&lt;button id=&quot;toggle&quot; onclick=&quot;toggleSound()&quot;&gt;play&lt;/button&gt;</span><br><span class="line">function toggleSound() &#123;</span><br><span class="line">    var music = document.getElementById(&apos;clickSound&apos;);</span><br><span class="line">    var toggle = document.getElementById(&apos;toggle&apos;);</span><br><span class="line"> </span><br><span class="line">    if(music.paused)&#123;</span><br><span class="line">        music.play();</span><br><span class="line">        toggle.innerHTML = &apos;Pause&apos;;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        music.pause();</span><br><span class="line">        toggle.innerHTML = &apos;Play&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">3、Geolocation</span><br><span class="line">请求一个位置信息，如果用户同意，浏览器就会返回位置信息，该位置信息是通过支持HTML5地理定位功能的底层设备提供给浏览器。位置信息由纬度／经度坐标和一些其他的元数据组成。有了这些位置信息就可以构建引人注意目的位置感知类应用程序。</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var x=document.getElementById(&quot;demo&quot;);</span><br><span class="line">function getLocation()</span><br><span class="line">  &#123;</span><br><span class="line">  if (navigator.geolocation)</span><br><span class="line">    &#123;</span><br><span class="line">    navigator.geolocation.getCurrentPosition(showPosition);</span><br><span class="line">    &#125;</span><br><span class="line">  else&#123;x.innerHTML=&quot;Geolocation is not supported by this browser.&quot;;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">function showPosition(position)</span><br><span class="line">  &#123;</span><br><span class="line">  x.innerHTML=&quot;Latitude: &quot; + position.coords.latitude +</span><br><span class="line">  &quot;&lt;br /&gt;Longitude: &quot; + position.coords.longitude;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4、Web Workers</span><br><span class="line"></span><br><span class="line">HTML5 Web Workers可以让Web 应用程序具备后台处理能力，它对多线程的支持非常好，因此，使用了HTML5的Javascript应用程序可以充分利用多核CPU带来的优势。</span><br><span class="line"></span><br><span class="line">将耗时长的任务分配给HTML5 Web Workers执行，可以避免弹出脚本运行缓慢的警告。</span><br><span class="line"></span><br><span class="line">Web Workers不能直接访问Web 页面和DOM API。</span><br><span class="line"></span><br><span class="line">Web Workers的另一个用途是监听由后台服务器广播的新闻消息，收到后台服务的消息后，将其显示在Web页面上。</span><br><span class="line"></span><br><span class="line">5、requestAnimationFrame</span><br><span class="line">浏览器可以优化并行的动画动作，更合理的重新排列动作序列，并把能够合并的动作放在一个渲染周期内完成，从而呈现出更流畅的动画效果。比如，通过requestAnimationFrame()，JS动画能够和CSS动画/变换或SVG SMIL动画同步发生。另外，如果在一个浏览器标签页里运行一个动画，当这个标签页不可见时，浏览器会暂停它，这会减少CPU，内存的压力，节省电池电量。6、</span><br><span class="line"></span><br><span class="line">6、websocket</span><br><span class="line">WebSocket作为HTML5一种新的协议，实现了浏览器与服务器的双向通讯。在 WebSocket API 中，浏览器和服务器只需要要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。</span><br><span class="line"></span><br><span class="line">7、应用程序缓存</span><br><span class="line">HTML5 的 Web storage API 采用了离线缓存，会生成一个清单文件（manifest file)，这个清单文件实质就是一系列的URL列表文件，这些URL分别指向页面当中的html,css,javascript,图片等相关内容。当使用离线应用时，应用会引入这一清单文件，浏览器会读取这一文件，下载相应的文件，并将其缓存到本地。使得这些web应用能够脱离网络使用，而用户在离线时的更改也同样会映射到清单文件中，并在重新连线之后将更改返回应用，工作方式与我们现在所使用的网盘有着异曲同工之处。</span><br><span class="line"></span><br><span class="line">首先，需要在页面头加入manifest属性：</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html manifest = &quot;cache.manifest&quot;&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">然后cache.manifest文件的书写方式为：</span><br><span class="line"></span><br><span class="line">CACHE MANIFEST</span><br><span class="line">#v0.11</span><br><span class="line"> </span><br><span class="line">CACHE:</span><br><span class="line"> </span><br><span class="line">js/app.js</span><br><span class="line">css/style.css</span><br><span class="line"> </span><br><span class="line">NETWORK:</span><br><span class="line">resourse/logo.png</span><br><span class="line"> </span><br><span class="line">FALLBACK:</span><br><span class="line">/ /offline.html</span><br><span class="line">离线存储的manifest一般由三个部分组成:</span><br><span class="line">1、CACHE:表示需要离线存储的资源列表，由于包含manifest文件的页面将被自动离线存储，所以不需要把页面自身也列出来。</span><br><span class="line"></span><br><span class="line">2、NETWORK:表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在CACHE和NETWORK中有一个相同的资源，那么这个资源还是会被离线存储，也就是说CACHE的优先级更高。</span><br><span class="line"></span><br><span class="line">3、FALLBACK:表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问offline.html。</span><br><span class="line"></span><br><span class="line">参考资料：</span><br><span class="line"></span><br><span class="line">http://www.w3school.com.cn/html5/index.asp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 三、 JS相关</span><br><span class="line">### 1. JS 基本数据类型的掌握、类型判断、常见用法</span><br><span class="line">    js中有六种数据类型，Number,String,Boolean,Undefined,Null 和 Object。es6中新加了一种基本数据类型，Symbol。</span><br><span class="line">    三大引用类型：Object、Array、function</span><br><span class="line"></span><br><span class="line">    类型判断常规方法主要有四种：</span><br><span class="line">    1) typeof</span><br><span class="line">      当操作数为null、[]、object时，都是object</span><br><span class="line">      Tip: 6大原始类型Null、Undefined、String、Number、Boolean和Symbol。</span><br><span class="line">    </span><br><span class="line">    2) instanceof</span><br><span class="line">        instanceof操作符主要用来检查构造函数的原型是否在对象的原型链上。</span><br><span class="line"></span><br><span class="line">    3） Object.prototype.toString</span><br><span class="line">        利用toString方法基本上可以解决所有内置对象类型的判断：</span><br><span class="line">        ``` bash</span><br><span class="line">        function type (obj) &#123;</span><br><span class="line">          return Reflect.apply(Object.prototype.toString, obj, []).replace(/^\[object\s(\w+)\]$/, &apos;$1&apos;).toLowerCase()</span><br><span class="line">        &#125;</span><br><span class="line">        type(new String(&apos;123&apos;)) // string</span><br></pre></td></tr></table></figure></p>
<pre><code>4） construcor
    · 实际上我们也可以通过constructor属性来达到类型判断的效果。
    · 但是在实际情况下，constructor属性可以被随意修改，而且你在原型继承中，很容易忽略掉constructor的正确指向：
    <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Rabbit (name) &#123;</span><br><span class="line">  Animal.call(this, name)</span><br><span class="line">&#125;</span><br><span class="line">Rabbit.prototype = Object.create(Animal.prototype);</span><br><span class="line">// 需要手动设置constructor的正确指向</span><br><span class="line">Rabbit.prototype.constructor = Rabbit;</span><br><span class="line">const rabbit = new Rabbit(<span class="string">'1'</span>);</span><br><span class="line">rabbit.constructor === Rabbit // <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</code></pre><h3 id="2-变量的声明、定义，闭包"><a href="#2-变量的声明、定义，闭包" class="headerlink" title="2. 变量的声明、定义，闭包"></a>2. 变量的声明、定义，闭包</h3><ul>
<li><p>在 JavaScript 中创建变量通常称为”声明”变量。</p>
</li>
<li><p>ES2015(ES6) 新增加了 let 和 const。</p>
<ul>
<li>let 声明的变量只在 let 命令所在的代码块内有效；<pre><code>不可以在使用后声明，没有变量提升；
</code></pre></li>
<li>const 用于声明一个或多个常量，声明时必须有初始值。<pre><code>一旦声明，常量的值就不能修改。
</code></pre></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">使用 var 关键字：</span><br><span class="line">var i = 5;</span><br><span class="line"><span class="keyword">for</span> (var i = 0; i &lt; 10; i++) &#123; // 一些代码... &#125; // 这里输出 i 为 10</span><br><span class="line"></span><br><span class="line">使用 <span class="built_in">let</span> 关键字：</span><br><span class="line">var i = 5;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; 10; i++) &#123; // 一些代码... &#125; // 这里输出 i 为 5</span><br></pre></td></tr></table></figure>
<p>  在第一个实例中，使用了 var 关键字，它声明的变量是全局的，包括循环体内与循环体外。<br>  在第二个实例中，使用 let 关键字， 它声明的变量作用域只在循环体内，循环体外的变量不受影响。</p>
</li>
<li><p>变量提升<br>JavaScript 中，var 关键字定义的变量可以在使用后声明，也就是变量可以先使用再声明（JavaScript 变量提升）。<br>let 关键字定义的变量则不可以在使用后声明，也就是变量需要先声明再使用。</p>
</li>
<li><p>变量作用域<br>变量作用域两种：全局变量、局部变量。js中函数内部可以读取全局变量，函数外部不能读取函数内部的局部变量。</p>
</li>
<li><p>闭包<br>能够读取其他函数内部变量的函数。 或简单理解为定义在一个函数内部的函数，内部函数持有外部函数内变量的引用。</p>
<p>闭包用途<br>1、读取函数内部的变量<br>2、让这些变量的值始终保持在内存中。不会再f1调用后被自动清除。<br>3、方便调用上下文的局部变量。利于代码封装。<br>原因：f1是f2的父函数，f2被赋给了一个全局变量，f2始终存在内存中，f2的存在依赖f1，因此f1也始终存在内存中，不会在调用结束后，被垃圾回收机制回收。</p>
</li>
</ul>
<h3 id="3、-数组、字符串、对象、函数的常⻅操作方法以及深浅拷贝"><a href="#3、-数组、字符串、对象、函数的常⻅操作方法以及深浅拷贝" class="headerlink" title="3、 数组、字符串、对象、函数的常⻅操作方法以及深浅拷贝"></a>3、 数组、字符串、对象、函数的常⻅操作方法以及深浅拷贝</h3><p>一、数组</p>
<ol>
<li>length 是Array的实例属性。返回或设置一个数组中的元素个数。该值是一个无符号 32-bit 整数，并且总是大于数组最高项的下标。</li>
<li>concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。</li>
<li>filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 </li>
<li>find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。</li>
<li>forEach() 方法对数组的每个元素执行一次提供的函数。</li>
<li>includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。</li>
<li>indexOf() 方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。</li>
<li>join() 方法将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。</li>
<li>map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</li>
<li>push() 方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度。</li>
<li>slice() 方法返回一个新的数组对象，这一对象是一个由 begin和 end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。</li>
<li>splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。</li>
</ol>
<p>二、字符串</p>
<ol>
<li>length 属性表示一个字符串的长度。</li>
<li>charAt() 方法从一个字符串中返回指定的字符。</li>
<li>charCodeAt() 方法返回0到65535之间的整数，表示给定索引处的UTF-16代码单元 (在 Unicode 编码单元表示一个单一的 UTF-16 编码单元的情况下，UTF-16 编码单元匹配 Unicode 编码单元。但在——例如 Unicode 编码单元 &gt; 0x10000 的这种——不能被一个 UTF-16 编码单元单独表示的情况下，只能匹配 Unicode 代理对的第一个编码单元) 。如果你想要整个代码点的值，使用 codePointAt()。</li>
<li>indexOf() 方法返回调用  String 对象中第一次出现的指定值的索引，开始在 fromIndex进行搜索。</li>
<li>slice() 方法提取一个字符串的一部分，并返回一新的字符串。</li>
<li>substr() 方法返回一个字符串中从指定位置开始到指定字符数的字符。<br>尽管 String.prototype.substr(…) 没有严格被废弃 (as in “removed from the Web standards”), 但它被认作是遗留的函数并且可以的话应该避免使用。它并非JavaScript核心语言的一部分，未来将可能会被移除掉。如果可以的话，使用 substring() 替代它.</li>
<li>substring() 方法返回一个字符串在开始索引到结束索引之间的一个子集, 或从开始索引直到字符串的末尾的一个子集。</li>
<li>toLowerCase() 会将调用该方法的字符串值转为小写形式，并返回。</li>
<li>toUpperCase() 将调用该方法的字符串值转换为大写形式，并返回。</li>
<li>padStart() 方法用另一个字符串填充当前字符串(重复，如果需要的话)，以便产生的字符串达到给定的长度。填充从当前字符串的开始(左侧)应用的,常见应用（时间格式的补零操作，2019-09-17），右侧填充有相对应的padEnd方法</li>
</ol>
<p>三、对象</p>
<ol>
<li>Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</li>
<li>Object.defineProperties() 方法直接在一个对象上定义新的属性或修改现有属性，并返回该对象。</li>
<li>Object.entries()方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for…in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。</li>
<li>Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for…in 循环遍历该对象时返回的顺序一致 。如果对象的键-值都不可枚举，那么将返回由键组成的5. hasOwnProperty() 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是是否有指定的键）</li>
</ol>
<p>四、函数</p>
<ol>
<li>apply() 方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。</li>
<li>bind()方法创建一个新的函数，在bind()被调用时，这个新函数的this被bind的第一个参数指定，其余的参数将作为新函数的参数供调用时使用。</li>
<li>call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。</li>
</ol>
<p>五、深拷贝、浅拷贝</p>
<p>JSON方法最常用的实现深拷贝的方式，直接看例子：<br>var obj1 = { a: { b: 1 } };<br>var obj2 = JSON.parse(JSON.stringfy(obj1));</p>
<p>这种方法很简单而且好用，但是有一点点瑕疵，它会抛弃对象的constructor。也就是深拷贝之后，不管这个对象原来的构造函数是什么，在深拷贝之后都会变成Object。<br>而且这种方法能正确处理的对象只有 Number, String, Boolean, Array，即那些能够被JSON直接表示的数据结构。RegExp对象或者function是无法通过这种方式深拷贝。<br>同时，也可以直接使用lodash等函数库去实现深拷贝。</p>
<h3 id="4、-正则匹配表达式"><a href="#4、-正则匹配表达式" class="headerlink" title="4、 正则匹配表达式"></a>4、 正则匹配表达式</h3><p>正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript 中，正则表达式也是对象。这些模式被用于 RegExp 的 exec 和 test 方法, 以及 String 的 match、replace、search 和 split 方法。<br>你可以使用以下两种方法之一构建一个正则表达式：<br>使用一个正则表达式字面量，其由包含在斜杠之间的模式组成，如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const regex1 = /ab+c/;</span><br><span class="line">const regex2 = /^[a-zA-Z]+[0-9]*\W?_$/gi;</span><br></pre></td></tr></table></figure></p>
<p>在加载脚本后，正则表达式字面值提供正则表达式的编译。当正则表达式保持不变时，使用此方法可获得更好的性能。<br>或者调用RegExp对象的构造函数，如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const regex1 = new reg(<span class="string">"ab+c"</span>);</span><br><span class="line">const regex2 =  new reg(<span class="string">"^[a-zA-Z]+[0-9]*\W?_$"</span>, gi);</span><br><span class="line">const regex3 =  new reg(/^[a-zA-Z]+[0-9]*\W?_$/, gi);</span><br></pre></td></tr></table></figure></p>
<p>使用构造函数提供正则表达式的运行时编译。使用构造函数，当你知道正则表达式模式将会改变，或者你不知道模式，并从另一个来源，如用户输入。</p>
<p>常用的正则表达式特殊字符如下：</p>
<ul>
<li><p>\<br>匹配将依照下列规则：</p>
<ul>
<li>在非特殊字符之前的反斜杠表示下一个字符是特殊的，不能从字面上解释。例如，前面没有’\’的’b’通常匹配小写’b’，无论它们出现在哪里。如果加了’\’,这个字符变成了一个特殊意义的字符，意思是匹配一个字符边界。</li>
<li>反斜杠也可以将其后的特殊字符，转义为字面量。例如，模式 /a<em>/ 代表会匹配 0 个或者多个 a。相反，模式 /a\</em>/ 将 ‘<em>‘ 的特殊性移除，从而可以匹配像 “a</em>“ 这样的字符串。</li>
<li>使用 new RegExp(“pattern”) 的时候不要忘记将 \ 进行转义，因为 \ 在字符串里面也是一个转义字符。</li>
</ul>
</li>
<li><p>^<br>匹配输入的开始。如果多行标志被设置为true，那么也匹配换行符后紧跟的位置。<br>例如，/^A/ 并不会匹配 “an A” 中的 ‘A’，但是会匹配 “An E” 中的 ‘A’。<br>当 ‘^’ 作为第一个字符出现在一个字符集合模式时，它将会有不同的含义。</p>
</li>
<li><p>$<br>匹配输入的结束。如果多行标示被设置为true，那么也匹配换行符前的位置。<br>例如，/t$/ 并不会匹配 “eater” 中的 ‘t’，但是会匹配 “eat” 中的 ‘t’。</p>
</li>
<li><p>*<br>匹配前一个表达式0次或多次。等价于 {0,}。<br>例如，/bo*/会匹配 “A ghost boooooed” 中的 ‘booooo’ 和 “A bird warbled” 中的 ‘b’，但是在 “A goat grunted” 中将不会匹配任何东西。</p>
</li>
<li><p>+<br>匹配前面一个表达式1次或者多次。等价于 {1,}。<br>例如，/a+/匹配了在 “candy” 中的 ‘a’，和在 “caaaaaaandy” 中所有的 ‘a’。</p>
</li>
<li><p>x|y<br>匹配‘x’或者‘y’。<br>例如，/green|red/匹配“green apple”中的‘green’和“red apple”中的‘red’</p>
</li>
<li><p>[xyz]<br>一个字符集合。匹配方括号中的任意字符，包括转义序列。你可以使用破折号（-）来指定一个字符范围。对于点（.）和星号（*）这样的特殊符号在一个字符集中没有特殊的意义。他们不必进行转义，不过转义也是起作用的。<br>例如，[abcd] 和[a-d]是一样的。他们都匹配”brisket”中的‘b’,也都匹配“city”中的‘c’。/[a-z.]+/ 和/[\w.]+/与字符串“test.i.ng”匹配。</p>
</li>
<li><p>[^xyz]<br>一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。<br>例如，[^abc] 和 [^a-c] 是一样的。他们匹配”brisket”中的‘r’，也匹配“chop”中的‘h’。</p>
</li>
<li><p>\d<br>匹配一个数字。 等价于[0-9]。<br>例如， /\d/ 或者 /[0-9]/ 匹配”B2 is the suite number.”中的’2’。</p>
</li>
</ul>
<h3 id="5、-DOM-相关触发事件、节点操作以及事件相关"><a href="#5、-DOM-相关触发事件、节点操作以及事件相关" class="headerlink" title="5、 DOM 相关触发事件、节点操作以及事件相关"></a>5、 DOM 相关触发事件、节点操作以及事件相关</h3><ul>
<li><p>什么是DOM事件流？<br>想象画在一张纸上的一组同心圆。如果把手指放在圆心上，那么手指指向的不仅仅是一个圆，而是纸上的所有圆。所以如果点击了某个按钮，点击事件不仅仅发生在这个按钮上，整个页面也被点击了。<br>事件流包括三个阶段: 事件捕获(capturing phase)、目标事件(target phase)、事件冒泡(bubbling phase)。<br>发生的顺序是：事件捕获阶段 –&gt; 目标事件阶段 –&gt; 事件冒泡阶段</p>
</li>
<li><p>什么是事件冒泡？<br>事件开始时由最具体的元素(目标元素)接收，然后逐级向上传播。<br>所谓事件冒泡就是事件像泡泡一样从最开始生成的地方一层一层往上冒，比如上图中a标签为事件目标，点击a标签后同时也会触发p、li上的点击事件，一层一层向上直至最外层的html或document。下面是代码示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"box"</span>&gt;</span><br><span class="line">  &lt;a id=<span class="string">"child"</span>&gt;事件冒泡&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  var box = document.getElementById(<span class="string">'box'</span>),</span><br><span class="line">      child = document.getElementById(<span class="string">'child'</span>);</span><br><span class="line">  </span><br><span class="line">  child.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      alert(<span class="string">'我是目标事件'</span>);</span><br><span class="line">  &#125;, <span class="literal">false</span>);</span><br><span class="line">  </span><br><span class="line">  box.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      alert(<span class="string">'事件冒泡至DIV'</span>);</span><br><span class="line">  &#125;, <span class="literal">false</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>上面的代码运行后我们点击a标签，首先会弹出’我是目标事件’提示，然后又会弹出’事件冒泡至DIV’的提示，这便说明了事件自内而外向上冒泡了。<br>那么我们如何阻止事件冒泡呢？这里就涉及事件的Event对象中的stopPropagation方法，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">child.addEventListener(<span class="string">'click'</span>, <span class="keyword">function</span>(e) &#123;</span><br><span class="line">  alert(<span class="string">'我是目标事件'</span>);</span><br><span class="line">  e.stopPropagation();</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>什么是事件捕获？<br>事件按 window -&gt; document -&gt; html -&gt; body -&gt; … -&gt; 目标元素 的方向向下层元素传递。<br>和事件冒泡相反，事件捕获是自上而下执行，我们只需要将addEventListener的第三个参数改为true就行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"box"</span>&gt;</span><br><span class="line">  &lt;a id=<span class="string">"child"</span>&gt;事件冒泡&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  var box = document.getElementById(<span class="string">'box'</span>),</span><br><span class="line">    child = document.getElementById(<span class="string">'child'</span>);</span><br><span class="line">  </span><br><span class="line">  child.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    alert(<span class="string">'我是目标事件'</span>);</span><br><span class="line">  &#125;, <span class="literal">true</span>);</span><br><span class="line">  </span><br><span class="line">  box.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    alert(<span class="string">'事件冒泡至DIV'</span>);</span><br><span class="line">  &#125;, <span class="literal">true</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>DOM事件对象汇总: <a href="https://www.runoob.com/jsref/dom-obj-event.html" target="_blank" rel="noopener">https://www.runoob.com/jsref/dom-obj-event.html</a></p>
</li>
<li><p>鼠标事件<br>在用鼠标触发事件时，主要的事件属性包含鼠标的位置和按键的状态，比如：clientX和clientY指定了鼠标在窗口坐标中的位置，button和which指定了按下的鼠标键是哪个。</p>
<p>onmouseenter:  当鼠标指针移动到元素上时触发<br>onmouseleave：当鼠标移出元素时触发<br>onmouseover：鼠标移到某元素上<br>onmouseout： 鼠标从某元素移开<br>onmouseenter 和 onmouseover 都是移动到元素上时触发，但是区别是onmouseenter移动到子元素上时也会再次触发并且还会再次冒泡到父元素，而onmouseover 只触发一次，当移动到元素的子元素时不会在有再触发也不会在冒泡,</p>
</li>
</ul>
<p>function moveFn(event) {<br>    console.log(event.screenX) // 获取鼠标基于屏幕的X轴坐标<br>    console.log(event.screenY) // 获取鼠标基于屏幕的Y轴坐标<br>    console.log(event.clientX) // 获取鼠标基于浏览器窗口的X轴坐标<br>    console.log(event.clientY) // 获取鼠标基于浏览器窗口的Y轴坐标<br>    console.log(event.pageX) // 获取鼠标基于文档的X轴坐标<br>    console.log(event.pageY) // 获取鼠标基于文档的Y轴坐标<br>}</p>
<p>function clickFn(event) {<br>    console.log(event.button) // 获取鼠标按下的键。非IE浏览器中0为鼠标左键，1为鼠标中键，2为鼠标右键<br>    console.log(event.which) // 获取指定事件上哪个键盘键或鼠标按钮被按下<br>}</p>
<p>document.addEventListener(‘mouseover’, moveFn, false);<br>document.addEventListener(‘click’, clickFn, false);<br>键盘事件<br>在用键盘触发事件时，主要的事件属性包含键盘的按键keyCode和是否按下特殊键，比如：keyCode指定了按下键的键码值，ctrlKey指定是否按下了ctrl键。</p>
<p>function keyFn(event) {<br>    console.log(event.keyCode); // 获取按下键的键码值<br>    console.log(event.ctrlKey); // 获取是否按下了ctrl键<br>    console.log(event.shiftKey); // 获取是否按下了shift键<br>    console.log(event.altKey); // 获取是否按下了alt键<br>    console.log(event.metaKey); // 获取是否按下了meta键<br>}</p>
<p>document.addEventListener(‘keyup’, keyFn, false);</p>
<p>常用DOM节点查找API<br>document.getElementById ：根据ID查找元素，大小写敏感，如果有多个结果，只返回第一个；</p>
<p>document.getElementsByClassName ：根据类名查找元素，多个类名用空格分隔，返回一个 HTMLCollection 。注意兼容性为IE9+（含）。另外，不仅仅是document，其它元素也支持 getElementsByClassName 方法；</p>
<p>document.getElementsByTagName ：根据标签查找元素， * 表示查询所有标签，返回一个 HTMLCollection 。</p>
<p>document.getElementsByName ：根据元素的name属性查找，返回一个 NodeList 。</p>
<p>document.querySelector ：返回单个Node，IE8+(含），如果匹配到多个结果，只返回第一个。</p>
<p>document.querySelectorAll ：返回一个 NodeList ，IE8+(含）。</p>
<p>document.forms ：获取当前页面所有form，返回一个 HTMLCollection ；</p>
<p>节点创建API<br>1、createElement 创建元素: 通过 createElement 创建的元素并不属于 document 对象，它只是创建出来，并未添加到html文档中，要调用 appendChild 或 insertBefore 等方法将其添加到HTML文档中。</p>
<p>2、createTextNode 创建文本节点</p>
<p>3、cloneNode 克隆节点:  node.cloneNode(true/false) ，它接收一个bool参数，用来表示是否复制子元素。</p>
<p>节点修改API<br>1、appendChild</p>
<p>2、insertBefore</p>
<p>3、insertAdjacentHTML</p>
<p>4、Element.insertAdjacentElement()</p>
<p>5、removeChild</p>
<p>6、replaceChild</p>
<p>参考：<a href="https://www.kancloud.cn/webxiaoma/javascript/710903#Event_93" target="_blank" rel="noopener">https://www.kancloud.cn/webxiaoma/javascript/710903#Event_93</a><br>参考：<a href="https://segmentfault.com/a/1190000007082623" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007082623</a><br>参考：<a href="https://www.cnblogs.com/season-huang/p/4322451.html" target="_blank" rel="noopener">https://www.cnblogs.com/season-huang/p/4322451.html</a></p>
<h3 id="6、对于基础的-Window、Document对象概念的掌握、使⽤"><a href="#6、对于基础的-Window、Document对象概念的掌握、使⽤" class="headerlink" title="6、对于基础的 Window、Document对象概念的掌握、使⽤"></a>6、对于基础的 Window、Document对象概念的掌握、使⽤</h3><p>[ Window对象 ] [ Document对象 ]<br>Window对象<br>代表浏览器中一个打开的窗口</p>
<p>对象属性<br>　　window //窗口自身<br>　　window.self //引用本窗户window=window.self<br>　　window.name //为窗口命名<br>　　window.location //URL地址，配备布置这个属性可以打开新的页面</p>
<p>对象方法<br>　　window.alert(“text”) //提示信息会话框<br>　　window.confirm(“text”) //确认会话框<br>　　window.prompt(“text”) //要求键盘输入会话框<br>　　window.setIntervel(“action”,time) //每一隔指定的时间(毫秒)就执行一次操作<br>　　window.clearInterval() //清除时间配备布置作用就是终止轮回<br>　　window.setTimeout(action,time) //隔了指定的时间(毫秒)执行一次操作<br>　　window.open() //打开新的窗口<br>　　window.close() //关闭窗口</p>
<p>成员对象<br>　　window.event<br>　　window.document //见document对象详解<br>　　window.history<br>　　window.screen<br>　　window.navigator<br>　　window.external<br>　　————————————————– ——————-<br>window.history对象<br>　　window.history.length //浏览过的页面数<br>　　history.back() //后退<br>　　history.forward() //前进<br>　　history.go(i) //前进或后退到历史记录的第i个页面  i&gt;0前进, i&lt;0 后退<br>　   ————————————————- ——————-<br>window.screen对象<br>    　window.screen.width //屏幕宽度<br>　　window.screen.height //屏幕高度<br>　　window.screen.colorDepth //屏幕色深<br>　　window.screen.availWidth //可用宽度<br>　　window.screen.availHeight //可用高度(除去任务栏的高度)<br>　　————————————————– ——————-<br>window.external对象<br>　　window.external.AddFavorite(“地址”,”标题” ) //把网站新增到保藏夹<br>　　————————————————– ——————-<br>window.navigator对象<br>　　window.navigator.appCodeName //浏览器代码名<br>　　window.navigator.appName //浏览器应用程序名<br>　　window.navigator.appMinorVersion //浏览器补丁版本<br>　　window.navigator.cpuClass //cpu类型 x86<br>　　window.navigator.platform //操作体系类型 win32<br>　　window.navigator.plugins<br>　　window.navigator.opsProfile<br>　　window.navigator.userProfile<br>　　window.navigator.systemLanguage //客户体系语言 zh-cn简体中文<br>　　window.navigator.userLanguage //用户语言,同上<br>　　window.navigator.appVersion //浏览器版本<br>　　window.navigator.userAgent<br>　　window.navigator.onLine //用户否在线<br>　　window.navigator.cookieEnabled //浏览器是否撑持cookie<br>　　window.navigator.mimeTypes</p>
<p>Document对象<br>代表整个HTML文档，可用来访问页面中所有元素</p>
<p>常用对象方法</p>
<p>document.write()                      //动态向页面写入内容<br>document.createElement(Tag)           //创建一个html标签对象<br>document.getElementById(ID)           //获得指定ID值的对象<br>document.getElementsByName(Name)      //获得指定Name值的对象<br>document.body.appendChild(oTag)</p>
<p>body-主体子对象</p>
<p>document.body.link              //未点击过的链接颜色<br>document.body.alink             //激活链接(焦点在此链接上)的颜色<br>document.body.vlink             //已点击过的链接颜色<br>document.body.text              //文本色<br>document.body.innerText         //设置<body>…</body>之间的文本<br>document.body.innerHTML         //设置<body>…</body>之间的HTML代码<br>document.body.topMargin         //页面上边距<br>document.body.background        //背景图片<br>document.body.appendChild(oTag) //动态生成一个HTML对象</p>
<p>常用对象事件</p>
<p>documeny.location.reload()          //刷新网页<br>document.location.reload(URL)       //打开新的网页<br>document.location.assign(URL)       //打开新的网页<br>document.location.replace(URL)      //打开新的网页<br>location-位置子对象</p>
<p>document.location.hash          // #号后的部分<br>document.location.host          // 域名+端口号<br>document.location.hostname      // 域名<br>document.location.href          // 完整URL<br>document.location.pathname      // 目录部分<br>document.location.port          // 端口号<br>document.location.protocol      // 网络协议(http:)<br>document.location.search        // ?号后的部分</p>
<h3 id="7、原型对象、原型链的相关概念"><a href="#7、原型对象、原型链的相关概念" class="headerlink" title="7、原型对象、原型链的相关概念"></a>7、原型对象、原型链的相关概念</h3><p>原型对象<br>1.1 理解原型对象<br>1) 函数的prototype属性<br>　　1. 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)<br>　　2. 原型对象中有一个属性constructor, 它指向函数对象</p>
<p>2) 操作原型对象<br>　　1. 可以通过prototype属性找到原型对象，并可以给该对象添加属性和方法(通常是添加方法)<br>　　2. 作用: 函数的所有实例对象自动拥有原型中的属性(方法)</p>
<p>1.2 显示原型对象和隐式原型对象<br>1) 概念<br>　　1. 每个函数function都有一个prototype，即显式原型<br>　　2. 每个实例对象都有一个<strong>proto</strong>，可称为隐式原型</p>
<p>看下面一段代码来理解原型：</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>var Person = function(name){<br>    this.name = name;<br>}</p>
<p>Person.prototype.sayHi = function(){<br>    console.log(“Hello! I am “ + this.name + “.”);<br>}</p>
<p>var joe = new Person(“joe”);<br>var john = new Person(“john”);</p>
<p>joe.sayHi();    //Hello! I am joe.<br>john.sayHi();   //Hello! I am john.<br>从上面的代码可以看出来，原型（Person）定义了一些公用的属性和方法；利用原型（Person）创建出来的新对象实例（joe和john对象）会共享原型（Person）的所有属性和方法。</p>
<p>把代码修改一下：</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>var Person = function(name){<br>    this.name = name;<br>}</p>
<p>var joe = new Person(“joe”);<br>var john = new Person(“john”);</p>
<p>Person.prototype.sayHi = function(){<br>    console.log(“Hello! I am “ + this.name + “.”);<br>}</p>
<p>joe.sayHi();    //Hello! I am joe.<br>john.sayHi();   //Hello! I am john.<br>这次把新创建的对象（joe和John）提前到原型（Person）的sayHi方法定义之前，并使用严格模式。原型（Person）的sayHi方法依然会被共享出去，所以原型（Person）的属性和方法总是被原型实例所共享。</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>var Person = function(name){<br>    this.name = name;<br>}</p>
<p>Person.prototype.sayHi = function(){<br>    console.log(“Hello! I am “ + this.name + “.”);<br>}</p>
<p>var joe = new Person(“joe”);<br>var john = new Person(“john”);</p>
<p>joe.sayHi();    //Hello! I am joe.<br>john.sayHi();   //Hello! I am john.</p>
<p>joe.getName = function(){<br>    console.log(this.name);<br>}</p>
<p>joe.getName();    //joe<br>john.getName;   //undefined<br>john.getName();   //报错</p>
<p>也正是因为这样对象的使用才能更加灵活、更加易于扩展。</p>
<p> 原型链<br>1)  概念</p>
<ol>
<li>访问一个对象的属性时，先在自身属性中查找，找到返回</li>
<li>如果没有, 再沿着<strong>proto</strong>这条链向上查找, 找到返回</li>
<li>如果最终没找到, 返回undefined</li>
<li><strong>proto</strong>这条原型查找链就是原型链: 隐式原型</li>
</ol>
<p>2)  作用</p>
<p> 查找对象的属性(方法)</p>
<p>3)  原型链_属性问题</p>
<ol>
<li>读取对象的属性值时: 会自动到原型链中查找</li>
<li>设置对象的属性值时: 不会查找原型链, 如果当前对象中没有此属性, 直接添加此属性并设置其值</li>
<li>方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上</li>
</ol>
<p>在上面的代码中，执行console.log(joe.<strong>proto</strong>)后在控制台可以看到输出了原型（Person），然后继续执行console.log(Person.<strong>proto</strong>)，控制台打印的结果是function(){}，为什么Person的原型是function呢？这是因为Person是一个构造函数，它的本质就是一个函数。在javascript中函数是一等对象。</p>
<p>现在用箭头符号来表示上面原型创建的过程：</p>
<p>代码<br>1<br>2<br>3<br>joe.<strong>proto</strong>  =&gt;  Person,</p>
<p>Person.<strong>proto</strong>  =&gt;  function(){}</p>
<p>由此总结，原型链记录了原型对象创建的整个过程，因此，我给原型链添加一个概念：原型链是原型对象创建过程的历史记录。</p>
<p>参考：<a href="https://www.cnblogs.com/jofun/p/8746511.html" target="_blank" rel="noopener">https://www.cnblogs.com/jofun/p/8746511.html</a></p>
<h3 id="8、-this绑定、概念掌握"><a href="#8、-this绑定、概念掌握" class="headerlink" title="8、 this绑定、概念掌握"></a>8、 this绑定、概念掌握</h3><p>学习 this 的第一步就是明白 this 既不是指向函数自身也不指向函数的作用域。this 实际上是在函数被调用时发生的绑定，它指向什么地方完全取决于函数在哪里被调用。</p>
<p>默认绑定</p>
<p>在 javascript 中 ，最常用的函数调用类型就是独立函数调用，因此可以把这条规则看作是无法应用其他规则时的默认规则。如果在调用函数的时候，函数不带任何修饰，也就是“光秃秃”的调用，那就会应用默认绑定规则, 默认绑定的指向的是全局作用域。</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7</p>
<p>function sayLocation() {<br> console.log(this.atWhere)<br>}</p>
<p>var atWhere = “I am in global”</p>
<p>sayLocation() // 默认绑定，this绑定在全局对象,输出 “I am in global”</p>
<p>再看一个例子</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10</p>
<p>var name = “global”<br>function person() {<br> console.log(this.name) // (1) “global”<br>  person.name = ‘inside’<br> function sayName() {<br>  console.log(this.name) // (2) “global” 不是 “inside”<br> }<br> sayName() // 在person函数内部执行sayName函数,this指向的同样是全局的对象<br>}<br>person()</p>
<p>在这个例子中，person 函数在全局作用域中被调用，因此第(1)句中的 this 就绑定在了全局对象上（在浏览器中是是window，在node中就是global）,因此第(1)句自然输出的是一个全局对象的 name 属性，当然就是”global”了。sayName函数在person函数内调用，即使这样第(2)句中的this指代的仍然是全局对象，即使 person 函数设置了 name 属性。</p>
<p>这就是默认绑定规则,它是 javascript 中最常见的一种函数调用模式，this 的绑定规则也是四种绑定规则中最简单的一种，就是绑定在全局作用域上。</p>
<p>默认绑定里的严格模式</p>
<p>在 javascript 中，如果使用了严格模式，则 this 不能绑定到全局对象。还是以第一个例子，只不过这次加上了严格模式声明</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7</p>
<p>‘use strict’<br>function sayLocation() {<br> console.log(this.atWhere)<br>}<br>var atWhere = “I am in global”<br>sayLocation()<br>// Uncaught TypeError: Cannot read property ‘atWhere’ of undefined</p>
<p>可以看出，在严格模式下，把 this 绑定到全局对象上时，实际上绑定的是 undefined ,因此上面这段代码会报错。</p>
<p>隐式绑定</p>
<p>当函数在调用时，如果函数有所谓的“落脚点”,即有上下文对象时，隐式绑定规则会把函数中的 this 绑定到这个上下文对象。如果觉得上面这段话不够直白的话，还是来看代码。</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14</p>
<p>function say() {<br> console.log(this.name)<br>}<br>var obj1 = {<br> name: “zxt”,<br> say: say<br>}</p>
<p>var obj2 = {<br> name: “zxt1”,<br> say: say<br>}<br>obj1.say() // zxt<br>obj2.say() // zxt1</p>
<p>很简单是不是。在上面这段代码中，obj1 , obj2 就是所谓的 say 函数的落脚点，专业一点的说法就是上下文对象，当给函数指定了这个上下文对象时，函数内部的this 自然指向了这个上下文对象。这也是很常见的一种函数调用模式。</p>
<p>隐式绑定时丢失上下文</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10</p>
<p>function say() {<br> console.log(this.name)<br>}<br>var name = “global”<br>var obj = {<br> name: “inside”,<br> say: say<br>}<br>var alias = obj.say // 设置一个简写 (1)<br>alias() // 函数调用 输出”global” (2)</p>
<p>可以看到这里输出的是 ”global“ ，为什么就和上例中不一样，我们明明只是给 obj.say 换了个名字而已？<br>首先我们来看上面第(1)句代码，由于在 javascript 中，函数是对象，对象之间是引用传递，而不是值传递。因此，第(1)句代码只是 alias = obj.say = say ，也就是 alias = say ，obj.say 只是起了一个桥梁的作用，alias 最终引用的是 say 函数的地址，而与 obj 这个对象无关了。这就是所谓的”丢失上下文“。最终执行 alias 函数，只不过简单的执行了say函数，输出”global”。</p>
<p>显式绑定</p>
<p>显式绑定，顾名思义，显示地将this绑定到一个上下文，javascript中，提供了三种显式绑定的方法，apply,call,bind。apply和call的用法基本相似，它们之间的区别是：</p>
<p>apply(obj,[arg1,arg2,arg3,…] 被调用函数的参数以数组的形式给出<br>call(obj,arg1,arg2,arg3,…) 被调用函数的参数依次给出<br>而bind函数执行后，返回的是一个新函数。下面以代码说明。</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18</p>
<p>// 不带参数<br>function speak() {<br>  console.log(this.name)<br>}</p>
<p>var name = “global”<br>var obj1 = {<br>  name: ‘obj1’<br>}<br>var obj2 = {<br>  name: ‘obj2’<br>}</p>
<p>speak() // global 等价于speak.call(window)<br>speak.call(window)</p>
<p>speak.call(obj1) // obj1<br>speak.call(obj2) // obj2</p>
<p>因此可以看出，apply, call 的作用就是给函数绑定一个执行上下文，且是显式绑定的。因此，函数内的this自然而然的绑定在了 call 或者 apply 所调用的对象上面。</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17</p>
<p>// 带参数<br>function count(num1, num2) {<br>  console.log(this.a * num1 + num2)<br>}</p>
<p>var obj1 = {<br>  a: 2<br>}<br>var obj2 = {<br>  a: 3<br>}</p>
<p>count.call(obj1, 1, 2) // 4<br>count.apply(obj1, [1, 2]) // 4</p>
<p>count.call(obj2, 1, 2) // 5<br>count.apply(obj2, [1, 2]) // 5</p>
<p>上面这个例子则说明了 apply 和 call 用法上的差异。<br>而 bind 函数，则返回一个绑定了指定的执行上下文的新函数。还是以上面这段代码为例</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20</p>
<p>// 带参数<br>function count(num1, num2) {<br>  console.log(this.a * num1 + num2)<br>}</p>
<p>var obj1 = {<br>  a: 2<br>}</p>
<p>var bound1 = count.bind(obj1) // 未指定参数<br>bound1(1, 2) // 4</p>
<p>var bound2 = count.bind(obj1, 1) // 指定了一个参数<br>bound2(2) // 4</p>
<p>var bound3 = count.bind(obj1, 1, 2) // 指定了两个参数<br>bound3() //4</p>
<p>var bound4 = count.bind(obj1, 1, 2, 3) // 指定了多余的参数,多余的参数会被忽略<br>bound4() // 4</p>
<p>所以，bind 方法只是返回了一个新的函数，这个函数内的this指定了执行上下文，而返回这个新函数可以接受参数。</p>
<p>new 绑定</p>
<p>最后要讲的一种 this 绑定规则，是指通过 new 操作符调用构造函数时发生的 this 绑定。首先要明确一点的是，在 javascript 中并没有其他语言那样的类的概念。构造函数也仅仅是普通的函数而已，只不过构造函数的函数名以大写字母开头，也只不过它可以通过 new 操作符调用而已.</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12</p>
<p>function Person(name,age) {<br>  this.name = name<br>  this.age = age<br>  console.log(“我也只不过是个普通函数”)<br>}<br>Person(“zxt”,22) // “我也只不过是个普通函数”<br>console.log(name) // “zxt”<br>console.log(age) // 22</p>
<p>var zxt = new Person(“zxt”,22) // “我也只不过是个普通函数”<br>console.log(zxt.name) // “zxt”<br>console.log(zxt.age) // 22</p>
<p>上面这个例子中，首先定义了一个 Person 函数，既可以普通调用，也可以以构造函数的形式的调用。当普通调用时，则按照正常的函数执行，输出一个字符串。 如果是通过一个new操作符,则构造了一个新的对象。那么，接下来我们再看看两种调用方式， this 分别绑定在了何处首先普通调用时，前面已经介绍过，此时应用默认绑定规则，this绑定在了全局对象上，此时全局对象上会分别增加 name 和 age 两个属性。当通过new操作符调用时，函数会返回一个对象，从输出结果上来看 this 对象绑定在了这个返回的对象上。<br>因此，所谓的new绑定是指通过new操作符来调用函数时，会产生一个新对象，并且会把构造函数内的this绑定到这个对象上。<br>事实上，在javascript中，使用new来调用函数，会自动执行下面的操作。</p>
<p>创建一个全新的对象<br>这个新对象会被执行原型连接<br>这个新对象会绑定到函数调用的this<br>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象<br>四种绑定的优先级</p>
<p>上面讲述了javascript中四种this绑定规则，这四种绑定规则基本上涵盖了所有函数调用情况。但是如果同时应用了这四种规则中的两种甚至更多，又该是怎么样的一个情况，或者说这四种绑定的优先级顺序又是怎么样的。<br>首先，很容易理解，默认绑定的优先级是最低的。这是因为只有在无法应用其他this绑定规则的情况下，才会调用默认绑定。那隐式绑定和显式绑定呢？还是上代码吧，代码可从来不会说谎。</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14</p>
<p>function speak() {<br>  console.log(this.name)<br>}</p>
<p>var obj1 = {<br>  name: ‘obj1’,<br>  speak: speak<br>}<br>var obj2 = {<br>  name: ‘obj2’<br>}</p>
<p>obj1.speak() // obj1 (1)<br>obj1.speak.call(obj2) // obj2 (2)</p>
<p>所以在上面代码中，执行了obj1.speak(),speak函数内部的this指向了obj1，因此(1)处代码输出的当然就是obj1，但是当显式绑定了speak函数内的this到obj2上，输出结果就变成了obj2，所有从这个结果可以看出显式绑定的优先级是要高于隐式绑定的。事实上我们可以这么理解obj1.speak.call(obj2)这行代码，obj1.speak只是间接获得了speak函数的引用，这就有点像前面所说的隐式绑定丢失了上下文。好，既然显式绑定的优先级要高于隐式绑定，那么接下来再来比较一下new 绑定和显式绑定。</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13</p>
<p>function foo(something) {<br>  this.a = something<br>}</p>
<p>var obj1 = {}<br>var bar = foo.bind(obj1) // 返回一个新函数bar，这个新函数内的this指向了obj1 (1)<br>bar(2) // this绑定在了Obj1上，所以obj1.a === 2<br>console.log(obj1.a)</p>
<p>var baz = new bar(3) // 调用new 操作符后，bar函数的this指向了返回的新实例baz (2)</p>
<p>console.log(obj1.a)<br>console.log(baz.a)</p>
<p>我们可以看到，在(1)处，bar函数内部的this原本指向的是obj1，但是在(2)处，由于经过了new操作符调用，bar函数内部的this却重新指向了返回的实例，这就可以说明new 绑定的优先级是要高于显式绑定的。<br>至此，四种绑定规则的优先级排序就已经得出了,分别是</p>
<p>new 绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定</p>
<p>箭头函数中的this绑定</p>
<p>箭头函数是ES6里一个重要的特性。<br>箭头函数的this是根据外层的（函数或者全局）作用域来决定的。函数体内的this对象指的是定义时所在的对象，而不是之前介绍的调用时绑定的对象。举一个例子</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10</p>
<p>var a = 1<br>var foo = () =&gt; {<br>  console.log(this.a) // 定义在全局对象中，因此this绑定在全局作用域<br>}</p>
<p>var obj = {<br>  a: 2<br>}<br>foo() // 1 ,在全局对象中调用<br>foo.call(obj) // 1,显示绑定，由obj对象来调用，但根本不影响结果</p>
<p>从上面这个例子看出，箭头函数的 this 强制性的绑定在了箭头函数定义时所在的作用域，而且无法通过显示绑定，如apply,call方法来修改。在来看下面这个例子</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32</p>
<p>// 定义一个构造函数<br>function Person(name,age) {<br>  this.name = name<br>  this.age = age<br>  this.speak = function (){<br>    console.log(this.name)<br>    // 普通函数（非箭头函数),this绑定在调用时的作用域<br>  }<br>  this.bornYear = () =&gt; {<br>    // 本文写于2016年，因此new Date().getFullYear()得到的是2016<br>    // 箭头函数，this绑定在实例内部<br>    console.log(new Date().getFullYear() - this.age)<br>    }<br>  }<br>}</p>
<p>var zxt = new Person(“zxt”,22)</p>
<p>zxt.speak() // “zxt”<br>zxt.bornYear() // 1994</p>
<p>// 到这里应该大家应该都没什么问题</p>
<p>var xiaoMing = {<br>  name: “xiaoming”,<br>  age: 18 // 小明永远18岁<br>}</p>
<p>zxt.speak.call(xiaoMing)<br>// “xiaoming” this绑定的是xiaoMing这个对象<br>zxt.bornYear.call(xiaoMing)<br>// 1994 而不是 1998,这是因为this永远绑定的是zxt这个实例</p>
<p>因此 ES6 的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 this ，具体来说就是，箭头函数会继承 外层函数调用的this绑定 ，而无论外层函数的this绑定到哪里。</p>
<p>小结</p>
<p>以上就是javascript中所有this绑定的情况，在es6之前，前面所说的四种绑定规则可以涵盖任何的函数调用情况，es6标准实施以后，对于函数的扩展新增了箭头函数，与之前不同的是，箭头函数的作用域位于箭头函数定义时所在的作用域。</p>
<p>而对于之前的四种绑定规则来说，掌握每种规则的调用条件就能很好的理解this到底是绑定在了哪个作用域。</p>
<h3 id="9、-异步的掌握和理解-宏任务、微任务、Promise、async-await"><a href="#9、-异步的掌握和理解-宏任务、微任务、Promise、async-await" class="headerlink" title="9、 异步的掌握和理解(宏任务、微任务、Promise、async-await)"></a>9、 异步的掌握和理解(宏任务、微任务、Promise、async-await)</h3><p>要了解异步我们首先要了解以下基本概念：</p>
<p>一、关于javascript<br>javascript是一门单线程语言，在最新的HTML5中提出了Web-Worker，但javascript是单线程这一核心仍未改变。</p>
<p>二、javascript事件循环<br>既然js是单线程，那就像只有一个窗口的银行，客户需要排队一个一个办理业务，同理js任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务也必须等着。</p>
<p>那么问题来了，假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？</p>
<p>因此聪明的程序员将任务分为两类：</p>
<p>1、同步任务</p>
<p>2、异步任务</p>
<p>当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。</p>
<p>而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。</p>
<p>三、js基本运行机制<br>1、同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。</p>
<p>2、当指定的事情完成时，Event Table会将这个函数移入Event Queue。</p>
<p>3、主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</p>
<p>上述过程会不断重复，也就是常说的Event Loop(事件循环)。流程如下图所示：</p>
<p>举个栗子：</p>
<p>let data = [];<br>$.ajax({<br>    url:<a href="http://www.javascript.com" target="_blank" rel="noopener">www.javascript.com</a>,<br>    data:data,<br>    success:() =&gt; {<br>        console.log(‘发送成功!’);<br>    }<br>})<br>console.log(‘代码执行结束’);<br>上面是一段简易的ajax请求代码：</p>
<p>1、ajax进入Event Table，注册回调函数success。</p>
<p>2、执行console.log(‘代码执行结束’)。</p>
<p>3、ajax事件完成，回调函数success进入Event Queue。</p>
<p>4、主线程从Event Queue读取回调函数success并执行。</p>
<p>那怎么知道主线程执行栈为空？</p>
<p>js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。</p>
<p>四、setTimeout<br>大名鼎鼎的setTimeout无需再多言，大家对他的第一印象就是异步可以延时执行，我们经常这么实现延时3秒执行：</p>
<p>setTimeout(() =&gt; {<br>    task()<br>},3000)<br>那如果是以下这种情况呢？</p>
<p>setTimeout(() =&gt; {<br>    task()<br>},3000)<br>sleep(10000000)<br>这个函数，是经过指定时间后，把要执行的任务(本例中为task())加入到Event Queue中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于3秒。</p>
<p>我们还经常遇到setTimeout(fn,0)这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？</p>
<p>答案是不会的，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。</p>
<p>举个栗子：</p>
<p>setTimeout(() =&gt; {<br>    console.log(‘1’)<br>}, 0);<br>console.log(‘2’);<br>// 2 1<br>关于setTimeout要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。</p>
<p>五、setInterval<br>setInterval上面说完了setTimeout，当然不能错过它的孪生兄弟setInterval。</p>
<p>他俩差不多，只不过后者是循环的执行。</p>
<p>对于执行顺序来说，setInterval会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。</p>
<p>唯一需要注意的一点是，对于setInterval(fn,ms)来说，我们已经知道不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入Event Queue。</p>
<p>一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了。这句话请读者仔细品味。</p>
<p>六、Promise与process.nextTick(callback)<br>Promise的定义和功能本文不再赘述，推荐阅读阮一峰老师的博客 <a href="http://es6.ruanyifeng.com/#docs/promise。" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/promise。</a></p>
<p>而process.nextTick(callback)类似node.js版的”setTimeout”，在事件循环的下一次循环中调用 callback 回调函数。</p>
<p>我们进入正题，除了广义的同步任务和异步任务，我们对任务有更精细的定义：</p>
<p>1、macro-task(宏任务)：包括整体代码script，setTimeout，setInterval</p>
<p>2、micro-task(微任务)：Promise，process.nextTick</p>
<p>不同类型的任务会进入对应的Event Queue，比如setTimeout和setInterval会进入相同的Event Queue。</p>
<p>事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。听起来有点绕，举个栗子：</p>
<p>setTimeout(function() {<br>    console.log(‘setTimeout’);<br>    resolve();<br>}, 0)<br>new Promise(function(resolve) {<br>    console.log(‘promise’);<br>}).then(function() {<br>    console.log(‘then’);<br>})<br>console.log(‘console’);<br>1、这段代码作为宏任务，进入主线程。</p>
<p>2、先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述)</p>
<p>3、接下来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue。</p>
<p>4、遇到console.log()，立即执行。</p>
<p>5、好啦，整体代码script作为第一个宏任务执行结束，看看有哪些微任务？</p>
<p>6、我们发现了then在微任务Event Queue里面，执行。</p>
<p>7、ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。</p>
<p>8、我们发现了宏任务Event Queue中setTimeout对应的回调函数，立即执行。</p>
<p>9、结束。</p>
<p>异步任务的执行流程如下图：</p>
<p>六、async-await<br>1、解决了什么问题?<br>async-await是promise和generator的语法糖，在async/await之前，我们有三种方式写异步代码：</p>
<p>1）嵌套回调</p>
<p>2）以Promise为主的链式回调</p>
<p>3）使用Generators</p>
<p>2、基本用法<br>// async/await<br>async getBooksByAuthorWithAwait(authorId) {<br>    const books = await bookModel.fetchAll();<br>    return books.filter(b =&gt; b.authorId === authorId);<br>}<br>上述代码就是async-await的基本使用形式。</p>
<p>3、async<br>用来表示函数是异步的，定义的函数会返回一个promise对象，可以使用then方法添加回调函数。</p>
<p>async function getNumber() {<br>    return 123;<br>}</p>
<p>getNumber().then(val =&gt; {<br>    console.log(val);// 123<br>}<br>若 async 定义的函数有返回值，return 123; 相当于Promise.resolve(123)</p>
<p>4、await<br>await 后面可以跟任何的JS 表达式。</p>
<p>虽然说 await 可以等很多类型的东西，但是它最主要的意图是用来等待 Promise 对象的状态被 resolved。</p>
<p>如果await的是 promise对象会造成异步函数停止执行并且等待 promise 的解决，如果等的是正常的表达式则立即执行。</p>
<p>***必须出现在 async 函数内部，不能单独使用。</p>
<p>举个栗子：await命令就可以让程序停顿指定的时间</p>
<p>function sleep(interval) {<br>  return new Promise(resolve =&gt; {<br>    setTimeout(resolve, interval);<br>  })<br>}</p>
<p>// 用法<br>async function one2FiveInAsync() {<br>  for(let i = 1; i &lt;= 5; i++) {<br>    console.log(i);<br>    await sleep(1000);<br>  }<br>}</p>
<p>one2FiveInAsync();<br>5、async-await 的陷阱（过于线性化）<br>虽然 await 能够使你的代码看起来像同步代码一样，但是一定要记住这些代码仍然是以异步的方式执行的，注意不要使代码过于线性化。</p>
<p>async getBooksAndAuthor(authorId) {<br>    const books = await bookModel.fetchAll();<br>    const author = await authorModel.fetch(authorId);<br>    return {<br>        author,<br>        books: books.filter(book =&gt; book.authorId === authorId),<br>    };<br>}<br>这段代码看起来逻辑上没有问题。然而是不正确的。</p>
<p>1）await bookModel.fetchAll() 将会等待 fetchAll() 执行完。</p>
<p>2）然后 await authorModel.fetch(authorId) 才会被执行</p>
<p>注意， authorModel.fetch(authorId) 并不依赖 bookModel.fetchAll() 的结果，实际上他们可以并行执行。然而，由于使用了 await 这两次调用就变成了串行的了，花费的总时间将会远超并行的方式。</p>
<p>以下是正确的使用方式：</p>
<p>async getBooksAndAuthor(authorId) {<br>    const bookPromise = bookModel.fetchAll();<br>    const authorPromise = authorModel.fetch(authorId);<br>    const book = await bookPromise;<br>    const author = await authorPromise;<br>    return {<br>        author,<br>        books: books.filter(book =&gt; book.authorId === authorId),<br>    };<br>}<br>或者更复杂的情况下，如果你想依次请求一个列表的内容，你必须依赖 promises：</p>
<p>async getAuthors(authorIds) {<br>    // WRONG, this will cause sequential calls<br>    // const authors = _.map(<br>    //   authorIds,<br>    //   id =&gt; await authorModel.fetch(id));<br>    // CORRECT<br>    const promises = _.map(authorIds, id =&gt; authorModel.fetch(id));<br>    const authors = await Promise.all(promises);<br>}<br>简而言之，你必须把这个工作流程看成是异步的，然后再尝试使用 await 以同步的方式去编写代码。</p>
<p>在复杂的流程下面，直接使用 promises 可能会更简单。</p>
<p>6、错误处理</p>
<p>使用 promises 的情况下，一个异步函数会返回两种可能的值：resolved 和 rejected。我们可以使用 .then() 来处理正常的情况 .catch() 处理异常情况。</p>
<p>然而对于 async/await 来说，异常处理可能会有点诡异。</p>
<p>1）try…catch</p>
<p>最标准的处理方式是使用 try…catch 表达式。当 await 一个函数调用的时候，任何 rejected 的值都会以异常的形式抛出来。这里有个例子：</p>
<p>class BookModel {<br>    fetchAll() {<br>        return new Promise((resolve, reject) =&gt; {<br>            window.setTimeout(() =&gt; {<br>                reject({‘error’: 400})<br>            }, 1000);<br>        });<br>    }<br>}<br>// async/await<br>async getBooksByAuthorWithAwait(authorId) {<br>    try {<br>        const books = await bookModel.fetchAll();<br>    } catch (error) {<br>        console.log(error);    // { “error”: 400 }<br>    }<br>}<br>2）使用 .catch</p>
<p>回忆一下 await 的功能：它会等待一个 promise 完成它的任务。同时请回忆一下， promise.catch() 也会返回一个 promise。因此我们可以像下面这样处理错误处理的方式：</p>
<p>let books = await bookModel.fetchAll()<br>    .catch((error) =&gt; {<br>        console.log(error);<br>    });<br>参考资料：</p>
<p><a href="https://juejin.im/post/59e85eebf265da430d571f89" target="_blank" rel="noopener">https://juejin.im/post/59e85eebf265da430d571f89</a></p>
<p><a href="https://juejin.im/post/5a6547d0f265da3e283a1df7?utm_medium=fe&amp;utm_source=weixinqun#heading-18" target="_blank" rel="noopener">https://juejin.im/post/5a6547d0f265da3e283a1df7?utm_medium=fe&amp;utm_source=weixinqun#heading-18</a></p>
<p><a href="https://juejin.im/post/5d116ae5518825328779c9d5" target="_blank" rel="noopener">https://juejin.im/post/5d116ae5518825328779c9d5</a></p>
<h3 id="10、-http、https协议-amp-amp-各层级关系-amp-amp-状态码"><a href="#10、-http、https协议-amp-amp-各层级关系-amp-amp-状态码" class="headerlink" title="10、 http、https协议&amp;&amp;各层级关系&amp;&amp;状态码"></a>10、 http、https协议&amp;&amp;各层级关系&amp;&amp;状态码</h3><p>一、HTTP<br>1、http概念<br>超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。 设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。通过HTTP或者HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。</p>
<p>HTTP是客户端浏览器或其他程序与Web服务器之间的应用层通信协议。</p>
<p>2、HTTP 特点<br>永远都是客户端发起请求，服务器回送响应 。<br>无状态的协议。 HTTP 是一种无状态协议。协议自身不对请求和响应之间的通信状态进行保存。<br>Cookie 管理状态。 Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。<br>URI 定位资源 HTTP 协议使用 URI 定位互联网上的资源。正是因为 URI 的特定功能，在互联网上任意位置的资源都能访问到。<br>持久连接</p>
<p>HTTP 协议的初始版本中，每进行一个 HTTP 通信都要断开一次 TCP 连接。比如使用浏览器浏览一个包含多张图片的 HTML 页面时，在发送请求访问 HTML 页面资源的同时，也会请求该 HTML 页面里包含的其他资源。因此，每次的请求都会造成无畏的 TCP 连接建立和断开，增加通信量的开销。 为了解决上述 TCP 连接的问题，HTTP/1.1 和部分 HTTP/1.0 想出了持久连接的方法。其特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。旨在建立一次 TCP 连接后进行多次请求和响应的交互。在 HTTP/1.1 中，所有的连接默认都是持久连接。</p>
<p>管线化<br>持久连接使得多数请求以管线化方式发送成为可能。以前发送请求后需等待并接收到响应，才能发送下一个请求。管线化技术出现后，不用等待亦可发送下一个请求。这样就能做到同时并行发送多个请求，而不需要一个接一个地等待响应了。 比如，当请求一个包含多张图片的 HTML 页面时，与挨个连接相比，用持久连接可以让请求更快结束。而管线化技术要比持久连接速度更快。请求数越多，时间差就越明显。</p>
<p>3、http协议层<br>HTTP（HyperText Transfer Protocol），超文本传输协议，是一个基于TCP实现的应用层协议。</p>
<p>4、HTTP工作过程<br>1）地址解析</p>
<p>如用客户端浏览器请求这个页面：localhost.com:8080/index.htm 从中分解出协议名、主机名、端口、对象路径等部分，对于我们的这个地址，解析得到的结果如下：</p>
<p>协议名：http<br>主机名：localhost.com<br>端口：8080<br>对象路径：/index.htm<br>复制代码<br>复制代码<br>在这一步，需要域名系统DNS解析域名,得主机的IP地址。</p>
<p>2）封装HTTP请求数据包</p>
<p>把以上部分结合本机自己的信息，封装成一个HTTP请求数据包</p>
<p>3）封装成TCP包，建立TCP连接（TCP的三次握手）</p>
<p>在HTTP工作开始之前，客户机（Web浏览器）首先要通过网络与服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接。这里是8080端口。</p>
<p>4）客户端向服务器发送请求命令</p>
<p>建立TCP连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。</p>
<p>5）服务器响应</p>
<p>服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。</p>
<p>实体消息是服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据.</p>
<p>6）服务器关闭TCP连接</p>
<p>一般情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接，然后如果客户端或者服务器在其头信息加入了这行代码 Connection:keep-alive ，TCP 连接在发送后将仍然保持打开状态，于是，客户端可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p>
<p>二、HTTPS<br>1、概念<br>超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。</p>
<p>HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。</p>
<p>HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p>
<p>简而言之: HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。</p>
<p>HTTPS比HTTP多了一层TLS/SSL协议</p>
<p>2、http与https区别<br>HTTP 是明文传输，HTTPS 通过 SSL\TLS 进行了加密<br>HTTP 的端口号是 80，HTTPS 是 443<br>HTTPS 需要到 CA 申请证书，一般免费证书很少，需要交费<br>HTTP 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</p>
<p>三、状态码<br>1xx：信息响应( Informational response)<br>简介：表示响应已被服务端接收、理解，但还需做进一步处理，该类型状态码往往是临时性的，因为马上将会变为以下状态之一：成功(2xx)、重定向(3xx)、异常或错误(4xx或5xx)</p>
<p>2XX：请求成功(Success)<br>简介：表示客户端发送的请求已成功被服务端接收、理解、接受</p>
<p>200 成功(ok)：标准的HTTP请求响应成功状态码，get请求中，响应将包含与请求对应的实体，post请求中，响应将包含实体的描述或实体的操作结果<br>202 已接受请求(Accepted)：服务端接受了请求，但还没处理，最终可能会成功、或不会被执行或禁止执行<br>204 无内容(No Content)：服务端成功处理了请求，但没返回任何内容<br>205 重置内容(Reset Content)：服务端成功处理了请求，但没返回任何内容，区别于204的是：该响应要求客户端重置文档视图。<br>206 部分内容(Partial Content)：服务端成功处理了请求的部分内容，该状态码一般用于HTTP下载工具的断点续传功能或多个下载的分段进行(如迅雷下载)<br>3XX：重定向(Redirection)<br>简介：表示客户端需要采取进一步的操作才能完成请求，该状态码常用于URL重定向，后续的请求地址在本次响应的Location域中指明</p>
<p>301 永久移动(Moved Permanently)：被请求资源已被永久的转移到新位置，并且将来对此资源的引用都应该使用它返回的URI之一，新的永久性URI将在Location域中返回。永远也别来烦我，去找张三吧。<br>302 临时移动(Found，原始短语为Moved Temporarily)：由于移动式临时的，客户端以后还是用原来的地址发送请求，新的临时URI将在Location域中返回<br>303 看其它(See Other)：请求的地址已经被移动，请求的对应地址可以在另一个URI上被找到<br>304 未修改(Not Modified)：表示当前资源的版本在根据请求头的If-Modified-Since和If-None-Match参数判断缓存后，资源未曾被修改，这样客户端不需要重新传新资源，客户端仍然使用上次下载的资源复件。<br>4XX：客户端错误(Client errors)<br>简介：表示错误情况可能是由客户端导致的，除非是一个HEAD请求，否则服务器应该把错误请求的详细解释实体抛出来阐述错误情况，这个错误信息应该告诉是临时的还是永久状况，该状态码适用于任何请求方法。客户端应该尽可能把错误实体展示给用户。</p>
<p>400 错误请求(Bad Request)：明显的客户端错误请求(如：语法缺陷，请求包过大、无效的请求消息片段、欺诈性请求路由)<br>401 未授权(Unauthorized)：类似于403 Forbidden错误，但不同的是该错误是指在特定的认证情况下，用户未能通过认证(如：登陆认证)<br>403 已拒绝(Forbidden)：该请求已被服务器验证为有效，但是服务器拒绝了它的操作，一般是因为用户没有取得对应资源的使用权。<br>404 未找到(Not Found)<br>405 方法不被允许(Method Not Allowed)：该请求方法不支持对需请求资源的访问。如：明明是需要post方法的，你却给我传了个get方法<br>406 请求无法接受(Not Acceptable)：请求资源的内容格式无法满足请求头中的要求，因而无法生成响应体，故无法接受，请求的格式由Content-type头重定义的媒体类型决定<br>408 请求超时(Request Timeout)：客户端没有在服务器预备等待的时间内完成一个请求的发送，客户端可以随时再次提交这一请求而无需进行任何更改。<br>409 冲突(Confict)：因为请求存在冲突无法处理，比如多人在线编辑工具出现的冲突<br>5XX：服务器错误(Server errors)<br>简介：表示服务端无法完成请求，该状态表示服务端在处理请求的过程中发生了错误或异常</p>
<p>500 内部服务错误(Internal Server Error)：通用错误消息，服务端遇到了一个未曾预料的情况(如：服务端可能没有使用try catch等错误处理机制来抓到并处理错误异常)，无法给出更具体的错误消息来解释 —— 我的错，但我不知道我错哪了<br>501 请求无法实现(Not implemented)：服务端不支持当前请求中所需的某个功能—— 臣妾做不到啊！<br>502 损坏的网关(Bad Gateway)：作为网关或代理工作的服务端尝试执行请求时，从上游服务器接收到无效的响应。<br>503 服务不可用(Service Unavailable)：由于临时的请求过载，导致服务端无法处理请求，该状况只是暂时的，并且会在一段时间后恢复，如果能预计延迟时间，那么响应中包含一个Retry-After头来标明延迟时间</p>
<h3 id="11、跨域知识的了解以及常见的跨域实现方法"><a href="#11、跨域知识的了解以及常见的跨域实现方法" class="headerlink" title="11、跨域知识的了解以及常见的跨域实现方法"></a>11、跨域知识的了解以及常见的跨域实现方法</h3><p>要明白什么是跨域之前，首先要明白什么是同源策略？</p>
<p>同源策略就是用来限制从一个源加载的文档或脚本与来自另一个源的资源进行交互。<br>如果协议、端口（如果指定了）和主机对于两个页面是相同的，则两个页面具有相同的源，也就是同源。也就是说，同源要同时满足以下3个条件：</p>
<p>协议相同<br>端口相同<br>主机相同<br>举个例子就一目了然了。我们来看下面的页面是否与 <a href="http://store.company.com/dir/index.html" target="_blank" rel="noopener">http://store.company.com/dir/index.html</a> 是同源的?</p>
<p>代码<br>1<br>2<br>3<br>4<br>5</p>
<ol>
<li><a href="http://store.company.com/dir/index2.html" target="_blank" rel="noopener">http://store.company.com/dir/index2.html</a> 同源</li>
<li><a href="http://store.company.com/dir2/index3.html" target="_blank" rel="noopener">http://store.company.com/dir2/index3.html</a> 同源 虽然在不同文件夹下</li>
<li><a href="https://store.company.com/secure.html" target="_blank" rel="noopener">https://store.company.com/secure.html</a> 不同源 不同的协议(https)</li>
<li><a href="http://store.company.com:81/dir/index.html" target="_blank" rel="noopener">http://store.company.com:81/dir/index.html</a> 不同源 不同的端口(81)</li>
<li><a href="http://news.company.com/dir/other.html" target="_blank" rel="noopener">http://news.company.com/dir/other.html</a> 不同源 不同的主机(news)<br>所以当面对跨域问题的时候，有什么解决方案呢？</li>
</ol>
<p>A. document.domain 方法<br>我们来看一个具体场景：有一个页面 <a href="http://www.example.com/a.html" target="_blank" rel="noopener">http://www.example.com/a.html</a> ，它里面有一个iframe，这个iframe的源是 <a href="http://example.com/b.html" target="_blank" rel="noopener">http://example.com/b.html</a> ，很显然它们是不同源的，所以我们无法在父页面中操控子页面的内容。<br>解决方案如下：</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br><!-- b.html --></p>
<script>
    document.domain = 'example.com';
</script>


<hr>
<!-- a.html -->
<script>
    document.domain = 'example.com';
    var iframe = document.getElementById('iframe').contentWindow.document;
    //后面就可以操作iframe里的内容了...
</script>
所以我们只要将两个页面的document.domain设置成一致就可以了，要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域。但是，这种方法只能解决主域相同的跨域问题。

B.window.name 方法
Window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。我们来看一个具体场景，在一个页面 example.com/a.html 中，我们想获取 data.com/data.html 中的数据，以下是解决方案：

代码
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
<!-- data.html -->
<script>
    window.name = 'data'; //这是就是我们需要通信的数据
</script>
-------------------------------------------------------

<!-- a.html -->
<html>
<head><meta name="generator" content="Hexo 3.8.0">
<script>
    function getData () {
        var iframe = document.getElementById('iframe');
        iframe.src = 'example.com/b.html'; // 这里让iframe与父页面同源
        iframe.onload = function () {
            var data = iframe.contentWindow.name; //在这里我们得到了跨域页面中传来的数据
        };
    }
</script>
</head>
<body>
</body>
</html>
C.JSONP 方法
JONSP(JSON with Padding)是JSON的一种使用模式。基本原理如下：

代码
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
<!-- a.html -->
<script>
    function dealData (data) {
        console.log(data);
    }
</script>
<script src="http://example.com/data.php?callback=dealData"></script>


<hr>
<p>&lt;?php<br>    $callback = $_GET[‘callback’];<br>    $data = ‘data’;<br>    echo $callback.’(‘.json_encode($data).’)’;<br>?&gt;</p>
<p>这时候在a.html中我们得到了一条js的执行语句dealData(‘data’)，从而达到了跨域的目的。所以JSONP的原理其实就是利用引入script不限制源的特点，把处理函数名作为参数传入，然后返回执行语句，仔细阅读以上代码就可以明白里面的意思了。<br>如果在jQuery中用JSONP的话就更加简单了：</p>
<p>代码<br>1<br>2<br>3<br>4<br>5</p>
<p><script><br>    $.getJSON(‘’<a href="http://example.com/data.php?callback=?&#39;">http://example.com/data.php?callback=?&#39;</a>, function (data) {<br>        console.log(data);<br>    });<br></script><br>注意jQuery会自动生成一个全局函数来替换callback=?中的问号，之后获取到数据后又会自动销毁，实际上就是起一个临时代理函数的作用。$.getJSON方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用JSONP的回调函数。</p>
<p>D.cors 方法</p>
<p>CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</p>
<p>E.postMessage 方法<br>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p>
<p>代码<br>1<br>2<br>3<br>4</p>
<ul>
<li>页面和其打开的新窗口的数据传递</li>
<li>多窗口之间消息传递</li>
<li>页面与嵌套的iframe消息传递</li>
<li>上面三个场景的跨域数据传递</li>
</ul>
<p>postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。</p>
<p>postMessage(message, targetOrigin, [transfer]);</p>
<p>代码<br>1<br>2<br>3</p>
<ul>
<li>message: 将要发送到其他 window的数据。</li>
<li>targetOrigin:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”*”（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。</li>
<li>transfer(可选)：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</li>
</ul>
<p>Eg. 接下来我们看个例子： <a href="http://localhost:3000/a.html" target="_blank" rel="noopener">http://localhost:3000/a.html</a> 页面向<a href="http://localhost:4000/b.html" target="_blank" rel="noopener">http://localhost:4000/b.html</a> 传递“你是谁”,然后后者传回”不告诉你”。</p>
<p>代码</p>
<p>// a.html</p>
<p>&lt;iframe src=“<a href="http://localhost:4000/b.html&quot;" target="_blank" rel="noopener">http://localhost:4000/b.html&quot;</a> frameborder=”0” id=”frame” onload=”load()”&gt; //等它加载完触发一个事件<br>//内嵌在 <a href="http://localhost:3000/a.html" target="_blank" rel="noopener">http://localhost:3000/a.html</a></p>
<p><script><br>    function load() {<br>        let frame = document.getElementById(‘frame’)<br>        frame.contentWindow.postMessage(‘你是谁’, ‘<a href="http://localhost:4000&#39;">http://localhost:4000&#39;</a>) //发送数据<br>        window.onmessage = function(e) {<br>        //接受返回数据<br>            console.log(e.data) //不告诉你<br>        }<br>    }<br></script><br>// b.html<br>window.onmessage = function(e) {<br>    console.log(e.data) // 你是谁<br>    e.source.postMessage(‘不告诉你’, e.origin)<br>}</p>
<p>参考：<a href="https://juejin.im/post/5c23993de51d457b8c1f4ee1" target="_blank" rel="noopener">https://juejin.im/post/5c23993de51d457b8c1f4ee1</a><br>参考：<a href="https://segmentfault.com/a/1190000013278814" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013278814</a><br>参考：<a href="https://blog.csdn.net/guoshenglong11/article/details/51953063" target="_blank" rel="noopener">https://blog.csdn.net/guoshenglong11/article/details/51953063</a></p>
<h3 id="12、-浏览器中的常见各类攻击手段"><a href="#12、-浏览器中的常见各类攻击手段" class="headerlink" title="12、 浏览器中的常见各类攻击手段"></a>12、 浏览器中的常见各类攻击手段</h3><p>常见的web攻击手段有 XSS攻击、CSRF攻击、SQL注入攻击…</p>
<p><em>XSS攻击
</em>CSRF攻击<br><em>SQL注入攻击
</em>文件上传漏洞<br><em>DDoS攻击
</em>其他攻击手段</p>
<p>XSS攻击<br>XSS（Cross Site Scripting）跨站脚本攻击，为了不与层叠样式表（CSS）混淆，故将跨站脚本攻击缩写为XSS。原理即在网页中嵌入恶意脚本，当用户打开网页时，恶意脚本便开始在用户浏览器上执行，以盗取客户端cookie、用户名、密码，甚至下载木马程式，危害可想而知。以一个表单输入举例说明：</p>
<p>代码<br>1</p>
<input type="text" name="firstname" value>


<p>倘若用户在表单中输入恶意脚本，即对输入做些处理，如：</p>
<p>代码<br>1</p>
<p><input type="text" name="firstname" value><script>alert(“longlong”)</script>&lt;!– “/&gt;</p>
<p>其实攻击的形式还有很多，比如将脚本伪装进URL，然后将URL进行URLEncode编码，当用户点击链接后，脚本就会被执行。</p>
<p>XSS防范：</p>
<p>之所以会发生XSS攻击，是因为用户输入的数据变成了代码， 因此需要对用户输入的数据进行HTML转义处理，将输出的“尖括号”、“单引号”、“引号”之类的特色符号进行转义。</p>
<p>HTML    HTML转义后的字符<br>&lt;    &lt;</p>
<blockquote>
<p>   &gt;<br>‘    &amp;<br>“    &quot;<br>CSRF攻击<br>CSRF攻击的全称跨站请求伪造（Cross Site Request Forgery），通过盗用用户的身份信息，以你的名义向第三方网站发起恶意请求，若转账、盗取账号、发信息、邮件。流程框图如下：</p>
</blockquote>
<p>所以CSRF攻击一般场景是：</p>
<p>1、用户登录受信站点A，生成本地cookie；<br>2、用户没有退出站点A，访问了恶意站点B。</p>
<p>CSRF攻击举例：</p>
<p>恶意转账</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>Get请求<br><a href="http://www.boc.com/transfer.do?accountNum=6233XXXX4324&amp;money=10000" target="_blank" rel="noopener">www.boc.com/transfer.do?accountNum=6233XXXX4324&amp;money=10000</a><br>参数说明<br>accountNum转账目标账号<br>money转账金额<br>如果银行系统利用上述接口转账，就用可能会被恶意网站攻击。当然上面仅是举例，银行安全等级不至于这么低，使用GET转账。比如银行升级接口为POST提交，当然这也不能解决根本的安全问题，黑客照样能够利用XSS漏洞植入恶意代码，请求转账接口。真实银行交易系统付款会有USB key、验证码、登陆密码、支付密码等一系列屏障，支付流程要复杂得多，安全系数也高很多。</p>
<p>CSRF攻击防御：</p>
<p>将cookie设置为HttpOnly<br>CSRF攻击很大程度是利用了浏览器的cookie，为了防止站内XSS漏洞，cookie设置HttpOnly属性，JS脚本就无法读取到cookie中的信息，避免攻击者伪造cookie的情况出现。<br>设置方式参考：<a href="https://www.cnblogs.com/relucent/p/4171478.html" target="_blank" rel="noopener">https://www.cnblogs.com/relucent/p/4171478.html</a></p>
<p>增加token</p>
<p>CSRF攻击之所以成功，主要是攻击中伪造了用户请求，而用户请求的验证信息都在cookie中，攻击者就可以利用cookie伪造请求通过安全验证。因此抵御CSRF攻击的关键就是，在请求中放入攻击者不能伪造的信息，并且信息不在cookie中。<br>鉴于此，开发人员可以在http请求中以参数的形式加一个token，此token在服务端生成，也在服务端校验，服务端的每次会话都可以用同一个token。如果验证token不一致，则认为至CSRF攻击，拒绝请求。 表单中增加一个隐藏域：</p>
<p>代码<br>1</p>
<p><input type="hidden" name="_token" value="tokenvalue"><br>在服务端session中添加token：</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>HttpSession session = request.getSession();<br>Object token = session.getAttribute(“_token”);<br>if(token == null || “”.equals(_token){<br>    session.setAttribute(“_token”,UUID.randomUUID().toString());<br>}<br>通过Referer识别</p>
<p>Http头中有一个字段Referer，它记录了Http请求来源地址。但是注意不要把Rerferer用在身份验证或者其他非常重要的检查上，因为Rerferer非常容易在客户端被改变。（火狐的一个插件RefControl修改Referer引用）</p>
<p>SQL注入攻击<br>SQL注入攻击就是把SQL命令伪装成正常的http请求参数，传递到服务端，欺骗服务器最终执行恶意的SQL命令，达到入侵目的。SQL注入攻击原理如下：</p>
<p>代码<br>1<br>2<br>3<br>String sql = “select * from user where nick = ‘“ + nickname + “‘ and password = ‘“ + password + “‘“;<br>Statement st = (Statement) conn.createStatement();<br>ResultSet rs = st.executeQuery(sql);<br>上述代码是校验用户名、密码是否有效，查询结果记录数大于0则表示有效。正常逻辑是用户名、密码匹配数据库记录；但攻击者会利用http参数进行SQL注入攻击，即password参数输入’ or ‘1’ = ‘1，导致SQL语句变为</p>
<p>代码<br>1<br>select * from user where nick = ‘zhangshan’ and password = ‘’ or ‘1’ = ‘1’;<br>上述语句的执行结果就相当于用户能够绕过登录验证。</p>
<p>SQL注入防范</p>
<p>使用预编译语句<br>Java原生的预编译语句为PreparedStatement，是Java.sql中的一个接口，继承自Statement。</p>
<p>SQL执行    说明<br>Statement    SQL语句（包含参数）会直接发给DBMS，编译后再执行<br>PreparedStatement    SQL语句（参数为占位符？）发给DBMS编译，DBMS直接运行编译后的SQL语句，参数会在执行阶段传入<br>使用ORM框架 ORM框架如MyBatis <a href="http://www.mybatis.org/mybatis-3/，在Mapper" target="_blank" rel="noopener">http://www.mybatis.org/mybatis-3/，在Mapper</a> XML配置的语句如下：</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6</p>
<p><select id="selectPerson" parametertype="int" resulttype="hashmap"><br>  SELECT * FROM PERSON WHERE ID = #{id}<br></select></p>
<p><select id="selectPerson" parametertype="int" resulttype="hashmap"><br>  SELECT * FROM PERSON WHERE ID = ${id}<br></select><br>有两种参数传递的方式：#{}、${}，两者的差异就在于，#是在预编译后，执行语句时再传递参数，$是先传递参数，然后再执行编译，再执行语句，SQL注入就是利用这种方式。</p>
<p>参考：<a href="https://blog.csdn.net/loongshawn/article/details/88047373" target="_blank" rel="noopener">https://blog.csdn.net/loongshawn/article/details/88047373</a><br>参考：<a href="https://blog.csdn.net/zou2ouzou/article/details/60888073" target="_blank" rel="noopener">https://blog.csdn.net/zou2ouzou/article/details/60888073</a></p>
<h3 id="13、关于-storage-和-cookie-的知识点，包括常见的缓存、存储机制"><a href="#13、关于-storage-和-cookie-的知识点，包括常见的缓存、存储机制" class="headerlink" title="13、关于 storage 和 cookie 的知识点，包括常见的缓存、存储机制"></a>13、关于 storage 和 cookie 的知识点，包括常见的缓存、存储机制</h3><p>Cookie<br>1.Cookie 的来源</p>
<p>Cookie 的本职工作并非本地存储，而是“维持状态”。 因为HTTP协议是无状态的，HTTP协议自身不对请求和响应之间的通信状态进行保存，通俗来说，服务器不知道用户上一次做了什么，这严重阻碍了交互式Web应用程序的实现。在典型的网上购物场景中，用户浏览了几个页面，买了一盒饼干和两瓶饮料。最后结帐时，由于HTTP的无状态性，不通过额外的手段，服务器并不知道用户到底买了什么，于是就诞生了Cookie。它就是用来绕开HTTP的无状态性的“额外手段”之一。服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器会话中的状态。</p>
<p>我们可以把Cookie 理解为一个存储在浏览器里的一个小小的文本文件，它附着在 HTTP 请求上，在浏览器和服务器之间“飞来飞去”。它可以携带用户信息，当服务器检查 Cookie 的时候，便可以获取到客户端的状态。</p>
<p>在刚才的购物场景中，当用户选购了第一项商品，服务器在向用户发送网页的同时，还发送了一段Cookie，记录着那项商品的信息。当用户访问另一个页面，浏览器会把Cookie发送给服务器，于是服务器知道他之前选购了什么。用户继续选购饮料，服务器就在原来那段Cookie里追加新的商品信息。结帐时，服务器读取发送来的Cookie就行了。</p>
<p>2.什么是Cookie及应用场景</p>
<p>Cookie指某些网站为了辨别用户身份而储存在用户本地终端上的数据(通常经过加密)。 cookie是服务端生成，客户端进行维护和存储。通过cookie,可以让服务器知道请求是来源哪个客户端，就可以进行客户端状态的维护，比如登陆后刷新，请求头就会携带登陆时response header中的set-cookie,Web服务器接到请求时也能读出cookie的值，根据cookie值的内容就可以判断和恢复一些用户的信息状态。</p>
<p>如上图所示，Cookie 以键值对的形式存在。<br>典型的应用场景有：</p>
<p>记住密码，下次自动登录。<br>购物车功能。<br>记录用户浏览数据，进行商品（广告）推荐。<br>3.Cookie的原理及生成方式</p>
<p>Cookie的原理</p>
<p>第一次访问网站的时候，浏览器发出请求，服务器响应请求后，会在响应头里面添加一个Set-Cookie选项，将cookie放入到响应请求中，在浏览器第二次发请求的时候，会通过Cookie请求头部将Cookie信息发送给服务器，服务端会辨别用户身份，另外，Cookie的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。<br>Cookie的生成方式主要有两种：</p>
<p>生成方式一：http response header中的set-cookie<br>我们可以通过响应头里的 Set-Cookie 指定要存储的 Cookie 值。默认情况下，domain 被设置为设置 Cookie 页面的主机名，我们也可以手动设置 domain 的值。</p>
<p>代码<br>1<br>Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2018 07:28:00 GMT;//可以指定一个特定的过期时间（Expires）或有效期（Max-Age）<br>当Cookie的过期时间被设定时，设定的日期和时间只与客户端相关，而不是服务端。</p>
<p>生成方式二：js中可以通过document.cookie可以读写cookie，以键值对的形式展示<br>例如我们在掘金社区控制台输入以下三句代码，便可以在Chrome 的 Application 面板查看生成的cookie:</p>
<p>代码<br>1<br>2<br>3<br>document.cookie=”userName=hello”<br>document.cookie=”gender=male”<br>document.cookie=’age=20;domain=.baidu.com’</p>
<p>从上图中我们可以得出：<br>Domain 标识指定了哪些域名可以接受Cookie。如果没有设置domain，就会自动绑定到执行语句的当前域。 如果设置为”.baidu.com”,则所有以”baidu.com”结尾的域名都可以访问该Cookie，所以在掘金社区上读取不到第三条代码存储Cookie值。</p>
<p>4.Cookie的缺陷</p>
<p>Cookie 不够大<br>Cookie的大小限制在4KB左右，对于复杂的存储需求来说是不够用的。当 Cookie 超过 4KB 时，它将面临被裁切的命运。这样看来，Cookie 只能用来存取少量的信息。此外很多浏览器对一个站点的cookie个数也是有限制的。这里需注意：各浏览器的cookie每一个name=value的value值大概在4k，所以4k并不是一个域名下所有的cookie共享的,而是一个name的大小。<br>过多的 Cookie 会带来巨大的性能浪费<br>Cookie 是紧跟域名的。同一个域名下的所有请求，都会携带 Cookie。大家试想，如果我们此刻仅仅是请求一张图片或者一个 CSS 文件，我们也要携带一个 Cookie 跑来跑去（关键是 Cookie 里存储的信息并不需要），这是一件多么劳民伤财的事情。Cookie 虽然小，请求却可以有很多，随着请求的叠加，这样的不必要的 Cookie 带来的开销将是无法想象的。<br>cookie是用来维护用户信息的，而域名(domain)下所有请求都会携带cookie，但对于静态文件的请求，携带cookie信息根本没有用，此时可以通过cdn（存储静态文件的）的域名和主站的域名分开来解决。<br>由于在HTTP请求中的Cookie是明文传递的，所以安全性成问题，除非用HTTPS。<br>5.Cookie与安全</p>
<p>对于 cookie 来说，我们还需要注意安全性。</p>
<p>HttpOnly 不支持读写，浏览器不允许脚本操作document.cookie去更改cookie， 所以为避免跨域脚本 (XSS) 攻击，通过JavaScript的 Document.cookie API无法访问带有 HttpOnly 标记的Cookie，它们只应该发送给服务端。如果包含服务端 Session 信息的 Cookie 不想被客户端 JavaScript 脚本调用，那么就应该为其设置 HttpOnly 标记。</p>
<p>代码<br>1<br>Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly<br>标记为 Secure 的Cookie只应通过被HTTPS协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过Cookie传输，因为Cookie有其固有的不安全性，Secure 标记也无法提供确实的安全保障。<br>为了弥补 Cookie 的局限性，让“专业的人做专业的事情”，Web Storage 出现了。<br>HTML5中新增了本地存储的解决方案—-Web Storage，它分成两类：sessionStorage和localStorage。这样有了WebStorage后，cookie能只做它应该做的事情了——作为客户端与服务器交互的通道，保持客户端状态。</p>
<p>LocalStorage<br>1.LocalStorage的特点</p>
<p>保存的数据长期存在，下一次访问该网站的时候，网页可以直接读取以前保存的数据。<br>大小为5M左右<br>仅在客户端使用，不和服务端进行通信<br>接口封装较好<br>基于上面的特点，LocalStorage可以作为浏览器本地缓存方案，用来提升网页首屏渲染速度(根据第一请求返回时，将一些不变信息直接存储在本地)。</p>
<p>2.存入/读取数据</p>
<p>localStorage保存的数据，以“键值对”的形式存在。也就是说，每一项数据都有一个键名和对应的值。所有的数据都是以文本格式保存。 存入数据使用setItem方法。它接受两个参数，第一个是键名，第二个是保存的数据。 localStorage.setItem(“key”,”value”); 读取数据使用getItem方法。它只有一个参数，就是键名。 var valueLocal = localStorage.getItem(“key”);<br>具体步骤，请看下面的例子：</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16</p>
<p><script><br>  if(window.localStorage){<br>    localStorage.setItem（’name’,’world’）<br>    localStorage.setItem（’gender’,’female’）<br> }<br></script></p>
<p><body><br>  <div id="name"></div><br>  <div id="gender"></div><br>  <script><br>    var name=localStorage.getItem(‘name’)<br>    var gender=localStorage.getItem(‘gender’)<br>    document.getElementById(‘name’).innerHTML=name<br>    document.getElementById(‘gender’).innerHTML=gender<br>  </script><br></body><br>3.使用场景</p>
<p>LocalStorage在存储方面没有什么特别的限制，理论上 Cookie 无法胜任的、可以用简单的键值对来存取的数据存储任务，都可以交给 LocalStorage 来做。<br>这里给大家举个例子，考虑到 LocalStorage 的特点之一是持久，有时我们更倾向于用它来存储一些内容稳定的资源。比如图片内容丰富的电商网站会用它来存储 Base64 格式的图片字符串：</p>
<p>sessionStorage<br>sessionStorage保存的数据用于浏览器的一次会话，当会话结束（通常是该窗口关闭），数据被清空；sessionStorage 特别的一点在于，即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的 sessionStorage 内容便无法共享；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。除了保存期限的长短不同，SessionStorage的属性和方法与LocalStorage完全一样。</p>
<p>1.sessionStorage的特点</p>
<p>会话级别的浏览器存储<br>大小为5M左右<br>仅在客户端使用，不和服务端进行通信<br>接口封装较好<br>基于上面的特点，sessionStorage 可以有效对表单信息进行维护，比如刷新时，表单信息不丢失。</p>
<p>2.使用场景</p>
<p>sessionStorage 更适合用来存储生命周期和它同步的会话级别的信息。这些信息只适用于当前会话，当你开启新的会话时，它也需要相应的更新或释放。比如微博的 sessionStorage就主要是存储你本次会话的浏览足迹：</p>
<p>lasturl 对应的就是你上一次访问的 URL 地址，这个地址是即时的。当你切换 URL 时，它随之更新，当你关闭页面时，留着它也确实没有什么意义了，干脆释放吧。这样的数据用 sessionStorage 来处理再合适不过。</p>
<p>3.sessionStorage 、localStorage 和 cookie 之间的区别</p>
<p>共同点：都是保存在浏览器端，且都遵循同源策略。<br>不同点：在于生命周期与作用域的不同<br>作用域：localStorage只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份localStorage数据。sessionStorage比localStorage更严苛一点，除了协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下:</p>
<p>生命周期：localStorage 是持久化的本地存储，存储在其中的数据是永远不会过期的，使其消失的唯一办法是手动删除；而 sessionStorage 是临时性的本地存储，它是会话级别的存储，当会话结束（页面被关闭）时，存储内容也随之被释放。<br>Web Storage 是一个从定义到使用都非常简单的东西。它使用键值对的形式进行存储，这种模式有点类似于对象，却甚至连对象都不是——它只能存储字符串，要想得到对象，我们还需要先对字符串进行一轮解析。<br>说到底，Web Storage 是对 Cookie 的拓展，它只能用于存储少量的简单数据。当遇到大规模的、结构复杂的数据时，Web Storage 也爱莫能助了。这时候我们就要清楚我们的终极大 boss——IndexedDB！</p>
<p>IndexedDB<br>IndexedDB 是一种低级API，用于客户端存储大量结构化数据(包括文件和blobs)。该API使用索引来实现对该数据的高性能搜索。IndexedDB 是一个运行在浏览器上的非关系型数据库。既然是数据库了，那就不是 5M、10M 这样小打小闹级别了。理论上来说，IndexedDB 是没有存储上限的（一般来说不会小于 250M）。它不仅可以存储字符串，还可以存储二进制数据。</p>
<p>1.IndexedDB的特点</p>
<p>键值对储存。<br>IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以”键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。<br>异步<br>IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。<br>支持事务。<br>IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。<br>同源限制<br>IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。<br>储存空间大<br>IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。<br>支持二进制储存。<br>IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。<br>2.IndexedDB的常见操作</p>
<p>在IndexedDB大部分操作并不是我们常用的调用方法，返回结果的模式，而是请求——响应的模式。</p>
<p>建立打开IndexedDB —-window.indexedDB.open(“testDB”)<br>这条指令并不会返回一个DB对象的句柄，我们得到的是一个IDBOpenDBRequest对象，而我们希望得到的DB对象在其result属性中</p>
<p>除了result，IDBOpenDBRequest接口定义了几个重要属性:</p>
<p>onerror: 请求失败的回调函数句柄<br>onsuccess:请求成功的回调函数句柄<br>onupgradeneeded:请求数据库版本变化句柄<br>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18</p>
<p><script><br>  function openDB(name){<br>    var request=window.indexedDB.open(name)//建立打开IndexedDB<br>    request.onerror=function (e){<br>      console.log(‘open indexdb error’)<br>    }<br>    request.onsuccess=function (e){<br>      myDB.db=e.target.result//这是一个 IDBDatabase对象，这就是IndexedDB对象<br>      console.log(myDB.db)//此处就可以获取到db实例<br>    }<br>  }<br>  var myDB={<br>    name:’testDB’,<br>    version:’1’,<br>    db:null<br>  }<br>  openDB(myDB.name)<br></script><br>控制台得到一个 IDBDatabase对象，这就是IndexedDB对象</p>
<p>关闭IndexedDB—-indexdb.close()</p>
<p>代码<br>1<br>2<br>3<br>function closeDB(db){<br>  db.close();<br>}<br>删除IndexedDB—-window.indexedDB.deleteDatabase(indexdb)</p>
<p>代码<br>1<br>2<br>3<br>function deleteDB(name) {<br>  indexedDB.deleteDatabase(name)<br>}<br>WebStorage、cookie 和 IndexedDB之间的区别</p>
<p>从上表可以看到，cookie 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 localStorage 和 sessionStorage 。对于不怎么改变的数据尽量使用 localStorage 存储，否则可以用 sessionStorage 存储。</p>
<p>总结下本文几个核心观点：</p>
<p>Cookie 的本职工作并非本地存储，而是“维持状态”<br>Web Storage 是 HTML5 专门为浏览器存储而提供的数据存储机制，不与服务端发生通信<br>IndexedDB 用于客户端存储大量结构化数据</p>
<p>参考：<a href="https://github.com/amandakelake/blog/issues/43" target="_blank" rel="noopener">https://github.com/amandakelake/blog/issues/43</a><br>参考：<a href="https://juejin.im/post/5c8e6fa8e51d453ec75168cd" target="_blank" rel="noopener">https://juejin.im/post/5c8e6fa8e51d453ec75168cd</a></p>
<h3 id="14、关于-Node-js-的常见用法和概念的掌握"><a href="#14、关于-Node-js-的常见用法和概念的掌握" class="headerlink" title="14、关于 Node.js 的常见用法和概念的掌握"></a>14、关于 Node.js 的常见用法和概念的掌握</h3><p>简介<br>Node是JavaScript语言的服务器运行环境。<br>所谓“运行环境”有两层意思：首先，JavaScript语言通过Node在服务器运行，在这个意义上，Node有点像JavaScript虚拟机；其次，Node提供大量工具库，使得JavaScript语言与操作系统互动（比如读写文件、新建子进程），在这个意义上，Node又是JavaScript的工具库。<br>Node内部采用Google公司的V8引擎，作为JavaScript语言解释器；通过自行开发的libuv库，调用操作系统资源。</p>
<p>安装与更新<br>访问官方网站nodejs.org或者github.com/nodesource/distributions，查看Node的最新版本和安装方法。<br>官方网站提供编译好的二进制包，可以把它们解压到/usr/local目录下面。</p>
<p>代码<br>1<br>$ tar -xf node-someversion.tgz<br>然后，建立符号链接，把它们加到$PATH变量里面的路径。</p>
<p>代码<br>1<br>2<br>$ ln -s /usr/local/node/bin/node /usr/local/bin/node<br>$ ln -s /usr/local/node/bin/npm /usr/local/bin/npm<br>下面是Ubuntu和Debian下面安装Deb软件包的安装方法。</p>
<p>代码<br>1<br>2<br>3<br>$ curl -sL <a href="https://deb.nodesource.com/setup_4.x" target="_blank" rel="noopener">https://deb.nodesource.com/setup_4.x</a> | sudo -E bash -<br>$ sudo apt-get install -y nodejs<br>$ apt-get install nodejs<br>安装完成以后，运行下面的命令，查看是否能正常运行。</p>
<p>代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node --version</span><br><span class="line"># 或者</span><br><span class="line">$ node -v</span><br></pre></td></tr></table></figure></p>
<p>更新node.js版本，可以通过node.js的n模块完成。</p>
<p>代码<br>1<br>2<br>$ sudo npm install n -g<br>$ sudo n stable</p>
<p>上面代码通过n模块，将node.js更新为最新发布的稳定版。<br>n模块也可以指定安装特定版本的node。</p>
<p>代码<br>1<br>$ sudo n 0.10.21</p>
<p>版本管理工具nvm<br>如果想在同一台机器，同时安装多个版本的node.js，就需要用到版本管理工具nvm。</p>
<p>代码<br>1<br>2<br>$ git clone <a href="https://github.com/creationix/nvm.git" target="_blank" rel="noopener">https://github.com/creationix/nvm.git</a> ~/.nvm<br>$ source ~/.nvm/nvm.sh<br>安装以后，nvm的执行脚本，每次使用前都要激活，建议将其加入~/.bashrc文件（假定使用Bash）。激活后，就可以安装指定版本的Node。</p>
<p>代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 安装最新版本</span><br><span class="line">$ nvm install node</span><br><span class="line"># 安装指定版本</span><br><span class="line">$ nvm install 0.12.1</span><br><span class="line"># 使用已安装的最新版本</span><br><span class="line">$ nvm use node</span><br><span class="line"># 使用指定版本的node</span><br><span class="line">$ nvm use 0.12</span><br></pre></td></tr></table></figure></p>
<p>nvm也允许进入指定版本的REPL环境。</p>
<p>代码<br>1<br>$ nvm run 0.12</p>
<p>如果在项目根目录下新建一个.nvmrc文件，将版本号写入其中，就只输入nvm use命令即可，不再需要附加版本号。<br>下面是其他经常用到的命令。</p>
<p>代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 查看本地安装的所有版本</span><br><span class="line">$ nvm ls</span><br><span class="line"># 查看服务器上所有可供安装的版本。</span><br><span class="line">$ nvm ls-remote</span><br><span class="line"># 退出已经激活的nvm，使用deactivate命令。</span><br><span class="line">$ nvm deactivate</span><br></pre></td></tr></table></figure>
<p>基本用法<br>安装完成后，运行node.js程序，就是使用node命令读取JavaScript脚本。<br>当前目录的demo.js脚本文件，可以这样执行。</p>
<p>代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node demo</span><br><span class="line"># 或者</span><br><span class="line">$ node demo.js</span><br></pre></td></tr></table></figure></p>
<p>使用-e参数，可以执行代码字符串。</p>
<p>代码<br>1<br>2<br>$ node -e ‘console.log(“Hello World”)’<br>Hello World</p>
<p>REPL环境<br>在命令行键入node命令，后面没有文件名，就进入一个Node.js的REPL环境（Read–eval–print loop，”读取-求值-输出”循环），可以直接运行各种JavaScript命令。</p>
<p>代码<br>1<br>2<br>3<br>4<br>$ node</p>
<blockquote>
<p>1+1<br>2</p>
</blockquote>
<p>如果使用参数 –use_strict，则REPL将在严格模式下运行。</p>
<p>代码<br>1<br>$ node –use_strict</p>
<p>REPL是Node.js与用户互动的shell，各种基本的shell功能都可以在里面使用，比如使用上下方向键遍历曾经使用过的命令。<br>特殊变量下划线（_）表示上一个命令的返回结果。</p>
<p>代码<br>1<br>2<br>3<br>4</p>
<blockquote>
<p>1 + 1<br>x = 1<br>1<br>var x = 1<br>在REPL中，如果运行一个表达式，会直接在命令行返回结果。如果运行一条语句，就不会有任何输出，因为语句没有返回值。</p>
</blockquote>
<p>代码<br>1<br>2<br>3</p>
<blockquote>
<p>x = 1<br>1<br>var x = 1<br>上面代码的第二条命令，没有显示任何结果。因为这是一条语句，不是表达式，所以没有返回值。</p>
</blockquote>
<p>异步操作<br>Node采用V8引擎处理JavaScript脚本，最大特点就是单线程运行，一次只能运行一个任务。这导致Node大量采用异步操作（asynchronous operation），即任务不是马上执行，而是插在任务队列的尾部，等到前面的任务运行完后再执行。由于这种特性，某一个任务的后续操作，往往采用回调函数（callback）的形式进行定义。</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>var isTrue = function(value, callback) {<br>  if (value === true) {<br>    callback(null, “Value was true.”);<br>  }<br>  else {<br>    callback(new Error(“Value is not true!”));<br>  }<br>}<br>上面代码就把进一步的处理，交给回调函数callback。<br>Node约定，如果某个函数需要回调函数作为参数，则回调函数是最后一个参数。另外，回调函数本身的第一个参数，约定为上一步传入的错误对象。</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>var callback = function (error, value) {<br>  if (error) {<br>    return console.log(error);<br>  }<br>  console.log(value);<br>}<br>上面代码中，callback的第一个参数是Error对象，第二个参数才是真正的数据参数。这是因为回调函数主要用于异步操作，当回调函数运行时，前期的操作早结束了，错误的执行栈早就不存在了，传统的错误捕捉机制try…catch对于异步操作行不通，所以只能把错误交给回调函数处理。</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>try {<br>  db.User.get(userId, function(err, user) {<br>    if(err) {<br>      throw err<br>    }<br>    // …<br>  })<br>} catch(e) {<br>  console.log(‘Oh no!’);<br>}<br>上面代码中，db.User.get方法是一个异步操作，等到抛出错误时，可能它所在的try…catch代码块早就运行结束了，这会导致错误无法被捕捉。所以，Node统一规定，一旦异步操作发生错误，就把错误对象传递到回调函数。</p>
<p>如果没有发生错误，回调函数的第一个参数就传入null。这种写法有一个很大的好处，就是说只要判断回调函数的第一个参数，就知道有没有出错，如果不是null，就肯定出错了。另外，这样还可以层层传递错误。</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>if(err) {<br>  // 除了放过No Permission错误意外，其他错误传给下一个回调函数<br>  if(!err.noPermission) {<br>    return next(err);<br>  }<br>}</p>
<p>全局对象和全局变量<br>Node提供以下几个全局对象，它们是所有模块都可以调用的。</p>
<p>global：表示Node所在的全局环境，类似于浏览器的window对象。需要注意的是，如果在浏览器中声明一个全局变量，实际上是声明了一个全局对象的属性，比如var x = 1等同于设置window.x = 1，但是Node不是这样，至少在模块中不是这样（REPL环境的行为与浏览器一致）。在模块文件中，声明var x = 1，该变量不是global对象的属性，global.x等于undefined。这是因为模块的全局变量都是该模块私有的，其他模块无法取到。<br>process：该对象表示Node所处的当前进程，允许开发者与该进程互动。<br>console：指向Node内置的console模块，提供命令行环境中的标准输入、标准输出功能。<br>Node还提供一些全局函数。</p>
<p>setTimeout()：用于在指定毫秒之后，运行回调函数。实际的调用间隔，还取决于系统因素。间隔的毫秒数在1毫秒到2,147,483,647毫秒（约24.8天）之间。如果超过这个范围，会被自动改为1毫秒。该方法返回一个整数，代表这个新建定时器的编号。<br>clearTimeout()：用于终止一个setTimeout方法新建的定时器。<br>setInterval()：用于每隔一定毫秒调用回调函数。由于系统因素，可能无法保证每次调用之间正好间隔指定的毫秒数，但只会多于这个间隔，而不会少于它。指定的毫秒数必须是1到2,147,483,647（大约24.8天）之间的整数，如果超过这个范围，会被自动改为1毫秒。该方法返回一个整数，代表这个新建定时器的编号。<br>clearInterval()：终止一个用setInterval方法新建的定时器。<br>require()：用于加载模块。<br>Buffer()：用于操作二进制数据。<br>Node提供两个全局变量，都以两个下划线开头。</p>
<p><strong>filename：指向当前运行的脚本文件名。
</strong>dirname：指向当前运行的脚本所在的目录。<br>除此之外，还有一些对象实际上是模块内部的局部变量，指向的对象根据模块不同而不同，但是所有模块都适用，可以看作是伪全局变量，主要为module, module.exports, exports等。</p>
<p>模块化结构<br>概述<br>Node.js采用模块化结构，按照CommonJS规范定义和使用模块。模块与文件是一一对应关系，即加载一个模块，实际上就是加载对应的一个模块文件。<br>require命令用于指定加载模块，加载时可以省略脚本文件的后缀名。</p>
<p>代码<br>1<br>2<br>3<br>var circle = require(‘./circle.js’);<br>// 或者<br>var circle = require(‘./circle’);<br>require方法的参数是模块文件的名字。它分成两种情况，第一种情况是参数中含有文件路径（比如上例），这时路径是相对于当前脚本所在的目录，第二种情况是参数中不含有文件路径，这时Node到模块的安装目录，去寻找已安装的模块（比如下例）。</p>
<p>代码<br>1<br>var bar = require(‘bar’);<br>有时候，一个模块本身就是一个目录，目录中包含多个文件。这时候，Node在package.json文件中，寻找main属性所指明的模块入口文件。</p>
<p>代码<br>1<br>2<br>3<br>4<br>{<br>  “name” : “bar”,<br>  “main” : “./lib/bar.js”<br>}<br>上面代码中，模块的启动文件为lib子目录下的bar.js。当使用require(‘bar’)命令加载该模块时，实际上加载的是./node_modules/bar/lib/bar.js文件。下面写法会起到同样效果。</p>
<p>代码<br>1<br>var bar = require(‘bar/lib/bar.js’)<br>如果模块目录中没有package.json文件，node.js会尝试在模块目录中寻找index.js或index.node文件进行加载。<br>模块一旦被加载以后，就会被系统缓存。如果第二次还加载该模块，则会返回缓存中的版本，这意味着模块实际上只会执行一次。如果希望模块执行多次，则可以让模块返回一个函数，然后多次调用该函数。</p>
<p>核心模块<br>如果只是在服务器运行JavaScript代码，用处并不大，因为服务器脚本语言已经有很多种了。Node.js的用处在于，它本身还提供了一系列功能模块，与操作系统互动。这些核心的功能模块，不用安装就可以使用，下面是它们的清单。</p>
<p>http：提供HTTP服务器功能。<br>url：解析URL。<br>fs：与文件系统交互。<br>querystring：解析URL的查询字符串。<br>child_process：新建子进程。<br>util：提供一系列实用小工具。<br>path：处理文件路径。<br>crypto：提供加密和解密功能，基本上是对OpenSSL的包装。<br>上面这些核心模块，源码都在Node的lib子目录中。为了提高运行速度，它们安装时都会被编译成二进制文件。<br>核心模块总是最优先加载的。如果你自己写了一个HTTP模块，require(‘http’)加载的还是核心模块。</p>
<p>自定义模块<br>Node模块采用CommonJS规范。只要符合这个规范，就可以自定义模块。<br>下面是一个最简单的模块，假定新建一个foo.js文件，写入以下内容。</p>
<p>代码<br>1<br>2<br>3<br>4<br>// foo.js<br>module.exports = function(x) {<br>    console.log(x);<br>};<br>上面代码就是一个模块，它通过module.exports变量，对外输出一个方法。</p>
<p>这个模块的使用方法如下。</p>
<p>代码<br>1<br>2<br>3<br>// index.js<br>var m = require(‘./foo’);<br>m(“这是自定义模块”);<br>上面代码通过require命令加载模块文件foo.js（后缀名省略），将模块的对外接口输出到变量m，然后调用m。这时，在命令行下运行index.js，屏幕上就会输出“这是自定义模块”。</p>
<p>代码<br>1<br>2<br>$ node index<br>这是自定义模块<br>module变量是整个模块文件的顶层变量，它的exports属性就是模块向外输出的接口。如果直接输出一个函数（就像上面的foo.js），那么调用模块就是调用一个函数。但是，模块也可以输出一个对象。下面对foo.js进行改写。</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>// foo.js<br>var out = new Object();<br>function p(string) {<br>  console.log(string);<br>}<br>out.print = p;<br>module.exports = out;<br>上面的代码表示模块输出out对象，该对象有一个print属性，指向一个函数。下面是这个模块的使用方法。</p>
<p>代码<br>1<br>2<br>3<br>// index.js<br>var m = require(‘./foo’);<br>m.print(“这是自定义模块”);<br>上面代码表示，由于具体的方法定义在模块的print属性上，所以必须显式调用print属性。</p>
<p>异常处理<br>Node是单线程运行环境，一旦抛出的异常没有被捕获，就会引起整个进程的崩溃。所以，Node的异常处理对于保证系统的稳定运行非常重要。<br>一般来说，Node有三种方法，传播一个错误。</p>
<p>使用throw语句抛出一个错误对象，即抛出异常。<br>将错误对象传递给回调函数，由回调函数负责发出错误。<br>通过EventEmitter接口，发出一个error事件。<br>try…catch结构<br>最常用的捕获异常的方式，就是使用try…catch结构。但是，这个结构无法捕获异步运行的代码抛出的异常。</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>try {<br>  process.nextTick(function () {<br>    throw new Error(“error”);<br>  });<br>} catch (err) {<br>  //can not catch it<br>  console.log(err);<br>}<br>try {<br>  setTimeout(function(){<br>    throw new Error(“error”);<br>  },1)<br>} catch (err) {<br>  //can not catch it<br>  console.log(err);<br>}<br>上面代码分别用process.nextTick和setTimeout方法，在下一轮事件循环抛出两个异常，代表异步操作抛出的错误。它们都无法被catch代码块捕获，因为catch代码块所在的那部分已经运行结束了。</p>
<p>一种解决方法是将错误捕获代码，也放到异步执行。</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>function async(cb, err) {<br>  setTimeout(function() {<br>    try {<br>      if (true)<br>        throw new Error(“woops!”);<br>      else<br>        cb(“done”);<br>    } catch(e) {<br>      err(e);<br>    }<br>  }, 2000)<br>}<br>async(function(res) {<br>  console.log(“received:”, res);<br>}, function(err) {<br>  console.log(“Error: async threw an exception:”, err);<br>});<br>// Error: async threw an exception: Error: woops!<br>上面代码中，async函数异步抛出的错误，可以同样部署在异步的catch代码块捕获。</p>
<p>这两种处理方法都不太理想。一般来说，Node只在很少场合才用try/catch语句，比如使用JSON.parse解析JSON文本。</p>
<p>回调函数<br>Node采用的方法，是将错误对象作为第一个参数，传入回调函数。这样就避免了捕获代码与发生错误的代码不在同一个时间段的问题。</p>
<p>代码<br>1<br>2<br>3<br>4<br>fs.readFile(‘/foo.txt’, function(err, data) {<br>  if (err !== null) throw err;<br>  console.log(data);<br>});<br>上面代码表示，读取文件foo.txt是一个异步操作，它的回调函数有两个参数，第一个是错误对象，第二个是读取到的文件数据。如果第一个参数不是null，就意味着发生错误，后面代码也就不再执行了。</p>
<p>下面是一个完整的例子。</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>function async2(continuation) {<br>  setTimeout(function() {<br>    try {<br>      var res = 42;<br>      if (true)<br>        throw new Error(“woops!”);<br>      else<br>        continuation(null, res); // pass ‘null’ for error<br>    } catch(e) {<br>      continuation(e, null);<br>    }<br>  }, 2000);<br>}<br>async2(function(err, res) {<br>  if (err)<br>    console.log(“Error: (cps) failed:”, err);<br>  else<br>    console.log(“(cps) received:”, res);<br>});<br>// Error: (cps) failed: woops!<br>上面代码中，async2函数的回调函数的第一个参数就是一个错误对象，这是为了处理异步操作抛出的错误。</p>
<p>EventEmitter接口的error事件<br>发生错误的时候，也可以用EventEmitter接口抛出error事件。</p>
<p>代码<br>1<br>2<br>3<br>var EventEmitter = require(‘events’).EventEmitter;<br>var emitter = new EventEmitter();<br>emitter.emit(‘error’, new Error(‘something bad happened’));<br>使用上面的代码必须小心，因为如果没有对error事件部署监听函数，会导致整个应用程序崩溃。所以，一般总是必须同时部署下面的代码。</p>
<p>代码<br>1<br>2<br>3<br>emitter.on(‘error’, function(err) {<br>  console.error(‘出错：’ + err.message);<br>});</p>
<p>uncaughtException事件<br>当一个异常未被捕获，就会触发uncaughtException事件，可以对这个事件注册回调函数，从而捕获异常。</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>var logger = require(‘tracer’).console();<br>process.on(‘uncaughtException’, function(err) {<br>  console.error(‘Error caught in uncaughtException event:’, err);<br>});<br>try {<br>  setTimeout(function(){<br>    throw new Error(“error”);<br>  },1);<br>} catch (err) {<br>  //can not catch it<br>  console.log(err);<br>}<br>只要给uncaughtException配置了回调，Node进程不会异常退出，但异常发生的上下文已经丢失，无法给出异常发生的详细信息。而且，异常可能导致Node不能正常进行内存回收，出现内存泄露。所以，当uncaughtException触发后，最好记录错误日志，然后结束Node进程。</p>
<p>代码<br>1<br>2<br>3<br>4<br>process.on(‘uncaughtException’, function(err) {<br>  logger.log(err);<br>  process.exit(1);<br>});<br>unhandledRejection事件<br>iojs有一个unhandledRejection事件，用来监听没有捕获的Promise对象的rejected状态。</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>var promise = new Promise(function(resolve, reject) {<br>  reject(new Error(“Broken.”));<br>});<br>promise.then(function(result) {<br>  console.log(result);<br>})<br>上面代码中，promise的状态变为rejected，并且抛出一个错误。但是，不会有任何反应，因为没有设置任何处理函数。</p>
<p>只要监听unhandledRejection事件，就能解决这个问题。</p>
<p>代码<br>1<br>2<br>3<br>process.on(‘unhandledRejection’, function (err, p) {<br>  console.error(err.stack);<br>})<br>需要注意的是，unhandledRejection事件的监听函数有两个参数，第一个是错误对象，第二个是产生错误的promise对象。这可以提供很多有用的信息。</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>var http = require(‘http’);<br>http.createServer(function (req, res) {<br>  var promise = new Promise(function(resolve, reject) {<br>    reject(new Error(“Broken.”))<br>  })<br>  promise.info = {url: req.url}<br>}).listen(8080)<br>process.on(‘unhandledRejection’, function (err, p) {<br>  if (p.info &amp;&amp; p.info.url) {<br>    console.log(‘Error in URL’, p.info.url)<br>  }<br>  console.error(err.stack)<br>})<br>上面代码会在出错时，输出用户请求的网址。</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>Error in URL /testurl<br>Error: Broken.<br>  at /Users/mikeal/tmp/test.js:9:14<br>  at Server.<anonymous> (/Users/mikeal/tmp/test.js:4:17)<br>  at emitTwo (events.js:87:13)<br>  at Server.emit (events.js:169:7)<br>  at HTTPParser.parserOnIncoming [as onIncoming] (_http_server.js:471:12)<br>  at HTTPParser.parserOnHeadersComplete (_http_common.js:88:23)<br>  at Socket.socketOnData (_http_server.js:322:22)<br>  at emitOne (events.js:77:13)<br>  at Socket.emit (events.js:166:7)<br>  at readableAddChunk (_stream_readable.js:145:16)<br>命令行脚本<br>node脚本可以作为命令行脚本使用。</anonymous></p>
<p>代码<br>1<br>$ node foo.js<br>上面代码执行了foo.js脚本文件。</p>
<p>foo.js文件的第一行，如果加入了解释器的位置，就可以将其作为命令行工具直接调用。</p>
<p>代码<br>1</p>
<p>#!/usr/bin/env node<br>调用前，需更改文件的执行权限。</p>
<p>代码<br>1<br>2<br>$ chmod u+x foo.js<br>$ ./foo.js arg1 arg2 …<br>作为命令行脚本时，console.log用于输出内容到标准输出，process.stdin用于读取标准输入，child_process.exec()用于执行一个shell命令。</p>
<p>参考：<a href="https://javascript.ruanyifeng.com/nodejs/basic.html" target="_blank" rel="noopener">https://javascript.ruanyifeng.com/nodejs/basic.html</a><br>参考：<a href="https://segmentfault.com/a/1190000005892501" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005892501</a></p>
<h2 id="二、CSS相关"><a href="#二、CSS相关" class="headerlink" title="二、CSS相关"></a>二、CSS相关</h2><h3 id="1、-CSS-常⻅见属性的应⽤用包括属性继承等概念的掌握"><a href="#1、-CSS-常⻅见属性的应⽤用包括属性继承等概念的掌握" class="headerlink" title="1、 CSS 常⻅见属性的应⽤用包括属性继承等概念的掌握"></a>1、 CSS 常⻅见属性的应⽤用包括属性继承等概念的掌握</h3><p>CSS教程<br><a href="https://www.runoob.com/css/css-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/css/css-tutorial.html</a></p>
<p>flex布局<br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p>
<p>CSS属性继承<br>概念: 指我们设置上级(父级)的CSS样式，上级（父级）及以下的子级（下级）都具有此属性。一般只有文字文本具有继承特性，如文字大小、文字加粗、文字颜色、字体等。</p>
<p>有继承性的属性<br>1、字体系列属性</p>
<p>font：组合字体</p>
<p>font-family：规定元素的字体系列</p>
<p>font-weight：设置字体的粗细</p>
<p>font-size：设置字体的尺寸</p>
<p>font-style：定义字体的风格</p>
<p>font-variant：设置小型大写字母的字体显示文本，这意味着所有的小写字母均会被转换为大写，但是所有使用小型大写字体的字母与其余文本相比，其字体尺寸更小。</p>
<p>font-stretch：对当前的 font-family 进行伸缩变形。所有主流浏览器都不支持。</p>
<p>font-size-adjust：为某个元素规定一个 aspect 值，这样就可以保持首选字体的 x-height。</p>
<p>2、文本系列属性</p>
<p>text-indent：文本缩进</p>
<p>text-align：文本水平对齐</p>
<p>line-height：行高</p>
<p>word-spacing：增加或减少单词间的空白（即字间隔）</p>
<p>letter-spacing：增加或减少字符间的空白（字符间距）</p>
<p>text-transform：控制文本大小写</p>
<p>direction：规定文本的书写方向</p>
<p>color：文本颜色</p>
<p>3、元素可见性：visibility</p>
<p>4、表格布局属性：caption-side、border-collapse、border-spacing、empty-cells、table-layout</p>
<p>5、列表布局属性：list-style-type、list-style-image、list-style-position、list-style</p>
<p>6、生成内容属性：quotes</p>
<p>7、光标属性：cursor</p>
<p>8、页面样式属性：page、page-break-inside、windows、orphans</p>
<p>9、声音样式属性：speak、speak-punctuation、speak-numeral、speak-header、speech-rate、volume、voice-family、pitch、pitch-range、stress、richness、、azimuth、elevation</p>
<p>无继承性的属性<br>1、display：规定元素应该生成的框的类型</p>
<p>2、文本属性：</p>
<p>vertical-align：垂直文本对齐</p>
<p>text-decoration：规定添加到文本的装饰</p>
<p>text-shadow：文本阴影效果</p>
<p>white-space：空白符的处理</p>
<p>unicode-bidi：设置文本的方向</p>
<p>3、盒子模型的属性：width、height、margin 、margin-top、margin-right、margin-bottom、margin-left、border、border-style、border-top-style、border-right-style、border-bottom-style、border-left-style、border-width、border-top-width、border-right-right、border-bottom-width、border-left-width、border-color、border-top-color、border-right-color、border-bottom-color、border-left-color、border-top、border-right、border-bottom、border-left、padding、padding-top、padding-right、padding-bottom、padding-left</p>
<p>4、背景属性：background、background-color、background-image、background-repeat、background-position、background-attachment</p>
<p>5、定位属性：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index</p>
<p>6、生成内容属性：content、counter-reset、counter-increment</p>
<p>7、轮廓样式属性：outline-style、outline-width、outline-color、outline</p>
<p>8、页面样式属性：size、page-break-before、page-break-after</p>
<p>9、声音样式属性：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during</p>
<p>所有元素可以继承的属性<br>1、元素可见性：visibility</p>
<p>2、光标属性：cursor</p>
<p>内联元素可以继承的属性<br>1、字体系列属性</p>
<p>2、除text-indent、text-align之外的文本系列属性</p>
<p>块级元素可以继承的属性<br>1、text-indent、text-align</p>
<p>BFC<br>块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视化CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</p>
<p>如何出发BFC?</p>
<p>根元素或包含根元素的元素<br>浮动元素（元素的 float 不是 none）<br>绝对定位元素（元素的 position 为 absolute 或 fixed）<br>行内块元素（元素的 display 为 inline-block）<br>表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值）<br>表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）<br>匿名表格单元格元素（元素的 display为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table）<br>overflow 值不为 visible 的块元素<br>display 值为 flow-root 的元素<br>contain 值为 layout、content或 strict 的元素<br>弹性元素（display为 flex 或 inline-flex元素的直接子元素）<br>网格元素（display为 grid 或 inline-grid 元素的直接子元素）<br>多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1）<br>column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。</p>
<p>参考链接<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/inheritance" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS/inheritance</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context</a></p>
<h3 id="2、CSS-中常⻅布局以及文本超长展示省略号"><a href="#2、CSS-中常⻅布局以及文本超长展示省略号" class="headerlink" title="2、CSS 中常⻅布局以及文本超长展示省略号"></a>2、CSS 中常⻅布局以及文本超长展示省略号</h3><p>一、文档流布局<br>最基本的布局方式，就是按照文档的顺序一个一个显示出来，块元素独占一行，行内元素共享一行</p>
<p>二、浮动布局<br>float : left | right</p>
<p>特点 :</p>
<ol>
<li>元素浮动之后不占据原来的位置(脱标)</li>
<li>浮动的盒子在一行上显示</li>
<li>行内元素浮动之后转换为行内块元素(不推荐使用,转行内元素还是用display:inline-block)</li>
</ol>
<p>作用 :</p>
<ol>
<li>文本绕图<br>2.制作导航<br>3.网页布局</li>
</ol>
<p>清除浮动<br>当父盒子没有定义高度,嵌套的盒子浮动后,下边的元素发生未知错误</p>
<p>clear : left | right | both</p>
<p>在最后一个浮动元素后添加标签.</p>
<p>三、定位布局<br>绝对定位</p>
<p>如果想为元素设置层模型中的绝对定位，需要设置position:absolute(表示绝对定位)，这条语句的作用将元素从文档流中拖出来，然后使用left、right、top、bottom属性相对于其最接近的一个具有定位属性的父包含块进行绝对定位。如果不存在这样的包含块，则相对于body元素，即相对于浏览器窗口，而其层叠顺序则通过z-index属性来定义。</p>
<p>相对定位</p>
<p>如果想为元素设置层模型中的相对定位，需要设置position:relative（表示相对定位），它通过left、right、top、bottom属性确定元素在正常文档流中的偏移位置。相对定位完成的过程是首先按static(float)方式生成一个元素，相对于以前的位置，移动方向和幅度由left、right、top、bottom属性确定，偏移前的位置保留不动。</p>
<p>固定定位</p>
<p>fixed：表示固定定位，与absolute定位类型类似，但它的相对移动的坐标是视图（屏幕内的网页窗口）本身。由于视图本身是固定的，它不会随浏览器窗口的滚动条滚动而变化，除非你在屏幕中移动浏览器窗口的屏幕位置，或改变浏览器窗口的显示大小，因此固定定位的元素会始终位于浏览器窗口内视图的某个位置，不会受文档流动影响，这与background-attachment:fixed;属性功能相同。以下代码可以实现相对于浏览器视图向右移动100px，向下移动50px。并且拖动滚动条时位置固定不变。</p>
<p>四、Flex布局<br>flex 的使用方法很简单，只需要将其 display 属性设置为 flex 就可以，也可以设置行内的 flex，记得 Webkit 内核的浏览器，必须加上 -webkit 前缀。注意，设为 Flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。</p>
<p>在使用 flex 的元素中，默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴开始的位置称为 main start，主轴结束的位置称为 main end。同理，交叉轴开始的位置称为 cross start，交叉轴结束的位置称为 cross end。在使用 flex 的子元素中，占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size。</p>
<p>父容器属性<br>父容器上有六个属性</p>
<p>flex-direction：主轴的方向。<br>flex-wrap：超出父容器子容器的排列样式。<br>flex-flow：flex-direction 属性和 flex-wrap 属性的简写形式。<br>justify-content：子容器在主轴的排列方向。<br>align-items：子容器在交叉轴的排列方向。<br>align-content：多根轴线的对齐方式。<br>flex-direction 属性<br>flex-direction 属性决定主轴的方向（主轴的方向不一定是水平的，这个属性就是设置主轴的方向，主轴默认是水平方向，从左至右，如果主轴方向设置完毕，那么交叉轴就不需要设置，交叉轴永远是主轴顺时针旋转 90°）。</p>
<p>flex-wrap 属性<br>flex-wrap 属性决定子容器如果在一条轴线排不下时，如何换行。</p>
<p>justify-content 属性<br>justify-content 属性定义了子容器在主轴上的对齐方式。</p>
<p>flex-flow 属性<br>flex-flow 属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap。</p>
<p>align-items 属性<br>align-items属性定义子容器在交叉轴上如何对齐。<br>具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p>
<p>align-content 属性<br>align-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>
<p>子容器属性<br>子容器也有 6 个属性：</p>
<p>order：子容器的排列顺序<br>flex-grow：子容器剩余空间的拉伸比例<br>flex-shrink：子容器超出空间的压缩比例<br>flex-basis：子容器在不伸缩情况下的原始尺寸<br>flex：子元素的 flex 属性是 flex-grow,flex-shrink 和 flex-basis 的简写<br>align-self<br>order 属性<br>order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0。</p>
<p>flex-grow 属性<br>flex-grow 属性定义子容器的伸缩比例。按照该比例给子容器分配空间。</p>
<p>flex-shrink 属性<br>flex-shrink 属性定义了子容器弹性收缩的比例。如图，超出的部分按 1:2 的比例从给子容器中减去。此属性要生效，父容器的 flex-wrap 属性要设置为 nowrap</p>
<p>flex-basis 属性<br>flex-basis 属性定义了子容器在不伸缩情况下的原始尺寸，主轴为横向时代表宽度，主轴为纵向时代表高度。</p>
<p>五、超长文本显示省略号<br>单行文本</p>
<p>多行文本</p>
<p>-webkit-line-clamp用来限制在一个块元素显示的文本的行数。 为了实现该效果，它需要组合其他的WebKit属性。</p>
<p>常见结合属性：</p>
<p>display: -webkit-box; 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 。</p>
<p>-webkit-box-orient 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 。</p>
<h3 id="3、-CSS的各种动画以及性能优化"><a href="#3、-CSS的各种动画以及性能优化" class="headerlink" title="3、 CSS的各种动画以及性能优化"></a>3、 CSS的各种动画以及性能优化</h3><p>容易混淆的几个CSS属性<br>animation (动画)</p>
<p>用于设置动画属性，他是一个简写的属性，包含6个属性<br>transition (过渡)    用于设置元素的样式过度，和animation有着类似的效果，但细节上有很大的不同<br>transform (变形)    用于元素进行旋转、缩放、移动或倾斜，和设置样式的动画并没有什么关系，就相当于color一样用来设置元素的“外表”<br>translate (移动)    translate只是transform的一个属性值，即移动<br>transition：property duration timing-function delay;<br>transition-property    设置过渡效果的CSS属性名称<br>transition-duration    完成过渡效果需要多少秒or毫秒<br>transition-timing-function    速度效果的速度曲线<br>transition-delay    过渡效果延迟多久开始<br>animation： name duration timing-function delay iteration-count direction play-state fill-mode;<br>name    用来调用@keyframes定义好的动画，与@keyframes定义的动画名称一致<br>duration    指定元素播放动画所持续的时间<br>timing-function    规定速度效果的速度曲线，是针对每一个小动画所在时间范围的变换速率<br>delay    定义在浏览器开始执行动画之前等待的时间，值整个animation执行之前等待的时间<br>iteration-count    定义动画的播放次数，可选具体次数或者无限(infinite)<br>direction    设置动画播放方向：normal(按时间轴顺序),reverse(时间轴反方向运行),alternate(轮流，即来回往复进行),alternate-reverse(动画先反运行再正方向运行，并持续交替运行)<br>play-state    控制元素动画的播放状态，通过此来控制动画的暂停和继续，两个值：running(继续)，paused(暂停)<br>fill-mode    控制动画结束后，元素的样式，有四个值：none(回到动画没开始时的状态)，forwards(动画结束后动画停留在结束状态)，backwords(动画回到第一帧的状态)，both(根据animation-direction轮流应用forwards和backwards规则)，注意与iteration-count不要冲突(动画执行无限次)<br>动画性能优化<br>动画为什么会卡顿？<br>现代的浏览器通常会有两个重要的执行线程，这2个线程协同工作来渲染一个网页：</p>
<p>主线程<br>合成线程<br>一般情况下，主线程负责：</p>
<p>运行JavaScript。<br>计算HTML 元素的 CSS 样式。<br>页面的布局<br>将元素绘制到一个或多个位图中<br>将这些位图交给合成线程<br>相应地，合成线程负责：</p>
<p>通过 GPU将位图绘制到屏幕上<br>通知主线程更新页面中可见或即将变成可见的部分的位图<br>计算出页面中哪部分是可见的<br>计算出当你在滚动页面时哪部分是即将变成可见的<br>当你滚动页面时将相应位置的元素移动到可视区域<br>长时间执行 JavaScript 或渲染一个很大的元素会阻塞主线程，在这期间，它将无法响应用户的交互。</p>
<p>相反，合成线程则会尽量去响应用户的交互。当一个页面发生变化时，合成线程会以每秒60 帧的间隔去不断重绘这个页面，即使这个页面不完整。</p>
<p>动画卡顿的解决方案<br>在使用css3 transtion做动画效果时，优先选择transform，尽量不要使用height，width，margin和padding。</p>
<p>为什么transform更加平滑？<br>在使用css3 transtion做动画效果时，transform实现的动画是与合成器线程相关的，不需要等待主线程样式计算或者 JS 执行，计算速度是很快的；而使用height，width，margin和padding时，导致布局和绘制的调整，主线程需要重新计算样式并且执行JS，计算速度自然就慢了。</p>
<p>性能消耗排名</p>
<p>性能消耗图，由此可见最受欢饮和性能最好的莫过于transform和opacity了。</p>
<p>其实呢，opacity和transform能解决的问题已经很多了，尽量少的使用其他的属性去进行动画制作</p>
<p>translate3d 开启GPU加速<br>在移动端，我们经常用到如上的CSS代码实现所谓的“硬件加速”，来提高动画的流畅度。在部分情况下，我们的CSS动画的确变的更加流畅。</p>
<p>但这个方法并不是万能药。当页面中加速的元素越来越多时，网页的性能便会下降。</p>
<p>参考<br><a href="http://sy-tang.github.io/2014/05/14/CSS%20animations%20and%20transitions%20performance-%20looking%20inside%20the%20browser/" target="_blank" rel="noopener">http://sy-tang.github.io/2014/05/14/CSS%20animations%20and%20transitions%20performance-%20looking%20inside%20the%20browser/</a></p>
<p><a href="https://juejin.im/post/5b137e6e51882513ac201dfb#heading-3" target="_blank" rel="noopener">https://juejin.im/post/5b137e6e51882513ac201dfb#heading-3</a></p>
<p><a href="https://juejin.im/post/5b6133a351882519d346853f#heading-4" target="_blank" rel="noopener">https://juejin.im/post/5b6133a351882519d346853f#heading-4</a></p>
<p><a href="https://div.io/topic/1348" target="_blank" rel="noopener">https://div.io/topic/1348</a></p>
<p><a href="http://zencode.in/14.CSS%E5%8A%A8%E7%94%BB%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html" target="_blank" rel="noopener">http://zencode.in/14.CSS%E5%8A%A8%E7%94%BB%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html</a></p>
<h3 id="4、关于-BFC-块级格式化上下文的理解以及触发-BFC-重新布局相关操作"><a href="#4、关于-BFC-块级格式化上下文的理解以及触发-BFC-重新布局相关操作" class="headerlink" title="4、关于 BFC 块级格式化上下文的理解以及触发 BFC 重新布局相关操作"></a>4、关于 BFC 块级格式化上下文的理解以及触发 BFC 重新布局相关操作</h3><p>BFC 定义<br>BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box（块级元素）参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干.</p>
<p>通俗地来说：创建了 BFC的元素就是一个独立的盒子，里面的子元素不会在布局上<br>影响外面的元素（里面怎么布局都不会影响外部），BFC任然属于文档中的普通流</p>
<p>BFC的生成：<br>知道了BFC怎么触发BFC<br>满足以下条件之一都可以触发BFC，变身为BFC</p>
<p>根元素<br>float属性不为none<br>position不为static和relative<br>overflow不为visible<br>display为inline-block, table-cell, table-caption, flex, inline-flex<br>你会发现BFC无处不在，只是自己用的时候不知道而已</p>
<p>BFC布局规则：<br>变身为BFC后有什么特性呢，以下：</p>
<p>内部的Box会在垂直方向，一个接一个地放置。<br>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠<br>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。<br>BFC的区域不会与float box重叠。<br>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。<br>计算BFC的高度时，浮动元素也参与计算<br>让我们建立一个BFC<br>HTML代码如下：</p>
<p><div class="container"><br>  Some Content here<br></div><br>我们可以用CSS为container容器附加上述条件,如overflow: scroll, overflow: hidden, display: flex, float: left, or display: table.尽管这些条件都能形成一个BFC，但是它们各自却有着不一样的表现：</p>
<p>display: table : 在响应式布局中会有问题</p>
<p>overflow: scroll : 可能会出现你不想要的滚动条</p>
<p>float: left: 使元素左浮动，并且其他元素对其环绕</p>
<p>overflow: hidden: 消除溢出部分</p>
<p>这么看来，建立BFC的最好方式莫过于overflow:hidden了：</p>
<p>.container {<br>  overflow: hidden;<br>}<br>在BFC中，块级元素又是怎么布局的呢？<br>W3C规范描述如下：</p>
<p>In a block formatting context, each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats).bfcbfc.jpg</p>
<p>简单的说：上图中所有属于BFC的box都默认左对齐，并且它们的左边距可以触及到容器container的左边。最后一个box，尽管它是浮动的，但它依然遵循这个原则。（BFC中的浮动下面会介绍）</p>
<p>－那么，BFC到底有什么卵用呢？</p>
<p>－实际上，真的特别有用</p>
<p>1.利用BFC可以消除Margin Collapse<br>在正常情况下，在一个容器内的所有box将会由上至下依次垂直排列，即我们所说的一个元素占一行，并切垂直相邻的距离(即margin)是由各自的margin决定的，而不是两个margin的叠加。</p>
<p>让我们看一个例子：红色的div包含三个绿色的p元素。</p>
<p>HTML代码：</p>
<p><div class="container"><br>  <p>Sibling 1</p><br>  <p>Sibling 2</p><br>  <p>Sibling 3</p><br></div><br>CSS代码：</p>
<p>.container {<br>  background-color: red;<br>  overflow: hidden; /<em> creates a block formatting context </em>/<br>}</p>
<p>p {<br>  background-color: lightgreen;<br>  margin: 10px 0;<br>}<br>理想情况下，我们会认为p标签之间的margin应该是它们的和(20px),但实际上却是10px.这其实是collapsing margins。</p>
<p>结果如下：</p>
<p>这似乎让人有点困惑，BFC导致了margin collapse，而现在又要用它来解决margin cllapse.但是始终要记住一点：只有当元素在同一个BFC中时，垂直方向上的margin<br>才会clollpase.如果它们属于不同的BFC，则不会有margin collapse.因此我们可以再建立一个BFC去阻止margin collpase的发生。</p>
<p>现在HTML变成：</p>
<p><div class="container"><br>  <p>Sibling 1</p><br>  <p>Sibling 2</p><br>  <div class="newBFC"><br>    <p>Sibling 3</p><br>  </div><br></div><br>CSS也有改变：</p>
<p>.container {<br>  background-color: red;<br>  overflow: hidden; /<em> creates a block formatting context </em>/<br>}</p>
<p>p {<br>  margin: 10px 0;<br>  background-color: lightgreen;<br>}</p>
<p>.newBFC {<br>  overflow: hidden;  /<em> creates new block formatting context </em>/<br>}<br>现在的结果为：</p>
<p>由于第二个p元素和第三个p元素属于不同的BFC，因此避免了margin collapse.</p>
<p>2.利用BFC去容纳浮动元素<br>我相信大家经常会遇到一个容器里有浮动元素，但是这个容器的高度却是0的场景，如下图：</p>
<p>看下面的例子：</p>
<p>HTML:</p>
<p><div class="container"><br>  <div>Sibling</div><br>  <div>Sibling</div><br></div><br>CSS:</p>
<p>.container {<br>  background-color: green;<br>}</p>
<p>.container div {<br>  float: left;<br>  background-color: lightgreen;<br>  margin: 10px;<br>}<br>结果：</p>
<p>在上边的情形中，container是不会有高度的，因为它包含了浮动元素。通常我们解决这个问题的办法是利用一个伪元素去实现clear fix，但是现在我们有了更好的解决办法，即利用BFC，因为它够容纳浮动元素的。<br>我们现在让container形成BFC规则，结果如下：</p>
<p>.container {<br>  overflow: hidden; /<em> creates block formatting context </em>/<br>  background-color: green;<br>}</p>
<p>.container div {<br>  float: left;<br>  background-color: lightgreen;<br>  margin: 10px;<br>}<br>结果：</p>
<p>3.利用BFC阻止文本换行<br>有时候，确切的说大多数情况(若没有特殊设置)，文本将会环绕浮动元素(如Figure 1),<br>但有时候这并不是我们期望的，我们想要的是Figure2。</p>
<p>往往可能大家都会选择利用margin－left来强行让p的容器有一个左边距，而距离恰好为Floated div的宽度，但现在我们可以利用BFC更好的解决这个问题。</p>
<p>首先让我们了解一下文本换行的原理吧：</p>
<p>在Figure1中，整个p元素实际上是处于上图中的黑色区域，p元素没有移动是因为它在浮动元素的下方。但实际上p作为行块级别的元素（相对于行内文本）却发生了移动，因为要给float元素’腾’位置，而随着文本的增加，文本高度超过浮动元素的部分则不会在水平方向上收缩内部距离，因此看起来像是环绕。</p>
<p>如图：</p>
<p>在解决这个问题之前，我们先来看一下W3C的规范在这方面的描述：</p>
<p>In a block formatting context, each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats).</p>
<p>W3C为这种情况提供了一个解决方案：unless the box establishes a new block formatting context，即为p建立BFC。</p>
<p>结果：</p>
<p>参考：<a href="https://www.sitepoint.com/understanding-block-formatting-contexts-in-css/" target="_blank" rel="noopener">https://www.sitepoint.com/understanding-block-formatting-contexts-in-css/</a></p>
<p>参考：<a href="https://www.cnblogs.com/Ry-yuan/p/8458809.html" target="_blank" rel="noopener">https://www.cnblogs.com/Ry-yuan/p/8458809.html</a></p>
<h3 id="5、-盒子模型"><a href="#5、-盒子模型" class="headerlink" title="5、 盒子模型"></a>5、 盒子模型</h3><p>一些基本概念<br>HTML的大多数元素都是块级(block)元素或行内(inline)元素</p>
<p>块级元素<br>默认情况下，块级元素会另起一行，并尽可能的充满整个容器。<br>块级元素可以包含行内元素和其他块级元素，相比于行内元素可以创建更复杂和大型的结构</p>
<p>块级元素列表：<br>html5新增的元素：<br>figcation：图文信息组标题 ，article：文章，figure：图文信息组<br>output：表单输出，aside：侧栏内容，footer：区段尾或页尾，audio：音频播放<br>video：视频播放，section：页面区段，canvas：画布、绘制图形，header：区段头或页头<br>hgroup：标题组，</p>
<p>address：联系方式信息，ol：有序列表，p：行，form：表单，pre：预格式化文本，blockqute：块引用<br>h1-h6：标题，table：表格，dd：列表中条目描述，dl：定义列表，div，hr：水平分割线</p>
<p>行内元素<br>行内元素不会另起一行只占据它对应的标签的边框所包含内容的空间，<br>只能包含数据和其他行内元素</p>
<p>行内元素列表<br>b，big，i，small，tt，<br>abbr，acronym，cite，code，dfn，em，kbd，strong，samp，var，<br>a，bdo，br，img，map，object，q，script，span，sub，sup，<br>button，input，label，select，textarea</p>
<p>块级元素和行内元素的区别<br>块级元素：<br>1.会另起一行，<br>2.可以设置width，height，margin，padding，border属性<br>3.默认宽度是容器的100%</p>
<p>行内元素：<br>1.和其他元素在同一行内<br>2.高度和宽度就是内容的高度和宽度<br>3.可以设置margin-left和margin-right属性，无法设置margin-top和margin-bottom属性<br>4.border和padding可以设置，但是border-top和padding-top到页面顶部后就不再增加</p>
<p>标准盒模型和IE盒模型<br>我们目前所学习的知识中，以标准盒子模型为准。</p>
<p>标准盒子模型：</p>
<p>IE盒子模型：</p>
<p>盒子中的区域<br>一个盒子中主要的属性就5个：width、height、padding、border、margin。如下：</p>
<p>width和height：内容的宽度、高度（不是盒子的宽度、高度）</p>
<p>padding：内边距</p>
<p>border：边框</p>
<p>margin：外边距</p>
<p>CSS盒模型和IE盒模型的区别：</p>
<p>在 标准盒子模型中，width 和 height 指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。</p>
<p>IE盒子模型中，width 和 height 指的是内容区域+border+padding的宽度和高度。</p>
<p>注：Android中也有margin和padding的概念，意思是差不多的，如果你会一点Android，应该比较好理解吧。区别在于，Android中没有border这个东西，而且在Android中，margin并不是控件的一部分，我觉得这样做更合理一些，呵呵。</p>
<p><body>标签也有margin</body></p>
<p><body>标签有必要强调一下。很多人以为<body>标签占据的是整个页面的全部区域，其实是错误的，正确的理解是这样的：整个网页最大的盒子是<document>，即浏览器。而<body>是<document>的儿子。浏览器给<body>默认的margin大小是8个像素，此时<body>占据了整个页面的一大部分区域，而不是全部区域。来看一段代码。</body></body></document></body></document></body></body></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"> &lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;Generator&quot; content=&quot;EditPlus®&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;Author&quot; content=&quot;&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;Keywords&quot; content=&quot;&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;Description&quot; content=&quot;&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">    &lt;style type=&quot;text/css&quot;&gt; div&#123; width: 100px; height: 100px; border: 1px solid red; padding: 20px; margin: 30px; &#125; &lt;/style&gt;</span><br><span class="line"></span><br><span class="line"> &lt;/head&gt;</span><br><span class="line"></span><br><span class="line"> &lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div&gt;有生之年&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;狭路相逢&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"> &lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，我们对div标签设置了边距等信息。打开chrome，按住F12，显示效果如下：</p>
<p>认识width、height<br>一定要知道，在前端开发工程师眼中，世界中的一切都是不同的。</p>
<p>比如说，丈量稿纸，前端开发工程师只会丈量内容宽度：</p>
<p>下面这两个盒子，真实占有宽高，都是302*302：</p>
<p>盒子1：</p>
<pre><code>.box1{
    width: 100px;
    height: 100px;
    padding: 100px;
    border: 1px solid red;
}
</code></pre><p>盒子2：</p>
<pre><code>.box2{
    width: 250px;
    height: 250px;
    padding: 25px;
    border: 1px solid red;
}
</code></pre><p>真实占有宽度 = 左border + 左padding + width + 右padding + 右border</p>
<p>上面这两个盒子的盒模型图如下：</p>
<p>如果想保持一个盒子的真实占有宽度不变，那么加width的时候就要减padding。加padding的时候就要减width。因为盒子变胖了是灾难性的，这会把别的盒子挤下去。</p>
<p>认识padding<br>padding区域也有颜色<br>padding就是内边距。padding的区域有背景颜色，css2.1前提下，并且背景颜色一定和内容区域的相同。也就是说，background-color将填充所有border以内的区域。</p>
<p>效果如下：</p>
<p>padding有四个方向<br>padding是4个方向的，所以我们能够分别描述4个方向的padding。</p>
<p>方法有两种，第一种写小属性；第二种写综合属性，用空格隔开。</p>
<p>小属性的写法：</p>
<pre><code>padding-top: 30px;
padding-right: 20px;
padding-bottom: 40px;
padding-left: 100px;
</code></pre><p>综合属性的写法：(上、右、下、左)（顺时针方向，用空格隔开。margin的道理也是一样的）</p>
<p>padding:30px 20px 40px 100px;<br>如果写了四个值，则顺序为：上、右、下、左。</p>
<p>如果只写了三个值，则顺序为：上、右、下。??和右一样。</p>
<p>如果只写了两个值，比如说：</p>
<p>padding: 30px 40px;<br>则顺序等价于：30px 40px 30px 40px;</p>
<p>要懂得，用小属性层叠大属性。比如：</p>
<p>padding: 20px;<br>padding-left: 30px;<br>上面的padding对应盒子模型为：</p>
<p>下面的写法：</p>
<p>padding-left: 30px;<br>padding: 20px;<br>第一行的小属性无效，因为被第二行的大属性层叠掉了。</p>
<p>下面的题，会做了，说明你明白了。</p>
<p>一些题目<br>题目1：说出下面盒子真实占有宽高，并画出盒模型图。</p>
<pre><code>div{
    width: 200px;
    height: 200px;
    padding: 10px 20px 30px;
    padding-right: 40px;
    border: 1px solid #000;
}
</code></pre><p>答案：</p>
<p>题目2：说出下面盒子真实占有宽高，并画出盒模型图。</p>
<pre><code>div{
    width: 200px;
    height: 200px;
    padding-left: 10px;
    padding-right: 20px;
    padding:40px 50px 60px;
    padding-bottom: 30px;
    border: 1px solid #000;
}
</code></pre><p>答案：</p>
<p>padding-left:10px； 和padding-right:20px; 没用，因为后面的padding大属性，层叠掉了他们。</p>
<p>盒子模型如下：</p>
<p>题目3：现在给你一个盒子模型图，请写出代码，试着用最最简单的方法写。</p>
<p>答案：</p>
<pre><code>width:123px;
height:123px;
padding:20px 40px;
border:1px solid red;
</code></pre><p>题目4：现在给你一个盒子模型图，请写出代码，试着用最最简单的方法写。</p>
<p>答案：</p>
<pre><code>width:123px;
height:123px;
padding:20px;
padding-right:40px;
border:1px solid red;
</code></pre><p>一些元素，默认带有padding<br>一些元素，默认带有padding，比如ul标签。如下：</p>
<p>上图显示，不加任何样式的ul，也是有40px的padding-left。</p>
<p>所以，我们做站的时候，为了便于控制，总是喜欢清除这个默认的padding。</p>
<p>可以使用*进行清除：</p>
<pre><code>*{
    margin: 0;
    padding: 0;
}
</code></pre><p>但是，*的效率不高，所以我们使用并集选择器，罗列所有的标签（不用背，有专业的清除默认样式的样式表，今后学习）：</p>
<p>body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,textarea,p,blockquote,th,td{<br>    margin:0;<br>    padding:0;<br>}<br>认识border<br>border就是边框。边框有三个要素：像素（粗细）、线型、颜色。</p>
<p>颜色如果不写，默认是黑色。另外两个属性不写，要命了，显示不出来边框。</p>
<p>border-style<br>border的所有的线型如下：（我们可以通过查看CSS参考手册得到）</p>
<p>比如border:10px ridge red;这个属性，在chrome和firefox、IE中有细微差别：（因为可以显示出效果，因此并不是兼容性问题，只是有细微差别而已）</p>
<p>如果公司里面的设计师是处女座的，追求极高的页面还原度，那么不能使用css来制作边框。就要用到图片，就要切图了。</p>
<p>所以，比较稳定的border-style就几个：solid、dashed、dotted。</p>
<p>border拆分<br>border是一个大综合属性。比如说：</p>
<p>border:1px solid red;<br>就是把4个边框，都设置为1px宽度、线型实线、red颜色。</p>
<p>PS：小技巧：在sublime text中，为了快速输入border:1px solid red;这个属性，可以直接输入bd，然后选第二个后回车。</p>
<p>border属性是能够被拆开的，有两大种拆开的方式：</p>
<p>（1）按三要素拆开：border-width、border-style、border-color。（一个border属性是由三个小属性综合而成的）</p>
<p>（2）按方向拆开：border-top、border-right、border-bottom、border-left。</p>
<p>现在我们明白了：一个border属性，是由三个小属性综合而成的。如果某一个小属性后面是空格隔开的多个值，那么就是上右下左的顺序。举例如下：</p>
<p>border-width:10px 20px;<br>border-style:solid dashed dotted;<br>border-color:red green blue yellow;<br>效果如下：</p>
<p>（1）按三要素拆：</p>
<p>border-width:10px;    //边框宽度<br>border-style:solid;   //线型<br>border-color:red;     //颜色。<br>等价于：</p>
<p>border:10px solid red;<br>(2)按方向来拆：</p>
<p>border-top:10px solid red;<br>border-right:10px solid red;<br>border-bottom:10px solid red;<br>border-left:10px solid red;<br>等价于：</p>
<p>border:10px solid red;<br>（3）按三要素和方向来拆：(就是把每个方向的，每个要素拆开。3*4 = 12)</p>
<pre><code>border-top-width:10px;
border-top-style:solid;
border-top-color:red;
border-right-width:10px;
border-right-style:solid;
border-right-color:red;
border-bottom-width:10px;
border-bottom-style:solid;
border-bottom-color:red;
border-left-width:10px;
border-left-style:solid;
border-left-color:red;
</code></pre><p>等价于：</p>
<p>border:10px solid red;<br>工作中到底用什么？很简答：什么简单用什么。但要懂得，用小属性层叠大属性。举例如下：</p>
<p>为了实现上方效果，写法如下：</p>
<p>border:10px solid red;<br>border-right-color:blue;</p>
<p>为了实现上方效果，写法如下：</p>
<p>border:10px solid red;<br>border-style:solid dashed;<br>border可以没有：</p>
<p>border:none;<br>可以某一条边没有：</p>
<p>border-left: none;<br>也可以调整左边边框的宽度为0：</p>
<p>border-left-width: 0;<br>参考：<a href="https://www.cnblogs.com/smyhvae/p/7256371.html" target="_blank" rel="noopener">https://www.cnblogs.com/smyhvae/p/7256371.html</a></p>
<p>参考：<a href="https://www.cnblogs.com/sichaoyun/p/6761341.html" target="_blank" rel="noopener">https://www.cnblogs.com/sichaoyun/p/6761341.html</a></p>
<h3 id="6、-常见浮动场景、清除浮动的常见办法"><a href="#6、-常见浮动场景、清除浮动的常见办法" class="headerlink" title="6、 常见浮动场景、清除浮动的常见办法"></a>6、 常见浮动场景、清除浮动的常见办法</h3><p>一、清除浮动是用于什么场景？<br>父元素内部的子元素浮动后，会造成父元素的塌陷，父元素的高度为0，因而不会显示样式。</p>
<p>举个栗子<br>html</p>
<p><div class="outer"><br>  <div class="inner"></div><br></div><br>css</p>
<p>.outer{<br>  width:300px;<br>  border: 1px solid #ccc;<br>  background:red;<br>}<br>.inner{<br>  width:100px;<br>  height:100px;<br>  background: blue;<br>  float:left;<br>}<br>以上代码显示结果为  </p>
<p>期待的结果为</p>
<p>有时候，父级元素本来就是没有样式的，那么他塌陷不塌陷无所谓咯，不不不，图森破，如果父级元素后面还有元素，由于父级元素的塌陷，他们就会上来占据父级元素的位置，效果就是，子元素覆盖在了父级元素下面元素的上面。<br>所以，在需要应用父级元素的样式的时候，在不希望子元素覆盖父级下一个元素的时候，要清除浮动。</p>
<p>二、清除浮动常见办法<br>1、给父级div定义高度 </p>
<p>原理：给父级div定义固定高度（height），能解决父级DIV 无法获取高度得问题。</p>
<p>优点：代码简洁。</p>
<p>缺点：高度被固定死了，是适合内容固定不变的模块。</p>
<p>2、空元素追加法</p>
<p>html</p>
<p><div class="box-set"><br>    <div class="box">Box 1</div><br>    <div class="box">Box 2</div><br>    <div class="box">Box 3</div><br>    <div class="clean"></div><br></div><br>css</p>
<p>.box-set{<br>    background-color: #e8aaa9;<br>}<br>.box {<br>    background: #8ec63f;<br>    width: 200px;<br>    height: 100px;<br>    float: left;<br>    margin: 10px;<br>    box-shadow: 20px 20px 10px #555;<br>}<br>.clean{<br>    clear: both;<br>}<br>注意：一般情况下不会使用这一种方式来清除浮动。</p>
<p>优点：浏览器支持好。</p>
<p>缺点：会增加页面的标签，造成结构的混乱。</p>
<p>3、overflow为hidden、auto</p>
<p>html</p>
<p><div class="box-set"><br>    <div class="box">Box 1</div><br>    <div class="box">Box 2</div><br>    <div class="box">Box 3</div><br></div><br>css</p>
<p>.box-set{<br>    background-color: #e8aaa9;<br>    overflow: hidden;<br>}<br>.box {<br>    background: #8ec63f;<br>    width: 200px;<br>    height: 100px;<br>    float: left;<br>    margin: 10px;<br>    box-shadow: 20px 20px 10px #555;<br>}<br>原理：这个方法的关键在于触发了BFC。</p>
<p>优点：代码简介，不存在结构和语义化问题。</p>
<p>缺点：无法显示需要溢出的元素（亦不太推荐使用）。</p>
<p>3、父级div定义伪类:after 和 zoom</p>
<p>html</p>
<p><div class="box-set"><br>    <div class="box">Box 1</div><br>    <div class="box">Box 2</div><br>    <div class="box">Box 3</div><br></div><br>css</p>
<p>.box-set:after{<br>    content:””;//设置内容为空<br>    height:0;//高度为0<br>    line-height:0;//行高为0<br>    display:block;//将文本转为块级元素<br>    visibility:hidden;//将元素隐藏<br>    clear:both//清除浮动<br>}<br>.box-set{<br>    background-color: #e8aaa9;<br>     /<em>在IE6和7的浏览器中，加上“</em>zoom”属性来触发父元素的hasLayout的机制。<em>/
    </em>zoom: 1;<br>}<br>.box {<br>    background: #8ec63f;<br>    width: 200px;<br>    height: 100px;<br>    float: left;<br>    margin: 10px;<br>    box-shadow: 20px 20px 10px #555;<br>}<br>原理：IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE转有属性)可解决ie6，ie7浮动问题。</p>
<p>优点：结构和语义化完全正确,代码量也适中，可重复利用率（建议定义公共类）。</p>
<p>缺点：代码不是非常简洁。</p>
<p>总结：<br>通过上面的例子，我们不难发现清除浮动的方法可以分成两类：</p>
<p>一是利用 clear 属性，包括在浮动元素末尾添加一个带有 clear: both 属性的空 div 来闭合元素，其实利用 :after 伪元素的方法也是在元素末尾添加一个内容为一个点并带有 clear: both 属性的元素实现的。<br>二是触发浮动元素父元素的 BFC (Block Formatting Contexts, 块级格式化上下文)，使到该父元素可以包含浮动元素。</p>
<h3 id="7、文档流的理解和常见改变文档流的方法"><a href="#7、文档流的理解和常见改变文档流的方法" class="headerlink" title="7、文档流的理解和常见改变文档流的方法"></a>7、文档流的理解和常见改变文档流的方法</h3><p>一、什么是文档流？<br>将窗体自上而下分成一行一行，并在每行中按从左至右依次排放元素，称为文档流，也称为普通流。<br>这个应该不难理解，HTML中全部元素都是盒模型，盒模型占用一定的空间，依次排放在HTML中，形成了文档流。</p>
<p>二、什么是脱离文档流？<br>元素脱离文档流之后，将不再在文档流中占据空间，而是处于浮动状态（可以理解为漂浮在文档流的上方）。脱离文档流的元素的定位基于正常的文档流，当一个元素脱离文档流后，依然在文档流中的其他元素将忽略该元素并填补其原先的空间。</p>
<p>三、怎么脱离文档流？<br>1.float<br>使用float可以脱离文档流。注意！！！：使用float脱离文档流时，其他盒子会无视这个元素，但其他盒子内的文本依然会为这个元素让出位置，环绕在该元素的周围。<br>举个栗子：</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>&lt;!DOCTYPE html&gt;</p>
<p><html lang="en"></html></p>
<p><head><meta name="generator" content="Hexo 3.8.0"><br>    <meta charset="UTF-8"><br>    <title>Title</title><br>    <style><br>        .first {<br>            width: 200px;<br>            height: 200px;<br>            border: 3px solid red;<br>            float: left;<br>        }<br>        .second {<br>            width: 200px;<br>            height: 100px;<br>            border: 3px solid blue;<br>        }<br>    </style><br></head></p>
<p><body></body></p>
<p><div class="first">123</div></p>
<p><div class="second">456</div><br><br><br>运行效果：</p>
<p>这段代码中把红色的框设置为了左浮，所以红色的框称为了浮动状态（浮动在蓝色框的上面），而蓝色框占用了原来空色框的位置。注意到，蓝色框中的文本依然认为红色框存在，所以为红色框让出了位置。由于div是块状元素，所以456出现在下方。</p>
<p>2.absolute<br>absolute称为绝对定位，其实博主觉得应该称为相对定位，因为使用absolute脱离文档流后的元素，是相对于该元素的父类（及以上，如果直系父类元素不满足条件则继续向上查询）元素进行定位的，并且这个父类元素的position必须是非static定位的（static是默认定位方式）。<br>举个栗子：</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>&lt;!DOCTYPE html&gt;</p>
<p><html lang="en"></html></p>
<p><head><meta name="generator" content="Hexo 3.8.0"><br>    <meta charset="UTF-8"><br>    <title>Title</title><br>    <style><br>        .first {<br>            width: 200px;<br>            height: 200px;<br>            border: 3px solid red;<br>        }<br>        .second {<br>            width: 200px;<br>            height: 100px;<br>            border: 3px solid blue;<br>            position: absolute;<br>        }<br>        .third {<br>            width: 200px;<br>            height: 200px;<br>            border: 3px solid green;<br>        }<br>    </style><br></head></p>
<p><body></body></p>
<p><div class="first">123</div></p>
<p><div class="second">456</div></p>
<p><div class="third">789</div><br><br><br>运行效果：</p>
<p>通过把蓝色的框的position设置为absolute使蓝色的框变为浮动状态，可以看到绿色的框被蓝色的框遮挡。emmm…，看起来貌似没有问题，但是还记得前面说的absolute是相对谁定位的吗？相对非static元素的父级定位的，这里蓝框的父级就是html，所以应该是相对于html定位，但是代码中没有提供相对位置，所以只能浮动在原来该元素在文档流中的位置上方。</p>
<p>下面加上相对位置并把html以dotted的形式显示出来：</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>&lt;!DOCTYPE html&gt;</p>
<p><html lang="en"></html></p>
<p><head><meta name="generator" content="Hexo 3.8.0"><br>    <meta charset="UTF-8"><br>    <title>Title</title><br>    <style><br>        .first {<br>            width: 200px;<br>            height: 200px;<br>            border: 3px solid red;<br>        }<br>        .second {<br>            width: 200px;<br>            height: 100px;<br>            border: 3px solid blue;<br>            position: absolute;<br>            left: 0;<br>            top: 0;<br>        }<br>        .third {<br>            width: 200px;<br>            height: 200px;<br>            border: 3px solid green;<br>        }<br>        html {<br>            border: dotted;<br>        }<br>    </style><br></head></p>
<p><body></body></p>
<p><div class="first">123</div></p>
<p><div class="second">456</div></p>
<p><div class="third">789</div><br><br><br>运行结果：</p>
<p>结果很明显，蓝色的框遮住了html的点，所以当父级元素的position全是static的时候，absolute是相对于html来进行定位的。</p>
<p>下面举个相对于父级元素定位的栗子：</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>&lt;!DOCTYPE html&gt;</p>
<p><html lang="en"></html></p>
<p><head><meta name="generator" content="Hexo 3.8.0"><br>    <meta charset="UTF-8"><br>    <title>Title</title><br>    <style><br>        .first {<br>            width: 200px;<br>            height: 200px;<br>            border: 3px solid red;<br>            position: relative;<br>        }<br>        .second {<br>            width: 200px;<br>            height: 100px;<br>            border: 3px solid blue;<br>            position: absolute;<br>            left: 0;<br>            top: 0;<br>        }<br>        .third {<br>            width: 200px;<br>            height: 200px;<br>            border: 3px solid green;<br>        }<br>        html {<br>            border: dotted;<br>        }<br>    </style><br></head></p>
<p><body></body></p>
<p><div class="first"><br>    123<br>    <div class="second"><br>        456<br>    </div><br></div></p>
<p><div class="third"><br>    789<br></div><br><br><br>运行结果：</p>
<p>嗯，没问题，蓝色的框是相对红色的框进行定位的，具体来说是相对于border。（可以试一下改变红色框的margin和paddind看看会发生什么）。<br>注意：绝对定位的窗口一般都要设置相对距离，当你同时设置top和bottom的时候，只有top会生效，同理，同时设置left和right的时候，只有left会生效。</p>
<p>3.fixed<br>完全脱离文档流，相对于浏览器窗口进行定位。（相对于浏览器窗口就是相对于html）。</p>
<p>举个栗子：</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>&lt;!DOCTYPE html&gt;</p>
<p><html lang="en"></html></p>
<p><head><meta name="generator" content="Hexo 3.8.0"><br>    <meta charset="UTF-8"><br>    <title>Title</title><br>    <style><br>        .first {<br>            width: 200px;<br>            height: 200px;<br>            border: 3px solid red;<br>        }<br>        .second {<br>            width: 200px;<br>            height: 100px;<br>            border: 3px solid blue;<br>            position: fixed;<br>            right: 0;<br>            top: 0;<br>        }<br>        .third {<br>            width: 200px;<br>            height: 200px;<br>            border: 3px solid green;<br>        }<br>        html {<br>            border: dotted;<br>        }<br>    </style><br></head></p>
<p><body></body></p>
<p><div class="first">123</div></p>
<p><div class="second">456</div></p>
<p><div class="third">789</div><br><br><br>运行结果：</p>
<p>可以很明显的看出，蓝色的框是相对于html进行定位的。当然，如果不提供相对位置的话，蓝色的框会浮动在其原先在文档流中的位置上方。</p>
<p>Note：文档流是在body中的，body在html中，这个在代码结构中也体现出来了，下面的例子可以更直观的看出：</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>&lt;!DOCTYPE html&gt;</p>
<p><html lang="en"></html></p>
<p><head><meta name="generator" content="Hexo 3.8.0"><br>    <meta charset="UTF-8"><br>    <title>Title</title><br>    <style><br>        .first {<br>            width: 200px;<br>            height: 200px;<br>            border: 3px solid red;<br>        }<br>        .second {<br>            width: 200px;<br>            height: 100px;<br>            border: 3px solid blue;<br>        }<br>        .third {<br>            width: 200px;<br>            height: 200px;<br>            border: 3px solid green;<br>        }<br>        body {<br>            border: dotted red;<br>        }<br>        html {<br>            border: double black;<br>        }<br>    </style><br></head></p>
<p><body></body></p>
<p><div class="first">123</div></p>
<p><div class="second">456</div></p>
<p><div class="third">789</div><br><br><br>运行结果：</p>
<p>最后说一个半脱离文档流的方法，就是position：relative。下面说明一下为什么是半脱离文档流。</p>
<p>先看下面这段代码：</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>&lt;!DOCTYPE html&gt;</p>
<p><html lang="en"></html></p>
<p><head><meta name="generator" content="Hexo 3.8.0"><br>    <meta charset="UTF-8"><br>    <title>Title</title><br>    <style><br>        .first {<br>            width: 200px;<br>            height: 200px;<br>            border: 3px solid red;<br>        }<br>        .second {<br>            width: 200px;<br>            height: 100px;<br>            border: 3px solid blue;<br>            position: relative;<br>            top: 100px;<br>        }<br>        .third {<br>            width: 200px;<br>            height: 200px;<br>            border: 3px solid green;<br>        }<br>    </style><br></head></p>
<p><body></body></p>
<p><div class="first">123</div></p>
<p><div class="second">456</div></p>
<p><div class="third">789</div><br><br><br>运行结果：</p>
<p>可以看到，蓝色的框是浮动了，但是绿色的框却相对于蓝色的框原先在文档流中的位置进行了定位。这就是所谓的半脱离文档流，本体还在文档流中占有位置，但是却可以通过改变位置使其漂浮到其他的地方，其定位方式是相对其原先在文档流中的位置进行定位的。<br>注意：可以尝试改变蓝色框的margin和padding属性，看一下会发生什么。<br>关键就是知道蓝色框在原来的文档流占用位置，相对定位后还是在原来的位置占据文档流。（类似实体投影到另一个地方）。</p>
<p>以上就是脱离文档流的方法。</p>
<p>参考：<a href="https://pcxiaobai.com/design/front/20190205/454.html" target="_blank" rel="noopener">https://pcxiaobai.com/design/front/20190205/454.html</a></p>
<h3 id="8、-CSS3新增属性"><a href="#8、-CSS3新增属性" class="headerlink" title="8、 CSS3新增属性"></a>8、 CSS3新增属性</h3><p>选择器<br>CSS3中新添加了很多选择器，解决了很多之前需要用javascript才能解决的布局问题。</p>
<p>element1~element2: 选择前面有element1元素的每个element2元素。<br>[attribute^=value]: 选择某元素attribute属性是以value开头的。<br>[attribute$=value]: 选择某元素attribute属性是以value结尾的。<br>[attribute*=value]: 选择某元素attribute属性包含value字符串的。<br>E:first-of-type: 选择属于其父元素的首个E元素的每个E元素。<br>E:last-of-type: 选择属于其父元素的最后E元素的每个E元素。<br>E:only-of-type: 选择属于其父元素唯一的E元素的每个E元素。<br>E:only-child: 选择属于其父元素的唯一子元素的每个E元素。<br>E:nth-child(n): 选择属于其父元素的第n个子元素的每个E元素。<br>E:nth-last-child(n): 选择属于其父元素的倒数第n个子元素的每个E元素。<br>E:nth-of-type(n): 选择属于其父元素第n个E元素的每个E元素。<br>E:nth-last-of-type(n): 选择属于其父元素倒数第n个E元素的每个E元素。<br>E:last-child: 选择属于其父元素最后一个子元素每个E元素。<br>:root: 选择文档的根元素。<br>E:empty: 选择没有子元素的每个E元素（包括文本节点)。<br>E:target: 选择当前活动的E元素。<br>E:enabled: 选择每个启用的E元素。<br>E:disabled: 选择每个禁用的E元素。<br>E:checked: 选择每个被选中的E元素。<br>E:not(selector): 选择非selector元素的每个元素。<br>E::selection: 选择被用户选取的元素部分。</p>
<p>Transition,Transform和Animation<br>A.Transition<br>Transition可以在当元素从一种样式变换为另一种样式时为元素添加效果，而不用使用Flash动画或JavaScript。Transition有如下属性：</p>
<p>transition-property: 规定应用过渡的CSS属性的名称。<br>transition-duration: 规定完成过渡效果需要多长时间。<br>transition-delay: 规定过渡效果何时开始，默认是0。<br>transition-timing-function: 规定过渡效果的时间曲线，默认是”ease”，还有linear、ease-in、ease-out、ease-in-out和cubic-bezier等过渡类型。<br>transition: 简写属性，用于在一个属性中设置四个过渡属性。</p>
<p>B.Transform<br>Transform用来向元素应用各种2D和3D转换，该属性允许我们对元素进行旋转、缩放、移动或倾斜等操作。<br>变换类型 transform可以有各种变换类型，即属性值：</p>
<p>none: 定义不进行转换。<br>matrix(n,n,n,n,n,n): 定义2D转换，使用六个值的矩阵。<br>matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n): 定义3D转换，使用16个值的4x4矩阵。<br>translate(x,y): 定义2D位移转换。<br>translate3d(x,y,z): 定义3D位移转换。<br>translateX(x): 定义位移转换，只是用X轴的值。<br>translateY(y): 定义位移转换，只是用Y轴的值。<br>translateZ(z): 定义3D位移转换，只是用Z轴的值。<br>scale(x,y): 定义2D缩放转换。<br>scale3d(x,y,z): 定义3D缩放转换。<br>scaleX(x): 通过设置X轴的值来定义缩放转换。<br>scaleY(y): 通过设置Y轴的值来定义缩放转换。<br>scaleZ(z): 通过设置Z轴的值来定义3D缩放转换。<br>rotate(angle): 定义2D旋转，在参数中规定角度。<br>rotate3d(x,y,z,angle): 定义3D旋转。<br>rotateX(angle): 定义沿着X轴的3D旋转。<br>rotateY(angle): 定义沿着Y轴的3D旋转。<br>rotateZ(angle): 定义沿着Z轴的3D旋转。<br>skew(x-angle,y-angle): 定义沿着X和Y轴的2D倾斜转换。<br>skewX(angle): 定义沿着X轴的2D倾斜转换。<br>skewY(angle): 定义沿着Y轴的2D倾斜转换。<br>perspective(n): 为3D转换元素定义透视视图。<br>浏览器支持<br>Internet Explorer 10、Firefox、Opera 支持 transform 属性。<br>Internet Explorer 9 支持替代的 -ms-transform 属性（仅适用于 2D 转换）。<br>Safari 和 Chrome 支持替代的 -webkit-transform 属性（3D 和 2D 转换）。<br>Opera 只支持 2D 转换。</p>
<p>C.Animation<br>Animation让CSS拥有了可以制作动画的功能。使用CSS3的Animation制作动画我们可以省去复杂的js代码。使用方法大概如下：具体用法可以参考教程：CSS3 Animation。</p>
<p>边框<br>CSS3新增了三个边框属性，分别是border-radius、box-shadow和border-image。border-radius可以创建圆角边框，box-shadow可以为元素添加阴影，border-image可以使用图片来绘制边框。IE9+支持border-radius和box-shadow属性。Firefox、Chrome以及Safari支持所有新的边框属性。</p>
<p>背景<br>CSS3新增了几个关于背景的属性，分别是background-clip、background-origin、background-size和background-break。</p>
<p>A.background-clip<br>background-clip属性用于确定背景画区，有以下几种可能的属性：</p>
<p>background-clip: border-box; 背景从border开始显示<br>background-clip: padding-box; 背景从padding开始显示<br>background-clip: content-box; 背景显content区域开始显示<br>background-clip: no-clip; 默认属性，等同于border-box<br>通常情况，背景都是覆盖整个元素的，利用这个属性可以设定背景颜色或图片的覆盖范围。</p>
<p>B.background-origin<br>background-clip属性用于确定背景的位置，它通常与background-position联合使用，可以从 border、padding、content来计算background-position（就像background-clip）。</p>
<p>background-origin: border-box; 从border开始计算background-position<br>background-origin: padding-box; 从padding开始计算background-position<br>background-origin: content-box; 从content开始计算background-position<br>C.background-size<br>background-size属性常用来调整背景图片的大小，主要用于设定图片本身。有以下可能的属性：</p>
<p>background-size: contain; 缩小图片以适合元素（维持像素长宽比）<br>background-size: cover; 扩展元素以填补元素（维持像素长宽比）<br>background-size: 100px 100px; 缩小图片至指定的大小<br>background-size: 50% 100%; 缩小图片至指定的大小，百分比是相对包 含元素的尺寸<br>D.background-break<br>CSS3中，元素可以被分成几个独立的盒子（如使内联元素span跨越多行），background-break 属性用来控制背景怎样在这些不同的盒子中显示。</p>
<p>background-break: continuous; 默认值。忽略盒之间的距离（也就是像元素没有分成多个盒子，依然是一个整体一样）<br>background-break: bounding-box; 把盒之间的距离计算在内；<br>background-break: each-box; 为每个盒子单独重绘背景。<br>文字效果<br>A.word-wrap<br>CSS3中，word-wrap属性允许您允许文本强制文本进行换行，即这意味着会对单词进行拆分。所有主流浏览器都支持 word-wrap 属性。</p>
<p>B.text-overflow<br>它与word-wrap是协同工作的，word-wrap设置或检索当当前行超过指定容器的边界时是否断开转行，而 text-overflow则设置或检索当当前行超过指定容器的边界时如何显示。对于“text-overflow”属性，有“clip”和“ellipsis”两种可供选择。</p>
<p>C.text-shadow<br>CSS3中，text-shadow可向文本应用阴影。能够规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色。</p>
<p>D.text-decoration<br>CSS3里面开始支持对文字的更深层次的渲染，具体有三个属性可供设置：</p>
<p>text-fill-color: 设置文字内部填充颜色<br>text-stroke-color: 设置文字边界填充颜色<br>text-stroke-width: 设置文字边界宽度<br>box-sizing<br>box-sizing属性可设置的值有content-box、border-box和inherit。</p>
<p>content-box: padding和border不被包含在定义的width和height之内。对象的实际宽度等于设置的width值和border、padding之和，即 (Element width = width + border + padding)，此属性表现为标准模式下的盒模型。<br>border-box: padding和border被包含在定义的width和height之内。对象的实际宽度就等于设置的width值，即使定义有border和padding也不会改变对象的实际宽度，即 (Element width = width)，此属性表现为怪异模式下的盒模型。</p>
<p>参考：<a href="https://juejin.im/entry/595f1e3c5188250d914dd53c" target="_blank" rel="noopener">https://juejin.im/entry/595f1e3c5188250d914dd53c</a><br>参考：<a href="https://leohxj.gitbooks.io/front-end-database/html-and-css-basic/css3-news.html" target="_blank" rel="noopener">https://leohxj.gitbooks.io/front-end-database/html-and-css-basic/css3-news.html</a></p>
<h3 id="9、CSS3中媒体查询简述"><a href="#9、CSS3中媒体查询简述" class="headerlink" title="9、CSS3中媒体查询简述"></a>9、CSS3中媒体查询简述</h3><p>1.首先要了解一下什么是媒体查询<br>媒体查询可以让我们根据设备显示器的特性（如视口宽度、屏幕比例、设备方向：横向或纵向）为其设定CSS样式，媒体查询由媒体类型和一个或多个检测媒体特性的条件表达式组成。媒体查询中可用于检测的媒体特性有 width 、 height 和 color （等）。使用媒体查询，可以在不改变页面内容的情况下，为特定的一些输出设备定制显示效果。</p>
<p>2.如何在css中引入媒体查询<br>媒体查询写在CSS样式代码的最后，CSS是层叠样式表，在同一特殊性下，靠后的的样式会重叠前面的样式</p>
<p>3.常见Media使用示例<br>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>/<em>媒体查询</em>/<br>/<em>当页面大于1200px 时，大屏幕，主要是PC 端</em>/<br>@media (min-width: 1200px) {<br>}<br>/<em>在992 和1199 像素之间的屏幕里，中等屏幕，分辨率低的PC</em>/<br>@media (min-width: 992px) and (max-width: 1199px) {</p>
<pre><code>#adver .center {
    width: 50%;
    margin: -10px 0 0 -25%;
}
main .center h2 {
    font-size: 40px;
}
</code></pre><p>}<br>/<em>在768 和991 像素之间的屏幕里，小屏幕，主要是PAD</em>/<br>@media (min-width: 768px) and (max-width: 991px) {</p>
<pre><code>#adver .center {
    width: 60%;
    margin: -10px 0 0 -30%;
}
#adver .search, #adver .button {
    font-size: 20px;
}
main .center h2 {
    font-size: 35px;
}
</code></pre><p>}<br>/<em>在480 和767 像素之间的屏幕里，超小屏幕，主要是手机</em>/<br>@media (min-width: 480px) and (max-width: 767px) {<br>    header, header .center, header .link {<br>        height: 45px;<br>    }<br>    header .logo, .sm-hidden,.sidebar,.md-hidden {<br>        display: none;<br>    }<br>    header .link {<br>        width: 100%;<br>        line-height: 45px;<br>    }</p>
<pre><code>#adver {
    padding: 45px 0 0 0;
}
#adver .center {
    width: 70%;
    height: 53px;
    margin: -10px 0 0 -35%;
}
#adver .search, #adver .button {
    height: 45px;
    font-size: 18px;
}
.sm-visible {
    display: block;
}
main .center h2 {
    font-size: 30px;
}
main .center p {
    font-size: 15px;
}
main figure {
    width: 49.2%;
}
</code></pre><p>}<br>/<em>在小于480 像素的屏幕，微小屏幕，更低分辨率的手机</em>/<br>@media (max-width: 479px) {<br>    header, header .center, header .link {<br>        height: 45px;<br>    }<br>    header .logo, .xs-hidden, .sm-hidden, .sidebar, .md-hidden  {<br>        display: none;<br>    }<br>    header .link {<br>        width: 100%;<br>        line-height: 45px;<br>    }<br>    header .link li {<br>        width: 25%;<br>    }</p>
<pre><code>#adver {
    padding: 45px 0 0 0;
}
#adver .center {
    width: 80%;
    height: 48px;
    margin: -10px 0 0 -40%;
}
#adver .search, #adver .button {
    height: 40px;
    font-size: 16px;
}
.sm-visible {
    display: block;
}
footer .bottom, footer .version {
    font-size: 13px;
}
main .center h2 {
    font-size: 26px;
}
main .center p {
    font-size: 14px;
}
main figure {
    width: 99%;
}
</code></pre><p>}</p>
<p>参考：<a href="https://www.jianshu.com/p/eb1123d5b20b" target="_blank" rel="noopener">https://www.jianshu.com/p/eb1123d5b20b</a><br>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries</a></p>
<h2 id="1-position属性有哪些？分别是如何定位的？"><a href="#1-position属性有哪些？分别是如何定位的？" class="headerlink" title="1.position属性有哪些？分别是如何定位的？"></a><font color="#e12" size="3"><strong>1.position属性有哪些？分别是如何定位的？</strong></font></h2><blockquote>
<p>relative    相对定位。相对于出生位置进行定位。<br>  absolute    绝对定位。相对于最近的有定位的父级进行定位，没有则相对于文档定位。<br>  fixed       固定定位。相对于浏览器窗口定位。<br>  static      默认值。没有定位。<br>  inherit     继承父级的position定位。</p>
</blockquote>
<h2 id="2-什么是事件委托？"><a href="#2-什么是事件委托？" class="headerlink" title="2.什么是事件委托？"></a><font color="#e12" size="3"><strong>2.什么是事件委托？</strong></font></h2><blockquote>
<p>事件委托指的是，在父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素DOM的类型，来做出不同的响应。(事件委托是利用事件冒泡和事件源对象进行处理)</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class = <span class="string">'ulDom'</span>&gt;</span><br><span class="line">  &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;2&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;3&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;4&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;5&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const ulDom = document.getElementsByClassName(<span class="string">'ulDom'</span>)[0];</span><br><span class="line">  ulDom.onclick = (e) =&gt; &#123;</span><br><span class="line">    console.log(e.target.innerHTML);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="3-浏览器从加载到渲染的过程，比如输入一个网址到显示页面的过程？"><a href="#3-浏览器从加载到渲染的过程，比如输入一个网址到显示页面的过程？" class="headerlink" title="3.浏览器从加载到渲染的过程，比如输入一个网址到显示页面的过程？"></a><font color="#e12" size="3"><strong>3.浏览器从加载到渲染的过程，比如输入一个网址到显示页面的过程？</strong></font></h2><blockquote>
<p>加载过程：<br>  浏览器根据 DNS 服务器解析得到域名的 IP 地址（服务器地址）<br>  浏览器和服务器建立TCP连接（三次握手）<br>  浏览器向服务器发送 HTTP 请求<br>  服务器收到、处理并返回 HTTP 请求<br>  浏览器得到返回内容，结束连接（四次挥手）<br><br>  渲染过程：<br>  根据 HTML 结构生成 DOM 树<br>  根据 CSS 生成 CSS 树<br>  将 DOM 树 和 CSS 树 整合形成 RenderTree<br>  根据 RenderTree 开始渲染和展示<br>  遇到&lt; script&gt;时，会执行并阻塞渲染</p>
</blockquote>
<hr>
<ul>
<li>详细版本：<br>DNS域名解析：把域名解析成IP地址<br>TCP 建立连接：TCP三次握手<br>浏览器发送HTTP请求<br>服务器处理并响应报文<br>浏览器解析并渲染页面<br>二者断开连接：TCP 结束连接（TCP四次挥手）</li>
</ul>
<p><font color="#f0a">一、DNS域名解析：</font><br>DNS domain name system 主要作用就是将主机域名转换为ip地址。<br>具体过程如下：<br>①用户主机上运行着DNS的客户端（就是我们的PC机或者手机客户端运行着DNS客户端）<br>②浏览器将接收到的url中抽取出域名字段（就是访问的主机名，比如<a href="http://www.baidu.com/）" target="_blank" rel="noopener">http://www.baidu.com/）</a>, 并将这个主机名传送给DNS应用的客户端<br>③DNS客户机端向DNS服务器端发送一份查询报文，报文中包含着要访问的主机名字段（中间包括一些列缓存查询以及分布式DNS集群的工作）<br>④该DNS客户机最终会收到一份回答报文，其中包含有该主机名对应的IP地址<br>⑤一旦该浏览器收到来自DNS的IP地址，就可以向该IP地址定位的HTTP服务器发起TCP连接</p>
<p><font color="#f0a">二、TCP连接（三次握手）：</font><br>TCP是因特网中的传输层协议，使用三次握手协议建立连接。当主动方发出SYN连接请求后，等待对方回答SYN+ACK，并最终对对方的 SYN 执行 ACK 确认。这种建立连接的方法可以防止产生错误的连接，TCP使用的流量控制协议是可变大小的滑动窗口协议。<br>TCP三次握手的过程如下：<br>客户端发送SYN（SEQ=x）报文给服务器端，进入SYN_SEND状态。<br>服务器端收到SYN报文，回应一个SYN （SEQ=y）ACK（ACK=x+1）报文，进入SYN_RECV状态。<br>客户端收到服务器端的SYN报文，回应一个ACK（ACK=y+1）报文，进入Established状态。<br>三次握手完成，TCP客户端和服务器端成功地建立连接，可以开始传输数据了。<br><img src="https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=d30689c3828ba61ecbe3c07d205dfc6f/29381f30e924b899cb32f6316e061d950a7bf6a9.jpg"></p>
<p><font color="#f0a">三、向服务器发送HTTP请求</font><br>建立TCP连接后，开始向Web服务器发送HTTP请求报文。<br>请求方法包含 8 种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。<br>URL 即请求地址，由 &lt;协议&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt;?&lt;参数&gt; 组成</p>
<p><font color="#f0a">四、服务器处理请求并返回 HTTP 报文</font><br><strong> 响应行包含：协议版本，状态码，状态码描述 </strong><br>状态码规则如下：<br>1xx：指示信息–表示请求已接收，继续处理。<br>2xx：成功–表示请求已被成功接收、理解、接受。<br>3xx：重定向–要完成请求必须进行更进一步的操作。<br>4xx：客户端错误–请求有语法错误或请求无法实现。<br>5xx：服务器端错误–服务器未能实现合法的请求。</p>
<p><font color="#f0a">五、浏览器解析并渲染页面</font><br>浏览器解析渲染页面分为一下五个步骤：<br>根据 HTML 解析出 DOM 树<br>根据 CSS 解析生成 CSS 规则树<br>结合 DOM 树和 CSS 规则树，生成渲染树<br>根据渲染树计算每一个节点的信息<br>根据计算好的信息绘制页面</p>
<p>1）根据 HTML 解析 DOM 树。<br>根据 HTML 的内容，将标签按照结构解析成为 DOM 树，DOM 树解析的过程是一个深度优先遍历。即先构建当前节点的所有子节点，再构建下一个兄弟节点。<br>在读取 HTML 文档，构建 DOM 树的过程中，若遇到 script 标签，则 DOM 树的构建会暂停，直至脚本执行完毕。</p>
<p>2）根据 CSS 解析生成 CSS 规则树<br>解析 CSS 规则树时， js 执行将暂停，直至 CSS 规则树就绪。<br>浏览器在 CSS 规则树生成之前不会进行渲染。</p>
<p>3）结合 DOM 树和 CSS 规则树，生成渲染树<br>DOM 树和 CSS 规则树全部准备好了以后，浏览器才会开始构建渲染树。<br>精简 CSS 可以加快 CSS 规则树的构建，从而加快页面相应速度。<br>根据渲染树计算每一个节点的信息（布局）</p>
<p>布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸<br>回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。<br>根据计算好的信息绘制页面，绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。<br>重排：当DOM的变化引发了元素几何属性的变化，比如改变元素的宽高，元素的位置，导致浏览器不得不重新计算元素的几何属性，并重新构建渲染树，这个过程称为“重排”。<br>重绘：完成重排后，要将重新构建的渲染树渲染到屏幕上，这个过程就是“重绘”。</p>
<p><i>js加载时间线：<br>1.开始解析页面，document.readyState的值为 loading ,<br>2 3 4 5 解析html,css,js,img等<br>6.当页面解析完成后，onreadystatechange事件中document.readyState变为 interactive ，<br>7.defer执行<br>8.document对象触发DOMContentloaded事件，这也标志着程序执行从同步脚本执行阶段，转换为事件驱动阶段（document.addEventListener）<br>9.onreadystatechange事件中document.readyState变为 complete<br>10.window对象触发load事件<br></i><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  console.log(<span class="string">'1.开始解析页面，document.readyState的值为'</span>, document.readyState, <span class="string">','</span>);</span><br><span class="line">  console.log(<span class="string">'2 3 4 5 解析html,css,js,img等,'</span>);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  document.addEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'8.document对象的DOMContentloaded事件执行，这也标志着程序执行从同步脚本执行阶段，转换为事件驱动阶段（document.addEventListener）'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  document.onreadystatechange = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    <span class="keyword">if</span> (document.readyState == <span class="string">'interactive'</span>) &#123;</span><br><span class="line">      console.log(<span class="string">'6.页面解析完成，document对象的onreadystatechange事件执行，document.readyState变为'</span>, document.readyState);</span><br><span class="line">      console.log(<span class="string">'7.defer执行'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (document.readyState == <span class="string">'complete'</span>) &#123;</span><br><span class="line">      console.log(<span class="string">'9.document对象的onreadystatechange事件执行，document.readyState变为'</span>, document.readyState);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  window.onload = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'10.window对象触发load事件'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p><font color="#f0a">六、TCP 断开连接（TCP四次挥手）</font><br>当数据传送完毕，需要断开 tcp 连接，此时发起 tcp 四次挥手。</p>
<p>发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)<br>被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。(第二次挥手：由服务器发起的，告诉浏览器：我收到了你的关闭请求报文，我准备一下，你等我消息)<br>被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。(第三次挥手：由服务器发起，给浏览器发送了响应报文：我准备好了，你可以准备关闭了)<br>发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。(第四次挥手：由浏览器发起，告诉服务器，我收到了你的响应报文，我准备关闭了，你可以关闭了。浏览器发送完响应报文后，等待一段时间，服务器端没有给其他回复，则浏览器也就关闭连接了)</p>
<h2 id="4-react生命周期有哪些？"><a href="#4-react生命周期有哪些？" class="headerlink" title="4.react生命周期有哪些？"></a><font color="#e12" size="3"><strong>4.react生命周期有哪些？</strong></font></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">组件载入阶段：</span><br><span class="line">  componentWillMount:组件即将被装载、渲染到页面上，只调用1次</span><br><span class="line">  render:组件在这里生成虚拟的 DOM 节点</span><br><span class="line">  componentDidMount:组件真正在被装载之后，这里可以拿到真实DOM执行操作，只调用1次</span><br><span class="line"></span><br><span class="line">运行中状态：</span><br><span class="line">  componentWillReceiveProps(nextProps):组件将要接收到新属性的时候调用，在这时setState不会触发额外的render,因为此时已经有一次来自父组件引发的render了。</span><br><span class="line">  shouldComponentUpdate:组件接受到新属性或者新状态的时候（返回 <span class="literal">false</span>，接收数据后不更新，阻止 render ，后面的函数不会继续执行）</span><br><span class="line">  componentWillUpdate:组件即将更新不能修改属性和状态。（这里也会调用render）</span><br><span class="line">  componentDidUpdate:组件已经更新</span><br><span class="line"></span><br><span class="line">销毁阶段：</span><br><span class="line">  componentWillUnmount:组件即将销毁，这时候可以销毁绑定的事件监听或者定时器什么的。</span><br></pre></td></tr></table></figure>
<p><br><br><br></p>
<h2 id="5-代码输出题"><a href="#5-代码输出题" class="headerlink" title="5.代码输出题"></a><font color="#e12" size="3"><strong>5.代码输出题</strong></font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  console.log(&apos;Promise&apos;);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(() =&gt; &#123;</span><br><span class="line">  console.log(&apos;resolved&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&apos;Hi&apos;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个问题是让我摔了两跤的大坑！！！<br>上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。</p>
</blockquote>
<p>下面这个例子，能很好地说明promise的作用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">const getJSON = <span class="keyword">function</span> (url) &#123;</span><br><span class="line">  const promise = new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">    const handler = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">      <span class="keyword">if</span> (this.readyState !== 4) &#123;</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (this.status === 200) &#123;</span><br><span class="line">        resolve(this.response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(new Error(this.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    const client = new XMLHttpRequest();</span><br><span class="line">    client.open(<span class="string">"GET"</span>, url);</span><br><span class="line">    client.onreadystatechange = handler;</span><br><span class="line">    client.responseType = <span class="string">"json"</span>;</span><br><span class="line">    client.setRequestHeader(<span class="string">"Accept"</span>, <span class="string">"application/json"</span>);</span><br><span class="line">    client.send();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getJSON(<span class="string">"/posts.json"</span>).<span class="keyword">then</span>(<span class="keyword">function</span> (json) &#123;</span><br><span class="line">  console.log(<span class="string">'Contents: '</span> + json);</span><br><span class="line">&#125;, <span class="keyword">function</span> (error) &#123;</span><br><span class="line">  console.error(<span class="string">'出错了'</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><br><br><br></p>
<h2 id="6-手写代码题"><a href="#6-手写代码题" class="headerlink" title="6.手写代码题"></a><font color="#e12" size="3"><strong>6.手写代码题</strong></font></h2><p>字符串中出现次数最多的字符？<br>  var str = ‘abcdaaaaaa’;<br>  console.log(num, char);<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> mostStr(str)&#123;</span><br><span class="line">  <span class="built_in">let</span> memory = &#123;&#125;;</span><br><span class="line">  <span class="built_in">let</span> num = [];</span><br><span class="line">  num[0] = 0;</span><br><span class="line">  <span class="built_in">let</span> char = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="built_in">let</span> i = 0 ; i &lt; str.length ; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(memory[str[i]])&#123;</span><br><span class="line">      memory[str[i]] += 1;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      memory[str[i]] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">let</span> j = 0;</span><br><span class="line">  <span class="keyword">for</span>(<span class="built_in">let</span> item <span class="keyword">in</span> memory)&#123;</span><br><span class="line">    <span class="keyword">if</span>(memory[item] &gt; num[j])&#123;</span><br><span class="line">      j = 0;</span><br><span class="line">      num = [];</span><br><span class="line">      char = [];</span><br><span class="line">      num[j] = memory[item];</span><br><span class="line">      char[j] = item;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(memory[item] === num[j])&#123;</span><br><span class="line">      j++;</span><br><span class="line">      num[j] = memory[item];</span><br><span class="line">      char[j] = item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> &#123;</span><br><span class="line">    <span class="string">'num'</span>: num,</span><br><span class="line">    <span class="string">'char'</span>: char,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br></p>
<h2 id="7-手写代码题"><a href="#7-手写代码题" class="headerlink" title="7.手写代码题"></a><font color="#e12" size="3"><strong>7.手写代码题</strong></font></h2><p>如何实现数组的随机排序？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4,5,6,7,8].sort(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">  <span class="built_in">return</span> Math.random() - 0.5;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><br><br><br></p>
<h2 id="8-css权重规则是如何计算的？"><a href="#8-css权重规则是如何计算的？" class="headerlink" title="8.css权重规则是如何计算的？"></a><font color="#e12" size="3"><strong>8.css权重规则是如何计算的？</strong></font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">选择器类型                     权重         举例：</span><br><span class="line">通配符选择器                    0           *&#123;&#125;</span><br><span class="line">标签选择器                      1           div&#123;&#125;</span><br><span class="line">class | 属性 | 伪类选择器       10           .ant-menu&#123;&#125;</span><br><span class="line">id选择器                      100           #areaMap&#123;&#125;</span><br><span class="line">行间样式                      100           &lt; div  style = &#123; &#123; color: &apos;red&apos; &#125; &#125;&gt;&#123; importData.success &#125;&lt; /div&gt;</span><br><span class="line">!important                   无穷大         background-color: @menu-selected-bg-color !important;</span><br><span class="line"></span><br><span class="line">复合选择器的权重为相应选择器累加之和</span><br></pre></td></tr></table></figure>
<p>2019年12月9日<br><br><br><br></p>
<h2 id="9-改变函数内部this指针的指向函数（bind，apply，call的区别）？"><a href="#9-改变函数内部this指针的指向函数（bind，apply，call的区别）？" class="headerlink" title="9.改变函数内部this指针的指向函数（bind，apply，call的区别）？"></a><font color="#e12" size="3"><strong>9.改变函数内部this指针的指向函数（bind，apply，call的区别）？</strong></font></h2><p>通过apply和call改变函数的this指向，他们两个函数的第一个参数都是一样的表示要改变指向的那个对象，第二个参数，apply是数组，而call则是arg1,arg2…这种形式。通过bind改变this作用域会返回一个新的函数，这个函数不会马上执行。</p>
<blockquote>
<p><font color="#7b3"><code>call()</code> 使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数</font><br> <font color="#7b3"><code>bind()</code> 创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被bind的第一个参数指定，其余的参数将作为新函数的参数供调用时使用</font>-</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">1、call的实现原理:</span><br><span class="line">  Function.prototype.call = <span class="keyword">function</span>(thisArg)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (typeof this !== <span class="string">'function'</span>) &#123; // 调用call的若不是函数则报错</span><br><span class="line">      throw new TypeError(<span class="string">'Error'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">                                  </span><br><span class="line">    thisArg = thisArg || window;      //若thisArg不存在，thisArg指向window</span><br><span class="line">    thisArg.fn = this;                // 将调用call函数的函数对象添加到thisArg的属性中</span><br><span class="line"></span><br><span class="line">    const res = thisArg.fn([...arguments].slice(1)); //去除参数的第一个值后执行这个添加的函数</span><br><span class="line">    delete thisArg.fn                 // 删除该属性</span><br><span class="line">    <span class="built_in">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">test</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'我是测试函数'</span>, this.name);</span><br><span class="line">  &#125;</span><br><span class="line">  var obj = &#123;</span><br><span class="line">    name: <span class="string">'obj'</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  test.call(obj);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2、apply的实现原理</span><br><span class="line">  Function.prototype.imitateApply = <span class="keyword">function</span> (context) &#123;</span><br><span class="line">    context = context || window;</span><br><span class="line">    context.func = this;</span><br><span class="line">    <span class="built_in">let</span> result;</span><br><span class="line">    <span class="keyword">if</span> (arguments[1]) &#123;</span><br><span class="line">        result = context.func(...arguments[1]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = context.func();</span><br><span class="line">    &#125;</span><br><span class="line">    Reflect.deleteProperty(context, <span class="string">'func'</span>);</span><br><span class="line">    <span class="built_in">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">3、<span class="built_in">bind</span>的实现原理</span><br><span class="line">  Function.prototype.imitateBind = <span class="keyword">function</span> (context) &#123;</span><br><span class="line">    // 获取绑定时的传参</span><br><span class="line">    <span class="built_in">let</span> args = [...arguments].slice(1),</span><br><span class="line">        // 定义中转构造函数，用于通过原型连接绑定后的函数和调用<span class="built_in">bind</span>的函数</span><br><span class="line">        F = <span class="function"><span class="title">function</span></span> () &#123;&#125;,</span><br><span class="line">        // 记录调用函数，生成闭包，用于返回函数被调用时执行</span><br><span class="line">        self = this,</span><br><span class="line">        // 定义返回(绑定)函数</span><br><span class="line">        bound = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">            // 合并参数，绑定时和调用时分别传入的</span><br><span class="line">            <span class="built_in">let</span> finalArgs = [...args, ...arguments]</span><br><span class="line">            </span><br><span class="line">            // 改变作用域，注:aplly/call是立即执行函数，即绑定会直接调用</span><br><span class="line">            // 这里之所以要使用instanceof做判断，是要区分是不是new xxx()调用的<span class="built_in">bind</span>方法</span><br><span class="line">            <span class="built_in">return</span> self.call((this instanceof F ? this : context), ...finalArgs)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    // 将调用函数的原型赋值到中转函数的原型上</span><br><span class="line">    F.prototype = self.prototype</span><br><span class="line">    // 通过原型的方式继承调用函数的原型</span><br><span class="line">    bound.prototype = new F()</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">return</span> bound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2019年12月10日</p>
<p><br><br><br></p>
<h2 id="10-react怎么从虚拟dom中拿出真实dom？"><a href="#10-react怎么从虚拟dom中拿出真实dom？" class="headerlink" title="10.react怎么从虚拟dom中拿出真实dom？"></a><font color="#e12" size="3"><strong>10.react怎么从虚拟dom中拿出真实dom？</strong></font></h2><p>11</p>
<p><br><br><br></p>
<h2 id="11-代码输出题"><a href="#11-代码输出题" class="headerlink" title="11.代码输出题"></a><font color="#e12" size="3"><strong>11.代码输出题</strong></font></h2><p>setTimeout(() =&gt; {</p>
<p>  console.log(1);</p>
<p>});</p>
<p>new Promise((resolve, reject) =&gt; {</p>
<p>  console.log(2);</p>
<p>  resolve(3);</p>
<p>}).then((val) =&gt; {</p>
<p>  console.log(val);</p>
<p>});</p>
<p>console.log(4);</p>
<p><br><br><br></p>
<h2 id="12-有以下-2-个判断数组的方法，请分别介绍它们之间的区别和优劣？Object-prototype-toString-call-、-instanceof"><a href="#12-有以下-2-个判断数组的方法，请分别介绍它们之间的区别和优劣？Object-prototype-toString-call-、-instanceof" class="headerlink" title="12.有以下 2 个判断数组的方法，请分别介绍它们之间的区别和优劣？Object.prototype.toString.call() 、 instanceof()"></a><font color="#e12" size="3"><strong>12.有以下 2 个判断数组的方法，请分别介绍它们之间的区别和优劣？Object.prototype.toString.call() 、 instanceof()</strong></font></h2><p>11</p>
<p><br><br><br></p>
<h2 id="13-手写代码题"><a href="#13-手写代码题" class="headerlink" title="13.手写代码题"></a><font color="#e12" size="3"><strong>13.手写代码题</strong></font></h2><p>获取当前url中的某个参数？</p>
<p><br><br><br></p>
<h2 id="14-es6-新增声明命令let和const有哪些异同？"><a href="#14-es6-新增声明命令let和const有哪些异同？" class="headerlink" title="14.es6 新增声明命令let和const有哪些异同？"></a><font color="#e12" size="3"><strong>14.es6 新增声明命令let和const有哪些异同？</strong></font></h2><p>11</p>
<p><br><br><br></p>
<h1 id="三、主流框架"><a href="#三、主流框架" class="headerlink" title="三、主流框架"></a>三、主流框架</h1><h2 id="3-1）react"><a href="#3-1）react" class="headerlink" title="3.1）react"></a>3.1）react</h2><p>1、说一下React<br>　　React是Facebook 开发的前端JavaScript库<br>   虚拟DOM：react引入虚拟DOM，每当数据变化通过reactdiff运算，将上一次的虚拟DOM与本次渲染的DOM进行对比，仅仅只渲染更新的，有效减少了DOM操作<br>　　JSX语法：js+xml，是js的语法扩展，编译后转换成普通的js对象<br>　　组件化思想：将具有独立功能的UI模块封装为一个组件，而小的组件又可以通过不同的组合嵌套组成大的组件，最终完成整个项目的构建<br>　　单向数据流：指数据的流向只能由父级组件通过props讲数据传递给子组件，不能由子组件向父组件传递数据<br>　　          要想实现数据的双向绑定只能由子组件接收父组件props传过来的方法去改变父组件数据，而不是直接将子组件数据传给父组件<br>　　生命周期：简单说一下生命周期：Mounting(挂载)、Updateing(更新)、Unmounting(卸载)</p>
<h1 id="四、浏览器相关"><a href="#四、浏览器相关" class="headerlink" title="四、浏览器相关"></a>四、浏览器相关</h1><h3 id="4-1）浏览器本地缓存"><a href="#4-1）浏览器本地缓存" class="headerlink" title="4.1）浏览器本地缓存"></a>4.1）浏览器本地缓存</h3><p>Web stroge 和cookie,<br>cookie其实是和服务器做交互的，主要是为服务器所用，web strong就是作为本地存储的。<br>Web strong主要有两种：localstroge和sessionstroge.<br>Localstroge：长期存在，同一域名共享。<br>Sessionstroge：只在会话存在，窗口关闭则不存在，窗口之间不可以共享。</p>
<p>Cookie的弊端：<br>Cookie数量和长度都是有限制的,每个域名最多只能有20条cookie，每个cookie长度不能超过4kb，否者会被截取。<br>Cookie会被拦截，然后获取session信息。</p>
<h2 id="1、getQueryString：从url中获取参数值。"><a href="#1、getQueryString：从url中获取参数值。" class="headerlink" title="1、getQueryString：从url中获取参数值。"></a><font color="#e12" size="3"><strong>1、getQueryString：从url中获取参数值。</strong></font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">export function getQueryString(name: string) &#123;</span><br><span class="line">  const reg = new RegExp(`([?&amp;])$&#123;name&#125;=([^&amp;]*?)(#|&amp;|$)`, &apos;i&apos;);</span><br><span class="line">  const r = window.location.href.match(reg);</span><br><span class="line">  if (r != null) &#123;</span><br><span class="line">    return decodeURIComponent(r[2]);</span><br><span class="line">  &#125;</span><br><span class="line">  return &apos;&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getQueryString(name) &#123;</span><br><span class="line">  var reg = new RegExp(&apos;(^|&amp;)&apos; + name + &apos;=([^&amp;]*)(&amp;|$)&apos;, &apos;i&apos;);</span><br><span class="line">  var r = window.location.search.substr(1).match(reg);</span><br><span class="line">  if (r != null) &#123;</span><br><span class="line">  return decodeURIComponent(r[2]);</span><br><span class="line">  &#125;</span><br><span class="line">  return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析：以上两种方式都是通过正则匹配的方式实现的。</p>
<ul>
<li><p><font color="#12e" size="3">知识点：</font></p>
<ul>
<li><p>正则<br>&amp;()         且的意思<br>(x1|x2|x3)  查找任何指定的选项<br>[]          查找该集合范围内的字符（或的意思）<br>[^xxx]      查找给定集合外的任何字符（非的意思）<br>n$          匹配任何结尾为n的字符串<br>n*          匹配任何包含零个或多个n的字符串<br>n?          匹配任何包含零个或一个n的字符串</p>
<p>i           代表不区分大小写</p>
<p>match       找到一个或多个正则表达式的匹配 例：str.match(reg)</p>
</li>
<li><p>BOM<br>window.location.href      设置或返回完整的URL<br>window.location.search    设置或返回从问好（?）开始的URL（查询部分）<br>（复习）：<br>pathname                  设置或返回当前URL的路径部分<br>reload()                  重新加载当前文档<br>replace()                 用新的文档替换当前文档  </p>
<p>URL：<a href="https://www.baidu.com/s?ie-utf-88&amp;f=3&amp;rsv_bp=1" target="_blank" rel="noopener">https://www.baidu.com/s?ie-utf-88&amp;f=3&amp;rsv_bp=1</a><br>资源定位符：协议名(https)  主机名(域名 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>  路径(/s)  参数名=参数值(ie-utf-88)</p>
</li>
<li><p>字符串方法<br>substr()     方法可在字符串中抽取从 start 下标开始的指定数目的字符。<br><strong><em>stringObject.substr(start,length)</em></strong></p>
<p>decodeURIComponent() 函数可对 encodeURIComponent() 函数编码的 URI 进行解码。<br><strong><em>decodeURIComponent(URIstring)</em></strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var test1=<span class="string">"http://www.w3school.com.cn/My first/"</span></span><br><span class="line"></span><br><span class="line">document.write(encodeURIComponent(test1)+ <span class="string">"&lt;br /&gt;"</span>)</span><br><span class="line">document.write(decodeURIComponent(test1))</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>2019年12月9日</p>
<h2 id="2、setCookie：设置Cookie。"><a href="#2、setCookie：设置Cookie。" class="headerlink" title="2、setCookie：设置Cookie。"></a><font color="#e12" size="3"><strong>2、setCookie：设置Cookie。</strong></font></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> setCookie(name: string, value: string): void &#123;</span><br><span class="line">  const now = new Date();</span><br><span class="line">  now.setDate(now.getDate() + (1000 * 60 * 60 * 24 * 30));</span><br><span class="line"></span><br><span class="line">  const str = `<span class="variable">$&#123;name&#125;</span>=<span class="variable">$&#123;value&#125;</span>;expires=<span class="variable">$&#123;now.toUTCString()&#125;</span>;path=/;SameSite=Lax;`;</span><br><span class="line">  document.cookie = str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2019年12月10日</p>
<h2 id="3、getCookie：获取Cookie。"><a href="#3、getCookie：获取Cookie。" class="headerlink" title="3、getCookie：获取Cookie。"></a><font color="#e12" size="3"><strong>3、getCookie：获取Cookie。</strong></font></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="keyword">function</span> getCookie(name: string) &#123;</span><br><span class="line">  <span class="built_in">let</span> start;</span><br><span class="line">  <span class="built_in">let</span> end;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (document.cookie.length &gt; 0) &#123;</span><br><span class="line">    start = document.cookie.indexOf(`<span class="variable">$&#123;name&#125;</span>=`);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (start !== -1) &#123;</span><br><span class="line">      start = start + name.length + 1;</span><br><span class="line">      end = document.cookie.indexOf(<span class="string">';'</span>, start);</span><br><span class="line">      <span class="keyword">if</span> (end === -1) &#123;</span><br><span class="line">        end = document.cookie.length;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">return</span> decodeURIComponent(document.cookie.substring(start, end));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> <span class="string">''</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/27/webpack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lemon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/background10.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="立夏">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/27/webpack/" itemprop="url">webpack</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-27T12:04:40+08:00">
                2019-10-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/1）前端-基础/" itemprop="url" rel="index">
                    <span itemprop="name">1）前端 - 基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://www.webpackjs.com/" target="_blank" rel="noopener">https://www.webpackjs.com/</a></p>
<h2 id="一、基础概念"><a href="#一、基础概念" class="headerlink" title="一、基础概念"></a><font color="red"><strong>一、基础概念</strong></font></h2><h3 id="1-1）-前端工程化"><a href="#1-1）-前端工程化" class="headerlink" title="1.1） 前端工程化"></a>1.1） 前端工程化</h3><p>  所谓工程化，可以简单认为是将框架的职责拓宽再拓宽，主旨是帮业务团队更好的完成需求，工程化会预测到一些常碰到的问题，将之扼杀在摇篮里，而这种路径是可重用的，是具有可持续性的，比如第一个优化去冗余，实在多次取去除冗余代码，思考冗余出现的原因，得出一个避免冗余的方案。</p>
<h3 id="1-2）自动化构建工具"><a href="#1-2）自动化构建工具" class="headerlink" title="1.2）自动化构建工具"></a>1.2）自动化构建工具</h3><p>  requireJS和grunt的出现，改变了业界前端代码的编写习惯，同时也成为推动前端工程化的一个基础。（requireJS回一个伟大的模块加速器，它的出现实现了js可以多人共同协作开发维护一个大型项目，grunt是一款js构建工具，主要完成编译、压缩、合并等一系列工作，后续有出现了yeoman、Gulp、Webpack等构建工具）</p>
<p>  webpack具有Grunt、Gulp对于静态资源自动化构建的能力，弥补了requireJS在模块化方面的缺陷，同时兼容AMD与CMD的模块加载规范，具有更强大的模块化功能。</p>
<h3 id="1-3）模式"><a href="#1-3）模式" class="headerlink" title="1.3）模式"></a>1.3）模式</h3><p>  开发模式：开发模式比较简单，主要就是监听文件变化，自动进行打包、合并的操作。<br>  生产模式：参考我们的技术栈与需求，哦们的静态文件都要发布到CDN中，而且必须有md5版本号，方便快速发布（CD更新极其缓慢，所以更新必须用新的文件名）。生产模式主要增加了文件压缩、文件md5名称更改、替换html等操作，这样的好处就是上线非常方便，一个命令就可以更新线上，而且不存在缓存问题。</p>
<h3 id="1-4）CDN"><a href="#1-4）CDN" class="headerlink" title="1.4）CDN"></a>1.4）CDN</h3><p>  CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要是内容存储和分发技术。<br>  CDN的基本原理是广泛应用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地方或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。<br>  CDN网络是在用户和服务器之间增加了cache层，如何将用户的请求引导到Cache服务器上获得源服务器的数据，主要是通过接管DNS实现，这是CDN的基本原理。</p>
<p>  1）用户在浏览器输入<a href="http://www.cdn.net这个域名，浏览器第一次发现本地没有DNS缓存，则向网络的DNS服务器请求；" target="_blank" rel="noopener">www.cdn.net这个域名，浏览器第一次发现本地没有DNS缓存，则向网络的DNS服务器请求；</a><br>  2）网站的DNS域名解析器设置了CNAME，指向了<a href="http://www.cdn.51cdn.net，请求指向了CDN网络中的智能DNS负载均衡系统；" target="_blank" rel="noopener">www.cdn.51cdn.net，请求指向了CDN网络中的智能DNS负载均衡系统；</a><br>  3）智能DNS负载均衡系统解析域名，把对用户响应速度最快的IP节点返回给用户；<br>  4）用户向该节点（CDN服务器）发送请求；<br>  5）由于是第一次访问，CDN服务器会向原WEB站点请求并缓存数据，<br>  6）请求结果发给用户。</p>
<h3 id="1-5）webpack-模块"><a href="#1-5）webpack-模块" class="headerlink" title="1.5）webpack 模块"></a>1.5）webpack 模块</h3><p>什么是 webpack 模块<br>对比 Node.js 模块，webpack 模块能够以各种方式表达它们的依赖关系，几个例子如下：<br>ES2015 import 语句<br>CommonJS require() 语句<br>AMD define 和 require 语句<br>css/sass/less 文件中的 @import 语句。<br>样式(url(…))或 HTML 文件(&lt; img src=…&gt;)中的图片链接(image url)<br>webpack 1 需要特定的 loader 来转换 ES 2015 import，然而通过 webpack 2 可以开箱即用。</p>
<h4 id="1-ES6-import"><a href="#1-ES6-import" class="headerlink" title="1) ES6 import"></a><strong>1) ES6 import</strong></h4><p>（<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import）" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import）</a><br>语法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import defaultExport from <span class="string">"module-name"</span>;</span><br><span class="line">import * as name from <span class="string">"module-name"</span>;</span><br><span class="line">import &#123; <span class="built_in">export</span> &#125; from <span class="string">"module-name"</span>;</span><br><span class="line">import &#123; <span class="built_in">export</span> as <span class="built_in">alias</span> &#125; from <span class="string">"module-name"</span>;</span><br><span class="line">import &#123; export1 , export2 &#125; from <span class="string">"module-name"</span>;</span><br><span class="line">import &#123; foo , bar &#125; from <span class="string">"module-name/path/to/specific/un-exported/file"</span>;</span><br><span class="line">import &#123; export1 , export2 as alias2 , [...] &#125; from <span class="string">"module-name"</span>;</span><br><span class="line">import defaultExport, &#123; <span class="built_in">export</span> [ , [...] ] &#125; from <span class="string">"module-name"</span>;</span><br><span class="line">import defaultExport, * as name from <span class="string">"module-name"</span>;</span><br><span class="line">import <span class="string">"module-name"</span>;</span><br><span class="line">var promise = import(<span class="string">"module-name"</span>);//这是一个处于第三阶段的提案。</span><br></pre></td></tr></table></figure></p>
<p>defaultExport<br>导入模块的默认导出接口的引用名。</p>
<p>module-name<br>要导入的模块。通常是包含目标模块的.js文件的相对或绝对路径名，可以不包括.js扩展名。某些特定的打包工具可能允许或需要使用扩展或依赖文件，它会检查比对你的运行环境。只允许单引号和双引号的字符串。</p>
<p>name<br>导入模块对象整体的别名，在引用导入模块时，它将作为一个命名空间来使用。</p>
<p>export, exportN<br>被导入模块的导出接口的名称。</p>
<p>alias, aliasN<br>将引用指定的导入的名称。</p>
<h4 id="2-CommonJS-require"><a href="#2-CommonJS-require" class="headerlink" title="2) CommonJS :require"></a><strong>2) CommonJS :require</strong></h4><p>CommonJS：采用同步的require方法来加载依赖并返回导出的接口。一个模块可以通过往exports对象上添加属性或者设置module.exports的值来确定导出哪些接口。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">require(<span class="string">"module"</span>);</span><br><span class="line">require(<span class="string">"../file.js"</span>);</span><br><span class="line">exports.doStuff = <span class="function"><span class="title">function</span></span>()&#123;&#125;;</span><br><span class="line">module.exports = someValue;</span><br></pre></td></tr></table></figure></p>
<p>优点：<br>服务端的模块可以被复用<br>已经有很多模块供使用了（npm）<br>很容易上手使用</p>
<p>缺点：<br>阻塞式的调用不能适用于网络请求，因为网络请求是异步的<br>无法同步require多个模块</p>
<h4 id="3-AMD-异步require"><a href="#3-AMD-异步require" class="headerlink" title="3) AMD:异步require"></a><strong>3) AMD:异步require</strong></h4><p>之前提到的模块系统只能同步require，而AMD则采用异步的实现形式。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">require([<span class="string">"module"</span>,<span class="string">"../file.js"</span>],<span class="keyword">function</span>(module,file)&#123;/*...*/&#125;);</span><br><span class="line">define(<span class="string">"mymodule"</span>,[<span class="string">"dep1"</span>,<span class="string">"dep2"</span>],<span class="keyword">function</span>(d1,d2)&#123;</span><br><span class="line">    <span class="built_in">return</span> someExportValue;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>优点：<br>能满足网络请求的异步需求<br>能同步加载多个模块</p>
<p>缺点：<br>代码复杂，更难写也更难读<br>似乎是一种绕路的笨办法</p>
<font color="red" size="2">任何静态资源都可以视作模块，然后模块之间也可以相互依赖，<br>通过webpack对模块进行处理后，可以打包成我们想要的静态资源。<br></font>

<h2 id="二、初识-webpack"><a href="#二、初识-webpack" class="headerlink" title="二、初识 webpack"></a>二、初识 webpack</h2><p>1、全局安装webpack<br>npm install webpack webpack-cli -g</p>
<p>2、初始化文件<br>npm init 或直接自己新建&amp;编写package.json</p>
<p>3、编写配置文件<br>entry： 是 页面入口文件配置 （html文件引入唯一的js 文件）<br>output：对应输出项配置（path ：入口文件最终要输出到哪里，    filename：输出文件的名称<br>publicPath：公共资源路径</p>
<p>4、打包<br>webpack -w  （实时监听）<br>webpack     （非）</p>
<p>webpack –progress –colors  –watch</p>
<h2 id="三、loader-加载器"><a href="#三、loader-加载器" class="headerlink" title="三、loader 加载器"></a>三、loader 加载器</h2><p>js：babel-loader 、 babel 、 babel-core<br>ts/tsx：awesome-typescript-loader<br>less：less-loader、css-loader、style-loader<br>css：css-loader、style-loader<br>eot|otf|ttf|woff|woff2：file-loader<br>xlsx|xls|csv|pdf：file-loader<br>jpg|jpeg|png|gif|svg：url-loade</p>
<p><strong>图片打包</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="built_in">test</span>:/\.(jpg|jpeg|png|gif|svg)$/,use:[<span class="string">'url-loader?limit=8192&amp;name=/[name].[ext]'</span>]&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="built_in">test</span>: /\.(jpg|jpeg|png|gif|svg)$/,</span><br><span class="line">  use: [</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">'url-loader'</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        // Inline files smaller than 10 kB</span><br><span class="line">        <span class="built_in">limit</span>: 10 * 1024,</span><br><span class="line">        name: <span class="string">'static/[name].[ext]'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>limit: 8192  如果图片小于8k，则直接转换成base64的格式。否则会打包成独立的图片文件。</p>
<h2 id="四、打包多个文件"><a href="#四、打包多个文件" class="headerlink" title="四、打包多个文件"></a>四、打包多个文件</h2><p>webpack 不仅仅适用于SPA开发 ，对于多页面 站点，webpack 支持得很好 ，通过更改配置文件为多入口<br>output 设置里面 [name] 代表 entry 的每一个键值 ，因此运行webpack 时候 会输出对应多个文件<br>dist/index1.js   dist/index2.js  在index1.html 和index2.html 两个页面 分别引用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;index1:<span class="string">'./src/js/entry1.js'</span>,index2:<span class="string">'./src/js/entry2.js'</span>&#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename:<span class="string">'[name].js'</span></span><br><span class="line">    path: __dirname+<span class="string">'/dist'</span>,</span><br><span class="line">    publicPath:__dirname+<span class="string">'/dist'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules:[</span><br><span class="line">      &#123;<span class="built_in">test</span>: /\.js$/,loader:<span class="string">"babel-loader"</span>&#125;,</span><br><span class="line">      &#123;<span class="built_in">test</span>: /\.css$/,use:[<span class="string">"css-loader"</span>,<span class="string">"style-loader"</span>]&#125;,</span><br><span class="line">      &#123;<span class="built_in">test</span>:/\.less$/,use:[<span class="string">"css-loader"</span>,<span class="string">"style-loader"</span>,<span class="string">"less-style"</span>]&#125;</span><br><span class="line">      &#123;<span class="built_in">test</span>:/\.(jpg|jpeg|png|gif|svg)$/,use:[<span class="string">'url-loader?limit=8192&amp;name=/[name].[ext]'</span>]&#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><font color="red"><strong>resolve：</strong></font><br>    root ：’’ //查找模块的话从这里开始查找 默认是从node_modules 文件夹开始找<br>    extensions：[] //自动扩展文件后缀名，因为这我们 require 模块可以省略不写后缀名称<br>    alias： {}  // 模块别名定义 方便后续直接引用别名，无须多写长长的地址</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">const config = &#123;</span><br><span class="line">  entry: ...</span><br><span class="line">  output: &#123;...&#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    <span class="built_in">alias</span>: &#123;</span><br><span class="line">      <span class="string">'common-pass'</span>: path.resolve(process.cwd(), <span class="string">'common-pass'</span>),</span><br><span class="line">      <span class="string">'common-base'</span>: path.resolve(process.cwd(), <span class="string">'common-base'</span>),</span><br><span class="line">      <span class="string">'common-system-manage'</span>: path.resolve(process.cwd(), <span class="string">'common-system-manage'</span>),</span><br><span class="line">      <span class="string">'common-user-manage'</span>: path.resolve(process.cwd(), <span class="string">'common-user-manage'</span>),</span><br><span class="line">      <span class="string">'common-ros'</span>: path.resolve(process.cwd(), <span class="string">'common-ros'</span>),</span><br><span class="line">      components: path.resolve(process.cwd(), <span class="string">'src'</span>, <span class="string">'components'</span>),</span><br><span class="line">      containers: path.resolve(process.cwd(), <span class="string">'src'</span>, <span class="string">'containers'</span>),</span><br><span class="line">      utils: path.resolve(process.cwd(), <span class="string">'src'</span>, <span class="string">'utils'</span>),</span><br><span class="line">      config: path.resolve(process.cwd(), <span class="string">'config'</span>),</span><br><span class="line">      moment$: <span class="string">'moment/moment.js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    modules: [<span class="string">'node_modules'</span>, <span class="string">'app'</span>],</span><br><span class="line">    extensions: [<span class="string">'.js'</span>, <span class="string">'.jsx'</span>, <span class="string">'.react.js'</span>, <span class="string">'.ts'</span>, <span class="string">'.tsx'</span>, <span class="string">'.json'</span>],</span><br><span class="line">    mainFields: [<span class="string">'browser'</span>, <span class="string">'jsnext:main'</span>, <span class="string">'main'</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [...],</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [...],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = merge(config, specialConfig);</span><br></pre></td></tr></table></figure>
<h2 id="五、插件"><a href="#五、插件" class="headerlink" title="五、插件"></a>五、插件</h2><p>1、代码压缩插件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var uglifyPlugin = new webpack.optimize.UglifyJsPlugin(&#123;minimize: <span class="literal">true</span>&#125;);</span><br><span class="line">plugins: [ uglifyPlugin ]</span><br></pre></td></tr></table></figure></p>
<p>2、公共模块插件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var CommonsChunkPlugin = new webpack.optimize.CommonsChunkPlugin(<span class="string">'common'</span>);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  plugins: [ CommonsChunkPlugin ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要在html页面上手动添加提取出的公共模块</p>
<p>3、css独立打包<br>如果我们希望样式通过 link标签 引入，而不是放在 style 标签内呢，即使这样做会多一个请求。这个时候我们就要配合插件一起使用啦，我们一起来看看。<br>$ npm install extract-text-webpack-plugin –save-dev<br>(–save-dev  —&gt; package.json)</p>
<p>安装完插件就要配置 webpack.config.js 了。我们添加以下代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var ExtractTextPlugin = require(<span class="string">"extract-text-webpack-plugin"</span>);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: ···,</span><br><span class="line">  output: &#123;···&#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules:[</span><br><span class="line">      ···</span><br><span class="line">      &#123;<span class="built_in">test</span>: /.css$/, use: ExtractTextPlugin.extract(&#123;fallback: <span class="string">'style-loader'</span>,use: <span class="string">'css-loader'</span>&#125;)&#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [ new ExtractTextPlugin(<span class="string">"[name].css"</span>) ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要在html页面上手动添加独立打包出来的css:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> <span class="built_in">type</span>=<span class="string">""</span> href=<span class="string">"./out/index.css"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<p>在ExtractTextPlugin的extract方法有两个参数，第一个参数是经过编译后通过style-loader单独提取出文件来，而第二个参数就是用来编译代码的loader。<br>当然，插件也支持所有独立样式打包成一个css文件。增加多一个参数即可。<br>new ExtractTextPlugin(‘style.css’,{allChunks:true});</p>
<p>至于你是打包成一个文件还是怎样 根据实际情况来定！</p>
<p><strong>4、挂载全局库</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var providePlugin = new webpack.ProvidePlugin(&#123;$: <span class="string">'jquery'</span>, jQuery: <span class="string">'jquery'</span>, <span class="string">'window.jQuery'</span>: <span class="string">'jquery'</span>&#125;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  plugins: [ providePlugin ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>5、还有很多插件 比如 ：autoprefixer<br>我们在书写css时 按规范 ，构建 时 利用 autoprefixer 可以输出 -webkit -moz 这样浏览器的前缀<br>npm install autoprefixer-loader –save-dev</p>
<hr>
<h2 id="六、webpack服务器"><a href="#六、webpack服务器" class="headerlink" title="六、webpack服务器"></a>六、webpack服务器</h2><p>webpack-dev-server 全局&amp;本地安装</p>
<p>package.json<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"webpack-dev-server  --devtool eval-source-map --progress --colors"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>npm run start</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/20/Hexo博客搭建全记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lemon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/background10.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="立夏">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/20/Hexo博客搭建全记录/" itemprop="url">Hexo博客搭建全记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-20T23:27:31+08:00">
                2019-09-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/3）前端-周边/" itemprop="url" rel="index">
                    <span itemprop="name">3）前端 - 周边</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1、重拾博客"><a href="#1、重拾博客" class="headerlink" title="1、重拾博客"></a>1、重拾博客</h1><ul>
<li>2019年9月20日<br>时隔半年，再次拾起博客，物是人非，要把博客重新在各种新装备中重新搭建起来，好在之前在硬盘中存了数据，直接本地电脑连接github即可。<blockquote>
<p>1）git –config user.name ‘xxx’<br>2) git –config user.email ‘xxx’<br>3) ssh-keygen -t rsa -C  <a href="mailto:&#39;xxx@qq.com" target="_blank" rel="noopener">&#39;xxx@qq.com</a>‘<br>4) 之后在github中建立新的SSH key<br>5）ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a><br>在第五步的时候需要到了一个问题：ssh: connect to host github.com port 22: Connection timed out。所以在.ssh文件加下，新建了config文件用于修改端口号，文件内容如下：</p>
<ul>
<li>Host github.com<br>User <a href="mailto:2544531706@163.com" target="_blank" rel="noopener">2544531706@163.com</a><br>Hostname ssh.github.com<br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/id_rsa<br>Port 443</li>
</ul>
</blockquote>
</li>
</ul>
<p><br></p>
<h1 id="2、配置about"><a href="#2、配置about" class="headerlink" title="2、配置about"></a>2、配置about</h1><ul>
<li><p>2019年12月19日<br>本意：想给hexo配置about。</p>
<blockquote>
<p>解决：</p>
<ul>
<li>第一种方式<br>1、使用hexo-admin插件，方便后台登录管理hexo博客，编写文章。<br>  npm install –save hexo-admin  （ 插件地址：<a href="https://github.com/jaredly/hexo-admin）" target="_blank" rel="noopener">https://github.com/jaredly/hexo-admin）</a><br>  hexo s<br>  localhost:4000/admin<br>2、配置admin<br>  添加用户名与密码  settings  -&gt;  Setup authentification here</li>
</ul>
</blockquote>
<p>  3、之后设置用户名和密码</p>
<pre><code>hexo s
localhost:4000/admin（受到密码保护）
</code></pre><ul>
<li>第二种方式<br>在source目录下，直接新建about文件夹，新建index.md,<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: about</span><br><span class="line"><span class="built_in">type</span>: about</span><br><span class="line">date: 2019-03-08 16:40:49</span><br><span class="line">---</span><br><span class="line">直接在这里编辑文字吧~</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/19/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lemon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/background10.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="立夏">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/19/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-19T20:43:20+08:00">
                2019-09-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/15/vue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lemon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/background10.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="立夏">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/15/vue/" itemprop="url">vue</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-15T18:12:12+08:00">
                2019-05-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/2）前端-框架/" itemprop="url" rel="index">
                    <span itemprop="name">2）前端 - 框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><style>.jc{font-weight:800;}.jc span{margin-left:30px;}h1{margin-top:40px;margin-bottom:20px;}h2{padding:0 !important;}</style></p>
<p></p><h1 id="vue简介"><a href="#vue简介" class="headerlink" title="vue简介"></a><font color="SteelBlue">vue简介</font></h1><p></p>
<div style="text-indent:2em;">Vue (读音 /vjuː/) 是一套用于构建用户界面的<font color="red">渐进式框架</font> 。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</div><br><div style="font-size:10px;">官网 ( <a href="https://cn.vuejs.org/" target="_blank" rel="noopener">https://cn.vuejs.org/</a> 、<a href="https://vuex.vuejs.org、https://router.vuejs.org/" target="_blank" rel="noopener">https://vuex.vuejs.org、https://router.vuejs.org/</a>) 看一下文档，边搭建项目实践边学习。<br>论坛推荐：hacknews、stackoverflow、medium.com、javascript weekly、掘金等</div>

<p></p><h1 id="vue概述"><a href="#vue概述" class="headerlink" title="vue概述"></a><font color="SteelBlue">vue概述</font></h1><p></p>
<div class="jc"><span>vue</span><span>vue-router</span><span>vuex</span><span>vue-cli</span><span>vue-devtools</span><span>awesome</span><br></div><br><h2 id="渐进式框架"><a href="#渐进式框架" class="headerlink" title="渐进式框架"></a><font color="CadetBlue">渐进式框架</font></h2><img src="data:image/png;base64,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" alt="渐进式"><br><img src="data:image/png;base64,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" alt="应用复杂度VS框架复杂度"><br><br><h2 id="vue中的两个核心点"><a href="#vue中的两个核心点" class="headerlink" title="vue中的两个核心点"></a><font color="CadetBlue">vue中的两个核心点</font></h2><strong>响应的数据绑定</strong>：数据发生改变，自动更新视图。利用Object.defineProperty中的getter/setter代理数<br><strong>视图组件：</strong> ui页面映射组件树，组件可重组，可维护。据。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">Object.defineProperty(obj,<span class="string">"key"</span>,&#123;</span><br><span class="line">    vale:10,</span><br><span class="line">    writable:<span class="literal">true</span>,</span><br><span class="line">    configurable:<span class="literal">true</span>,</span><br><span class="line">    enumerable:<span class="literal">true</span>,</span><br><span class="line">    <span class="function"><span class="title">get</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> 100;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span></span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br><br><h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a><font color="CadetBlue">虚拟DOM</font></h2>提供一种方便的工具，使得开发效率得到保证。<br>保证最小化的DOM操作，使得执行效率得到保证。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"message"</span>&gt;        render(h)&#123;</span><br><span class="line">  Hello world!                  <span class="built_in">return</span> h(</span><br><span class="line">&lt;/div&gt;                             <span class="string">'div'</span>,</span><br><span class="line">                                    &#123;class:<span class="string">'message'</span>&#125;,</span><br><span class="line">                                    [<span class="string">'hello World!'</span>]</span><br><span class="line">                                )</span><br><span class="line">                             &#125;</span><br></pre></td></tr></table></figure><br><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"demo1"</span>&gt;</span><br><span class="line">    &lt;p class=<span class="string">"demo2"</span>&gt;hello&lt;/p&gt;</span><br><span class="line">    <span class="string">"world"</span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">function</span> vElement(tagName,prop,children)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(this instanceof vElement))&#123;</span><br><span class="line">            <span class="built_in">return</span> new vElement(tagName,prop,children);</span><br><span class="line">        &#125;</span><br><span class="line">        this.tagName = tagName;</span><br><span class="line">        this.prop = prop;</span><br><span class="line">        this.children = children;</span><br><span class="line">        var count = 0;</span><br><span class="line">        this.children.forEach(<span class="keyword">function</span>(child)&#123;</span><br><span class="line">            <span class="keyword">if</span>(child instanceof vElement)&#123;</span><br><span class="line">                count += child.count</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;)</span><br><span class="line">        this.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">    vElement.prototype.render = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        var tagName = this.tagName;</span><br><span class="line">        var prop = this.prop;</span><br><span class="line">        var children = this.children;</span><br><span class="line">        var element = document.createElement(tagName);</span><br><span class="line">        <span class="keyword">for</span>(var curProp <span class="keyword">in</span>  prop)&#123;</span><br><span class="line">            element.setAttribute(curProp,prop[curProp])</span><br><span class="line">        &#125;</span><br><span class="line">        children.forEach(<span class="keyword">function</span>(child)&#123;</span><br><span class="line">            <span class="keyword">if</span>(child instanceof vElement)&#123;</span><br><span class="line">                var childDom = child.render();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                var childDom = document.createTextNode(child);</span><br><span class="line">            &#125;</span><br><span class="line">            element.appendChild(childDom);</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">    var dom = vElement(<span class="string">"div"</span>,&#123;class:<span class="string">"demo1"</span>&#125;,[vElement(<span class="string">"p"</span>,&#123;class:<span class="string">"demo2"</span>&#125;,[<span class="string">"hello"</span>]),<span class="string">"world"</span>]);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><br><br><h2 id="MVVM模式"><a href="#MVVM模式" class="headerlink" title="MVVM模式"></a><font color="CadetBlue">MVVM模式</font></h2><strong>M</strong> ：model 数据模型<br><strong>V</strong> : view视图模型<br><strong>VM</strong>：view-model视图模型<br><br><br><h2 id="vue实例"><a href="#vue实例" class="headerlink" title="vue实例"></a><font color="CadetBlue">vue实例</font></h2><strong>构造器</strong> 在实例化vue时，需要传入一个选项对象，它可以包含数据、模板、挂载元素、方法、生命周期钩子等<br><strong>vue的属性和方法</strong> 每个vue实例都会代理其data对象里的所有的属性。<br>简单项目我们可以只使用vue，通过script标签引入sdn服务器上的vue.js，或者下载到本地进行引入使用，分为开发版本和生产版本两种。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.我们new一个vue对象，在其中配置选项。</span></span><br><span class="line">    new Vue(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.必填项：挂载元素</span></span><br><span class="line">    &lt;div id=<span class="string">"app1"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        new Vue(&#123;</span><br><span class="line">            el:<span class="string">"#app1"</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.第二项：数据</span></span><br><span class="line">    &lt;div id=<span class="string">"app1"</span>&gt;&lt;/div&gt;<span class="comment">#声明式渲染</span></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        new Vue(&#123;</span><br><span class="line">            el:<span class="string">"#app1"</span>,</span><br><span class="line">            data:&#123;</span><br><span class="line">                message:<span class="string">"Hello World!"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure><br><br><h2 id="声明渲染"><a href="#声明渲染" class="headerlink" title="声明渲染"></a><font color="CadetBlue">声明渲染</font></h2><strong>命令式编程</strong>：命令“机器”去做事情（how），不管你想要的是什么（what），它都会按照你的命令实现。<br><strong>声明式编程</strong>：告诉“机器”你想要的是什么（what），让机器想出如何去做（how）。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#举个栗子</span></span><br><span class="line">var arr = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">#命令式编程</span></span><br><span class="line"><span class="keyword">for</span>(var i = 0 ; i &lt; 10 ; i++)&#123;</span><br><span class="line">    console.log(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#声明式编程</span></span><br><span class="line">arr.forEach(<span class="keyword">function</span>(e,i)&#123;</span><br><span class="line">    console.log(e);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br><br><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a><font color="CadetBlue">指令</font></h2><strong>指令（Directives）</strong>是带有 v- 前缀的特殊属性。指令属性的值预期是单一javascript表达式。<br><style>.zl br{display:none;} .zl .zl_one,.zl .zl_two{display:inline-block;vertical-align: top;margin-left:150px;font-weight:900;}</style><br><div class="zl"><br>    <div class="zl_one"><br>        <div>v-text</div><br>        <div>v-show</div><br>        <div>v-else</div><br>        <div>v-for</div><br>        <div>v-bind</div><br>        <div>v-pre</div><br>        <div>v-once</div><br>    </div><br>    <div class="zl_two"><br>        <div>v-html</div><br>        <div>v-if</div><br>        <div>v-else-if</div><br>        <div>v-on</div><br>        <div>v-model</div><br>        <div>v-cloak</div><br>    </div><br></div><br>v-show : DOM节点是否显示<br>v-if : DOM节点是否存在<br>v-on  ： 可缩写成：<br>v-bind:绑定属性(单项数据流)。如：v-bind:id=”id+1231”  表达式。可缩写成@<br>v-model:双向数据流，页面渲染和data相互改变。单项数据流是data映射页面数据，但是页面数据改变不映射data数据。双向数据流的实现原理是将页面数据赋给data数据<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;div v-bind:id=<span class="string">"id+111"</span>&gt;v-bind:id&lt;/div&gt;</span><br><span class="line">    &lt;div v-if = <span class="string">"flag"</span>&gt;v-if&lt;/div&gt;</span><br><span class="line">    &lt;div v-show = <span class="string">"flag"</span>&gt;v-show&lt;/div&gt;</span><br><span class="line">    &lt;div v-if = <span class="string">"ifElse == 1"</span>&gt;v-if1&lt;/div&gt;</span><br><span class="line">    &lt;div v-else-if = <span class="string">"ifElse == 2"</span>&gt;v-else-if2&lt;/div&gt;</span><br><span class="line">    &lt;div v-else = <span class="string">"ifElse == 3"</span>&gt;v-else3&lt;/div&gt;</span><br><span class="line">    &lt;div v-for=<span class="string">"(item,index) in arr"</span> :key=<span class="string">"index"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div v-for=<span class="string">"(value,attr,index) in obj"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div <span class="built_in">type</span>=<span class="string">"text"</span> v-on:click=<span class="string">"clickHandle"</span>&gt;v-on绑定事件&lt;/div&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> v-on:keyup=<span class="string">"keyupHandle"</span>&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> v-on:keyup.enter=<span class="string">"keyupEnterHandle"</span>&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> :value = <span class="string">"value"</span>&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> v-model:value = <span class="string">"model"</span>&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"text"</span>  :value = <span class="string">"rule"</span> @keyup=<span class="string">"ruleTrue"</span>&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"checkbox"</span> v-model=<span class="string">"checked"</span>&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el:<span class="string">"#app"</span>,</span><br><span class="line">        data:&#123;</span><br><span class="line">            message:<span class="string">"Hello World!"</span>,</span><br><span class="line">            id:<span class="string">"demo"</span>,</span><br><span class="line">            flag:<span class="literal">false</span>,</span><br><span class="line">            ifElse:1,</span><br><span class="line">            arr:[<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"e"</span>],</span><br><span class="line">            obj:&#123;</span><br><span class="line">                name:<span class="string">"jyy"</span>,</span><br><span class="line">                age:18</span><br><span class="line">            &#125;,</span><br><span class="line">            value:10,</span><br><span class="line">            model:111,</span><br><span class="line">            rule:<span class="string">"model双向数据绑定的原理是model事件"</span>,</span><br><span class="line">            checked:<span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            clickHandle:<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">                console.log(<span class="string">"v-on绑定事件"</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">            keyupHandle:<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">                console.log(<span class="string">"v-on绑定keyup事件"</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">            keyupEnterHandle:<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">                console.log(<span class="string">"v-on绑定keyup的enter事件-详见事件修饰符"</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">            ruleTrue:<span class="keyword">function</span>(e)&#123;</span><br><span class="line">                this.rule = e.target.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><br><br><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a><font color="CadetBlue">模板</font></h2><br><strong>html模板</strong>  支持双大括号和指令，不支持html语法<br><strong>字符串模板</strong>  例如：<br><div style="margin-left:50px;"><br>1.template：支持html，支持双大括号，会覆盖<br><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el:<span class="string">"#app2"</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        message:<span class="string">"Hello World!"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    template:`&lt;div&gt;Hello World!&lt;/div&gt;`</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br><br><font color="red"><strong> ` `支持换行</strong></font><br><br>2. template：&lt; script type=”text/xTemplate” id=”item”&gt;······&lt;/ script &gt;<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/xTemplate"</span> id=<span class="string">"item"</span>&gt;&lt;div&gt;模板&lt;/div&gt;&lt;/script &gt;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el:<span class="string">"#app2"</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        message:<span class="string">"Hello World!"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    template:<span class="comment">#item</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br><br></div>

<p><strong>render函数</strong><br><img src="data:image/png;base64,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" alt="render"><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var vm= new Vue(&#123;</span><br><span class="line">        el:<span class="string">"#app3"</span>,</span><br><span class="line">        data:&#123;&#125;,</span><br><span class="line">        render:<span class="keyword">function</span>(createElement)&#123;</span><br><span class="line">            <span class="built_in">return</span> createElement(<span class="string">"div"</span>,[createElement(<span class="string">"p"</span>,[<span class="string">"hello"</span>]),<span class="string">"world"</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<script src="https://vuejs.org/js/vue.min.js"></script>
<div id="app3"></div>
<script>
    var vm= new Vue({
        el:"#app3",
        data:{},
        render:function(createElement){
            return createElement("div",[createElement("p",["hello"]),"world"])
        }
    })
    // console.log(vm)
</script>

<p><strong>createElement 参数</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">#与 `v-bind:class` 的 API 相同，接受一个字符串、对象或字符串和对象组成的数组</span></span><br><span class="line">  <span class="string">'class'</span>: &#123;</span><br><span class="line">    foo: this.foo,</span><br><span class="line">    bar: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">#与 `v-bind:style` 的 API 相同， 接受一个字符串、对象，或对象组成的数组</span></span><br><span class="line">  style: &#123;</span><br><span class="line">    color: <span class="string">'red'</span>,</span><br><span class="line">    fontSize: <span class="string">'14px'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">#普通的 HTML 特性</span></span><br><span class="line">  attrs: &#123;</span><br><span class="line">    id: <span class="string">'foo'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">#组件 prop</span></span><br><span class="line">  props: &#123;</span><br><span class="line">    myProp: <span class="string">'bar'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">#DOM 属性</span></span><br><span class="line">  domProps: &#123;</span><br><span class="line">    innerHTML: <span class="string">'baz'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">#事件监听器在 `on` 属性内， 但不再支持如 `v-on:keyup.enter` 这样的修饰器。需要在处理函数中手动检查 keyCode。</span></span><br><span class="line">  on: &#123;</span><br><span class="line">    click: this.clickHandler</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">#仅用于组件，用于监听原生事件，而不是组件内部使用 `vm.$emit` 触发的事件。</span></span><br><span class="line">  nativeOn: &#123;</span><br><span class="line">    click: this.nativeClickHandler</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">#自定义指令。注意，你无法对 `binding` 中的 `oldValue`  赋值，因为 Vue 已经自动为你进行了同步。</span></span><br><span class="line">  directives: [</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">'my-custom-directive'</span>,</span><br><span class="line">      value: <span class="string">'2'</span>,</span><br><span class="line">      expression: <span class="string">'1 + 1'</span>,</span><br><span class="line">      arg: <span class="string">'foo'</span>,</span><br><span class="line">      modifiers: &#123;</span><br><span class="line">        bar: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">#作用域插槽的格式为 &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125;</span></span><br><span class="line">  scopedSlots: &#123;</span><br><span class="line">    default: props =&gt; createElement(<span class="string">'span'</span>, props.text)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">#如果组件是其它组件的子组件，需为插槽指定名称</span></span><br><span class="line">  slot: <span class="string">'name-of-slot'</span>,</span><br><span class="line">  <span class="comment">#其它特殊顶层属性</span></span><br><span class="line">  key: <span class="string">'myKey'</span>,</span><br><span class="line">  ref: <span class="string">'myRef'</span>,</span><br><span class="line">  <span class="comment">#如果你在渲染函数中给多个元素都应用了相同的 ref 名， 那么 `$refs.myRef` 会变成一个数组。</span></span><br><span class="line">  refInFor: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>render中的if、else、for、map等</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var vm= new Vue(&#123;</span><br><span class="line">        el:<span class="string">"#app4"</span>,</span><br><span class="line">        data:&#123;flag:<span class="literal">false</span>&#125;,</span><br><span class="line">        <span class="keyword">if</span>(this.flag)&#123;</span><br><span class="line">            <span class="built_in">return</span> createElement(<span class="string">"div"</span>,[createElement(<span class="string">"p"</span>,[<span class="string">"hello"</span>]),<span class="string">"world"</span>]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">return</span> createElement(<span class="string">"div"</span>,[createElement(<span class="string">"p"</span>,[<span class="string">"hello"</span>])])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p></p><h1 id="vue实例-todoList"><a href="#vue实例-todoList" class="headerlink" title="vue实例-todoList"></a><font color="SteelBlue">vue实例-todoList</font></h1><br>markdown不支持双大括号写法，所以双大括号的内容无法展现。但是实质上的逻辑都是没问题的。<p></p>
<p><style>.todo {width: 90%;height: auto;margin-left: 15px;border: 1px solid rgb(87, 183, 121);border-radius: 10px;padding: 20px;}.todo br {display: none;}.titleTag {text-align: center;margin-top: 20px;display: inline-block;width: 20%;height: 30px;border-radius: 10px;background-color: rgb(87, 183, 121);color: #fff;}.titleTag input {width: 40px;height: 28px;border: none;background-color: rgb(87, 183, 121);border-radius: 10px;color: #fff;text-align: center;}input {outline: none;}.ymcontent {display: inline-block;width: 78%;height: 28px;}.ymcontent input {width: 90%;height: 28px;border: 1px solid rgb(87, 183, 121);border-radius: 10px;}.clear {margin-left: 10px;display: inline-block;width: 18px;height: 18px;background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAYAAABWzo5XAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAOQSURBVDhPRVNviFRVFP/d+96b93Z2ZvbPbNPmVrAKQeiaVpiRWH4QCsu0CMsPEVaoBCpIRVSwgn0IQkpkQSIL6ksUhEGlQRTWp1AKzexDsEi17u60s+7O25nZ9+/2O/dNdYY37757zv2d8zvnd5WhoWvvnzuMybnz6C/W8NCag7h9ZFPXk9uVa9/h299PoJ02sGroXuxY80bXA1igKF7GkxMlFPwAlXKANM0w12zg6Y1H8dhdr9rAz346gk8ujWN4sIogcBG22nb/7W1z0I5LoMyY7cd8lItlDFR9aA24rkYcZ5iqT2HPfccYnuKjCy9i9OYRFHs1DzLG06jPLiFKlvHOI4twhu6ZHZ/8+zKq1R5WIiwVhK3rKvQGZfw4+SV+nT6HkVoNhSCjD8h7YVDp8xE2IzSjaTgrH9DjMUI4UopShLExFsxj1oIbsAofhYIkkJjcrxkrH0obdDoJtOcWSSNGliqkiUISkwh7lCaw9FwCuK7smW5MninlWiyJFQpOEXr7nfsw27iOKEoZlDGYhxJtwUzGdyKHgCyTx9iqxM/uotM2mJmbwebRvdBb1u7CtvXPYLpeJzqBeECyZZljgQUoI6iA5GBMwN9yW+Hq1DVsWbUP60Z25OOXEk98cRBfXTyFvkoRBfbG8RxOJ4PjSOMdOC7XHIBM1BBwvrmIrbc9j113v2UpssbcBko3sZKU2TWoiP+qk7XQlP6wKK6733T2F2/pnu4CvXvmdUycfQWlngoHx4ayJ4ZpMzZfgKVmATEEsdP0NQYqffjw/CGcvnjUAqnvL502hz54FCuqNY5bkQ6pOKTiJZaSdkjH4/QsPRFrLkaJlcr+qP+F17Z+A6d3rD6+FDV4mBHURVdOVieKk1GUsdayz03uSSK7phV8B652Mb/0J3SzvcCaHTsZXhc+MjF5C2vRDXtCikJJEhjRksiB10b65LH5YbQAvXJ4DHJpjRGAfPTSExmxiK3ZCrHYDLnO+2NHLP9MJHFhGOHWvjugWp3QbH65hMH+AaK7VLJmuaTmGsy363hqw0tI1TI+//k4VtRuhB8YKwOP8gjDDtrxAt7b3cp11FiYwYNHhlEuFdHj+1Dsw2LrOh7fsB8HHp6wNRw/8yy+vnIKw9Ub7B3sxHLz2zi5exalYPB/QUZxB29+uhdXG7/QUcbOjS/g/tVPWJB/7YffPsbZyycRo4XRoTE8t2mCgvXoAf4BgNXKTxCeOB0AAAAASUVORK5CYII=) no-repeat;vertical-align: -3px;}.titleTag .monthL {width: 16px;padding: 0;}.weekN {display: inline-block;}.week {text-align: center;}.week .titleTag {width: 96%;margin-right: 38px;}.week .date {width: 163px;height: 28px;display: inline-block;text-align: right;}.post-block .weekUl {margin-top: 10px;padding: 0;width: 100%;height: 280px;}.todo .week .weekUl li {list-style: none;height: 35px;width: 100%;text-align: left;}.todo .week .weekUl li span {text-align: center;color: rgb(87, 183, 121);display: inline-block;width: 20%;}.todo .week .weekUl li input {width: 70%;height: 28px;border: 1px solid rgb(87, 183, 121);border-radius: 10px;}.w100 {width: 96%;margin-right: 38px;margin-top: 20px;}.l30 {width: 30%;text-decoration: none;}.lr20 {margin: 0 14px;}.noteList {width: 70%;position: relative;top: -44px;left: 15%;}.todo .notes .noteList li {position: relative;list-style: none;border-bottom: 1px solid rgba(87, 183, 121, 0.5);width: 98%;height:40px;line-height: 40px;margin-left: 80px;padding-bottom: 5px;}.todo .noteLi .destory {display: none;position: absolute;right: -11px;bottom: -18px;width: 40px;height: 40px;margin: auto 0;font-size: 30px;color: #cc9a9a;margin-bottom: 11px;transition: color 0.2s ease-out;border: none;background: transparent;outline:none;}.todo .noteLi .edit{display:none;}.todo .editing{height: 40px;}.todo .editing .view{display:none;}.todo .editing .edit{display:block;border: none;width: 100%;height: 40px;}.todo .noteLi .destory:hover {color: #af5b5e;}.todo .noteLi:hover .destory {display: block;}.noteThing {width: 100%;}.noteThing input {width: 68%;margin-left: 7px;}.gray{text-decoration: line-through;color: #999;}.listEmpty{position: relative;bottom: 20px;left: 40%;}@media (min-width: 0px) and (max-width: 500px) {.ymcontent input {width: 70%;}.week .date {display: none;}}</style></p>
<p><div class="todo" id="todoList"><br>    <div class="year"><br>        <div class="titleTag"><input type="text" v-model="year">年目标</div><br>        <div class="ymcontent"><br>            <input type="text" class="year_content" v-model="yearContent"><br>            <i class="clear"></i><br>        </div><br>    </div><br>    <div class="month"><br>        <div class="titleTag"><input type="text" v-model="mounth">月任务</div><br>        <div class="ymcontent"><br>            <input type="text" class="month_content" v-model="mounthCentent"><br>            <i class="clear"></i><br>        </div><br>    </div><br>    <div class="week"><br>        <div class="titleTag"><br>            <div class="weekN">第<input type="text" class="monthL" v-model="weekNow">/<input type="text" class="monthL" v-model="weekTotal">周计划</div><br>            <div class="date"><input type="text" class="monthL" v-model="weekMounth1">月<input type="text" class="monthL" v-model="weekDay1">日-<input type="text" class="monthL" v-model="weekMounth2">月<input type="text" class="monthL" v-model="weekDay2">日</div><br>        </div><br>        <ul class="weekUl"><br>            <li><br>                <span>周一</span><br>                <input type="text" v-model="Monday"><br>                <i class="clear"></i><br>            </li><br>            <li><br>                <span>周二</span><br>                <input type="text" v-model="Tuesday"><br>                <i class="clear"></i><br>            </li><br>            <li><br>                <span>周三</span><br>                <input type="text" v-model="Wednesday"><br>                <i class="clear"></i><br>            </li><br>            <li><br>                <span>周四</span><br>                <input type="text" v-model="Thursday"><br>                <i class="clear"></i><br>            </li><br>            <li><br>                <span>周五</span><br>                <input type="text" v-model="Friday"><br>                <i class="clear"></i><br>            </li><br>            <li><br>                <span>周六</span><br>                <input type="text" v-model="Saturday"><br>                <i class="clear"></i><br>            </li><br>            <li><br>                <span>周日</span><br>                <input type="text" v-model="Sunday"><br>                <i class="clear"></i><br>            </li><br>        </ul><br>    </div><br>    <div class="titleTag w100">便利贴</div><br>    <div class="notes"><br>        <div class="ymcontent noteThing"><br>            <div class="titleTag">添加事项</div><br>            <input type="text" class="year_content" v-model="todo" @keyup.enter="enterHandle"><br>        </div><br>        <div class="ymcontent noteThing"><br>            <a class="titleTag l30" href="#all" v-show="textArr.length">所有任务<span></span></a><br>            <a class="titleTag l30 lr20" href="#un" v-show="unLength">未完成任务<span></span></a><br>            <a class="titleTag l30" href="#ed" v-show="edLength">已完成任务<span></span></a><br>        </div><br>        <div class="titleTag">任务列表</div><br>        <div v-if="textArr.length"><br>            <ul class="noteList clearFix"><br>                <li v-for="(item,index) in filterTodo" :class="{noteLi:true,gray:item.checked,editing:editing==index}" @dblclick="douLiClick(item.title,index)"><br>                    <div class="view"><br>                        <input type="checkbox" class="toggle" v-model="item.checked"><br>                        <label></label><br>                        <button class="destory" @click="clearHandle(index,item)">x</button><br>                    </div><br>                    <input type="text" class="edit" @keyup.enter="edited(item,index)" @keyup.esc="restoreTodo(item,index)" v-model="item.title" v-focus="editing==index" @blur="edited(item,index)"><br>                </li><br>            </ul><br>        </div><br>        <div v-else class="listEmpty">当前列表为空~</div><br>    </div><br></div></p>
<script>var storage = {get(key){return JSON.parse(window.localStorage.getItem(key));},set(key,value){return window.localStorage.setItem(key,JSON.stringify(value));}}
    // 上方计划表localStorage
    var year = storage.get("year") || "";
    var yearContent = storage.get("yearContent") || "";
    var mounth = storage.get("mounth") || "";
    var mounthCentent = storage.get("mounthCentent") || "";
    var weekNow = storage.get("weekNow") || "";
    var weekTotal = storage.get("weekTotal") || "";
    var weekMounth1 = storage.get("weekMounth1") || "";
    var weekDay1 = storage.get("weekDay1") || "";
    var weekMounth2 = storage.get("weekMounth2") || "";
    var weekDay2 = storage.get("weekDay2") || "";
    var Monday = storage.get("Monday") || "";
    var Tuesday = storage.get("Tuesday") || "";
    var Wednesday = storage.get("Wednesday") || "";
    var Thursday = storage.get("Thursday") || "";
    var Friday = storage.get("Friday") || "";
    var Saturday = storage.get("Saturday") || "";
    var Sunday = storage.get("Sunday") || "";
    // 上方计划表localStorage   
    var textArr = storage.get("todo") || [];
    var filterHash={
        "all":function(textArr){
            return textArr;
        },
        "un":function(textArr){
            return textArr.filter(function(item){
                return !item.checked;
            })
        },
        "ed":function(textArr){
            return textArr.filter(function(item){
                return item.checked;
            })
        }
    }
    // var textArr = [{
    //     "title":"吃饭",
    //     "checked":true
    // },{
    //     "title":"睡觉",
    //     "checked":false
    // },{
    //     "title":"打豆豆",
    //     "checked":false
    // }];
    var vm = new Vue({
        el: "#todoList",
        data: {
            textArr,
            todo:"",
            editing:undefined,
            beforeTodo:"",
            thisHash:"all",
            // 上方计划表localStorage
            year,
            yearContent,
            mounth,
            mounthCentent,
            weekNow,
            weekTotal,
            weekMounth1,
            weekDay1,
            weekMounth2,
            weekDay2,
            Monday,
            Tuesday,
            Wednesday, 
            Thursday,
            Friday,
            Saturday,
            Sunday
            // 上方计划表localStorage
        },
        methods:{
            enterHandle:function(e){
                // if(e.target.value !== ""){
                //     var obj = {
                //         "title":e.target.value,
                //         "checked":false
                //     }
                //     this.textArr.push(obj);
                //     e.target.value="";
                // }
                this.textArr.push({
                    "title":this.todo,
                    "checked":false
                });
                this.todo = '';
            },
            clearHandle:function(index,item){
                // console.log(this.textArr.indexOf(item));
                this.textArr.splice(index,1);
            },
            douLiClick:function(title,index){
                this.editing = index;
                this.beforeTodo = title;
            },
            edited:function(item,index){
                this.editing = undefined;
            },
            restoreTodo:function(item,index){
                this.textArr.splice(index,1,{
                    "title":this.beforeTodo,
                    "checked":item.checked
                })
                this.editing = undefined;
            }
        },
        computed:{
            unLength : function(){
                return this.textArr.filter(function(item){return !item.checked;}).length;
            },
            edLength : function(){
                return this.textArr.filter(function(item){return item.checked;}).length;
            },
            filterTodo:function(){
              if(!this.thisHash){
                this.thisHash = "all";
              }
              return filterHash[this.thisHash](this.textArr);
            }
        },
        directives:{
            focus:{
                update:function(el,binding){
                    if(binding.value){
                        el.focus();
                    }
                }
            }
        },
        watch:{
            textArr:function(){//浅层次的监听
                    storage.set("todo",this.textArr);
            },
            textArr:{//深层次的监听
                deep:true,
                handler:function(){
                    storage.set("todo",this.textArr);
                }
            },
            // 上方计划表localStorage
            year:function(){//浅层次的监听
                storage.set("year",this.year);
            },
            yearContent:function(){
                storage.set("yearContent",this.yearContent);
            },
            mounth:function(){
                storage.set("mounth",this.mounth);
            },
            mounthCentent:function(){
                storage.set("mounthCentent",this.mounthCentent);
            },
            weekNow:function(){
                storage.set("weekNow",this.weekNow);
            },
            weekTotal:function(){
                storage.set("weekTotal",this.weekTotal);
            },
            weekMounth1:function(){
                storage.set("weekMounth1",this.weekMounth1);
            },
            weekDay1:function(){
                storage.set("weekDay1",this.weekDay1);
            },
            weekMounth2:function(){
                storage.set("weekMounth2",this.weekMounth2);
            },
            weekDay2:function(){
                storage.set("weekDay2",this.weekDay2);
            },
            Monday:function(){
                storage.set("Monday",this.Monday);
            },
            Tuesday:function(){
                storage.set("Tuesday",this.Tuesday);
            },
            Wednesday:function(){
                storage.set("Wednesday",this.Wednesday);
            }, 
            Thursday:function(){
                storage.set("Thursday",this.Thursday);
            },
            Friday:function(){
                storage.set("Friday",this.Friday);
            },
            Saturday:function(){
                storage.set("Saturday",this.Saturday);
            },
            Sunday:function(){
                storage.set("Sunday",this.Sunday);
            }
            // 上方计划表localStorage
        }
    });
    function hashChange(){
        vm.thisHash = window.location.hash.slice(1);
    }
    window.addEventListener("hashchange",hashChange);
    hashChange();
    </script>



<p>vue-TodoList项目总结<br>1.v-model双向数据绑定，帮助筛选数据。v-model替代e.target.value<br>2.v-if 判断列表是否为空，v-show是否显示<br>3.双大括号中可写文本，可写表达式，可写方法<br>4.computed计算属性，和methods不同的是：computed有缓存。好<br>5.vue重写了push，splice数组方法<br>6.@方法可以传参<br>7.<font color="red">indexOf</font>可以返回索引值。this.textArr.indexOf(item)<br>8.<font color="red">dblClick双击</font><br>9.操作数组中的某一项，可以用传参之后看是否和参数相等来判断<br>10.<font color="red">自定义指令directives</font>，自定义指令定义函数提供的几个钩子函数：bind、inserted、update、componentUpdated、unbind。钩子函数的参数el、binding、vnode、oldVnode.<br>11.<font color="red">监听函数watch ,深层和浅层</font><br>12.<font color="red">hashchange事件</font><br>13.<font color="red">利用localStorage存储值</font></p>
<h1 id="vue组件"><a href="#vue组件" class="headerlink" title="vue组件"></a>vue组件</h1><h2 id="全局组件和局部组件"><a href="#全局组件和局部组件" class="headerlink" title="全局组件和局部组件"></a>全局组件和局部组件</h2><p>优点：可复用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"vueCom"</span>&gt;</span><br><span class="line">    &lt;my-component&gt;&lt;/my-component&gt;</span><br><span class="line">    &lt;jyy&gt;&lt;/jyy&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.component(<span class="string">"my-component"</span>,&#123;</span><br><span class="line">        template:`&lt;div&gt;我是全局组件&lt;/div&gt;`</span><br><span class="line">    &#125;)</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el:<span class="string">"#vueCom"</span>,</span><br><span class="line">        components:&#123;</span><br><span class="line">          jyy:&#123;</span><br><span class="line">            template:`&lt;div&gt;我是局部组件&lt;/div&gt;`</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>结果如下：</p>
<p><div id="vueCom"><br>  <div>我是全局组件</div><br>  <div>我是局部组件</div><br></div><br>1.局部和全局的概念，我们应该很容易知道。全局组件是可以应用在所有vue组件中的，局部组件只能应用于定义的组件中。<br>2.html模板渲染是遵循html的语法规则。例如：在&lt; table&gt;&lt; div&gt;&lt;/ div&gt;&lt;/ table&gt;这种写法，会被浏览器解析成&lt; div&gt;&lt;/ div&gt;&lt; table&gt;&lt;/ table&gt;。有一个偷换概念的解决办法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#错误的</span></span><br><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;jyy&gt;&lt;/jyy&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#正确的</span></span><br><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tr is=<span class="string">"jyy"</span>&gt;&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure></p>
<p>3.字符串模板不受html语法限制</p>
<h2 id="全局API"><a href="#全局API" class="headerlink" title="全局API"></a>全局API</h2><p>全局API都可以设置成全局，如<br>Vue.directive(“focus”,{<br>    update:{…}<br>})<br>全局API有：<br>Vue.extend<br>Vue.nextTick<br>Vue.set<br>Vue.delete<br>Vue.directive<br>Vue.filter<br>Vue.component<br>Vue.use<br>Vue.mixin<br>Vue.compile<br>Vue.observable<br>Vue.version<br><strong>特别介绍：</strong><br>Vue.extend( options )<br>参数：{Object} options<br>用法：使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。data 选项是特例，需要注意 - 在 Vue.extend() 中它必须是函数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"mount-point"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;// 创建构造器</span><br><span class="line">var Profile = Vue.extend(&#123;</span><br><span class="line">  template: <span class="string">'&lt;p&gt;aka&lt;/p&gt;'</span>,</span><br><span class="line">  data: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      firstName: <span class="string">'Walter'</span>,</span><br><span class="line">      lastName: <span class="string">'White'</span>,</span><br><span class="line">      <span class="built_in">alias</span>: <span class="string">'Heisenberg'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// 创建 Profile 实例，并挂载到一个元素上。</span><br><span class="line">new Profile().<span class="variable">$mount</span>(<span class="string">'#mount-point'</span>);&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p>Walter White aka Heisenberg</p>

<h2 id="组件data需是function"><a href="#组件data需是function" class="headerlink" title="组件data需是function"></a>组件data需是function</h2><p>当我们把data写成对象时，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">"my-component"</span>,&#123;</span><br><span class="line">    template:`&lt;div&gt;&lt;button&gt;&#123;&#123;count++&#125;&#125;&lt;/button&gt;&lt;/div&gt;`,</span><br><span class="line">    data:&#123;</span><br><span class="line">        count:1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>会报一个这样的错误：<font color="red">[Vue warn]: The “data” option should be a function that returns a per-instance value in component definitions.</font></p>
<p>我们需要把data写成一个函数，这样每个组件都会拥有自己的data，相互不影响。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">"my-component"</span>,&#123;</span><br><span class="line">    template:`&lt;div&gt;&lt;button @click=<span class="string">"count++"</span>&gt;&#123;&#123;count&#125;&#125;&lt;/button&gt;&lt;/div&gt;`,</span><br><span class="line">    data:<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> &#123;</span><br><span class="line">            count:1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="组件props"><a href="#组件props" class="headerlink" title="组件props"></a>组件props</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"vueCom"</span>&gt;</span><br><span class="line">    &lt;my-component data<span class="_">-s</span>=<span class="string">"123"</span>&gt;&lt;/my-component&gt;</span><br><span class="line">    &lt;my-component  data<span class="_">-s</span>=<span class="string">"456"</span>&gt;&lt;/my-component&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.component(<span class="string">"my-component"</span>,&#123;</span><br><span class="line">        template:`&lt;div&gt;&lt;button&gt;&#123;&#123;dataS&#125;&#125;&lt;/button&gt;&lt;/div&gt;`,</span><br><span class="line">        props:[<span class="string">"dataS"</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><font color="red">注意：需要小驼峰式写法。父组件依旧可以向子进行传值等操作</font></p>
<h3 id="还可以定义props的type、require、等限制条件"><a href="#还可以定义props的type、require、等限制条件" class="headerlink" title="还可以定义props的type、require、等限制条件"></a>还可以定义props的type、require、等限制条件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"vueCom"</span>&gt;</span><br><span class="line">    &lt;my-component :data<span class="_">-s</span>=<span class="string">"number"</span>&gt;&lt;/my-component&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.component(<span class="string">"my-component"</span>,&#123;</span><br><span class="line">        template:`&lt;div&gt;&lt;button @click=<span class="string">"dataS++"</span>&gt;&#123;&#123;dataS&#125;&#125;&lt;/button&gt;&lt;/div&gt;`,</span><br><span class="line">        props:&#123;</span><br><span class="line">            dataS:&#123;</span><br><span class="line">                <span class="built_in">type</span>:Number,                 <span class="comment"># (或者是instanceof a自定义类型)</span></span><br><span class="line">                required:<span class="literal">true</span>,               <span class="comment">#(代表必填项)</span></span><br><span class="line">                validator:<span class="keyword">function</span>(value)&#123;   <span class="comment">#(验证条件，不满足会报错)</span></span><br><span class="line">                    <span class="built_in">return</span> value&gt;10;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el:<span class="string">"#vueCom"</span>,</span><br><span class="line">        data:&#123;</span><br><span class="line">            number:789</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="避免直接改变props属性值"><a href="#避免直接改变props属性值" class="headerlink" title="避免直接改变props属性值"></a>避免直接改变props属性值</h3><p>问题描述：直接改变props里的属性值，不仅会报错。如果需要v-if或v-shoe这些会发生重新渲染的问题，因为props里的属性值是单向数据流，所以我们采用data来过渡。或者通过computed也行，但是切记computed是监控data中的值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"vueCom"</span>&gt;</span><br><span class="line">    &lt;button @click=<span class="string">"shHiHandle"</span>&gt;显示/隐藏&lt;/button&gt;</span><br><span class="line">    &lt;my-component :data<span class="_">-s</span>=<span class="string">"number"</span> v-show=<span class="string">"flag"</span>&gt;&lt;/my-component&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.component(<span class="string">"my-component"</span>,&#123;</span><br><span class="line">        template:`&lt;div&gt;&lt;button @click=<span class="string">"dataS123++"</span>&gt;&#123;&#123;dataS123&#125;&#125;&lt;/button&gt;&lt;/div&gt;`,</span><br><span class="line">        data:<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">            <span class="built_in">return</span> &#123;</span><br><span class="line">                dataS123:this.dataS</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        props:&#123;</span><br><span class="line">            dataS:&#123;</span><br><span class="line">                <span class="built_in">type</span>:Number,</span><br><span class="line">                //(或者是instanceof a自定义类型)</span><br><span class="line">                required:<span class="literal">true</span>,</span><br><span class="line">                validator:<span class="keyword">function</span>(value)&#123;</span><br><span class="line">                    <span class="built_in">return</span> value&gt;10;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el:<span class="string">"#vueCom"</span>,</span><br><span class="line">        data:&#123;</span><br><span class="line">            number:789,</span><br><span class="line">            flag:<span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            shHiHandle:<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">                this.flag = !this.flag;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="子组件向父组件传值"><a href="#子组件向父组件传值" class="headerlink" title="子组件向父组件传值"></a>子组件向父组件传值</h3><p>父组件向子组件传值可以通过绑定属性props的方式，子组件向父组件</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/15/React/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lemon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/background10.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="立夏">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/15/React/" itemprop="url">React</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-15T11:04:06+08:00">
                2019-04-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/2）前端-框架/" itemprop="url" rel="index">
                    <span itemprop="name">2）前端 - 框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <!-- 宝蓝 4169E1 -->
<!-- 亮天蓝色    00BFFF -->
<!-- 天蓝色      87CEFA -->
<!-- 闪光绿      00FF00 -->
<h1 id="一、React是什么"><a href="#一、React是什么" class="headerlink" title="一、React是什么"></a><font color="#4169E1">一、React是什么</font></h1><p>React 是一个用于构建用户界面的 JavaScript 库。</p>
<p>MVC -&gt; React</p>
<h2 id="效率高"><a href="#效率高" class="headerlink" title="效率高"></a><font color="#00BFFF">效率高</font></h2><p>虚拟DOM：传统web页面一般是直接操作DOM，代价很大，涉及重绘重排非常耗性能，而React 为了尽可能减少对DOM的操作，提供了一种不同的而又强大的方式来更新DOM，代替直接操作DOM,就是Virtual dom，一个轻量级虚拟的dom。更新virtual dom时不保证马上影响真实dom，react会等到事件循环结束，然后利用<font color="    #00FF00">diff算法</font>，通过当前新的dom与之前做比较，计算出最小的步骤更新真实的dom。</p>
<h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a><font color="#00BFFF">组件化</font></h2><p>components 组件：在dom树上的节点被称为元素，在这里不同称为virtual dom，整体称为component， 众多的virtual dom的节点就是一个完整的抽象的组件。</p>
<h2 id="清晰"><a href="#清晰" class="headerlink" title="清晰"></a><font color="#00BFFF">清晰</font></h2><p>单项数据流：从父节点传递到子节点。</p>
<h2 id="state-amp-amp-props"><a href="#state-amp-amp-props" class="headerlink" title="state &amp;&amp; props"></a><font color="#00BFFF">state &amp;&amp; props</font></h2><p>state和props包含组件所需要的一些数据，当state或props的数据发生变化时，将会调用Render重新渲染，<br>React把组件看成是一个状态机。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致。</p>
<h2 id="class组件-和-生命周期钩子"><a href="#class组件-和-生命周期钩子" class="headerlink" title="class组件 和 生命周期钩子"></a><font color="#00BFFF">class组件 和 生命周期钩子</font></h2><ul>
<li><p>挂载<br>constructor()<br>static getDerivedStateFromProps()<br>render()<br>componentDidMount()</p>
</li>
<li><p>更新<br>static getDerivedStateFromProps()<br>shouldComponentUpdate()<br>render()<br>getSnapshotBeforeUpdate()<br>componentDidUpdate()</p>
</li>
<li><p>卸载<br>componentWillUnmount()</p>
<div class="post-warning"><strong>注意:</strong><br>  下述生命周期方法即将过时，在新代码中应该避免使用它们：<br>  UNSAFE_componentWillMount()<br>  UNSAFE_componentWillUpdate()<br>  UNSAFE_componentWillReceiveProps()<br></div>
</li>
<li><p>错误处理<br>当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法：<br>static getDerivedStateFromError()<br>componentDidCatch()</p>
</li>
<li><p>其他 APIs<br>组件还提供了一些额外的 API：<br>  setState()<br>  forceUpdate()<br>class 属性<br>  defaultProps<br>  displayName</p>
</li>
<li><p>实例属性<br>  props<br>  state</p>
</li>
</ul>
<h2 id="函数式组件-和-Hooks"><a href="#函数式组件-和-Hooks" class="headerlink" title="函数式组件 和 Hooks"></a><font color="#00BFFF">函数式组件 和 Hooks</font></h2><p><br><br><br><br><br><br></p>
<h1 id="二、创建新的-React-应用"><a href="#二、创建新的-React-应用" class="headerlink" title="二、创建新的 React 应用"></a><font color="#4169E1">二、创建新的 React 应用</font></h1><h2 id="2-1）create-react-app搭建"><a href="#2-1）create-react-app搭建" class="headerlink" title="2.1）create-react-app搭建"></a><font color="#00BFFF">2.1）create-react-app搭建</font></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">npm install create-react-app -g</span><br><span class="line">create-react-app xxx</span><br><span class="line"><span class="built_in">cd</span> xxx</span><br><span class="line">npm start</span><br><span class="line">或</span><br><span class="line">npx create-react-app my-app</span><br><span class="line"><span class="built_in">cd</span> my-app</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>
<h2 id="2-2）从头开始打造工具链"><a href="#2-2）从头开始打造工具链" class="headerlink" title="2.2）从头开始打造工具链"></a><font color="#00BFFF">2.2）从头开始打造工具链</font></h2><h3 id="2-1-1）package-json"><a href="#2-1-1）package-json" class="headerlink" title="2.1.1）package.json"></a>2.1.1）package.json</h3><p>package.json是下载依赖包的“说明书”，主要介绍其中的3个属性。<br><strong>1.devDependencies 开发依赖</strong><br><strong>2.dependencies 生产依赖</strong><br><strong>3.script 定义脚本命令(npm run …)</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"webpack-dev-server --progress --colors --devtool source-map"</span>,</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"git rm -rf dist&amp;&amp;node build/build.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"react1"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;&#125;,</span><br><span class="line">  <span class="string">"author"</span>: <span class="string">"jiyingying"</span>,</span><br><span class="line">  <span class="string">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="string">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"webpack-dev-server"</span>: <span class="string">"^3.1.9"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"babel"</span>: <span class="string">"^6.23.0"</span>,</span><br><span class="line">    <span class="string">"babel-core"</span>: <span class="string">"^6.24.0"</span>,</span><br><span class="line">    <span class="string">"babel-loader"</span>: <span class="string">"^7.1.5"</span>,</span><br><span class="line">    <span class="string">"babel-preset-es2015"</span>: <span class="string">"^6.24.0"</span>,</span><br><span class="line">    <span class="string">"babel-preset-react"</span>: <span class="string">"^6.23.0"</span>,</span><br><span class="line">    <span class="string">"babel-preset-stage-0"</span>: <span class="string">"^6.22.0"</span>,</span><br><span class="line">    <span class="string">"babel-preset-stage-2"</span>: <span class="string">"^6.22.0"</span>,</span><br><span class="line">    <span class="string">"babel-preset-env"</span>: <span class="string">"^1.7.0"</span>,</span><br><span class="line">    <span class="string">"css-loader"</span>: <span class="string">"^0.27.3"</span>,</span><br><span class="line">    <span class="string">"file-loader"</span>: <span class="string">"^0.10.1"</span>,</span><br><span class="line">    <span class="string">"react"</span>: <span class="string">"^15.3.0"</span>,</span><br><span class="line">    <span class="string">"react-dom"</span>: <span class="string">"^15.3.0"</span>,</span><br><span class="line">    <span class="string">"style-loader"</span>: <span class="string">"^0.23.1"</span>,</span><br><span class="line">    <span class="string">"url-loader"</span>: <span class="string">"^0.5.8"</span>,</span><br><span class="line">    <span class="string">"webpack"</span>: <span class="string">"^4.41.2"</span>,</span><br><span class="line">    <span class="string">"webpack-cli"</span>: <span class="string">"^3.3.9"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-2）webpack-config-js"><a href="#2-1-2）webpack-config-js" class="headerlink" title="2.1.2）webpack.config.js"></a>2.1.2）webpack.config.js</h3><p>module.exports模块导出 =<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;entry <font color="blue">入口文件</font> : ‘./src/js/entry.js<font color="blue">入口文件的相对地址</font>‘,<br>&nbsp;&nbsp;&nbsp;&nbsp;output <font color="blue">出口文件</font> : {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path <font color="blue">出口文件路径</font> : __dirname+’/static/‘ <font color="blue">相对地址+出口文件夹名称</font>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;publicPath <font color="blue">公共路径</font> : “<a href="http://localhost:8080/static" target="_blank" rel="noopener">http://localhost:8080/static</a> <font color="blue">路径值</font>“,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filename <font color="blue">出口文件名称</font> : ‘index.js <font color="blue">出口文件名称值</font>‘<br>&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;module <font color="blue">模块配置</font> : {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rules <font color="blue">（规定使用什么loader解析相应文件，2.0版本之后是rules，1.0是loaders）</font> : [<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{test : /.less$/ , <font color="red">use</font> : <font color="red">[</font>‘style-loader’,’css-loader’,’less-loader’<font color="red">]</font> } <font color="blue">解析less文件</font>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test <font color="blue"></font> : /.js$/  <font color="blue">使用babel-loader解析js</font> ,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loader  <font color="blue">当只有1个loader时，可以写loaader，当其后的值是多个时，写use</font>  : “babel-loader”  ,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exclude <font color="blue">表示哪些目录中的 .js 文件不要进行 babel-loader,include与之相反</font> :/node_modules/ <font color="blue"></font> ,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;query <font color="blue">询问</font> : {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;presets <font color="blue">预置</font> : [<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;require.resolve(‘babel-preset-es2015’) <font color="blue">识别es6</font> ,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;require.resolve(‘babel-preset-react’) <font color="blue">识别JSX语法</font> ,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;require.resolve(‘babel-preset-stage-0’) <font color="blue">识别es7</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{test:/.(jpg|png)$/,loader:’url-loader’} <font color="blue">解析jpg和png文件</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;devServer <font color="blue">设备服务器配置</font> :{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;port <font color="blue">端口号</font> :3030,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;historyApiFallback:true,//单页面应用<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inline:true,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;historyApiFallback: true,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;disableHostCheck: true,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hot <font color="blue">热更新</font> : true,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxy <font color="blue">代理</font> : {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;”/api/“: {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;target: “<a href="http://jiyingying.m.ncfwxlocal.com/&quot;" target="_blank" rel="noopener">http://jiyingying.m.ncfwxlocal.com/&quot;</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;secure: false,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;changeOrigin: true<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry:<span class="string">'./src/js/entry.js'</span>,</span><br><span class="line">  output:&#123;</span><br><span class="line">      path:__dirname+<span class="string">'/static/'</span>,</span><br><span class="line">      publicPath:<span class="string">"http://localhost:3030/static"</span>,</span><br><span class="line">      filename:<span class="string">'index.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  module:&#123;</span><br><span class="line">      rules:[</span><br><span class="line">          &#123;<span class="built_in">test</span>:/\.less$/,use:[<span class="string">'style-loader'</span>,<span class="string">'css-loader'</span>,<span class="string">'less-loader'</span>]&#125;,</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="built_in">test</span>:/\.js$/,</span><br><span class="line">              loader:<span class="string">"babel-loader"</span>,</span><br><span class="line">              exclude:/node_modules/,</span><br><span class="line">              query:&#123;</span><br><span class="line">                  presets:[</span><br><span class="line">                      require.resolve(<span class="string">'babel-preset-es2015'</span>),</span><br><span class="line">                      require.resolve(<span class="string">'babel-preset-react'</span>),</span><br><span class="line">                      require.resolve(<span class="string">'babel-preset-stage-0'</span>)</span><br><span class="line">                  ]</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;<span class="built_in">test</span>:/\.(jpg|png)$/,loader:<span class="string">'url-loader'</span>&#125;</span><br><span class="line">      ]</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer:&#123;</span><br><span class="line">      port:3030,</span><br><span class="line">      historyApiFallback:<span class="literal">true</span>,//单页面应用</span><br><span class="line">      inline:<span class="literal">true</span>,</span><br><span class="line">      historyApiFallback: <span class="literal">true</span>,</span><br><span class="line">      disableHostCheck: <span class="literal">true</span>,</span><br><span class="line">      hot: <span class="literal">true</span>,</span><br><span class="line">      proxy: &#123;</span><br><span class="line">          <span class="string">"/api/"</span>: &#123;</span><br><span class="line">            target: <span class="string">"http://jiyingying.m.ncfwxlocal.com/"</span>,</span><br><span class="line">            secure: <span class="literal">false</span>,</span><br><span class="line">            changeOrigin: <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const path = require(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/js/entry.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname,<span class="string">'dist'</span>),</span><br><span class="line">    publicPath:<span class="string">'/dist'</span>,</span><br><span class="line">    filename:<span class="string">'bundle.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules:[&#123;</span><br><span class="line">        <span class="built_in">test</span>: /\.js$/,</span><br><span class="line">        loader: <span class="string">"babel-loader"</span>,</span><br><span class="line">        exclude: /node_modules/,</span><br><span class="line">        query: &#123;</span><br><span class="line">            presets: [</span><br><span class="line">              require.resolve(<span class="string">'babel-preset-es2015'</span>),</span><br><span class="line">              require.resolve(<span class="string">'babel-preset-react'</span>),</span><br><span class="line">              require.resolve(<span class="string">'babel-preset-stage-0'</span>),</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    port: 8083,</span><br><span class="line">    historyApiFallback: <span class="literal">true</span>,</span><br><span class="line">    inline: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-3）创建第一个react组件"><a href="#2-1-3）创建第一个react组件" class="headerlink" title="2.1.3）创建第一个react组件"></a>2.1.3）创建第一个react组件</h3><p>按照配置，创建对应的入口文件，文件基本内容如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var React = require(<span class="string">'react'</span>);</span><br><span class="line">var ReactDom = require(<span class="string">'react-dom'</span>);</span><br><span class="line"></span><br><span class="line">var App = React.createClass(&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">    const fontStyle = &#123;</span><br><span class="line">      color:<span class="string">'green'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    const arr = [<span class="string">'小白兔'</span>,<span class="string">'白又白'</span>,<span class="string">'两只耳朵竖起来'</span>];</span><br><span class="line">    <span class="built_in">return</span> &lt;div style=&#123;&#123; color: <span class="string">'red'</span>, &#125;&#125;&gt;</span><br><span class="line">            外层</span><br><span class="line">            &lt;div style = &#123; fontStyle &#125;&gt;内层&lt;/div&gt;</span><br><span class="line">            &lt;ul className = <span class="string">'ulClass'</span>&gt;</span><br><span class="line">              &#123;</span><br><span class="line">                arr.map( (item,index) =&gt; &lt;li key = &#123;index&#125;&gt;&#123;item&#125;&lt;/li&gt; )</span><br><span class="line">              &#125;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">            &lt;div&gt;&#123;this.props.name&#125;&lt;/div&gt;</span><br><span class="line">           &lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ReactDom.render(</span><br><span class="line">  &lt;App name = <span class="string">'ji'</span>/&gt;,</span><br><span class="line">  document.getElementById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>1）自定义组件的首字母必须大写<br>2）JSX语法 ： style的添加方式：行间直接写 或 行间变量声明<br>            数组方法<br>            className<br><strong><em>注意：不要在render中定义变量，这里只是为了讲述上述知识点</em></strong></p>
<ul>
<li><p>目前创建组件的方式有三种，分别是createClass、es6的class组件、函数式组件、<br>推荐阅读：<a href="https://www.jianshu.com/p/1dc57d51348b" target="_blank" rel="noopener">https://www.jianshu.com/p/1dc57d51348b</a></p>
<p>目前认为，createClass的效率比较慢，之后可能会被废弃，但是现在还没有。常用class组件，也有函数式组件，但是具体什么时候用class组件或函数式组件，暂时还没有定论。<br>createClass的实现，源码底层还会调用React.createElement等方法实现。但是我们轻易不要直接调用这些工具方法。</p>
</li>
</ul>
<h2 id="2-3）封装高阶架构命令"><a href="#2-3）封装高阶架构命令" class="headerlink" title="2.3）封装高阶架构命令"></a><font color="#00BFFF">2.3）封装高阶架构命令</font></h2><p><br><br><br><br><br></p>
<h1 id="三、核心概念"><a href="#三、核心概念" class="headerlink" title="三、核心概念"></a><font color="#4169E1">三、核心概念</font></h1><h2 id="3-1）JSX"><a href="#3-1）JSX" class="headerlink" title="3.1）JSX"></a><font color="#00BFFF">3.1）JSX</font></h2><ul>
<li><p>JSX是JS的语法扩展，它具有JS的全部功能。React认为：渲染逻辑常常与其他UI逻辑，比如：有一些数据需要放在UI中展示、有一些绑定处理事件需要放在UI中、数据发生变化时需要通知UI。所以React没有将 <em>标记</em> 和 <em>逻辑</em> 分离，而是将它们放在一个被称为“组件”的松散耦合单元中。</p>
</li>
<li><p>JSX这个有趣的标签语法，既不是字符串，也不是HTML。JSX可以生成React“元素”，这些元素会被渲染成DOM。</p>
</li>
<li><p>在 JSX 中嵌入表达式<br><strong>为了便于阅读，我们会将 JSX 拆分为多行。同时，我们建议将内容包裹在括号中，虽然这样做不是强制要求的，但是这可以避免遇到<font color="#00FF00">自动插入分号陷阱</font>。</strong></p>
</li>
<li><p>JSX 也是一个表达式</p>
</li>
<li><p>JSX 特定属性</p>
<div class="post-warning">警告：<br>  因为 JSX 语法上更接近 JavaScript 而不是 HTML，所以 React DOM 使用 camelCase（小驼峰命名）来定义属性的名称，而不使用 HTML 属性名称的命名约定。<br>  例如，JSX 里的 class 变成了 className，而 tabindex 则变为 tabIndex。<br></div>
</li>
<li><p>使用 JSX 指定子元素</p>
</li>
<li><p>JSX 防止注入攻击</p>
<ul>
<li><p>你可以安全地在 JSX 当中插入用户输入内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const title = response.potentiallyMaliciousInput;</span><br><span class="line">// 直接使用是安全的：</span><br><span class="line">const element = &lt;h1&gt;&#123;title&#125;&lt;/h1&gt;;</span><br></pre></td></tr></table></figure>
<p><strong>React DOM 在渲染所有输入内容之前，默认会进行转义。它可以确保在你的应用中，永远不会注入那些并非自己明确编写的内容。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止<font color="#00FF00"> XSS（cross-site-scripting, 跨站脚本）攻击</font>。</strong></p>
</li>
</ul>
</li>
<li><p>JSX 表示对象</p>
<ul>
<li><p>Babel 会把 JSX 转译成一个名为 React.createElement() 函数调用。<br>以下两种示例代码完全等效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const element = (</span><br><span class="line">  &lt;h1 className=<span class="string">"greeting"</span>&gt;</span><br><span class="line">    Hello, world!</span><br><span class="line">  &lt;/h1&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">const element = React.createElement(</span><br><span class="line">  <span class="string">'h1'</span>,</span><br><span class="line">  &#123;className: <span class="string">'greeting'</span>&#125;,</span><br><span class="line">  <span class="string">'Hello, world!'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>React.createElement() 会预先执行一些检查，以帮助你编写无错代码，但实际上它创建了一个这样的对象：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 注意：这是简化过的结构</span><br><span class="line">const element = &#123;</span><br><span class="line">  <span class="built_in">type</span>: <span class="string">'h1'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    className: <span class="string">'greeting'</span>,</span><br><span class="line">    children: <span class="string">'Hello, world!'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这些对象被称为 “React 元素”。它们描述了你希望在屏幕上看到的内容。React 通过读取这些对象，然后使用它们来构建 DOM 以及保持随时更新。</p>
</li>
</ul>
</li>
</ul>
<h2 id="3-2）元素渲染"><a href="#3-2）元素渲染" class="headerlink" title="3.2）元素渲染"></a><font color="#00BFFF">3.2）元素渲染</font></h2><ul>
<li>与浏览器的 DOM 元素不同，React 元素是创建<font color="#00FF00">开销极小的普通对象</font>。React DOM 会负责更新 DOM 来与 React 元素保持一致。</li>
</ul>
<h3 id="将一个元素渲染为-DOM"><a href="#将一个元素渲染为-DOM" class="headerlink" title="将一个元素渲染为 DOM"></a>将一个元素渲染为 DOM</h3><p>  假设你的 HTML 文件某处有一个 &lt;div>：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"root"</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>  我们将其称为“根” DOM 节点，因为该节点内的所有内容都将由 React DOM 管理。</p>
<p>  仅使用 React 构建的应用通常只有单一的根 DOM 节点。如果你在将 React 集成进一个已有应用，那么你可以在应用中包含任意多的独立根 DOM 节点。</p>
<h3 id="更新已渲染的元素"><a href="#更新已渲染的元素" class="headerlink" title="更新已渲染的元素"></a>更新已渲染的元素</h3><ul>
<li><p>React 元素是不可变对象。一旦被创建，你就无法更改它的子元素或者属性。一个元素就像电影的单帧：它代表了某个特定时刻的 UI。</p>
</li>
<li><p>根据我们已有的知识，更新 UI 唯一的方式是创建一个全新的元素，并将其传入 ReactDOM.render()。</p>
<p>思考：【元素渲染】考虑一个计时器的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">tick</span></span>() &#123;</span><br><span class="line">  const element = (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">      &lt;h2&gt;It is &#123;new Date().toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">  ReactDOM.render(element, document.getElementById(<span class="string">'root'</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(tick, 1000);</span><br></pre></td></tr></table></figure>
<p>这个例子会在 setInterval() 回调函数，每秒都调用 ReactDOM.render()。</p>
<p>注意：在实践中，大多数 React 应用只会调用一次 ReactDOM.render()。</p>
<pre><code>React 只更新它需要更新的部分
React DOM 会将元素和它的子元素与它们之前的状态进行比较，并只会进行必要的更新来使 DOM 达到
预期的状态。

本例中，尽管每一秒我们都会新建一个描述整个 UI 树的元素，React DOM 只会更新实际改变了的内容，
也就是例子中的文本节点。
</code></pre></li>
</ul>
<h3 id="React-只更新它需要更新的部分"><a href="#React-只更新它需要更新的部分" class="headerlink" title="React 只更新它需要更新的部分"></a>React 只更新它需要更新的部分</h3><p><br><br><br><br><br></p>
<h2 id="3-3）组件-amp-Props"><a href="#3-3）组件-amp-Props" class="headerlink" title="3.3）组件 &amp; Props"></a><font color="#00BFFF">3.3）组件 &amp; Props</font></h2><h3 id="3-1-1）函数组件-与-class-组件"><a href="#3-1-1）函数组件-与-class-组件" class="headerlink" title="3.1.1）函数组件 与 class 组件"></a>3.1.1）函数组件 与 class 组件</h3><p>定义组件最简单的方式就是编写 JavaScript 函数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Welcome(props) &#123;</span><br><span class="line">  <span class="built_in">return</span> &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数是一个有效的 React 组件，因为它接收唯一带有数据的 “props”（代表属性）对象与并返回一个 React 元素。这类组件被称为“函数组件”，因为它本质上就是 JavaScript 函数。</p>
<p>你同时还可以使用 ES6 的 class 来定义组件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Welcome extends React.Component &#123;</span><br><span class="line">  <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述两个组件在 React 里是等效的。</p>
<h3 id="3-1-2）渲染组件"><a href="#3-1-2）渲染组件" class="headerlink" title="3.1.2）渲染组件"></a>3.1.2）渲染组件</h3><p>当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性（attributes）以及子组件（children）转换为单个对象传递给组件，这个对象被称之为 “props”。</p>
<h3 id="3-1-3）props-父-gt-子"><a href="#3-1-3）props-父-gt-子" class="headerlink" title="3.1.3）props (父 -&gt; 子)"></a>3.1.3）props (父 -&gt; 子)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var React = require(<span class="string">'react'</span>);</span><br><span class="line">var ReactDom = require(<span class="string">'react-dom'</span>);</span><br><span class="line"></span><br><span class="line">var App = React.createClass(&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &lt;div&gt;</span><br><span class="line">            &#123; this.props.name &#125;</span><br><span class="line">           &lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ReactDom.render(</span><br><span class="line">  &lt;App name = <span class="string">'ji'</span>/&gt;,</span><br><span class="line">  document.getElementById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<font color="#a11"><strong>可嵌套子组件：this.props.children</strong></font>

<h3 id="3-1-4）子-gt-父"><a href="#3-1-4）子-gt-父" class="headerlink" title="3.1.4）子 -&gt; 父"></a>3.1.4）子 -&gt; 父</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Son extends Component&#123;</span><br><span class="line">  constructor(props)&#123;</span><br><span class="line"> 		super(props)</span><br><span class="line"> 		this.state = &#123;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">changeText</span></span>()&#123;</span><br><span class="line">    this.props.changeText(<span class="string">'123'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &lt;div onClick=&#123; this.changeText()&#125;&gt;</span><br><span class="line">            &#123; this.state.text &#125;</span><br><span class="line">           &lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)];</span><br><span class="line"></span><br><span class="line">class App extends Component&#123;</span><br><span class="line">  constructor(props)&#123;</span><br><span class="line"> 		super(props)</span><br><span class="line"> 		this.state = &#123;</span><br><span class="line">      text: <span class="string">'父亲'</span>，</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  changeText(text)&#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      text,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &lt;Son changeText=&#123; (text) =&gt; this.changeText.bind(this, text)&#125;&gt;</span><br><span class="line">            &#123; this.state.text &#125;</span><br><span class="line">           &lt;/Son &gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ReactDom.render(</span><br><span class="line">  &lt;App name = <span class="string">'ji'</span>/&gt;,</span><br><span class="line">  document.getElementById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="3-1-5）Props-的只读性"><a href="#3-1-5）Props-的只读性" class="headerlink" title="3.1.5）Props 的只读性"></a><font color="#87CEFA">3.1.5）Props 的只读性</font></h3><blockquote>
<p>组件无论是使用函数声明还是通过 class 声明，都决不能修改自身的 props。<br>  来看下这个 sum 函数：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> sum(a, b) &#123;</span><br><span class="line">  <span class="built_in">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>  这样的函数被称为 <font color="00FF00">“纯函数”</font>，因为该函数不会尝试更改入参，且多次调用下相同的入参始终返回相同的结果。</p>
<p>  相反，下面这个函数则不是纯函数，因为它更改了自己的入参：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> withdraw(account, amount) &#123;</span><br><span class="line">  account.total -= amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  React 非常灵活，但它也有一个严格的规则：所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。</p>
<p>  当然，应用程序的 UI 是动态的，并会伴随着时间的推移而变化。我们将介绍一种新的概念，称之为 “state”。在不违反上述规则的情况下，state 允许 React 组件随用户操作、网络响应或者其他变化而动态更改输出内容。</p>
<h2 id="3-4）State-amp-生命周期"><a href="#3-4）State-amp-生命周期" class="headerlink" title="3.4）State &amp; 生命周期"></a><font color="#00BFFF">3.4）State &amp; 生命周期</font></h2><blockquote>
<p><strong>将函数组件转换成 class 组件</strong></p>
<ol>
<li>创建一个ES6 class，并且继承于 React.Component。</li>
<li>添加一个空的 render() 方法。</li>
<li>将函数体移动到 render() 方法之中。</li>
<li>在 render() 方法中使用 this.props 替换 props。</li>
</ol>
</blockquote>
<blockquote>
<p><strong>向 class 组件中添加局部的 state</strong></p>
<ol>
<li>添加一个 class 构造函数，然后在该函数中为 this.state 赋初值</li>
<li>在 render() 方法中的 t可以调用 this.state中的值</li>
<li>this.setState({}) 方法可以改变this.state中的值</li>
</ol>
</blockquote>
<blockquote>
<p><strong>将生命周期方法添加到 Class 中</strong></p>
</blockquote>
<h3 id="一、正确地使用-State"><a href="#一、正确地使用-State" class="headerlink" title="一、正确地使用 State"></a>一、正确地使用 State</h3><h4 id="1-不要直接修改-State"><a href="#1-不要直接修改-State" class="headerlink" title="1. 不要直接修改 State"></a><font color="#EE82EE" size="3">1. 不要直接修改 State</font></h4><p>  例如，此代码不会重新渲染组件：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Wrong</span><br><span class="line">this.state.comment = <span class="string">'Hello'</span>;</span><br><span class="line">而是应该使用 setState():</span><br><span class="line"></span><br><span class="line">// Correct</span><br><span class="line">this.setState(&#123;comment: <span class="string">'Hello'</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<p>  构造函数是唯一可以给 this.state 直接赋值的地方：</p>
<h4 id="2-State的更新可能是异步的"><a href="#2-State的更新可能是异步的" class="headerlink" title="2. State的更新可能是异步的"></a><font color="#EE82EE" size="3">2. State的更新可能是异步的</font></h4><p>   出于性能考虑，React 可能会把多个 setState() 调用合并成一个调用。<br>   因为 this.props 和 this.state 可能会异步更新，所以不要依赖他们的值来更新下一个状态。</p>
<p>   例如，此代码可能会无法更新计数器：<br>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Wrong</span><br><span class="line">this.setState(&#123;</span><br><span class="line">  counter: this.state.counter + this.props.increment,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>要解决这个问题，  <font color="#00FF00">可以让 setState() 接收一个函数而不是一个对象</font>。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Correct</span><br><span class="line">this.setState((state, props) =&gt; (&#123;</span><br><span class="line">  counter: state.counter + props.increment</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">上面使用了箭头函数，不过使用普通的函数也同样可以：</span><br><span class="line">// Correct</span><br><span class="line">this.setState(<span class="keyword">function</span>(state, props) &#123;</span><br><span class="line">  <span class="built_in">return</span> &#123;</span><br><span class="line">    counter: state.counter + props.increment</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="3-State的更新会被合并"><a href="#3-State的更新会被合并" class="headerlink" title="3. State的更新会被合并"></a><font color="#EE82EE" size="3">3. State的更新会被合并</font></h4><p>当你调用 setState() 的时候，React 会把你提供的对象合并到当前的 state。</p>
<h3 id="二、数据是向下流动的"><a href="#二、数据是向下流动的" class="headerlink" title="二、数据是向下流动的"></a>二、数据是向下流动的</h3><blockquote>
<p>state 为局部的或是封装，是因为除了拥有并设置了它的组件，其他组件都无法访问。</p>
</blockquote>
<blockquote>
<p>组件可以选择把它的 state 作为 props 向下传递到它的子组件中,这通常会被叫做“自上而下”或是“单向”的数据流。任何的 state 总是所属于特定的组件，而且从该 state 派生的任何数据或 UI 只能影响树中“低于”它们的组件。</p>
</blockquote>
<blockquote>
<p>在class组件中使用state</p>
</blockquote>
<ol>
<li><p>函数式组件实现定时显示时间</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Clock(props) &#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">      &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">tick</span></span>() &#123;</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    &lt;Clock date=&#123;new Date()&#125; /&gt;,</span><br><span class="line">    document.getElementById(<span class="string">'root'</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(tick, 1000);</span><br></pre></td></tr></table></figure>
</li>
<li><p>class组件实现定时显示时间</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Clock extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;date: new Date()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span></span>() &#123;</span><br><span class="line">    this.timerID = setInterval(</span><br><span class="line">      () =&gt; this.tick(),</span><br><span class="line">      1000</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentWillUnmount</span></span>() &#123;</span><br><span class="line">    clearInterval(this.timerID);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">tick</span></span>() &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      date: new Date()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Clock /&gt;,</span><br><span class="line">  document.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="3-5）其他概念"><a href="#3-5）其他概念" class="headerlink" title="3.5）其他概念"></a><font color="00BFFF">3.5）其他概念</font></h2><h3 id="1、事件处理"><a href="#1、事件处理" class="headerlink" title="1、事件处理"></a>1、事件处理</h3><ul>
<li><p><font color="#00FF00">【命名】</font>React 事件的命名采用小驼峰式（camelCase），而不是纯小写。</p>
</li>
<li><p><font color="#00FF00">【函数】</font>使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。</p>
</li>
<li><p><font color="#00FF00">【阻止默认行为-preventDefault】</font>在 React 中另一个不同点是你不能通过返回 false 的方式阻止默认行为。你必须显式的使用 preventDefault 。</p>
</li>
<li><p><font color="#00FF00">【this】</font>你必须谨慎对待 JSX 回调函数中的 this，在 JavaScript 中，class 的方法默认不会绑定 this。如果你忘记绑定 this.handleClick 并把它传入了 onClick，当你调用这个函数的时候 this 的值为 undefined。</p>
<p>这并不是 React 特有的行为；这其实与 JavaScript 函数工作原理有关。通常情况下，如果你没有在方法后面添加 ()，例如 onClick={this.handleClick}，你应该为这个方法绑定 this。</p>
</li>
<li><font color="#00FF00">【箭头函数】</font>如果你没有使用 class fields 语法，你可以在回调中使用箭头函数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class LoggingButton extends React.Component &#123;</span><br><span class="line">  <span class="function"><span class="title">handleClick</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'this is:'</span>, this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">    // 此语法确保 `handleClick` 内的 `this` 已被绑定。</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; this.handleClick()&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>此语法问题在于每次渲染 LoggingButton 时都会创建不同的回调函数。在大多数情况下，这没什么问题，<font color="#EE82EE">但如果该回调函数作为 prop 传入子组件时，这些组件可能会进行额外的重新渲染。我们通常建议在构造器中绑定或使用 class fields 语法来避免这类性能问题。</font>

</li>
</ul>
<h4 id="向事件处理程序传递参数"><a href="#向事件处理程序传递参数" class="headerlink" title="向事件处理程序传递参数"></a>向事件处理程序传递参数</h4><p>在循环中，通常我们会为事件处理函数传递额外的参数。例如，若 id 是你要删除那一行的 ID，以下两种方式都可以向事件处理函数传递参数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;(e) =&gt; this.deleteRow(id, e)&#125;&gt;Delete Row&lt;/button&gt;</span><br><span class="line">&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/button&gt;</span><br></pre></td></tr></table></figure></p>
<p>上述两种方式是等价的，分别通过箭头函数和 Function.prototype.bind 来实现。</p>
<p>在这两种情况下，React 的事件对象 e 会被作为第二个参数传递。如果通过箭头函数的方式，事件对象必须显式的进行传递，而通过 bind 的方式，事件对象以及更多的参数将会被隐式的进行传递。</p>
<h3 id="2、条件渲染"><a href="#2、条件渲染" class="headerlink" title="2、条件渲染"></a>2、条件渲染</h3><p>元素变量<br>与运算符&amp;&amp;<br>三目运算符<br>阻止组件渲染</p>
<h3 id="3、列表-amp-Key"><a href="#3、列表-amp-Key" class="headerlink" title="3、列表 &amp; Key"></a>3、列表 &amp; Key</h3><p>渲染多个组件<br>基础列表组件</p>
<ul>
<li><p>key：</p>
<ul>
<li>一个元素的 key 最好是这个元素在列表中拥有的一个独一无二的字符串。</li>
<li>当元素没有确定 id 的时候，万不得已你可以使用元素索引 index 作为 key。</li>
<li><p>如果列表项目的顺序可能会变化，我们不建议使用索引来用作 key 值，因为这样做会导致性能变差，还可能引起组件状态的问题。可以看看 Robin Pokorny 的深度解析使用索引作为 key 的负面影响这一篇文章。如果你选择不指定显式的 key 值，那么 React 将默认使用索引用作为列表项目的 key 值。<br>深入解析为什么 key 是必须的:<br>(<a href="https://react.docschina.org/docs/reconciliation.html#recursing-on-children" target="_blank" rel="noopener">https://react.docschina.org/docs/reconciliation.html#recursing-on-children</a>)</p>
</li>
<li><p>key 只是在兄弟节点之间必须唯一</p>
</li>
</ul>
</li>
<li><p>在 JSX 中嵌入 map()</p>
</li>
</ul>
<h3 id="4、表单"><a href="#4、表单" class="headerlink" title="4、表单"></a>4、表单</h3><p>受控组件<br>textarea 标签<br>select 标签<br>文件 input 标签<br>处理多个输入</p>
<blockquote>
<p>受控输入空值<br>  在受控组件上指定 value 的 prop 会阻止用户更改输入。如果你指定了 value，但输入仍可编辑，则可能是你意外地将value 设置为 undefined 或 null。</p>
</blockquote>
<p>  下面的代码演示了这一点。（输入最初被锁定，但在短时间延迟后变为可编辑。）<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(&lt;input value=<span class="string">"hi"</span> /&gt;, mountNode);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  ReactDOM.render(&lt;input value=&#123;null&#125; /&gt;, mountNode);</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>受控组件的替代品<br>  有时使用受控组件会很麻烦，因为你需要为数据变化的每种方式都编写事件处理函数，并通过一个 React 组件传递所有的输入 state。当你将之前的代码库转换为 React 或将 React   React 库集成时，这可能会令人厌烦。在这些情况下，你可能希望使用非受控组件, 这是实现输入表单的另一种方式</p>
</blockquote>
<blockquote>
<p>成熟的解决方案<br>  如：Formik</p>
</blockquote>
<h3 id="5、状态提升"><a href="#5、状态提升" class="headerlink" title="5、状态提升 "></a><font color="00BFFF">5、状态提升 </font></h3><blockquote>
<p>在 React 应用中，任何可变数据应当只有一个相对应的唯一“数据源”。通常，state 都是首先添加到需要渲染数据的组件中去。然后，如果其他组件也需要这个 state，那么你可以将它提升至这些组件的最近共同父组件中。你应当依靠自上而下的数据流，而不是尝试在不同组件间同步 state。</p>
</blockquote>
<h3 id="6、组合-vs-继承"><a href="#6、组合-vs-继承" class="headerlink" title="6、组合 vs 继承 "></a><font color="00BFFF">6、组合 vs 继承 </font></h3><h4 id="包含关系"><a href="#包含关系" class="headerlink" title="包含关系"></a>包含关系</h4><ol>
<li><p>props.children</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">WelcomeDialog</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    &lt;FancyBorder color=<span class="string">"blue"</span>&gt;</span><br><span class="line">      &lt;h1 className=<span class="string">"Dialog-title"</span>&gt;</span><br><span class="line">        Welcome</span><br><span class="line">      &lt;/h1&gt;</span><br><span class="line">      &lt;p className=<span class="string">"Dialog-message"</span>&gt;</span><br><span class="line">        Thank you <span class="keyword">for</span> visiting our spacecraft!</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">    &lt;/FancyBorder&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>props.属性</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> SplitPane(props) &#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"SplitPane"</span>&gt;</span><br><span class="line">      &lt;div className=<span class="string">"SplitPane-left"</span>&gt;</span><br><span class="line">        &#123;props.left&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div className=<span class="string">"SplitPane-right"</span>&gt;</span><br><span class="line">        &#123;props.right&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">App</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    &lt;SplitPane</span><br><span class="line">      left=&#123;</span><br><span class="line">        &lt;Contacts /&gt;</span><br><span class="line">      &#125;</span><br><span class="line">      right=&#123;</span><br><span class="line">        &lt;Chat /&gt;</span><br><span class="line">      &#125; /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="特例关系"><a href="#特例关系" class="headerlink" title="特例关系"></a>特例关系</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Dialog(props) &#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    &lt;FancyBorder color=<span class="string">"blue"</span>&gt;</span><br><span class="line">      &lt;h1 className=<span class="string">"Dialog-title"</span>&gt;</span><br><span class="line">        &#123;props.title&#125;</span><br><span class="line">      &lt;/h1&gt;</span><br><span class="line">      &lt;p className=<span class="string">"Dialog-message"</span>&gt;</span><br><span class="line">        &#123;props.message&#125;</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;/FancyBorder&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SignUpDialog extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleChange = this.handleChange.bind(this);</span><br><span class="line">    this.handleSignUp = this.handleSignUp.bind(this);</span><br><span class="line">    this.state = &#123;login: <span class="string">''</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">      &lt;Dialog title=<span class="string">"Mars Exploration Program"</span></span><br><span class="line">              message=<span class="string">"How should we refer to you?"</span>&gt;</span><br><span class="line">        &lt;input value=&#123;this.state.login&#125;</span><br><span class="line">               onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.handleSignUp&#125;&gt;</span><br><span class="line">          Sign Me Up!</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      &lt;/Dialog&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    this.setState(&#123;login: e.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">handleSignUp</span></span>() &#123;</span><br><span class="line">    alert(`Welcome aboard, <span class="variable">$&#123;this.state.login&#125;</span>!`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7、React-哲学"><a href="#7、React-哲学" class="headerlink" title="7、React 哲学 "></a><font color="00BFFF">7、React 哲学 </font></h3><p>第一步：将设计好的 UI 划分为组件层级<br>第二步：用 React 创建一个静态版本<br>第三步：确定 UI state 的最小（且完整）表示<br>第四步：确定 state 放置的位置<br>第五步：添加反向数据流</p>
<p><br><br><br><br><br><br><br><br><br><br><br><br><br></p>
<h1 id="四、高级指引"><a href="#四、高级指引" class="headerlink" title="四、高级指引"></a><font color="#4169E1">四、高级指引</font></h1><h2 id="4-1）无障碍"><a href="#4-1）无障碍" class="headerlink" title="4.1）无障碍"></a><font color="#00BFFF">4.1）无障碍</font></h2><h3 id="1、语义化的HTML"><a href="#1、语义化的HTML" class="headerlink" title="1、语义化的HTML"></a><font color="#87CEFA">1、语义化的HTML</font></h3><ul>
<li>Fragments标签，短语法：&lt;&gt;&lt;/&gt;</li>
</ul>
<h3 id="2、无障碍表单"><a href="#2、无障碍表单" class="headerlink" title="2、无障碍表单"></a><font color="#87CEFA">2、无障碍表单</font></h3><ul>
<li><p>标记</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;label htmlFor=<span class="string">"namedInput"</span>&gt;Name:&lt;/label&gt;</span><br><span class="line">&lt;input id=<span class="string">"namedInput"</span> <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"name"</span>/&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在出错时提醒用户</p>
</li>
</ul>
<h3 id="3、控制焦点"><a href="#3、控制焦点" class="headerlink" title="3、控制焦点"></a><font color="#87CEFA">3、控制焦点</font></h3><ul>
<li>键盘焦点及焦点轮廓</li>
<li>跳过内容机制</li>
<li>使用程序管理焦点<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class CustomTextInput extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    // 创造一个 textInput DOM 元素的 ref</span><br><span class="line">    this.textInput = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">  // 使用 `ref` 回调函数以在实例的一个变量中存储文本输入 DOM 元素</span><br><span class="line">  //（比如，this.textInput）。</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">      &lt;input</span><br><span class="line">        <span class="built_in">type</span>=<span class="string">"text"</span></span><br><span class="line">        ref=&#123;this.textInput&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4、鼠标和指针事件"><a href="#4、鼠标和指针事件" class="headerlink" title="4、鼠标和指针事件"></a><font color="#87CEFA">4、鼠标和指针事件</font></h3><ol>
<li><p>在 window 对象中附上一个 click 事件以关闭弹窗：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class OuterClickExample extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line"></span><br><span class="line">    this.state = &#123; isOpen: <span class="literal">false</span> &#125;;</span><br><span class="line">    this.toggleContainer = React.createRef();</span><br><span class="line"></span><br><span class="line">    this.onClickHandler = this.onClickHandler.bind(this);</span><br><span class="line">    this.onClickOutsideHandler = this.onClickOutsideHandler.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span></span>() &#123;</span><br><span class="line">    window.addEventListener(<span class="string">'click'</span>, this.onClickOutsideHandler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentWillUnmount</span></span>() &#123;</span><br><span class="line">    window.removeEventListener(<span class="string">'click'</span>, this.onClickOutsideHandler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">onClickHandler</span></span>() &#123;</span><br><span class="line">    this.setState(currentState =&gt; (&#123;</span><br><span class="line">      isOpen: !currentState.isOpen</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onClickOutsideHandler(event) &#123;</span><br><span class="line">    <span class="keyword">if</span> (this.state.isOpen &amp;&amp; !this.toggleContainer.current.contains(event.target)) &#123;</span><br><span class="line">      this.setState(&#123; isOpen: <span class="literal">false</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">      &lt;div ref=&#123;this.toggleContainer&#125;&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.onClickHandler&#125;&gt;Select an option&lt;/button&gt;</span><br><span class="line">        &#123;this.state.isOpen &amp;&amp; (</span><br><span class="line">          &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;Option 1&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;Option 2&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;Option 3&lt;/li&gt;</span><br><span class="line">          &lt;/ul&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用正确的事件触发器，比如 onBlur 和 onFocus，同样可以达成这项功能：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">class BlurExample extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line"></span><br><span class="line">    this.state = &#123; isOpen: <span class="literal">false</span> &#125;;</span><br><span class="line">    this.timeOutId = null;</span><br><span class="line"></span><br><span class="line">    this.onClickHandler = this.onClickHandler.bind(this);</span><br><span class="line">    this.onBlurHandler = this.onBlurHandler.bind(this);</span><br><span class="line">    this.onFocusHandler = this.onFocusHandler.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">onClickHandler</span></span>() &#123;</span><br><span class="line">    this.setState(currentState =&gt; (&#123;</span><br><span class="line">      isOpen: !currentState.isOpen</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 我们在下一个时间点使用 setTimeout 关闭弹窗。</span><br><span class="line">  // 这是必要的，因为失去焦点事件会在新的焦点事件前被触发，</span><br><span class="line">  // 我们需要通过这个步骤确认这个元素的一个子节点</span><br><span class="line">  // 是否得到了焦点。</span><br><span class="line">  <span class="function"><span class="title">onBlurHandler</span></span>() &#123;</span><br><span class="line">    this.timeOutId = setTimeout(() =&gt; &#123;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        isOpen: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 如果一个子节点获得了焦点，不要关闭弹窗。</span><br><span class="line">  <span class="function"><span class="title">onFocusHandler</span></span>() &#123;</span><br><span class="line">    clearTimeout(this.timeOutId);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">    // React 通过把失去焦点和获得焦点事件传输给父节点</span><br><span class="line">    // 来帮助我们。</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">      &lt;div onBlur=&#123;this.onBlurHandler&#125;</span><br><span class="line">           onFocus=&#123;this.onFocusHandler&#125;&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.onClickHandler&#125;</span><br><span class="line">                aria-haspopup=<span class="string">"true"</span></span><br><span class="line">                aria-expanded=&#123;this.state.isOpen&#125;&gt;</span><br><span class="line">          Select an option</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">        &#123;this.state.isOpen &amp;&amp; (</span><br><span class="line">          &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;Option 1&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;Option 2&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;Option 3&lt;/li&gt;</span><br><span class="line">          &lt;/ul&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="5、更复杂的部件"><a href="#5、更复杂的部件" class="headerlink" title="5、更复杂的部件"></a><font color="#87CEFA">5、更复杂的部件</font></h3><p>即使最复杂的部件也可以实现无障碍访问。</p>
<h3 id="6、其他考虑因素"><a href="#6、其他考虑因素" class="headerlink" title="6、其他考虑因素"></a><font color="#87CEFA">6、其他考虑因素</font></h3><h4 id="1-设置语言"><a href="#1-设置语言" class="headerlink" title="1. 设置语言"></a>1. 设置语言</h4><h4 id="2-设置文档标题"><a href="#2-设置文档标题" class="headerlink" title="2. 设置文档标题"></a>2. 设置文档标题</h4><h4 id="3-色彩对比度"><a href="#3-色彩对比度" class="headerlink" title="3. 色彩对比度"></a>3. 色彩对比度</h4><h3 id="7、开发及测试"><a href="#7、开发及测试" class="headerlink" title="7、开发及测试"></a><font color="#87CEFA">7、开发及测试</font></h3><h4 id="1-键盘"><a href="#1-键盘" class="headerlink" title="1. 键盘"></a>1. 键盘</h4><h4 id="2-开发辅助"><a href="#2-开发辅助" class="headerlink" title="2. 开发辅助"></a>2. 开发辅助</h4><p>  eslint-plugin-jsx-a11y</p>
<h4 id="3-在浏览器中测试无障碍辅助功能"><a href="#3-在浏览器中测试无障碍辅助功能" class="headerlink" title="3. 在浏览器中测试无障碍辅助功能"></a>3. 在浏览器中测试无障碍辅助功能</h4><p>aXe,aXe-core 以及 react-axe<br>WebAIM WAVE<br>无障碍辅助功能检测器和无障碍辅助功能树</p>
<h4 id="4-屏幕朗读器"><a href="#4-屏幕朗读器" class="headerlink" title="4. 屏幕朗读器"></a>4. 屏幕朗读器</h4><ul>
<li><p>常用屏幕朗读器:<br> 火狐中的 NVDA<br> Safari 中的 VoiceOver<br> Internet Explorer 中的 JAWS</p>
</li>
<li><p>其他屏幕朗读器:<br>  Google Chrome 中的 ChromeVox</p>
</li>
</ul>
<h2 id="4-2）代码分割"><a href="#4-2）代码分割" class="headerlink" title="4.2）代码分割"></a><font color="#00BFFF">4.2）代码分割</font></h2><h3 id="1、打包"><a href="#1、打包" class="headerlink" title="1、打包"></a><font color="#87CEFA">1、打包</font></h3><p>大多数 React 应用都会使用 Webpack，Rollup 或 Browserify 这类的构建工具来打包文件。 打包是一个将文件引入并合并到一个单独文件的过程，最终形成一个 “bundle”。 接着在页面上引入该 bundle，整个应用即可一次性加载。</p>
<h3 id="2、代码分割"><a href="#2、代码分割" class="headerlink" title="2、代码分割"></a><font color="#87CEFA">2、代码分割</font></h3><p>对你的应用进行代码分割能够帮助你“懒加载”当前用户所需要的内容，能够显著地提高你的应用性能。尽管并没有减少应用整体的代码体积，但你可以避免加载用户永远不需要的代码，并在初始加载的时候减少所需加载的代码量。</p>
<h3 id="3、import"><a href="#3、import" class="headerlink" title="3、import()"></a><font color="#87CEFA">3、import()</font></h3><p>在应用中引入代码分割的最佳方式是通过动态 import() 语法。<br>当使用 Babel 时，你要确保 Babel 能够解析动态 import 语法而不是将其进行转换。对于这一要求你需要 babel-plugin-syntax-dynamic-import 插件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package.json</span><br><span class="line"></span><br><span class="line">&quot;babel&quot;: &#123;</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    &quot;@babel/plugin-syntax-dynamic-import&quot;,</span><br><span class="line">    [</span><br><span class="line">      &quot;import&quot;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;libraryName&quot;: &quot;antd&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;styled-components&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;babel-plugin-add-react-displayname-babel7&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    &quot;sofa-react&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、React-lazy"><a href="#4、React-lazy" class="headerlink" title="4、React.lazy"></a><font color="#87CEFA">4、React.lazy</font></h3><p>React.lazy 函数能让你像渲染常规组件一样处理动态引入（的组件）。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">使用之前：</span><br><span class="line">import OtherComponent from <span class="string">'./OtherComponent'</span>;</span><br><span class="line"></span><br><span class="line">使用之后：</span><br><span class="line">import React, &#123; Suspense &#125; from <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line">const OtherComponent = React.lazy(() =&gt; import(<span class="string">'./OtherComponent'</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">MyComponent</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt;</span><br><span class="line">        &lt;OtherComponent /&gt;</span><br><span class="line">      &lt;/Suspense&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此代码将会在组件首次渲染时，自动导入包含 OtherComponent 组件的包。</p>
<p>React.lazy 接受一个函数，这个函数需要动态调用 import()。它必须返回一个 Promise，该 Promise 需要 resolve 一个 defalut export 的 React 组件。</p>
<p>然后应在 Suspense 组件中渲染 lazy 组件，如此使得我们可以使用在等待加载 lazy 组件时做优雅降级（如 loading 指示器等）。fallback 属性接受任何在组件加载过程中你想展示的 React 元素。</p>
<h3 id="5、异常捕获边界（Error-boundaries）"><a href="#5、异常捕获边界（Error-boundaries）" class="headerlink" title="5、异常捕获边界（Error boundaries）"></a><font color="#87CEFA">5、异常捕获边界（Error boundaries）</font></h3><p>如果模块加载失败（如网络问题），它会触发一个错误。你可以通过异常捕获边界（Error boundaries）技术来处理这些情况，以显示良好的用户体验并管理恢复事宜。</p>
<h3 id="6、基于路由的代码分割"><a href="#6、基于路由的代码分割" class="headerlink" title="6、基于路由的代码分割"></a><font color="#87CEFA">6、基于路由的代码分割</font></h3><h3 id="7、命名导出（Named-Exports）"><a href="#7、命名导出（Named-Exports）" class="headerlink" title="7、命名导出（Named Exports）"></a><font color="#87CEFA">7、命名导出（Named Exports）</font></h3><h2 id="4-3-Context"><a href="#4-3-Context" class="headerlink" title="4.3) Context"></a><font color="#00BFFF">4.3) Context</font></h2><font color="#00FF00">Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。</font>

<h3 id="1、-何时使用-Context"><a href="#1、-何时使用-Context" class="headerlink" title="1、 何时使用 Context"></a><font color="#87CEFA">1、 何时使用 Context</font></h3><p>Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。</span><br><span class="line">// 为当前的 theme 创建一个 context（“light”为默认值）。</span><br><span class="line">const ThemeContext = React.createContext(<span class="string">'light'</span>);</span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">    // 使用一个 Provider 来将当前的 theme 传递给以下的组件树。</span><br><span class="line">    // 无论多深，任何组件都能读取这个值。</span><br><span class="line">    // 在这个例子中，我们将 “dark” 作为当前的值传递下去。</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">      &lt;ThemeContext.Provider value=<span class="string">"dark"</span>&gt;</span><br><span class="line">        &lt;Toolbar /&gt;</span><br><span class="line">      &lt;/ThemeContext.Provider&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 中间的组件再也不必指明往下传递 theme 了。</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Toolbar</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ThemedButton /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ThemedButton extends React.Component &#123;</span><br><span class="line">  // 指定 contextType 读取当前的 theme context。</span><br><span class="line">  // React 会往上找到最近的 theme Provider，然后使用它的值。</span><br><span class="line">  // 在这个例子中，当前的 theme 值为 “dark”。</span><br><span class="line">  static contextType = ThemeContext;</span><br><span class="line">  <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &lt;Button theme=&#123;this.context&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2、使用-Context-之前的考虑"><a href="#2、使用-Context-之前的考虑" class="headerlink" title="2、使用 Context 之前的考虑"></a><font color="#87CEFA">2、使用 Context 之前的考虑</font></h3><p>Context 主要应用场景在于很多不同层级的组件需要访问同样一些的数据。请谨慎使用，因为这会使得组件的复用性变差。</p>
<h3 id="3、API"><a href="#3、API" class="headerlink" title="3、API"></a><font color="#87CEFA">3、API</font></h3><h4 id="React-createContext"><a href="#React-createContext" class="headerlink" title="React.createContext"></a>React.createContext</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const MyContext = React.createContext(defaultValue);</span><br></pre></td></tr></table></figure>
<h4 id="Context-Provider"><a href="#Context-Provider" class="headerlink" title="Context.Provider"></a>Context.Provider</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyContext.Provider value=&#123;/* 某个值 */&#125;&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Class-contextType"><a href="#Class-contextType" class="headerlink" title="Class.contextType"></a>Class.contextType</h4><h4 id="Context-Consumer"><a href="#Context-Consumer" class="headerlink" title="Context.Consumer"></a>Context.Consumer</h4><h4 id="Context-displayName"><a href="#Context-displayName" class="headerlink" title="Context.displayName"></a>Context.displayName</h4><p>context 对象接受一个名为 displayName 的 property，类型为字符串。React DevTools 使用该字符串来确定 context 要显示的内容。</p>
<h2 id="4-4-错误边界"><a href="#4-4-错误边界" class="headerlink" title="4.4) 错误边界"></a><font color="#00BFFF">4.4) 错误边界</font></h2><h3 id="错误边界"><a href="#错误边界" class="headerlink" title="错误边界"></a>错误边界</h3><div class="post-warning">注意<br>错误边界无法捕获以下场景中产生的错误：<br><br>事件处理<br>异步代码（例如 setTimeout 或 requestAnimationFrame 回调函数）<br>服务端渲染<br>它自身抛出来的错误（并非它的子组件）<br></div>

<p>如果一个 class 组件中定义了 static getDerivedStateFromError() 或 componentDidCatch() 这两个生命周期方法中的任意一个（或两个）时，那么它就变成一个错误边界。当抛出错误后，请使用 static getDerivedStateFromError() 渲染备用 UI ，使用 componentDidCatch() 打印错误信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class ErrorBoundary extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123; hasError: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static getDerivedStateFromError(error) &#123;</span><br><span class="line">    // 更新 state 使下一次渲染能够显示降级后的 UI</span><br><span class="line">    <span class="built_in">return</span> &#123; hasError: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidCatch(error, errorInfo) &#123;</span><br><span class="line">    // 你同样可以将错误日志上报给服务器</span><br><span class="line">    logErrorToMyService(error, errorInfo);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (this.state.hasError) &#123;</span><br><span class="line">      // 你可以自定义降级后的 UI 并渲染</span><br><span class="line">      <span class="built_in">return</span> &lt;h1&gt;Something went wrong.&lt;/h1&gt;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> this.props.children; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后你可以将它作为一个常规组件去使用：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ErrorBoundary&gt;</span><br><span class="line">  &lt;MyWidget /&gt;</span><br><span class="line">&lt;/ErrorBoundary&gt;</span><br></pre></td></tr></table></figure></p>
<p>错误边界的工作方式类似于 JavaScript 的 catch {}，不同的地方在于错误边界只针对 React 组件。只有 class 组件才可以成为错误边界组件。大多数情况下, 你只需要声明一次错误边界组件, 并在整个应用中使用它。</p>
<p>注意错误边界仅可以捕获其子组件的错误，它无法捕获其自身的错误。如果一个错误边界无法渲染错误信息，则错误会冒泡至最近的上层错误边界，这也类似于 JavaScript 中 catch {} 的工作机制。</p>
<h3 id="错误边界应该放置在哪？"><a href="#错误边界应该放置在哪？" class="headerlink" title="错误边界应该放置在哪？"></a>错误边界应该放置在哪？</h3><p>错误边界的粒度由你来决定，可以将其包装在最顶层的路由组件并为用户展示一个 “Something went wrong” 的错误信息，就像服务端框架经常处理崩溃一样。你也可以将单独的部件包装在错误边界以保护应用其他部分不崩溃。</p>
<h3 id="未捕获错误（Uncaught-Errors）的新行为"><a href="#未捕获错误（Uncaught-Errors）的新行为" class="headerlink" title="未捕获错误（Uncaught Errors）的新行为"></a>未捕获错误（Uncaught Errors）的新行为</h3><p>自 React 16 起，任何未被错误边界捕获的错误将会导致整个 React 组件树被卸载。</p>
<h3 id="组件栈追踪"><a href="#组件栈追踪" class="headerlink" title="组件栈追踪"></a>组件栈追踪</h3><p>如果你没有使用 Create React App，可以手动将该插件(@babel/plugin-transform-react-jsx-source)添加到你的 Babel 配置中。注意它仅用于开发环境，<strong>在生产环境必须将其禁用</strong> 。</p>
<h3 id="关于-try-catch-？"><a href="#关于-try-catch-？" class="headerlink" title="关于 try/catch ？"></a>关于 try/catch ？</h3><h3 id="关于事件处理器"><a href="#关于事件处理器" class="headerlink" title="关于事件处理器"></a>关于事件处理器</h3><p>如果你需要在事件处理器内部捕获错误，使用普通的 JavaScript try / catch 语句。</p>
<h3 id="自-React-15-的命名更改"><a href="#自-React-15-的命名更改" class="headerlink" title="自 React 15 的命名更改"></a>自 React 15 的命名更改</h3><p>React 15 中有一个支持有限的错误边界方法 unstable_handleError。此方法不再起作用，同时自 React 16 beta 发布起你需要在代码中将其修改为 componentDidCatch。</p>
<h2 id="4-5-Refs-转发"><a href="#4-5-Refs-转发" class="headerlink" title="4.5) Refs 转发"></a><font color="#00BFFF">4.5) Refs 转发</font></h2><h3 id="转发-refs-到-DOM-组件"><a href="#转发-refs-到-DOM-组件" class="headerlink" title="转发 refs 到 DOM 组件"></a>转发 refs 到 DOM 组件</h3><ul>
<li>Ref 转发是一个可选特性，其允许某些组件接收 ref，并将其向下传递（换句话说，“转发”它）给子组件。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const FancyButton = React.forwardRef((props, ref) =&gt; (</span><br><span class="line">  &lt;button ref=&#123;ref&#125; className=<span class="string">"FancyButton"</span>&gt;</span><br><span class="line">    &#123;props.children&#125;</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line">// 你可以直接获取 DOM button 的 ref：</span><br><span class="line">const ref = React.createRef();</span><br><span class="line">&lt;FancyButton ref=&#123;ref&#125;&gt;Click me!&lt;/FancyButton&gt;;</span><br></pre></td></tr></table></figure>
<p>这样，使用 FancyButton 的组件可以获取底层 DOM 节点 button 的 ref ，并在必要时访问，就像其直接使用 DOM button 一样。</p>
<p>以下是对上述示例发生情况的逐步解释：<br>我们通过调用 React.createRef 创建了一个 React ref 并将其赋值给 ref 变量。<br>我们通过指定 ref 为 JSX 属性，将其向下传递给 <fancybutton ref="{ref}">。<br>React 传递 ref 给 forwardRef 内函数 (props, ref) =&gt; …，作为其第二个参数。<br>我们向下转发该 ref 参数到 &lt; button ref={ref}&gt;，将其指定为 JSX 属性。<br>当 ref 挂载完成，ref.current 将指向 &lt;button> DOM 节点。</fancybutton></p>
<div class="post-warning"><br>注意<br><br>第二个参数 ref 只在使用 React.forwardRef 定义组件时存在。常规函数和 class 组件不接收 ref 参数，且 props 中也不存在 ref。<br><br>Ref 转发不仅限于 DOM 组件，你也可以转发 refs 到 class 组件实例中。<br></div>

<h3 id="组件库维护者的注意事项"><a href="#组件库维护者的注意事项" class="headerlink" title="组件库维护者的注意事项"></a>组件库维护者的注意事项</h3><p>当你开始在组件库中使用 forwardRef 时，你应当将其视为一个破坏性更改，并发布库的一个新的主版本</p>
<h3 id="在高阶组件中转发-refs"><a href="#在高阶组件中转发-refs" class="headerlink" title="在高阶组件中转发 refs"></a>在高阶组件中转发 refs</h3><p>在 DevTools 中显示自定义名称</p>
<h2 id="4-6-Fragments"><a href="#4-6-Fragments" class="headerlink" title="4.6) Fragments"></a><font color="#00BFFF">4.6) Fragments</font></h2><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Columns extends React.Component &#123;</span><br><span class="line">  <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">      &lt;React.Fragment&gt;</span><br><span class="line">        &lt;td&gt;Hello&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;World&lt;/td&gt;</span><br><span class="line">      &lt;/React.Fragment&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="短语法"><a href="#短语法" class="headerlink" title="短语法"></a>短语法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Columns extends React.Component &#123;</span><br><span class="line">  <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;td&gt;Hello&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;World&lt;/td&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以像使用任何其他元素一样使用 &lt;&gt; &lt;/&gt;，除了它不支持 key 或属性。</p>
<h3 id="带-key-的-Fragments"><a href="#带-key-的-Fragments" class="headerlink" title="带 key 的 Fragments"></a>带 key 的 Fragments</h3><p>key 是唯一可以传递给 Fragment 的属性。未来我们可能会添加对其他属性的支持，例如事件。</p>
<h2 id="4-7-高阶组件"><a href="#4-7-高阶组件" class="headerlink" title="4.7) 高阶组件"></a><font color="#00BFFF">4.7) 高阶组件</font></h2><h3 id="使用-HOC-解决横切关注点问题"><a href="#使用-HOC-解决横切关注点问题" class="headerlink" title="使用 HOC 解决横切关注点问题"></a>使用 HOC 解决横切关注点问题</h3><blockquote>
<p>高阶组件（HOC higherOrderComponent）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。<br>  具体而言，高阶组件是参数为组件，返回值为新组件的函数。</p>
</blockquote>
<ul>
<li><p>我们在一个地方定义这个逻辑，并在许多组件之间共享它。这正是高阶组件擅长的地方</p>
</li>
<li><p>请注意，HOC 不会修改传入的组件，也不会使用继承来复制其行为。相反，HOC 通过将组件包装在容器组件中来组成新组件。HOC 是纯函数，没有副作用。</p>
</li>
</ul>
<h3 id="不要改变原始组件。使用组合。"><a href="#不要改变原始组件。使用组合。" class="headerlink" title="不要改变原始组件。使用组合。"></a>不要改变原始组件。使用组合。</h3><blockquote>
<p>您可能已经注意到 HOC 与容器组件模式之间有相似之处。容器组件担任分离将高层和低层关注的责任，由容器管理订阅和状态，并将 prop 传递给处理渲染 UI。HOC 使用容器作为其实现的一部分，你可以将 HOC 视为参数化容器组件。</p>
</blockquote>
<h3 id="约定：将不相关的-props-传递给被包裹的组件"><a href="#约定：将不相关的-props-传递给被包裹的组件" class="headerlink" title="约定：将不相关的 props 传递给被包裹的组件"></a>约定：将不相关的 props 传递给被包裹的组件</h3><h3 id="约定：最大化可组合性"><a href="#约定：最大化可组合性" class="headerlink" title="约定：最大化可组合性"></a>约定：最大化可组合性</h3><p>最常见的 HOC 签名如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// React Redux 的 `connect` 函数</span><br><span class="line">const ConnectedComment = connect(commentSelector, commentActions)(CommentList);</span><br></pre></td></tr></table></figure></p>
<p>刚刚发生了什么？！如果你把它分开，就会更容易看出发生了什么。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// connect 是一个函数，它的返回值为另外一个函数。</span><br><span class="line">const enhance = connect(commentListSelector, commentListActions);</span><br><span class="line">// 返回值为 HOC，它会返回已经连接 Redux store 的组件</span><br><span class="line">const ConnectedComment = enhance(CommentList);</span><br></pre></td></tr></table></figure></p>
<p>换句话说，connect 是一个返回高阶组件的高阶函数！</p>
<h3 id="约定：包装显示名称以便轻松调试"><a href="#约定：包装显示名称以便轻松调试" class="headerlink" title="约定：包装显示名称以便轻松调试"></a>约定：包装显示名称以便轻松调试</h3><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>不要在 render 方法中使用 HOC</li>
<li>务必复制静态方法</li>
<li>Refs 不会被传递</li>
</ol>
<h2 id="4-8）与第三方库协同"><a href="#4-8）与第三方库协同" class="headerlink" title="4.8）与第三方库协同"></a><font color="#00BFFF">4.8）与第三方库协同</font></h2><p>之后可以再看</p>
<h2 id="4-9）深入-JSX"><a href="#4-9）深入-JSX" class="headerlink" title="4.9）深入 JSX"></a><font color="#00BFFF">4.9）深入 JSX</font></h2><p>实际上，JSX 仅仅只是 React.createElement(component, props, …children) 函数的语法糖。如下 JSX 代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyButton color=<span class="string">"blue"</span> shadowSize=&#123;2&#125;&gt;</span><br><span class="line">  Click Me</span><br><span class="line">&lt;/MyButton&gt;</span><br><span class="line">会编译为：</span><br><span class="line"></span><br><span class="line">React.createElement(</span><br><span class="line">  MyButton,</span><br><span class="line">  &#123;color: <span class="string">'blue'</span>, shadowSize: 2&#125;,</span><br><span class="line">  <span class="string">'Click Me'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h3 id="指定-React-元素类型"><a href="#指定-React-元素类型" class="headerlink" title="指定 React 元素类型"></a><font color="#87CEFA">指定 React 元素类型</font></h3><ol>
<li><p>React 必须在作用域内</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import React from <span class="string">'react'</span>;</span><br><span class="line">import CustomButton from <span class="string">'./CustomButton'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">WarningButton</span></span>() &#123;</span><br><span class="line">  // <span class="built_in">return</span> React.createElement(CustomButton, &#123;color: <span class="string">'red'</span>&#125;, null);</span><br><span class="line">  <span class="built_in">return</span> &lt;CustomButton color=<span class="string">"red"</span> /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 JSX 类型中使用点语法<br>在 JSX 中，你也可以使用点语法来引用一个 React 组件。当你在一个模块中导出许多 React 组件时，这会非常方便。例如，如果 MyComponents.DatePicker 是一个组件，你可以在 JSX 中直接使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import React from <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line">const MyComponents = &#123;</span><br><span class="line">  DatePicker: <span class="keyword">function</span> DatePicker(props) &#123;</span><br><span class="line">    <span class="built_in">return</span> &lt;div&gt;Imagine a &#123;props.color&#125; datepicker here.&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">BlueDatePicker</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> &lt;MyComponents.DatePicker color=<span class="string">"blue"</span> /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用户定义的组件必须以大写字母开头</p>
</li>
<li><p>在运行时选择类型<br>如果你想通过通用表达式来（动态）决定元素类型，你需要首先将它赋值给大写字母开头的变量。这通常用于根据 prop 来渲染不同组件的情况下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import React from <span class="string">'react'</span>;</span><br><span class="line">import &#123; PhotoStory, VideoStory &#125; from <span class="string">'./stories'</span>;</span><br><span class="line"></span><br><span class="line">const components = &#123;</span><br><span class="line">  photo: PhotoStory,</span><br><span class="line">  video: VideoStory</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> Story(props) &#123;</span><br><span class="line">  // 正确！JSX 类型可以是大写字母开头的变量。</span><br><span class="line">  const SpecificStory = components[props.storyType];</span><br><span class="line">  <span class="built_in">return</span> &lt;SpecificStory story=&#123;props.story&#125; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="JSX-中的-Props"><a href="#JSX-中的-Props" class="headerlink" title="JSX 中的 Props"></a><font color="#87CEFA">JSX 中的 Props</font></h3><ol>
<li><p>JavaScript 表达式作为 Props</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent foo=&#123;1 + 2 + 3 + 4&#125; /&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串字面量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent message=<span class="string">"hello world"</span> /&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Props 默认值为 “True”<br>如果你没给 prop 赋值，它的默认值是 true。以下两个 JSX 表达式是等价的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyTextBox autocomplete /&gt;</span><br><span class="line"></span><br><span class="line">&lt;MyTextBox autocomplete=&#123;<span class="literal">true</span>&#125; /&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>通常，我们不建议不传递 value 给 prop，因为这可能与 ES6 对象简写混淆，{foo} 是 {foo: foo} 的简写，而不是 {foo: true}。这样实现只是为了保持和 HTML 中标签属性的行为一致。</p>
<ol start="4">
<li>属性展开<br>如果你已经有了一个 props 对象，你可以使用展开运算符 … 来在 JSX 中传递整个 props 对象。以下两个组件是等价的：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">App1</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> &lt;Greeting firstName=<span class="string">"Ben"</span> lastName=<span class="string">"Hector"</span> /&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">App2</span></span>() &#123;</span><br><span class="line">  const props = &#123;firstName: <span class="string">'Ben'</span>, lastName: <span class="string">'Hector'</span>&#125;;</span><br><span class="line">  <span class="built_in">return</span> &lt;Greeting &#123;...props&#125; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>你还可以选择只保留当前组件需要接收的 props，并使用展开运算符将其他 props 传递下去。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const Button = props =&gt; &#123;</span><br><span class="line">  const &#123; kind, ...other &#125; = props;</span><br><span class="line">  const className = kind === <span class="string">"primary"</span> ? <span class="string">"PrimaryButton"</span> : <span class="string">"SecondaryButton"</span>;</span><br><span class="line">  <span class="built_in">return</span> &lt;button className=&#123;className&#125; &#123;...other&#125; /&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const App = () =&gt; &#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Button kind=<span class="string">"primary"</span> onClick=&#123;() =&gt; console.log(<span class="string">"clicked!"</span>)&#125;&gt;</span><br><span class="line">        Hello World!</span><br><span class="line">      &lt;/Button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="JSX-中的子元素"><a href="#JSX-中的子元素" class="headerlink" title="JSX 中的子元素"></a><font color="#87CEFA">JSX 中的子元素</font></h3><ol>
<li>字符串字面量</li>
<li>JSX 子元素</li>
<li>JavaScript 表达式作为子元素</li>
<li>函数作为子元素</li>
<li>布尔类型、Null 以及 Undefined 将会忽略</li>
</ol>
<h2 id="4-10）性能优化-Optimizing-Performance"><a href="#4-10）性能优化-Optimizing-Performance" class="headerlink" title="4.10）性能优化 Optimizing Performance"></a><font color="#00BFFF">4.10）性能优化 Optimizing Performance</font></h2><h3 id="使用生产版本"><a href="#使用生产版本" class="headerlink" title="使用生产版本"></a>使用生产版本</h3><ul>
<li>Create React App</li>
<li>单文件构建</li>
<li>Brunch</li>
<li>Browserify</li>
<li>Rollup</li>
<li>webpack</li>
</ul>
<h3 id="使用-Chrome-Performance-标签分析组件"><a href="#使用-Chrome-Performance-标签分析组件" class="headerlink" title="使用 Chrome Performance 标签分析组件"></a>使用 Chrome Performance 标签分析组件</h3><h3 id="使用开发者工具中的分析器对组件进行分析"><a href="#使用开发者工具中的分析器对组件进行分析" class="headerlink" title="使用开发者工具中的分析器对组件进行分析"></a>使用开发者工具中的分析器对组件进行分析</h3><h3 id="虚拟化长列表"><a href="#虚拟化长列表" class="headerlink" title="虚拟化长列表"></a>虚拟化长列表</h3><h3 id="避免调停"><a href="#避免调停" class="headerlink" title="避免调停"></a>避免调停</h3><p>即使 React 只更新改变了的 DOM 节点，重新渲染仍然花费了一些时间。在大部分情况下它并不是问题，不过如果它已经慢到让人注意了，你可以通过覆盖生命周期方法 shouldComponentUpdate 来进行提速。该方法会在重新渲染前被触发。其默认实现总是返回 true，让 React 执行更新：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你知道在什么情况下你的组件不需要更新，你可以在 shouldComponentUpdate 中返回 false 来跳过整个渲染过程。其包括该组件的 render 调用以及之后的操作。</p>
<p>在大部分情况下，你可以继承 <font color="00FF00">React.PureComponent</font> 以代替手写 shouldComponentUpdate()。它用当前与之前 props 和 state 的浅比较覆写了 shouldComponentUpdate() 的实现。</p>
<h3 id="shouldComponentUpdate-的作用"><a href="#shouldComponentUpdate-的作用" class="headerlink" title="shouldComponentUpdate 的作用"></a>shouldComponentUpdate 的作用</h3><h3 id="不可变数据的力量"><a href="#不可变数据的力量" class="headerlink" title="不可变数据的力量"></a>不可变数据的力量</h3><p>concat、扩展运算符、Object.assign</p>
<p>避免更改你正用于 props 或 state 的值:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">handleClick</span></span>() &#123;</span><br><span class="line">  this.setState(state =&gt; (&#123;</span><br><span class="line">    words: state.words.concat([<span class="string">'marklar'</span>])</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;</span><br><span class="line">ES6 数组支持扩展运算符，这让代码写起来更方便了。如果你在使用 Create React App，该语法已经默认支持了。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">handleClick</span></span>() &#123;</span><br><span class="line">  this.setState(state =&gt; (&#123;</span><br><span class="line">    words: [...state.words, <span class="string">'marklar'</span>],</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>你可以用类似的方式改写代码来避免可变对象的产生。例如，我们有一个叫做 colormap 的对象。我们希望写一个方法来将 colormap.right 设置为 ‘blue’。我们可以这么写：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> updateColorMap(colormap) &#123;</span><br><span class="line">  colormap.right = <span class="string">'blue'</span>;</span><br><span class="line">&#125;</span><br><span class="line">为了不改变原本的对象，我们可以使用 Object.assign 方法：</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> updateColorMap(colormap) &#123;</span><br><span class="line">  <span class="built_in">return</span> Object.assign(&#123;&#125;, colormap, &#123;right: <span class="string">'blue'</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-11）Portals"><a href="#4-11）Portals" class="headerlink" title="4.11）Portals"></a><font color="#00BFFF">4.11）Portals</font></h2><p>Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.createPortal(child, container)</span><br><span class="line">第一个参数（child）是任何可渲染的 React 子元素，例如一个元素，字符串或 fragment。第二个参数（container）是一个 DOM 元素。</span><br></pre></td></tr></table></figure></p>
<h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">  // React 并*没有*创建一个新的 div。它只是把子元素渲染到 `domNode` 中。</span><br><span class="line">  // `domNode` 是一个可以在任何位置的有效 DOM 节点。</span><br><span class="line">  <span class="built_in">return</span> ReactDOM.createPortal(</span><br><span class="line">    this.props.children,</span><br><span class="line">    domNode</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个 portal 的典型用例是当父组件有 overflow: hidden 或 z-index 样式时，但你需要子组件能够在视觉上“跳出”其容器。例如，对话框、悬浮卡以及提示框：</p>
<div class="post-warning"><br>注意:<br><br>当在使用 portal 时, 记住管理键盘焦点就变得尤为重要。<br><br>对于模态对话框，通过遵循 WAI-ARIA 模态开发实践，来确保每个人都能够运用它<br></div>

<h3 id="通过-Portal-进行事件冒泡"><a href="#通过-Portal-进行事件冒泡" class="headerlink" title="通过 Portal 进行事件冒泡"></a>通过 Portal 进行事件冒泡</h3><h2 id="4-12）Profiler-API"><a href="#4-12）Profiler-API" class="headerlink" title="4.12）Profiler API"></a><font color="#00BFFF">4.12）Profiler API</font></h2><p>Profiler 测量渲染一个 React 应用多久渲染一次以及渲染一次的“代价”。 它的目的是识别出应用中渲染较慢的部分，或是可以使用类似 memoization 优化的部分，并从相关优化中获益。</p>
<h2 id="4-13）不使用-ES6"><a href="#4-13）不使用-ES6" class="headerlink" title="4.13）不使用 ES6"></a><font color="#00BFFF">4.13）不使用 ES6</font></h2><p>如果你还未使用过 ES6，你可以使用 create-react-class 模块：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var createReactClass = require(<span class="string">'create-react-class'</span>);</span><br><span class="line">var Greeting = createReactClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>ES6 中的 class 与 createReactClass() 方法十分相似，但有以下几个区别值得注意。</p>
<h3 id="1-声明默认属性"><a href="#1-声明默认属性" class="headerlink" title="1. 声明默认属性"></a>1. 声明默认属性</h3><p>无论是函数组件还是 class 组件，都拥有 defaultProps 属性：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Greeting extends React.Component &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Greeting.defaultProps = &#123;</span><br><span class="line">  name: <span class="string">'Mary'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">如果使用 createReactClass() 方法创建组件，那就需要在组件中定义 getDefaultProps() 函数：</span><br><span class="line">var Greeting = createReactClass(&#123;</span><br><span class="line">  getDefaultProps: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      name: <span class="string">'Mary'</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="2-初始化-State"><a href="#2-初始化-State" class="headerlink" title="2. 初始化 State"></a>2. 初始化 State</h3><p>如果使用 ES6 的 class 关键字创建组件，你可以通过给 this.state 赋值的方式来定义组件的初始 state：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Counter extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;count: props.initialCount&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果使用 createReactClass() 方法创建组件，你需要提供一个单独的 getInitialState 方法，让其返回初始 state：</span><br><span class="line"></span><br><span class="line">var Counter = createReactClass(&#123;</span><br><span class="line">  getInitialState: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;count: this.props.initialCount&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="3-自动绑定"><a href="#3-自动绑定" class="headerlink" title="3. 自动绑定"></a>3. 自动绑定</h3><p>对于使用 ES6 的 class 关键字创建的 React 组件，组件中的方法遵循与常规 ES6 class 相同的语法规则。这意味着这些方法不会自动绑定 this 到这个组件实例。 你需要在 constructor 中显式地调用 .bind(this)：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class SayHello extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;message: <span class="string">'Hello!'</span>&#125;;</span><br><span class="line">    // 这一行很重要！</span><br><span class="line">    this.handleClick = this.handleClick.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">handleClick</span></span>() &#123;</span><br><span class="line">    alert(this.state.message);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">    // 由于 `this.handleClick` 已经绑定至实例，因此我们才可以用它来处理点击事件</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;this.handleClick&#125;&gt;</span><br><span class="line">        Say hello</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">如果使用 createReactClass() 方法创建组件，组件中的方法会自动绑定至实例，所以不需要像上面那样做：</span><br><span class="line"></span><br><span class="line">var SayHello = createReactClass(&#123;</span><br><span class="line">  getInitialState: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;message: <span class="string">'Hello!'</span>&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  handleClick: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    alert(this.state.message);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;this.handleClick&#125;&gt;</span><br><span class="line">        Say hello</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="4-14）不使用-JSX-的-React"><a href="#4-14）不使用-JSX-的-React" class="headerlink" title="4.14）不使用 JSX 的 React"></a><font color="#00BFFF">4.14）不使用 JSX 的 React</font></h2><ul>
<li><p>React 并不强制要求使用 JSX。当你不想在构建环境中配置有关 JSX 编译时，不在 React 中使用 JSX 会更加方便。</p>
</li>
<li><p>每个 JSX 元素只是调用 React.createElement(component, props, …children) 的语法糖。因此，使用 JSX 可以完成的任何事情都可以通过纯 JavaScript 完成。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Hello extends React.Component &#123;</span><br><span class="line">  <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> React.createElement(<span class="string">'div'</span>, null, `Hello <span class="variable">$&#123;this.props.toWhat&#125;</span>`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  React.createElement(Hello, &#123;toWhat: <span class="string">'World'</span>&#125;, null),</span><br><span class="line">  document.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="4-15）协调"><a href="#4-15）协调" class="headerlink" title="4.15）协调"></a><font color="#00BFFF">4.15）协调</font></h2><h3 id="设计动力"><a href="#设计动力" class="headerlink" title="设计动力"></a>设计动力</h3><p>React 在以下两个假设的基础之上提出了一套 O(n) 的启发式算法：</p>
<ol>
<li>两个不同类型的元素会产生出不同的树；</li>
<li>开发者可以通过 key prop 来暗示哪些子元素在不同的渲染下能保持稳定；</li>
</ol>
<h3 id="Diffing-算法"><a href="#Diffing-算法" class="headerlink" title="Diffing 算法"></a>Diffing 算法</h3><ul>
<li>比对不同类型的元素</li>
<li>比对同一类型的元素</li>
<li>比对同类型的组件元素</li>
<li>对子节点进行递归</li>
<li>Keys</li>
<li>权衡</li>
</ul>
<h2 id="4-16）Refs-and-the-DOM"><a href="#4-16）Refs-and-the-DOM" class="headerlink" title="4.16）Refs and the DOM"></a><font color="#00BFFF">4.16）Refs and the DOM</font></h2><h3 id="何时使用-Refs"><a href="#何时使用-Refs" class="headerlink" title="何时使用 Refs"></a>何时使用 Refs</h3><ul>
<li>管理焦点，文本选择或媒体播放。</li>
<li>触发强制动画。</li>
<li>集成第三方 DOM 库。</li>
</ul>
<h3 id="勿过度使用-Refs"><a href="#勿过度使用-Refs" class="headerlink" title="勿过度使用 Refs"></a>勿过度使用 Refs</h3><h3 id="创建-Refs"><a href="#创建-Refs" class="headerlink" title="创建 Refs"></a>创建 Refs</h3><p>Refs 是使用 React.createRef() 创建的，并通过 ref 属性附加到 React 元素。</p>
<h3 id="访问-Refs"><a href="#访问-Refs" class="headerlink" title="访问 Refs"></a>访问 Refs</h3><p>当 ref 被传递给 render 中的元素时，对该节点的引用可以在 ref 的 current 属性中被访问。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const node = this.myRef.current;</span><br></pre></td></tr></table></figure></p>
<h4 id="1-为-DOM-元素添加-ref"><a href="#1-为-DOM-元素添加-ref" class="headerlink" title="1. 为 DOM 元素添加 ref"></a>1. 为 DOM 元素添加 ref</h4><h4 id="2-为-class-组件添加-Ref"><a href="#2-为-class-组件添加-Ref" class="headerlink" title="2. 为 class 组件添加 Ref"></a>2. 为 class 组件添加 Ref</h4><p>请注意，这仅在 CustomTextInput 声明为 class 时才有效<br>你不能在函数组件上使用 ref 属性，因为他们没有实例。</p>
<h4 id="3-Refs-与函数组件"><a href="#3-Refs-与函数组件" class="headerlink" title="3. Refs 与函数组件"></a>3. Refs 与函数组件</h4><font color="00FF00">如果要在函数组件中使用 ref，你可以使用 forwardRef（可与 useImperativeHandle 结合使用），或者可以将该组件转化为 class 组件。</font>

<p>不管怎样，你可以在函数组件内部使用 ref 属性，只要它指向一个 DOM 元素或 class 组件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> CustomTextInput(props) &#123;</span><br><span class="line">  // 这里必须声明 textInput，这样 ref 才可以引用它</span><br><span class="line">  const textInput = useRef(null);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">handleClick</span></span>() &#123;</span><br><span class="line">    textInput.current.focus();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        <span class="built_in">type</span>=<span class="string">"text"</span></span><br><span class="line">        ref=&#123;textInput&#125; /&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        <span class="built_in">type</span>=<span class="string">"button"</span></span><br><span class="line">        value=<span class="string">"Focus the text input"</span></span><br><span class="line">        onClick=&#123;handleClick&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="将-DOM-Refs-暴露给父组件"><a href="#将-DOM-Refs-暴露给父组件" class="headerlink" title="将 DOM Refs 暴露给父组件"></a>将 DOM Refs 暴露给父组件</h3><h3 id="回调-Refs"><a href="#回调-Refs" class="headerlink" title="回调 Refs"></a>回调 Refs</h3><h3 id="过时-API：String-类型的-Refs"><a href="#过时-API：String-类型的-Refs" class="headerlink" title="过时 API：String 类型的 Refs"></a>过时 API：String 类型的 Refs</h3><h3 id="关于回调-refs-的说明"><a href="#关于回调-refs-的说明" class="headerlink" title="关于回调 refs 的说明"></a>关于回调 refs 的说明</h3><h2 id="4-17）Render-Props"><a href="#4-17）Render-Props" class="headerlink" title="4.17）Render Props"></a><font color="#00BFFF">4.17）Render Props</font></h2><h3 id="使用-Render-Props-来解决横切关注点（Cross-Cutting-Concerns）"><a href="#使用-Render-Props-来解决横切关注点（Cross-Cutting-Concerns）" class="headerlink" title="使用 Render Props 来解决横切关注点（Cross-Cutting Concerns）"></a>使用 Render Props 来解决横切关注点（Cross-Cutting Concerns）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 如果你出于某种原因真的想要 HOC，那么你可以轻松实现</span><br><span class="line">// 使用具有 render prop 的普通组件创建一个！</span><br><span class="line"><span class="keyword">function</span> withMouse(Component) &#123;</span><br><span class="line">  <span class="built_in">return</span> class extends React.Component &#123;</span><br><span class="line">    <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">      <span class="built_in">return</span> (</span><br><span class="line">        &lt;Mouse render=&#123;mouse =&gt; (</span><br><span class="line">          &lt;Component &#123;...this.props&#125; mouse=&#123;mouse&#125; /&gt;</span><br><span class="line">        )&#125;/&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-Props-而非-render"><a href="#使用-Props-而非-render" class="headerlink" title="使用 Props 而非 render"></a>使用 Props 而非 render</h3><p>尽管之前的例子使用了 render，我们也可以简单地使用 children prop！<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;Mouse children=&#123;mouse =&gt; (</span><br><span class="line">  &lt;p&gt;鼠标的位置是 &#123;mouse.x&#125;，&#123;mouse.y&#125;&lt;/p&gt;</span><br><span class="line">)&#125;/&gt;</span><br><span class="line">记住，children prop 并不真正需要添加到 JSX 元素的 “attributes” 列表中。相反，你可以直接放置到元素的内部！</span><br><span class="line"></span><br><span class="line">&lt;Mouse&gt;</span><br><span class="line">  &#123;mouse =&gt; (</span><br><span class="line">    &lt;p&gt;鼠标的位置是 &#123;mouse.x&#125;，&#123;mouse.y&#125;&lt;/p&gt;</span><br><span class="line">  )&#125;</span><br><span class="line">&lt;/Mouse&gt;</span><br><span class="line">你将在 react-motion 的 API 中看到此技术。</span><br><span class="line"></span><br><span class="line">由于这一技术的特殊性，当你在设计一个类似的 API 时，你或许会要直接地在你的 propTypes 里声明 children 的类型应为一个函数。</span><br><span class="line"></span><br><span class="line">Mouse.propTypes = &#123;</span><br><span class="line">  children: PropTypes.func.isRequired</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><p>将 Render Props 与 React.PureComponent 一起使用时要小心</p>
<h2 id="4-18）静态类型检查"><a href="#4-18）静态类型检查" class="headerlink" title="4.18）静态类型检查"></a><font color="#00BFFF">4.18）静态类型检查</font></h2><p>像 <font color="00FF00">Flow</font> 和 <font color="00FF00">TypeScript</font> 等这些静态类型检查器，可以在运行前识别某些类型的问题。他们还可以通过增加自动补全等功能来改善开发者的工作流程。出于这个原因，我们建议在大型代码库中使用 Flow 或 TypeScript 来代替 PropTypes。</p>
<h3 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h3><p>Flow 是一个针对 JavaScript 代码的静态类型检测器</p>
<h3 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h3><p>TypeScript 是一种由微软开发的编程语言。它是 JavaScript 的一个类型超集，包含独立的编译器。作为一种类型语言，TypeScript 可以在构建时发现 bug 和错误，这样程序运行时就可以避免此类错误。<br>(<a href="https://www.typescriptlang.org/" target="_blank" rel="noopener">https://www.typescriptlang.org/</a>)</p>
<h3 id="Reason"><a href="#Reason" class="headerlink" title="Reason"></a>Reason</h3><p>Reason 不是一种新的语言；它是一种新的语法和工具链，底层使用的是经过实战验证的 OCaml 语言。Reason 在 OCaml 之上提供了 JavaScript 程序员的熟悉语法，而且集成了现有的 NPM/Yarn 工作流。</p>
<h3 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h3><p>Kotlin 是由 JetBrains 开发的一门静态类型语言。其目标平台包括 JVM、Android、LLVM 和 JavaScript。</p>
<h3 id="其他语言"><a href="#其他语言" class="headerlink" title="其他语言"></a>其他语言</h3><p>注意，还有其他静态类型语言可以编译成 JavaScript，也与 React 兼容。例如，和 elmish-react 一起使用的 F#/Fable。</p>
<h2 id="4-19）严格模式"><a href="#4-19）严格模式" class="headerlink" title="4.19）严格模式"></a><font color="#00BFFF">4.19）严格模式</font></h2><p>StrictMode 是一个用来突出显示应用程序中潜在问题的工具。与 Fragment 一样，StrictMode 不会渲染任何可见的 UI。它为其后代元素触发额外的检查和警告。</p>
<div class="post-warning"><strong>注意：</strong><br>严格模式检查仅在开发模式下运行；它们不会影响生产构建。<br></div>

<h3 id="识别不安全的生命周期"><a href="#识别不安全的生命周期" class="headerlink" title="识别不安全的生命周期"></a>识别不安全的生命周期</h3><h3 id="关于使用过时字符串-ref-API-的警告"><a href="#关于使用过时字符串-ref-API-的警告" class="headerlink" title="关于使用过时字符串 ref API 的警告"></a>关于使用过时字符串 ref API 的警告</h3><h3 id="关于使用废弃的-findDOMNode-方法的警告"><a href="#关于使用废弃的-findDOMNode-方法的警告" class="headerlink" title="关于使用废弃的 findDOMNode 方法的警告"></a>关于使用废弃的 findDOMNode 方法的警告</h3><h3 id="检测意外的副作用"><a href="#检测意外的副作用" class="headerlink" title="检测意外的副作用"></a>检测意外的副作用</h3><h3 id="检测过时的-context-API"><a href="#检测过时的-context-API" class="headerlink" title="检测过时的 context API"></a>检测过时的 context API</h3><h2 id="4-20）使用-PropTypes-进行类型检查"><a href="#4-20）使用-PropTypes-进行类型检查" class="headerlink" title="4.20）使用 PropTypes 进行类型检查"></a><font color="#00BFFF">4.20）使用 PropTypes 进行类型检查</font></h2><h2 id="4-21）非受控组件"><a href="#4-21）非受控组件" class="headerlink" title="4.21）非受控组件"></a><font color="#00BFFF">4.21）非受控组件</font></h2><ul>
<li><p>默认值 defaultValue</p>
</li>
<li><p>文件输入</p>
</li>
</ul>
<h2 id="4-22）Web-Components"><a href="#4-22）Web-Components" class="headerlink" title="4.22）Web Components"></a><font color="#00BFFF">4.22）Web Components</font></h2><h1 id="五、API"><a href="#五、API" class="headerlink" title="五、API"></a><font color="#4169E1">五、API</font></h1><h2 id="5-1）React"><a href="#5-1）React" class="headerlink" title="5.1）React"></a><font color="#00BFFF">5.1）React</font></h2><blockquote>
<p>React 是 React 库的入口。如果你通过使用 &lt; script&gt; 标签的方式来加载 React，则可以通过 React 全局变量对象来获得 React 的顶层 API。当你使用 ES6 与 npm 时，可以通过编写 import React from ‘react’ 来引入它们。当你使用 ES5 与 npm 时，则可以通过编写 var React = require(‘react’) 来引入它们。</p>
</blockquote>
<h3 id="1-组件"><a href="#1-组件" class="headerlink" title="1. 组件"></a><font color="87CEFA">1. 组件</font></h3><p>React.Component<br>React.PureComponent<br>create-react-class<br>React.memo</p>
<blockquote>
<p>React.PureComponent 与 React.Component 很相似。两者的区别在于 React.Component 并未实现 shouldComponentUpdate()，而 React.PureComponent 中以浅层对比 prop 和 state 的方式来实现了该函数。你也可以考虑使用 <font color="#00FF00">immutable</font> 对象加速嵌套数据的比较。</p>
</blockquote>
<p>此外，React.PureComponent 中的 shouldComponentUpdate() 将跳过所有子组件树的 prop 更新。因此，请确保所有子组件也都是“纯”的组件。</p>
<h3 id="2-创建React元素"><a href="#2-创建React元素" class="headerlink" title="2. 创建React元素"></a><font color="87CEFA">2. 创建React元素</font></h3><p>JSX<br>createElement()<br>createFactory()</p>
<h3 id="3-转换元素"><a href="#3-转换元素" class="headerlink" title="3. 转换元素"></a><font color="87CEFA">3. 转换元素</font></h3><p>cloneElement()<br>isValidElement()<br>React.Children</p>
<blockquote>
<p>React.isValidElement(object)<br>  验证对象是否为 React 元素，返回值为 true 或 false。</p>
</blockquote>
<blockquote>
<p>React.Children.map(children, function[(thisArg)])<br>  注意:如果 children 是一个 Fragment 对象，它将被视为单一子节点的情况处理，而不会被遍历。</p>
<ul>
<li>React.Children.forEach<br>React.Children.count, 返回 children 中的组件总数量。<br>React.Children.only, 验证 children 是否只有一个子节点（一个 React 元素），如果有则返回它，否则此方法会抛出错误。<br>React.Children.toArray</li>
</ul>
</blockquote>
<h3 id="4-Fragments"><a href="#4-Fragments" class="headerlink" title="4. Fragments"></a><font color="87CEFA">4. Fragments</font></h3><p>React.Fragment</p>
<h3 id="5-Refs"><a href="#5-Refs" class="headerlink" title="5. Refs"></a><font color="87CEFA">5. Refs</font></h3><p>React.createRef<br>React.forwardRef</p>
<blockquote>
<p>React.forwardRef 会创建一个React组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。这种技术并不常见，但在以下两种场景中特别有用：</p>
</blockquote>
<p>转发 refs 到 DOM 组件<br>在高阶组件中转发 refs<br>React.forwardRef 接受渲染函数作为参数。React 将使用 props 和 ref 作为参数来调用此函数。此函数应返回 React 节点。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const FancyButton = React.forwardRef((props, ref) =&gt; (</span><br><span class="line">  &lt;button ref=&#123;ref&#125; className=<span class="string">"FancyButton"</span>&gt;</span><br><span class="line">    &#123;props.children&#125;</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line">// You can now get a ref directly to the DOM button:</span><br><span class="line">const ref = React.createRef();</span><br><span class="line">&lt;FancyButton ref=&#123;ref&#125;&gt;Click me!&lt;/FancyButton&gt;;</span><br></pre></td></tr></table></figure></p>
<h3 id="6-Suspense"><a href="#6-Suspense" class="headerlink" title="6. Suspense"></a><font color="87CEFA">6. Suspense</font></h3><p>Suspense 使得组件可以“等待”某些操作结束后，再进行渲染。目前，Suspense 仅支持的使用场景是：通过 React.lazy 动态加载组件。它将在未来支持其它使用场景，如数据获取等。</p>
<p>React.lazy<br>React.Suspense</p>
<blockquote>
<p>React.Suspense 可以指定加载指示器（loading indicator），以防其组件树中的某些子组件尚未具备渲染条件。目前，懒加载组件是 &lt;React.Suspense&gt; 支持的唯一用例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 该组件是动态加载的</span><br><span class="line">const OtherComponent = React.lazy(() =&gt; import(<span class="string">'./OtherComponent'</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">MyComponent</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    // 显示 &lt;Spinner&gt; 组件直至 OtherComponent 加载完成</span><br><span class="line">    &lt;React.Suspense fallback=&#123;&lt;Spinner /&gt;&#125;&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;OtherComponent /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/React.Suspense&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="7-Hook"><a href="#7-Hook" class="headerlink" title="7. Hook"></a><font color="87CEFA">7. Hook</font></h3><p>Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</p>
<ul>
<li><p><strong>基础 Hook</strong><br>useState<br>useEffect<br>useContext</p>
</li>
<li><p><strong>额外的 Hook</strong><br>useReducer<br>useCallback<br>useMemo<br>useRef<br>useImperativeHandle<br>useLayoutEffect<br>useDebugValue</p>
</li>
</ul>
<h2 id="5-2）组件的生命周期"><a href="#5-2）组件的生命周期" class="headerlink" title="5.2）组件的生命周期"></a><font color="#00BFFF">5.2）组件的生命周期</font></h2><h3 id="1-生命周期图谱"><a href="#1-生命周期图谱" class="headerlink" title="1. 生命周期图谱"></a><font color="87CEFA">1. 生命周期图谱</font></h3><p><img src="../../../../images/lifeCycleA.png"><br><img src="../../../../images/lifeCycleB.png"></p>
<ul>
<li><p>挂载<br>constructor()<br>static getDerivedStateFromProps()<br>render()<br>componentDidMount()</p>
</li>
<li><p>更新<br>static getDerivedStateFromProps()<br>shouldComponentUpdate()<br>render()<br>getSnapshotBeforeUpdate()<br>componentDidUpdate()</p>
</li>
<li><p>卸载<br>componentWillUnmount()</p>
<div class="post-warning"><strong>注意:</strong><br>  下述生命周期方法即将过时，在新代码中应该避免使用它们：<br>  UNSAFE_componentWillMount()<br>  UNSAFE_componentWillUpdate()<br>  UNSAFE_componentWillReceiveProps()<br></div>

</li>
</ul>
<h3 id="2-常用的生命周期方法"><a href="#2-常用的生命周期方法" class="headerlink" title="2. 常用的生命周期方法"></a><font color="87CEFA">2. 常用的生命周期方法</font></h3><h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor()"></a><font color="87CEFA">constructor()</font></h4><ul>
<li><p>如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数。</p>
</li>
<li><p>在其他语句之前前调用 super(props)</p>
</li>
<li><p>通常，在 React 中，构造函数仅用于以下两种情况：<br>通过给 this.state 赋值对象来初始化内部 state。<br>为事件处理函数绑定实例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">constructor(props) &#123;</span><br><span class="line">  super(props);</span><br><span class="line">  // 不要在这里调用 this.setState()</span><br><span class="line">  this.state = &#123; counter: 0 &#125;;</span><br><span class="line">  this.handleClick = this.handleClick.bind(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount()"></a><font color="87CEFA">componentDidMount()</font></h4><ul>
<li><font color="#0f0">componentDidMount() 会在组件挂载后（插入 DOM 树中）立即调用。依赖于 DOM 节点的初始化应该放在这里。如需通过网络请求获取数据，此处是实例化请求的好地方。</font>
</li>
<li><p>你可以在 componentDidMount() 里直接调用 setState()。它将触发额外渲染，但此渲染会发生在浏览器更新屏幕之前。如此保证了即使在 render() 两次调用的情况下，用户也不会看到中间状态。请谨慎使用该模式，因为它会导致性能问题。通常，你应该在 constructor() 中初始化 state。如果你的渲染依赖于 DOM 节点的大小或位置，比如实现 modals 和 tooltips 等情况下，你可以使用此方式处理。</p>
</li>
</ul>
<h4 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate()"></a><font color="87CEFA">componentDidUpdate()</font></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">componentDidUpdate(prevProps, prevState, snapshot)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>当组件更新后，可以在此处对 DOM 进行操作。如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求。（例如，当 props 未发生变化时，则不会执行网络请求）。</p>
</li>
<li><p>你也可以在 componentDidUpdate() 中直接调用 setState()，但请注意它必须被包裹在一个条件语句里，正如上述的例子那样进行处理，否则会导致死循环。它还会导致额外的重新渲染，虽然用户不可见，但会影响组件性能。不要将 props “镜像”给 state，请考虑直接使用 props。</p>
</li>
<li><p>如果组件实现了 getSnapshotBeforeUpdate() 生命周期（不常用），则它的返回值将作为 componentDidUpdate() 的第三个参数 “snapshot” 参数传递。否则此参数将为 undefined。</p>
</li>
</ul>
<div class="post-warning"><strong>注意</strong><br>如果shouldComponentUpdate()返回值为false，则不会调用componentDidUpdate()。<br></div>

<h4 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount()"></a><font color="87CEFA">componentWillUnmount()</font></h4><ul>
<li><p>componentWillUnmount() 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 componentDidMount() 中创建的订阅等。</p>
</li>
<li><p>componentWillUnmount() 中不应调用 setState()，因为该组件将永远不会重新渲染。组件实例卸载后，将永远不会再挂载它。</p>
</li>
</ul>
<h3 id="3-不常用的生命周期方法"><a href="#3-不常用的生命周期方法" class="headerlink" title="3. 不常用的生命周期方法"></a><font color="87CEFA">3. 不常用的生命周期方法</font></h3><h4 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate()"></a><font color="87CEFA">shouldComponentUpdate()</font></h4><h4 id="static-getDerivedStateFromProps"><a href="#static-getDerivedStateFromProps" class="headerlink" title="static getDerivedStateFromProps()"></a><font color="87CEFA">static getDerivedStateFromProps()</font></h4><p>static getDerivedStateFromProps()会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。</p>
<h4 id="getSnapshotBeforeUpdate"><a href="#getSnapshotBeforeUpdate" class="headerlink" title="getSnapshotBeforeUpdate()"></a><font color="87CEFA">getSnapshotBeforeUpdate()</font></h4><ul>
<li><p>getSnapshotBeforeUpdate() 在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为参数传递给 componentDidUpdate()。</p>
</li>
<li><p>此用法并不常见，但它可能出现在 UI 处理中，如需要以特殊方式处理滚动位置的聊天线程等。</p>
</li>
<li><p>应返回 snapshot 的值（或 null）。</p>
</li>
</ul>
<h4 id="Error-boundaries"><a href="#Error-boundaries" class="headerlink" title="Error boundaries"></a><font color="87CEFA">Error boundaries</font></h4><ul>
<li><p>Error boundaries 是 React 组件，它会在其子组件树中的任何位置捕获 JavaScript 错误，并记录这些错误，展示降级 UI 而不是崩溃的组件树。Error boundaries 组件会捕获在渲染期间，在生命周期方法以及其整个树的构造函数中发生的错误。</p>
</li>
<li><p>如果 class 组件定义了生命周期方法 static getDerivedStateFromError() 或 componentDidCatch() 中的任何一个（或两者），它就成为了 Error boundaries。通过生命周期更新 state 可让组件捕获树中未处理的 JavaScript 错误并展示降级 UI。</p>
</li>
<li><p>仅使用 Error boundaries 组件来从意外异常中恢复的情况；不要将它们用于流程控制。</p>
</li>
</ul>
<h4 id="static-getDerivedStateFromError"><a href="#static-getDerivedStateFromError" class="headerlink" title="static getDerivedStateFromError()"></a><font color="87CEFA">static getDerivedStateFromError()</font></h4><ul>
<li>此生命周期会在后代组件抛出错误后被调用。 它将抛出的错误作为参数，并返回一个值以更新 state<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class ErrorBoundary extends React.Component&lt;object, IState&gt; &#123;</span><br><span class="line">  public static <span class="function"><span class="title">getDerivedStateFromError</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123; hasError: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  constructor(props: object) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      hasError: <span class="literal">false</span>,</span><br><span class="line">      errorMessage: <span class="string">''</span>,</span><br><span class="line">      errorInfo: <span class="string">''</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public componentDidCatch(error: any, info: any) &#123;</span><br><span class="line">    // 错误上报</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      errorMessage: error,</span><br><span class="line">      errorInfo: info,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public <span class="function"><span class="title">render</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (this.state.hasError) &#123;</span><br><span class="line">      <span class="built_in">return</span> (&lt;&gt;</span><br><span class="line">        &lt;h1&gt;Something went wrong.&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;&#123; this.state.errorMessage.toString() &#125;&lt;/h2&gt;</span><br><span class="line">        &lt;pre&gt;&#123; this.state.errorInfo &amp;&amp; this.state.errorInfo.componentStack &#125;&lt;/pre&gt;</span><br><span class="line">      &lt;/&gt;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> this.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="componentDidCatch"><a href="#componentDidCatch" class="headerlink" title="componentDidCatch()"></a><font color="87CEFA">componentDidCatch()</font></h4><h3 id="4-其他-API"><a href="#4-其他-API" class="headerlink" title="4. 其他 API"></a>4. 其他 API</h3><p>setState()<br>forceUpdate()</p>
<h3 id="5-Class-属性"><a href="#5-Class-属性" class="headerlink" title="5. Class 属性"></a>5. Class 属性</h3><p>defaultProps<br>displayName</p>
<h3 id="6-实例属性"><a href="#6-实例属性" class="headerlink" title="6. 实例属性"></a>6. 实例属性</h3><p>props<br>state</p>
<h2 id="5-3）React-DOM"><a href="#5-3）React-DOM" class="headerlink" title="5.3）React DOM"></a><font color="#00BFFF">5.3）React DOM</font></h2><p>react-dom 的 package 提供了可在应用顶层使用的 DOM（DOM-specific）方法，如果有需要，你可以把这些方法用于 React 模型以外的地方。不过一般情况下，大部分组件都不需要使用这个模块。</p>
<p>render()<br>hydrate()<br>unmountComponentAtNode()<br>findDOMNode()<br>createPortal()</p>
<h2 id="5-4）ReactDOMServer"><a href="#5-4）ReactDOMServer" class="headerlink" title="5.4）ReactDOMServer"></a><font color="#00BFFF">5.4）ReactDOMServer</font></h2><p>下述方法可以被使用在服务端和浏览器环境。</p>
<p>renderToString()<br>renderToStaticMarkup()<br>下述附加方法依赖一个只能在服务端使用的 package（stream）。它们在浏览器中不起作用。</p>
<p>renderToNodeStream()<br>renderToStaticNodeStream()</p>
<h2 id="5-5）DOM元素"><a href="#5-5）DOM元素" class="headerlink" title="5.5）DOM元素"></a><font color="#00BFFF">5.5）DOM元素</font></h2><h3 id="属性差异"><a href="#属性差异" class="headerlink" title="属性差异"></a>属性差异</h3><ul>
<li>checked</li>
<li>className</li>
<li><p>dangerouslySetInnerHTML<br>dangerouslySetInnerHTML 是 React 为浏览器 DOM 提供 innerHTML 的替换方案。通常来讲，使用代码直接设置 HTML 存在风险，因为很容易无意中使用户暴露于跨站脚本（XSS）的攻击。因此，你可以直接在 React 中设置 HTML，但当你想设置 dangerouslySetInnerHTML 时，需要向其传递包含 key 为 __html 的对象，以此来警示你。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">createMarkup</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> &#123;__html: <span class="string">'First &amp;middot; Second'</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">MyComponent</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> &lt;div dangerouslySetInnerHTML=&#123;createMarkup()&#125; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>htmlFor</p>
</li>
<li>onChange</li>
<li>selected</li>
<li>style</li>
<li>suppressContentEditableWarning</li>
<li>suppressHydrationWarning</li>
<li>value</li>
</ul>
<h3 id="All-Supported-HTML-Attributes"><a href="#All-Supported-HTML-Attributes" class="headerlink" title="All Supported HTML Attributes"></a>All Supported HTML Attributes</h3><h2 id="5-6）合成事件"><a href="#5-6）合成事件" class="headerlink" title="5.6）合成事件"></a><font color="#00BFFF">5.6）合成事件</font></h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>SyntheticEvent 实例将被传递给你的事件处理函数，它是浏览器的原生事件的跨浏览器包装器。除兼容所有浏览器外，它还拥有和浏览器原生事件相同的接口，包括 stopPropagation() 和 preventDefault()。</p>
<p>如果因为某些原因，当你需要使用浏览器的底层事件时，只需要使用 nativeEvent 属性来获取即可。每个 SyntheticEvent 对象都包含以下属性：</p>
<p>boolean bubbles<br>boolean cancelable<br>DOMEventTarget currentTarget<br>boolean defaultPrevented<br>number eventPhase<br>boolean isTrusted<br>DOMEvent nativeEvent<br>void preventDefault()<br>boolean isDefaultPrevented()<br>void stopPropagation()<br>boolean isPropagationStopped()<br>void persist()<br>DOMEventTarget target<br>number timeStamp<br>string type</p>
<h3 id="事件池"><a href="#事件池" class="headerlink" title="事件池"></a>事件池</h3><p>SyntheticEvent 是合并而来。这意味着 SyntheticEvent 对象可能会被重用，而且在事件回调函数被调用后，所有的属性都会无效。出于性能考虑，你不能通过异步访问事件。</p>
<h3 id="支持的事件"><a href="#支持的事件" class="headerlink" title="支持的事件"></a>支持的事件</h3><h4 id="剪贴板事件"><a href="#剪贴板事件" class="headerlink" title="剪贴板事件"></a>剪贴板事件</h4><p>事件名：onCopy onCut onPaste<br>属性: DOMDataTransfer clipboardData</p>
<h4 id="复合事件"><a href="#复合事件" class="headerlink" title="复合事件"></a>复合事件</h4><p>事件名: onCompositionEnd onCompositionStart onCompositionUpdate<br>属性: string data</p>
<h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h4><p>事件名: onKeyDown onKeyPress onKeyUp<br>属性:<br>    boolean altKey<br>    number charCode<br>    boolean ctrlKey<br>    boolean getModifierState(key)<br>    string key<br>    number keyCode<br>    string locale<br>    number location<br>    boolean metaKey<br>    boolean repeat<br>    boolean shiftKey<br>    number which</p>
<h4 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h4><p>事件名: onFocus onBlur<br>属性: DOMEventTarget relatedTarget</p>
<h4 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h4><p>事件名: onChange onInput onInvalid onReset onSubmit </p>
<h4 id="通用事件"><a href="#通用事件" class="headerlink" title="通用事件"></a>通用事件</h4><p>事件名: onError onLoad</p>
<h4 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h4><p>事件名: onClick onContextMenu onDoubleClick onDrag onDragEnd onDragEnter onDragExit<br>onDragLeave onDragOver onDragStart onDrop onMouseDown onMouseEnter onMouseLeave<br>onMouseMove onMouseOut onMouseOver onMouseUp<br>属性:<br>    boolean altKey<br>    number button<br>    number buttons<br>    number clientX<br>    number clientY<br>    boolean ctrlKey<br>    boolean getModifierState(key)<br>    boolean metaKey<br>    number pageX<br>    number pageY<br>    DOMEventTarget relatedTarget<br>    number screenX<br>    number screenY<br>    boolean shiftKey</p>
<ul>
<li>onMouseEnter 和 onMouseLeave 事件从离开的元素向进入的元素传播，不是正常的冒泡，也没有捕获阶段。</li>
</ul>
<h4 id="指针事件"><a href="#指针事件" class="headerlink" title="指针事件"></a>指针事件</h4><p>事件名: onPointerDown onPointerMove onPointerUp onPointerCancel onGotPointerCapture<br>onLostPointerCapture onPointerEnter onPointerLeave onPointerOver onPointerOut<br>属性:<br>    number pointerId<br>    number width<br>    number height<br>    number pressure<br>    number tangentialPressure<br>    number tiltX<br>    number tiltY<br>    number twist<br>    string pointerType<br>    boolean isPrimary</p>
<ul>
<li>onPointerEnter 和 onPointerLeave 事件从离开的元素向进入的元素传播，不是正常的冒泡，也没有捕获阶段。</li>
</ul>
<h4 id="选择事件"><a href="#选择事件" class="headerlink" title="选择事件"></a>选择事件</h4><p>事件名: onSelect</p>
<h4 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h4><p>事件名: onTouchCancel onTouchEnd onTouchMove onTouchStart<br>属性:<br>    boolean altKey<br>    DOMTouchList changedTouches<br>    boolean ctrlKey<br>    boolean getModifierState(key)<br>    boolean metaKey<br>    boolean shiftKey<br>    DOMTouchList targetTouches<br>    DOMTouchList touches</p>
<h4 id="UI-事件"><a href="#UI-事件" class="headerlink" title="UI 事件"></a>UI 事件</h4><p>事件名: onScroll<br>属性: number detail<br>      DOMAbstractView view</p>
<h4 id="滚轮事件"><a href="#滚轮事件" class="headerlink" title="滚轮事件"></a>滚轮事件</h4><p>事件名: onWheel<br>属性:<br>    number deltaMode<br>    number deltaX<br>    number deltaY<br>    number deltaZ</p>
<h4 id="媒体事件"><a href="#媒体事件" class="headerlink" title="媒体事件"></a>媒体事件</h4><p>事件名: onAbort onCanPlay onCanPlayThrough onDurationChange onEmptied onEncrypted<br>onEnded onError onLoadedData onLoadedMetadata onLoadStart onPause onPlay<br>onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend<br>onTimeUpdate onVolumeChange onWaiting</p>
<h4 id="图像事件"><a href="#图像事件" class="headerlink" title="图像事件"></a>图像事件</h4><p>事件名: onLoad onError</p>
<h4 id="动画事件"><a href="#动画事件" class="headerlink" title="动画事件"></a>动画事件</h4><p>事件名: onAnimationStart onAnimationEnd onAnimationIteration<br>属性:<br>    string animationName<br>    string pseudoElement<br>    float elapsedTime</p>
<h4 id="过渡事件"><a href="#过渡事件" class="headerlink" title="过渡事件"></a>过渡事件</h4><p>事件名: onTransitionEnd<br>属性:<br>    string propertyName<br>    string pseudoElement<br>    float elapsedTime</p>
<h4 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h4><p>事件名: onToggle</p>
<h2 id="5-7）React-术语词汇表"><a href="#5-7）React-术语词汇表" class="headerlink" title="5.7）React 术语词汇表"></a><font color="#00BFFF">5.7）React 术语词汇表</font></h2><h3 id="单页面应用-SPA"><a href="#单页面应用-SPA" class="headerlink" title="单页面应用 SPA"></a><font color="#00BFFF">单页面应用 SPA</font></h3><p>单页面应用(single-page application)，是一个应用程序，它可以加载单个 HTML 页面，以及运行应用程序所需的所有必要资源（例如 JavaScript 和 CSS）。与页面或后续页面的任何交互，都不再需要往返 server 加载资源，即页面不会重新加载。</p>
<h3 id="ES6-ES2015-ES2016-等"><a href="#ES6-ES2015-ES2016-等" class="headerlink" title="ES6, ES2015, ES2016 等"></a><font color="#00BFFF">ES6, ES2015, ES2016 等</font></h3><p>这些首字母缩写都是指 ECMAScript 语言规范标准的最新版本，JavaScript 语言是此标准的一个实现。其中 ES6 版本（也称为 ES2015）包括对前面版本的许多补充，例如：箭头函数、class、模板字面量、let 和 const 语句。(<a href="https://es6.ruanyifeng.com/" target="_blank" rel="noopener">https://es6.ruanyifeng.com/</a>)</p>
<h3 id="Compiler（编译器）"><a href="#Compiler（编译器）" class="headerlink" title="Compiler（编译器）"></a><font color="#00BFFF">Compiler（编译器）</font></h3><p>JavaScript compiler 接收 JavaScript 代码，然后对其进行转换，最终返回不同格式的 JavaScript 代码。最为常见的使用示例是，接收 ES6 语法，然后将其转换为旧版本浏览器能够解释执行的语法。Babel 是 React 最常用的 compiler。</p>
<h3 id="Bundler（打包工具）"><a href="#Bundler（打包工具）" class="headerlink" title="Bundler（打包工具）"></a><font color="#00BFFF">Bundler（打包工具）</font></h3><p>bundler 会接收写成单独模块（通常有数百个）的 JavaScript 和 CSS 代码，然后将它们组合在一起，最终生成出一些为浏览器优化的文件。常用的打包 React 应用的工具有 webpack 和 Browserify。</p>
<h3 id="Package-管理工具"><a href="#Package-管理工具" class="headerlink" title="Package 管理工具"></a><font color="#00BFFF">Package 管理工具</font></h3><p>package 管理工具，是帮助你管理项目依赖的工具。npm 和 Yarn 是两个常用的管理 React 应用依赖的 package 管理工具。它们都是使用了相同 npm package registry 的客户端。</p>
<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a><font color="#00BFFF">CDN</font></h3><p>CDN 代表内容分发网络（Content Delivery Network）。CDN 会通过一个遍布全球的服务器网络来分发缓存的静态内容。</p>
<h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a><font color="#00BFFF">JSX</font></h3><p>JSX 是一个 JavaScript 语法扩展。它类似于模板语言，但它具有 JavaScript 的全部能力。JSX 最终会被编译为 React.createElement() 函数调用，返回称为 “React 元素” 的普通 JavaScript 对象。</p>
<h3 id="元素"><a href="#元素" class="headerlink" title="元素"></a><font color="#00BFFF">元素</font></h3><p>React 元素是构成 React 应用的基础砖块。人们可能会把元素与广为人知的“组件”概念相互混淆。元素描述了你在屏幕上想看到的内容。React 元素是不可变对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;</span><br></pre></td></tr></table></figure></p>
<p>通常我们不会直接使用元素，而是从组件中返回元素。</p>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a><font color="#00BFFF">组件</font></h3><ol>
<li>props<br>props 是 React 组件的输入。它们是从父组件向下传递给子组件的数据。</li>
</ol>
<p>记住，props 是只读的。不应以任何方式修改它们：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 错误做法！</span><br><span class="line">props.number = 42;</span><br></pre></td></tr></table></figure></p>
<p>如果你想要修改某些值，以响应用户输入或网络响应，请使用 state 来作为替代。</p>
<ol start="2">
<li>props.children<br>每个组件都可以获取到 props.children。它包含组件的开始标签和结束标签之间的内容</li>
</ol>
<ol start="3">
<li>state</li>
</ol>
<ul>
<li>当组件中的一些数据在某些时刻发生变化时，这时就需要使用 state 来跟踪状态。</li>
<li>state 和 props 之间最重要的区别是：props 由父组件传入，而 state 由组件本身管理。组件不能修改 props，但它可以修改 state。</li>
</ul>
<h3 id="生命周期方法"><a href="#生命周期方法" class="headerlink" title="生命周期方法"></a><font color="#00BFFF">生命周期方法</font></h3><p>生命周期方法，用于在组件不同阶段执行自定义功能。在组件被创建并插入到 DOM 时（即挂载中阶段（mounting）），组件更新时，组件取消挂载或从 DOM 中删除时，都有可以使用的生命周期方法。</p>
<h3 id="受控组件-vs-非受控组件"><a href="#受控组件-vs-非受控组件" class="headerlink" title="受控组件 vs 非受控组件"></a><font color="#00BFFF">受控组件 vs 非受控组件</font></h3><p>React 有两种不同的方式来处理表单输入。</p>
<p>如果一个 input 表单元素的值是由 React 控制，就其称为受控组件。当用户将数据输入到受控组件时，会触发修改状态的事件处理器，这时由你的代码来决定此输入是否有效（如果有效就使用更新后的值重新渲染）。如果不重新渲染，则表单元素将保持不变。</p>
<p>一个非受控组件，就像是运行在 React 体系之外的表单元素。当用户将数据输入到表单字段（例如 input，dropdown 等）时，React 不需要做任何事情就可以映射更新后的信息。然而，这也意味着，你无法强制给这个表单字段设置一个特定值。</p>
<p>在大多数情况下，你应该使用受控组件。</p>
<h3 id="key"><a href="#key" class="headerlink" title="key"></a><font color="#00BFFF">key</font></h3><ul>
<li><p>“key” 是在创建元素数组时，需要用到的一个特殊字符串属性。key 帮助 React 识别出被修改、添加或删除的 item。应当给数组内的每个元素都设定 key，以使元素具有固定身份标识。</p>
</li>
<li><p>只需要保证，在同一个数组中的兄弟元素之间的 key 是唯一的。而不需要在整个应用程序甚至单个组件中保持唯一。</p>
</li>
<li><p>不要将 Math.random() 之类的值传递给 key。重要的是，在前后两次渲染之间的 key 要具有“固定身份标识”的特点，以便 React 可以在添加、删除或重新排序 item 时，前后对应起来。理想情况下，key 应该从数据中获取，对应着唯一且固定的标识符，例如 post.id。</p>
</li>
</ul>
<h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a><font color="#00BFFF">Ref</font></h3><ul>
<li><p>React 支持一个特殊的、可以附加到任何组件上的 ref 属性。此属性可以是一个由 React.createRef() 函数创建的对象、或者一个回调函数、或者一个字符串（遗留 API）。当 ref 属性是一个回调函数时，此函数会（根据元素的类型）接收底层 DOM 元素或 class 实例作为其参数。这能够让你直接访问 DOM 元素或组件实例。</p>
</li>
<li><p>谨慎使用 ref。如果你发现自己经常使用 ref 来在应用中“实现想要的功能”，你可以考虑去了解一下自上而下的数据流。</p>
</li>
</ul>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a><font color="#00BFFF">事件</font></h3><ul>
<li>使用 React 元素处理事件时，有一些语法上差异：<br>React 事件处理器使用 camelCase（驼峰式命名）而不使用小写命名。<br>通过 JSX，你可以直接传入一个函数，而不是传入一个字符串，来作为事件处理器。</li>
</ul>
<h3 id="协调"><a href="#协调" class="headerlink" title="协调"></a><font color="#00BFFF">协调</font></h3><p>当组件的 props 或 state 发生变化时，React 通过将最新返回的元素与原先渲染的元素进行比较，来决定是否有必要进行一次实际的 DOM 更新。当它们不相等时，React 才会更新 DOM。这个过程被称为“协调”。</p>
<p><br><br><br></p>
<h1 id="六、React-Hook"><a href="#六、React-Hook" class="headerlink" title="六、React Hook"></a><font color="#4169E1">六、React Hook</font></h1><h2 id="1）-简介"><a href="#1）-简介" class="headerlink" title="1） 简介"></a><font color="#00BFFF">1） 简介</font></h2><blockquote>
<p>Hook是React 16.8的新特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</p>
</blockquote>
<p><strong>React Hooks 要解决的问题是状态共享</strong>，称为 <strong>状态逻辑复用</strong> 会更恰当，因为只共享数据处理逻辑，不会共享数据本身。</p>
<p>意思很明了，就是拓展函数式组件的边界。结果也很清晰，只要 Class 组件能实现的，函数式组件 + Hooks都能胜任。</p>
<h2 id="2）-Hook是什么"><a href="#2）-Hook是什么" class="headerlink" title="2） Hook是什么"></a><font color="#00BFFF">2） Hook是什么</font></h2><blockquote>
<p>Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数，这使得你不使用 class 也能使用 React。（Hook 不能在 class 组件中使用） </p>
</blockquote>
<blockquote>
<p>规则</p>
<ul>
<li>只在最顶层使用 Hook<ul>
<li>不要在循环条件，嵌套函数中调用Hook</li>
<li>确保Hook在每次组件render时调用顺序都是一样的</li>
</ul>
</li>
<li>不要在普通的 JavaScript 函数中调用 Hook<ul>
<li>在 React 的函数组件中调用 Hook</li>
<li>在自定义的Hook中可以调用Hook</li>
</ul>
</li>
</ul>
</blockquote>
<p>理想的情况 : <font color="#0f0"><strong>“有状态的组件没有渲染，有渲染的组件没有状态”</strong></font></p>
<h2 id="3）-常用Hooks"><a href="#3）-常用Hooks" class="headerlink" title="3） 常用Hooks"></a><font color="#00BFFF">3） 常用Hooks</font></h2><h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><blockquote>
<p>可以让函数组件在生命周期中，有维护自己的数据和状态的功能。</p>
</blockquote>
<h4 id="1-参数"><a href="#1-参数" class="headerlink" title="1. 参数"></a>1. 参数</h4><ol>
<li>如果是函数，这是一种惰性初始 state，这个函数就只会在初始渲染时候调用，函数的返回值就是 state 的初始值。</li>
<li>如果是数据，直接作为 state 的初始值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const [test, setTest] = React.useState(0);</span><br><span class="line"></span><br><span class="line">const [test, setTest] = React.useState(() =&gt; &#123;</span><br><span class="line">  return 123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="2-覆盖式更新"><a href="#2-覆盖式更新" class="headerlink" title="2. 覆盖式更新"></a>2. 覆盖式更新</h4><p>  setTest更新值的方式是全部覆盖式更新，这跟class组件的setState不一样。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 如果要更新单个值</span><br><span class="line">const [test, setTest] = React.useState(&#123; aa: 1, bb: 2 &#125;);</span><br><span class="line">setTest(&#123;</span><br><span class="line">  ...test,</span><br><span class="line">  aa: 10,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h4 id="3-函数式更新"><a href="#3-函数式更新" class="headerlink" title="3. 函数式更新"></a>3. 函数式更新</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Counter(&#123;initialCount&#125;) &#123;</span><br><span class="line">  const [count, setCount] = useState(initialCount);</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(initialCount)&#125;&gt;Reset&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount - 1)&#125;&gt;-&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount + 1)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-QA"><a href="#4-QA" class="headerlink" title="4. QA"></a>4. QA</h4><ol>
<li><p>我应该使用单个还是多个 state 变量？</p>
<blockquote>
<p>把所有 state 都放在同一个 <code>useState</code> 调用中，或是每一个字段都对应一个 <code>useState</code> 调用，这两方式都能跑通。当你在这两个极端之间找到平衡，然后把相关 state 组合到几个独立的 state 变量时，组件就会更加的可读。</p>
</blockquote>
</li>
<li><p>可不可以不通过setState直接给state赋值？</p>
<blockquote>
<p>“state” is read-only。<br>直接改变state的值会报错<br>修改复杂类型的state的属性，没有效果，组件不会重新渲染</p>
</blockquote>
</li>
<li><p>如何比较state?</p>
<blockquote>
<p>React 使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description" target="_blank" rel="noopener"><code>Object.is</code> 比较算法</a> 来比较 state。<br>我们更新一个 state 变量，我们会 <font color="#0f0"><strong>替换</strong></font> 它的值。这和 class 中的 <code>this.setState</code> 不一样，this.setState会把更新后的字段合并入对象中。</p>
</blockquote>
</li>
</ol>
<h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><h4 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h4><h5 id="关于React副作用"><a href="#关于React副作用" class="headerlink" title="关于React副作用"></a>关于React副作用</h5><blockquote>
<p>UI = F(props)</p>
</blockquote>
<p>翻译成普通话就是：一个组件最终的dom结构与样式是由父级传递的props决定的。</p>
<p>了解过函数式编程的同学，应该知道过一个概念，叫「纯函数」。意思是固定的输入必然有固定的输出，它不依赖任何外部因素，也不会对外部环境产生影响。</p>
<p>react希望自己的组件渲染也是个纯函数，所以有了纯函数组件。然而真正的业务场景是有各种状态的，实际影响UI的还有内部的state。(其实还有context，暂时先不讨论）。</p>
<blockquote>
<p>UI = F(props, state, context)</p>
</blockquote>
<p>这个state可能会因为各种原因产生变化，从而导致组件的渲染结果不一致。相同的入参（props）下，每次render都有可能返回不同的UI。因此任何导致此现象的行为都是副作用（side effects）。比如用户点击下一页，导致页码与列表发生变化，这就是副作用。同样的props，不点击时是第一页数据，点击一下后，变成了第二页的数据or请求失败的页面or其他UI交互。<br>当然state是明面上影响了UI，暗地里，可能还有其他因素会影响UI。比如组件内运用了缓存，导致每次渲染可能都不一样，这也是副作用。</p>
<h5 id="处理副作用"><a href="#处理副作用" class="headerlink" title="处理副作用"></a>处理副作用</h5><p>数据获取，设置订阅以及手动更改 React 组件中的 DOM 都属于副作用。 useEffect可以让我们在函数组件中执行副作用操作</p>
<div class="post-warning"><strong>提示</strong><br>如果你熟悉 React class 的生命周期函数，你可以把 useEffect Hook 看做 componentDidMount，componentDidUpdate 和 componentWillUnmount 这三个函数的组合。</div>


<h5 id="细化粒度"><a href="#细化粒度" class="headerlink" title="细化粒度"></a>细化粒度</h5><blockquote>
<p>每次我们重新渲染，都会生成 <strong>新的</strong> effect，替换掉之前的。某种意义上讲，effect 更像是渲染结果的一部分 —— 每个 effect “属于”一次特定的渲染。</p>
</blockquote>
<blockquote>
<p>提示: 使用多个 Effect 实现关注点分离<br>  使用 Hook 其中一个目的就是要解决 class 中生命周期函数经常包含不相关的逻辑，但又把相关逻辑分离到了几个不同方法中的问题。<br>  Hook 允许我们按照代码的用途分离他们</p>
</blockquote>
<h4 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h4><h5 id="2-1）用法"><a href="#2-1）用法" class="headerlink" title="2.1）用法"></a>2.1）用法</h5><p>useEffect的执行时机，主要根据 dependences 的情况来区分：</p>
<ol>
<li>dependences不传的时候，每次组件dom渲染结束后，都会走一遍这个useEffect；</li>
<li>dependences传空数组的时候，表示该useEffect不依赖任何变量，只有在组件第一次dom渲染后执行；</li>
<li>dependences传非空数组的时候，表示该useEffect依赖该数组中的元素变化，当组件dom渲染结束后，如果这些依赖项发生了改变的话，就要执行一次这个useEffect。</li>
</ol>
<h5 id="2-2）实例"><a href="#2-2）实例" class="headerlink" title="2.2）实例"></a>2.2）实例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  console.log(&apos;dom挂载&apos;);</span><br><span class="line">  return () =&gt; &#123;</span><br><span class="line">    console.log(&apos;dom卸载&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, [count]);</span><br></pre></td></tr></table></figure>
<p>上述代码的执行结果是：</p>
<ul>
<li>初始dom渲染后打印出 <code>dom挂载</code></li>
<li>count发生变化后，组件再次render时，先执行 <code>dom卸载</code>，再执行 <code>dom挂载</code></li>
<li>以此类推下去<br>这个过程理解就可以说明：<code>为什么每次组件render都有自己的state和effect和事件</code>。</li>
</ul>
<h5 id="2-3）清除"><a href="#2-3）清除" class="headerlink" title="2.3）清除"></a>2.3）清除</h5><p>在 React 组件中有两种常见副作用操作：需要清除的和不需要清除的。</p>
<ul>
<li><p><strong>无需清除的effect</strong></p>
<blockquote>
<p>有时候，我们只想在 React 更新 DOM 之后运行一些额外的代码。比如发送网络请求，手动变更 DOM，记录日志，这些都是常见的无需清除的操作。因为我们在执行完这些操作之后，就可以忽略他们了</p>
</blockquote>
<div class="post-warning"><strong>提示</strong>与 componentDidMount 或 componentDidUpdate 不同，使用 useEffect 调度的 effect 不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快。大多数情况下，effect 不需要同步地执行。在个别情况下（例如测量布局），有单独的 useLayoutEffect Hook 供你使用，其 API 与 useEffect 相同。</div>


</li>
</ul>
<ul>
<li><p><strong>需要清除的effect (定时器，绑定事件，订阅，防止内存泄漏)</strong></p>
<blockquote>
<p>在class组件中，我们需要在<code>componentDidMount</code> 和 <code>componentWillUnmount</code>、<code>componentDidUpdate</code>中来写入绑定和清除的代码。业务逻辑分布在各个生命周期中难以维护且容易出错。useEffect可以在同一个地方执行绑定和清除的代码。可读性可维护性更强。只用在effect函数内部执行绑定方法，再return一个清除的方法即可。</p>
<p>effect 在每次渲染的时候都会执行。这就是为什么 React 会在执行当前 effect 之前对上一个 effect 进行清除。</p>
</blockquote>
<p><font color="#0f0">class+生命周期：</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class FriendStatus extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123; isOnline: null &#125;;</span><br><span class="line">    this.handleStatusChange = this.handleStatusChange.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    ChatAPI.subscribeToFriendStatus(</span><br><span class="line">      this.props.friend.id,</span><br><span class="line">      this.handleStatusChange</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    ChatAPI.unsubscribeFromFriendStatus(</span><br><span class="line">      this.props.friend.id,</span><br><span class="line">      this.handleStatusChange</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  handleStatusChange(status) &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      isOnline: status.isOnline</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    if (this.state.isOnline === null) &#123;</span><br><span class="line">      return &apos;Loading...&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    return this.state.isOnline ? &apos;Online&apos; : &apos;Offline&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="#0f0">function+Hook：</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function FriendStatus(props) &#123;</span><br><span class="line">  const [isOnline, setIsOnline] = useState(null);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    function handleStatusChange(status) &#123;</span><br><span class="line">      setIsOnline(status.isOnline);</span><br><span class="line">    &#125;</span><br><span class="line">    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    // Specify how to clean up after this effect:</span><br><span class="line">    return function cleanup() &#123;</span><br><span class="line">      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  if (isOnline === null) &#123;</span><br><span class="line">    return &apos;Loading...&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  return isOnline ? &apos;Online&apos; : &apos;Offline&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="2-4）执行"><a href="#2-4）执行" class="headerlink" title="2.4）执行"></a>2.4）执行</h5><blockquote>
<p>并非所有 effect 都可以被延迟执行。例如，在浏览器执行下一次绘制前，用户可见的 DOM 变更就必须同步执行，这样用户才不会感觉到视觉上的不一致。（概念上类似于被动监听事件和主动监听事件的区别。）React 为此提供了一个额外的 useLayoutEffect Hook 来处理这类 effect。它和 useEffect 的结构相同，区别只是调用时机不同。</p>
</blockquote>
<h5 id="2-5）QA"><a href="#2-5）QA" class="headerlink" title="2.5）QA"></a>2.5）QA</h5><ol>
<li><p>为什么要在组件内部调用useEffect?</p>
<blockquote>
<p>放在组件内部让我们可以在effect中直接访问state。它已经保存在函数作用域中。Hook使用了js的闭包机制。</p>
</blockquote>
</li>
<li><p>如果我的 effect 的依赖频繁变化，我该怎么办？</p>
<blockquote>
<p>某些时候我只想在函数组件挂载的时候运行它，但是在effect中却用到了组件内的state,props等变量。这时候就会引起某些bug。</p>
</blockquote>
</li>
<li><p>为什么要在 effect 中返回一个函数？ </p>
<blockquote>
<p>这是 effect 可选的清除机制。每个 effect 都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。它们都属于 effect 的一部分。</p>
</blockquote>
</li>
<li><p>React 何时清除 effect？ </p>
<blockquote>
<p>React 会在组件卸载的时候执行清除操作。正如之前学到的，effect 在每次渲染的时候都会执行。这就是为什么 React 会在执行当前 effect 之前对上一个 effect 进行清除。</p>
</blockquote>
</li>
</ol>
<h3 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h3><blockquote>
<p>useContext 接受上下文对象（从React.createContext返回的值）并返回当前上下文值。</p>
<p>当前的 <code>context</code> 值由上层组件中距离当前组件最近的 <code>&lt;CountContext.Provider&gt;</code> 的 <code>value</code> prop 决定。</p>
<p>当Context Provider的value发生变化时，他的所有子级消费者都会rerender。</p>
</blockquote>
<p><code>useContext</code> 的参数必须是 <em>context 对象本身</em></p>
<h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><blockquote>
<p><a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usestate" target="_blank" rel="noopener"><code>useState</code></a> 的替代方案。它接收一个形如 <code>(state, action) =&gt; newState</code> 的 reducer，并返回当前的 state 以及与其配套的 <code>dispatch</code> 方法。</p>
<p> state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。并且，使用 useReducer 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 dispatch 而不是回调函数 。</p>
<p>React 会确保 <code>dispatch</code> 函数的标识是稳定的，并且不会在组件重新渲染时改变。这就是为什么可以安全地从 <code>useEffect</code> 或 <code>useCallback</code> 的依赖列表中省略 <code>dispatch</code>。</p>
</blockquote>
<ul>
<li><p>指定初始化state</p>
<blockquote>
<p>将初始 state 作为第二个参数传入 <code>useReducer</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const [state, dispatch] = useReducer(</span><br><span class="line">    reducer,</span><br><span class="line">    &#123;count: initialCount&#125;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>
</li>
<li><p>惰性初始化</p>
<blockquote>
<p>需要将 <code>init</code> 函数作为 <code>useReducer</code> 的第三个参数传入，这样初始 state 将被设置为 <code>init(initialArg)</code></p>
<p>这么做可以将用于计算 state 的逻辑提取到 reducer 外部，这也为将来对重置 state 的 action 做处理提供了便利</p>
<p>局部状态不推荐使用 <code>useReducer</code> ，会导致函数内部状态过于复杂，难以阅读。 <code>useReducer</code> 建议在多组件间通信时，结合 <code>useContext</code> 一起使用。</p>
</blockquote>
</li>
</ul>
<ol>
<li><p>如何自己写一个useReducer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function useReducer(reducer, initialState) &#123;</span><br><span class="line">  const [state, setState] = useState(initialState);</span><br><span class="line"></span><br><span class="line">  function dispatch(action) &#123;</span><br><span class="line">    const nextState = reducer(state, action);</span><br><span class="line">    setState(nextState);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return [state, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>如何用useReducer创建一个redux</p>
<blockquote>
<p>真正实现一个 Redux 功能，也就是全局维持一个状态，任何组件 <code>useReducer</code> 都会访问到同一份数据，可以和useContext一起使用。</p>
<p>大体思路是利用 <code>useContext</code> 共享一份数据，作为 Custom Hooks 的数据源。将useReducer中获取state和dispatch当做参数传递给useContext</p>
</blockquote>
</li>
</ol>
<p>总结起来就是：</p>
<ul>
<li>如果你的页面<code>state</code>很简单，可以直接使用<code>useState</code></li>
<li>如果你的页面<code>state</code>比较复杂（state是一个对象或者state非常多散落在各处）请使用userReducer</li>
<li>如果你的页面组件层级比较深，并且需要子组件触发<code>state</code>的变化，可以考虑useReducer + useContext</li>
</ul>
<h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><blockquote>
<p>返回一个 <a href="https://en.wikipedia.org/wiki/Memoization" target="_blank" rel="noopener">memoized</a> 回调函数。</p>
<p>该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性,去避免非必要渲染<br>useCallback(fn, deps) 相当于 useMemo(() =&gt; fn, deps)</p>
<p>所有回调函数中引用的值都应该出现在依赖项数组中</p>
<p>推荐所有函数组件内函数的用 <code>React.useCallback</code> 包裹，以保证准确性与性能。推荐<code>useCallback</code> 第二个参数必须写</p>
</blockquote>
<p>1.拿到onChange抛出的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export const useInputValue = val =&gt; &#123;</span><br><span class="line">  let [value, setValue] = useState(val);</span><br><span class="line">  let onChange = useCallback(function(event) &#123;</span><br><span class="line">    setValue(event.currentTarget.value);</span><br><span class="line">  &#125;, []);//保证inputDom只绑定监听事件一次</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    value,</span><br><span class="line">    onChange</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 效果：通过 useInputValue() 拿到 Input 框当前用户输入的值，而不是手动监听 onChange 再腾一个 otherInputValue 和一个回调函数把这一堆逻辑写在无关的地方。</p>
</blockquote>
<h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><blockquote>
<p>返回一个memoized值 <code>const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);</code><br>你可以把 <code>useMemo</code> 作为一种性能优化的手段</p>
</blockquote>
<p>两个参数依次是计算函数（通常是组件函数）和依赖状态列表，当依赖的状态发生改变时，才会触发计算函数的执行。如果没有指定依赖，则每一次渲染过程都会执行该计算函数。</p>
<p>前面我们说过了当状态发生变化时，没有设置关联状态的 useEffect 会全部执行。同样的，通过计算出来的值或者引入的组件也会重新计算/挂载一遍，即使与其关联的状态没有发生任何变化。 </p>
<p>在类组件中我们有 shouldComponetUpdate 以及 React.memo 帮助我们去做性能优化。所以在函数组件中就出现了useMemo。</p>
<p><code>在业务中，我们可以用  useMemo  来处理计算结果的缓存或引入组件的防止重复挂载优化。</code>其接受两个参数，第一个参数为一个 Getter 方法，返回值为要缓存的数据或组件，第二个参数为该返回值相关联的状态，当其中任何一个状态发生变化时就会重新调用 Getter 方法生成新的返回值。</p>
<blockquote>
<p>初次接受  useMemo  时可能我们会觉得该钩子只是用来做计算结果的缓存，返回值只能是一个数字或字符串。其实  useMemo  并不关心我们的返回值类型是什么，它只是在关联状态发生变动时重新调用我们传递的 Getter 方法 生成新的返回值，也就是说  <code>useMemo  生成的是 Getter 方法与依赖数组的关联关系</code>。因此，如果我们将函数的返回值替换为一个组件，那么就可以实现对组件挂载/重新挂载的性能优化。</p>
</blockquote>
<h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><blockquote>
<p>useRef 返回一个<strong>可变</strong>的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内保持不变。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const refContainer = useRef(initialValue);</span><br></pre></td></tr></table></figure>
<blockquote>
<p> <code>useRef()</code> 和自建一个 <code>{current: ...}</code> 对象的唯一区别是，<code>useRef</code> 会在每次渲染时返回同一个 ref 对象。</p>
<p>当 ref 对象内容发生变化时，useRef 并不会通知你。变更 .current 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用回调 ref 来实现。</p>
</blockquote>
<p>useRef hook的作用：</p>
<ul>
<li>获取DOM元素的节点</li>
<li>获取子组件的实例</li>
<li>渲染周期之间共享数据的存储（state不能存储跨渲染周期的数据，因为state的保存会触发组件重渲染）</li>
</ul>
<p>useRef之所以总能取到变量最新值的原因：它保存的变量不会随着每次数据的变化重新生成，所以相当于保存了一份该变量的引用，所以总能保持在最后一次赋值的状态。</p>
<h3 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h3><h3 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h3><h3 id="useDebugValue"><a href="#useDebugValue" class="headerlink" title="useDebugValue"></a>useDebugValue</h3><p>useDebugValue 可用于在 React 开发者工具中显示自定义 hook 的标签。</p>
<h2 id="4-特点"><a href="#4-特点" class="headerlink" title="4) 特点"></a>4) 特点</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ol>
<li>让在函数组件中有可维护的状态和数据</li>
<li>函数组件业务变更无需修改成class组件</li>
<li>告别了繁杂的this和难以记忆的生命周期</li>
<li>合并的生命周期componentDidMount、componentDidUpdate、和 componentWillUnmount</li>
<li>更好的完成状态之间的共享.</li>
<li>多个状态不会产生嵌套，写法还是平铺的，也解决了高阶组件和函数组件的嵌套过深</li>
<li>Hooks 可以引用其他 Hooks。</li>
<li>useReducer集成redux</li>
<li>useEffect接受脏操作等到react更新了DOM之后，它再依次执行我们定义的副作用函数。‘</li>
<li>状态与UI的界限份的越来越清晰</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>有些hooks行为怪异很难理解。 useEffect最甚；有时候依赖和回调写的不注意就容易死循环。</li>
<li>规矩很多（ 函数必须以 “use” 命名开头，顺序，不能在条件判断循环中声明等等)</li>
<li>逻辑复杂的场景中或者系统的主要架构中用hook进行状态或者数据管理还是不太放心。</li>
<li>社区好像更热衷于造轮子</li>
</ol>
<h3 id="5）总结"><a href="#5）总结" class="headerlink" title="5）总结"></a>5）总结</h3><blockquote>
<p>应该理性的选择，hook和现在的项目系统不冲突，现在也是模块化开发，可以从新的模块入手来尝试在模块内部用hook来处理数据和逻辑状态。</p>
<p>在一些简单的页面里，引入redux，saga那一套东西显得有些大材小用，而且开发起来也有些繁琐，使用hook会更灵活轻便一些。</p>
<p>我们也可以开发一些常用的hook，当老项目有新的功能完全可以用Hook去开发，如果对老的组件进行修改时就可以考虑给老组件上Hook，不建议一上来就进行大改。随着常用Hook组件库的丰富，后期改起来也会非常快。</p>
<p>在使用Hook时难免少不了一些常用的Hook，如果可以将这些常用的Hook封装起来。变成工具库。</p>
</blockquote>
<ul>
<li><p><a href="https://github.com/dt-fe/weekly/blob/v2/120.%E7%B2%BE%E8%AF%BB%E3%80%8AReact%20Hooks%20%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E3%80%8B.md" target="_blank" rel="noopener">React Hooks 最佳实践</a></p>
</li>
<li><p><a href="https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/" target="_blank" rel="noopener">useEffect 完整指南</a></p>
</li>
<li><p><a href="https://www.robinwieruch.de/react-hooks-fetch-data" target="_blank" rel="noopener">How to fetch data with React Hooks?</a></p>
</li>
</ul>
<h1 id="七、有价值的QA"><a href="#七、有价值的QA" class="headerlink" title="七、有价值的QA"></a><font color="#4169E1">七、有价值的QA</font></h1><ol>
<li><p>节流、防抖和requestAnimationFrame<br>节流：基于时间的频率来进行抽样更改 (例如 _.throttle)<br>防抖：一段时间的不活动之后发布更改 (例如 _.debounce)<br>requestAnimationFrame 节流：基于 requestAnimationFrame 的抽样更改 (例如 raf-schd)</p>
</li>
<li><p>应该如何更新那些依赖于当前的 state 的 state 呢？<br>给 setState 传递一个函数，而不是一个对象，就可以确保每次的调用都是使用最新版的 state。<br>传递一个函数可以让你在函数内访问到当前的 state 的值。因为 setState 的调用是分批的，所以你可以链式地进行更新，并确保它们是一个建立在另一个之上的，这样才不会发生冲突：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.setState((state) =&gt; &#123;</span><br><span class="line">  // 重要：在更新的时候读取 `state`，而不是 `this.state`。</span><br><span class="line">  <span class="built_in">return</span> &#123;count: state.count + 1&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/29/js/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lemon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/background10.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="立夏">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/29/js/" itemprop="url">js</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-29T17:09:29+08:00">
                2019-03-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/1）前端-基础/" itemprop="url" rel="index">
                    <span itemprop="name">1）前端 - 基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>JavaScript，前端三大基础语言之一</p>
<h1 id="第一章、-JS基础"><a href="#第一章、-JS基础" class="headerlink" title="第一章、 JS基础"></a><font color="#DC143C">第一章、 JS基础</font></h1><h2 id="第一节、基础概念"><a href="#第一节、基础概念" class="headerlink" title="第一节、基础概念"></a><font color="#FF69B4">第一节、基础概念</font></h2><p><strong>javaScript是单线程 、解释性、兼容于ECMA标准的脚本语言</strong></p>
<blockquote>
<p>浏览器是由外壳（Shell）和内核（kernel）组成，最重要的是内核（解析页面）。<br>  渲染引擎（html、css）<br>  JS引擎（执行js代码），目前最快的是Chrome的V8引擎。<br>  其他模块</p>
</blockquote>
<ul>
<li>编译性语言：C    C++<br>先把语言编译一遍，形成一个新的文件，再执行。<br>执行速度快、跨平台性差</li>
<li>解释性语言：js    php     python<br>不需要编译成文件<br>跨平台性好、执行速度慢</li>
<li>java结合两者优点，效率折中，java通过javac编译成.class语言，在jvm(Java Virtual Machine，java虚拟机)中执行。</li>
</ul>
<blockquote>
<p><strong>ECMA标准</strong> - 为了取得技术优势，微软推出JScript，CEnvi推出ScriptEase，与javaScript一样可在浏览器中运行。为了统一规格，javascript兼容于ECMA（European Computer Manufacturers Association，欧洲计算机制造联合会）标准，因此也称为ECMAScript。</p>
</blockquote>
<blockquote>
<p>单线程<br>  js执行队列：js执行主线程 &lt;- task1,1ms &lt;- task2,2ms &lt;- task2,1ms &lt;- task1,1ms &lt;- task1,1ms</p>
</blockquote>
<h2 id="第二节、ECMAScript"><a href="#第二节、ECMAScript" class="headerlink" title="第二节、ECMAScript"></a><font color="#FF69B4">第二节、ECMAScript</font></h2><p>js三大部分：<br>  ECMAScript（描述了该语言和基本对象）<br>  DOM（文档对象模型，描述了处理网页内容的方法和接口）<br>  BOM（浏览器对象模型，描述与浏览器进行交互的方法和接口）</p>
<h3 id="一、引入"><a href="#一、引入" class="headerlink" title="一、引入"></a>一、引入</h3><p>行间样式（不过一般都不这样写）<br>页面内嵌&lt;script>&lt;/script>标签<br>外部引入&lt;script src = ‘xxx’>&lt;/script><br>（为符合W3C标准：结构、样式、行为相分离，通常会采用外部引入）</p>
<h3 id="二、基础语法"><a href="#二、基础语法" class="headerlink" title="二、基础语法"></a>二、基础语法</h3><h4 id="1-变量（variable）"><a href="#1-变量（variable）" class="headerlink" title="1. 变量（variable）"></a><strong>1. 变量（variable）</strong></h4><p>  1) 变量声明<br>     声明、赋值分解<br>     单一var声明<br>  2）命名规则<br>     1、变量名只能以英文字母、 _ 、 $开头<br>     2、变量名可以包括英文字母、 _ 、 $和数字<br>     3、不可以用系统的关键字、保留字作为变量名</p>
<blockquote>
<p>关键字<br>    var void if else switch case default do while try catch throw for continue break return in  delete typeof instanceof new this with finally function</p>
</blockquote>
<blockquote>
<p>保留字<br>    boolean const char byte double float int long short enum interface  static  private    protected package    public import class super extends throws debugger export implements abstract    final        goto    native     synchronized    transient volatile</p>
</blockquote>
<h4 id="2-值类型"><a href="#2-值类型" class="headerlink" title="2. 值类型"></a><strong>2. 值类型</strong></h4><p>  a. 不可改变的原始值（栈类型 stack）： number   string     Boolean    undefined    null<br>  b. 引用值（堆数据 heap）： function  object  array</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 以下两个值分别是什么？</span><br><span class="line">    var a = 1;</span><br><span class="line">    var b = 2;</span><br><span class="line">    var num1 = a,b;</span><br><span class="line">    var num2 = (a,b);</span><br><span class="line">2. 以下,x的最终值是什么？</span><br><span class="line">    var x = 1;</span><br><span class="line">    if (function f() &#123;&#125;) &#123;</span><br><span class="line">      x += typeof f;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-js语法基本规则"><a href="#3-js语法基本规则" class="headerlink" title="3. js语法基本规则"></a><strong>3. js语法基本规则</strong></h4><p>  语句后面用分号结束；<br>  书写格式要规范，“ + - = /”两边都应有空格；<br>  js语法错误会引发后续代码终止，但不会影响其他js代码块；</p>
<h4 id="4-js运算符"><a href="#4-js运算符" class="headerlink" title="4. js运算符"></a><strong>4. js运算符</strong></h4><h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><blockquote>
<p>运算操作符:</p>
<pre><code>+                        1）数字运算，字符串连接   2）任何数据+字符串都等于字符串
- * / % = ()             1）优先级“=”最弱  “()”较高
++ -- += -= /= *= %=
</code></pre></blockquote>
<blockquote>
<p>比较运算符: &gt; &lt; == &gt;= &lt;= != === !==  1）结果为boolean值</p>
</blockquote>
<blockquote>
<p>逻辑运算符: &amp;&amp; || ！ 1）结果为真实值</p>
</blockquote>
<blockquote>
<p>被认定为false的值: undefined null NaN ‘’ “” 0 false</p>
</blockquote>
<blockquote>
<p>typeof: number 、 string 、 boolean 、 undefined 、 object 、 function六种数据类型</p>
</blockquote>
  <font color="red">(null 、[] 、object -&gt; object)</font>

<h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><pre><code>1. 显示类型转换
    Number()
    String()
    Boolean()
    toString()
    parseInt()
    parseFloat()
2. 隐式类型转换
    isNaN()     被认定NaN:undefined 、 NaN 、{}
    ++ / --  + / -（一元正负）
    +
    *、/ %
    &amp;&amp; || !
    &lt;   &gt;   &lt;=   &gt;=
    ==   !=
3. 不发生类型转换
    === !==
</code></pre><p>  思考：</p>
<ol>
<li><p>请问以下c的值分别是什么？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;            var a = 0;              var a = 1;</span><br><span class="line">var b = 2;            var b = 2;              var b = 0;</span><br><span class="line">var c = a &amp;&amp; b;       var c = a &amp;&amp; b;         var c = a &amp;&amp; b;</span><br></pre></td></tr></table></figure>
</li>
<li><p>请问以下c的值分别是什么？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;            var a = 0;              var a = 1;</span><br><span class="line">var b = 2;            var b = 2;              var b = 0;</span><br><span class="line">var c = a || b;       var c = a || b;         var c = a || b;</span><br></pre></td></tr></table></figure>
</li>
<li><p>请问以下结果分别是什么？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = 0;                       var a = 0;             </span><br><span class="line">var b = 2;                       var b = 2;        </span><br><span class="line">a &lt; b &amp;&amp; document.write(b)       a &gt; b &amp;&amp; document.write(b)</span><br></pre></td></tr></table></figure>
</li>
<li><p>请问以下结果分别是什么？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NaN == NaN  [] == []  undefined == undefined  undefined == null</span><br></pre></td></tr></table></figure>
</li>
<li><p>请问以下的值分别是什么？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = 1 + 1 + <span class="string">'aini'</span> + 1 + 1;</span><br><span class="line">var b = 1 + 1 + <span class="string">'aini'</span> + ( 1 + 1 );</span><br></pre></td></tr></table></figure>
</li>
<li><p>请问以下结果是什么？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = 1 / 0;</span><br><span class="line">var b = 1 / 0;</span><br><span class="line">document.write(a - b);</span><br></pre></td></tr></table></figure>
</li>
<li><p>请问以下结果分别是什么？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = 0;                          var a = 0;</span><br><span class="line">var b = 10;                         var b = 10;</span><br><span class="line">b += a++;                           b += ++a;</span><br><span class="line">document.write(b,a);                document.write(b,a);</span><br></pre></td></tr></table></figure>
</li>
<li><p>请问以下结果分别是什么？<br>var a = ( 10 * 3 - 4 / 2 + 1 ) % 2,<br> b = 3;<br>b %= a;<br>document.write(a++, –b);</p>
</li>
<li>var a = 123; var b = 234;请交换a 和 b的值。</li>
</ol>
<h4 id="5-条件语句"><a href="#5-条件语句" class="headerlink" title="5. 条件语句"></a><strong>5. 条件语句</strong></h4><p>  if 、 if else 、 if else if<br>  for 、 while 、do while<br>  switch  case default<br>  break 、 continue</p>
<h4 id="6-引用值"><a href="#6-引用值" class="headerlink" title="6. 引用值"></a><strong>6. 引用值</strong></h4><p>1）数组<br>2）对象</p>
<blockquote>
<p>编程形式的区别：面向过程、面向对象</p>
</blockquote>
<p>3）函数</p>
<ol>
<li>函数声明、函数表达式</li>
<li><p>参数(形参、实参、实参列表)<br><font color="red">注意：形参、实参、实参列表（arguments）的映射关系。</font></p>
<blockquote>
<p>大加法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">BigAdd</span></span>() &#123;</span><br><span class="line">  var sum = 0;</span><br><span class="line">  <span class="keyword">for</span> (var i = 0 ; i &lt; arguments.length ; i++) &#123;</span><br><span class="line">    sum += arguments[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> sum; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>返回值<br>return什么，函数便等于什么（函数名用 <font color="red">小驼峰式</font> 写法）</p>
</li>
<li>作用域<br>定义：变量（变量作用域又称上下文）和函数生效（能被访问）的区域<br>全局变量、局部变量<br>作用域的访问顺序</li>
</ol>
<h3 id="三、复杂数据类型"><a href="#三、复杂数据类型" class="headerlink" title="三、复杂数据类型"></a>三、复杂数据类型</h3><h4 id="3-1）函数"><a href="#3-1）函数" class="headerlink" title="3.1）函数"></a>3.1）函数</h4><h5 id="1、预编译"><a href="#1、预编译" class="headerlink" title="1、预编译"></a>1、预编译</h5><p>  （规律）函数声明提升、变量声明提升<br>  （原理）预编译发生在执行的前一刻。一个函数执行，函数会先发生预编译，预编译过程中会产生执行期上下文对象。Activation Object 活动对象（AO）</p>
<blockquote>
<p>四部曲<br>    1、创建AO对象<br>    2、找形参和变量声明，将变量和形参名作为AO属性名，值为undefined<br>    3、将实参值和形参统一<br>    4、在函数体里面找函数声明，值赋予函数体<br>    <font color="red">* 每个函数最后都有一个return，当执行到这一步时，AO被处理掉，函数就不执行了。</font></p>
</blockquote>
<blockquote>
<p>全局也能预编译<br>    三步：<br>    1、创建GO（Global Object）对象<br>    2、找变量声明，将变量名作为GO属性名，值为undefined<br>    3、找函数声明，值赋予函数体</p>
</blockquote>
<h5 id="2、作用域"><a href="#2、作用域" class="headerlink" title="2、作用域"></a>2、作用域</h5><ul>
<li><p>[[scope]]：每个javascript函数都是一个对象，对象中有些属性我们可以访问，有些不可以，这些属性仅供javascript引擎存取，[[scope]]就是其中一个。[[scope]]指的就是我们所说的作用域，其中存储了运行期上下文的集合。</p>
</li>
<li><p>作用域链：[[scope]]中所存储的执行期上下文对象的集合，这个集合呈链式链接。我们把这个链式链接叫做作用域链。</p>
</li>
<li><p>运行期上下文：当函数执行时，会创建一个称为执行期上下文的内部对象。一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对象的执行期上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行期上下文，当函数执行完，执行上下文被销毁。</p>
</li>
<li><p>查找变量：从作用域链的顶端依次向下查找。</p>
</li>
</ul>
<h5 id="3、闭包"><a href="#3、闭包" class="headerlink" title="3、闭包"></a>3、闭包</h5><blockquote>
<p>当内部函数被保存到外部时，会生成闭包，闭包会导致原有作用域链不释放，造成内存泄露</p>
</blockquote>
<h6 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h6><p>a) 可以实现公有变量<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">函数累加器（公有变量）</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">a</span></span>()&#123;                               <span class="keyword">function</span> <span class="function"><span class="title">a</span></span>()&#123;</span><br><span class="line">  var num = 0;                                var num = 0;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">b</span></span>()&#123;                               <span class="keyword">function</span> <span class="function"><span class="title">b</span></span>()&#123;</span><br><span class="line">    console.log(++num);                          console.log(++num);</span><br><span class="line">  &#125;                                           &#125;</span><br><span class="line">  <span class="built_in">return</span>  b;                                  <span class="keyword">function</span> <span class="function"><span class="title">c</span></span>()&#123;</span><br><span class="line">&#125;                                                console.log(--num);</span><br><span class="line">var getCounter = a();                          &#125;</span><br><span class="line">getCounter();    ---&gt; 1                        <span class="built_in">return</span> [b,c];</span><br><span class="line">getCounter();    ---&gt; 2                      &#125;</span><br><span class="line">getCounter();    ---&gt; 3                      var getCounterArr = a();  </span><br><span class="line">                                             getCounterArr[0]();    ---&gt; 1   </span><br><span class="line">                                             getCounterArr[1]();    ---&gt; 0</span><br></pre></td></tr></table></figure></p>
<p>b) 可以做缓存<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">eater</span></span>()&#123;</span><br><span class="line">  var food = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">eat</span></span>()&#123;</span><br><span class="line">    console.log(food);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> buy(foods)&#123;</span><br><span class="line">    food = foods;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> &#123; eat: eat, buy: buy &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var person = eater();</span><br><span class="line">person.buy(<span class="string">'apple'</span>);</span><br><span class="line">person.eat();          ----&gt; <span class="string">'apple'</span></span><br></pre></td></tr></table></figure></p>
<p>c) 可以实现封装、属性私有化<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">wrapper</span></span>()&#123;</span><br><span class="line">  var slice = Array.prototype.slice;</span><br><span class="line">  ...很多变量</span><br><span class="line">  <span class="keyword">function</span> $()&#123;</span><br><span class="line">    ...很多变量</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">add</span></span>()&#123;...&#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">show</span></span>()&#123;...&#125;</span><br><span class="line">    ...很多函数</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> &#123;add: add,show: show...很多函数&#125;;</span><br><span class="line">&#125;</span><br><span class="line">var $ = wrapper();</span><br><span class="line">var obj = $();</span><br></pre></td></tr></table></figure></p>
<font color="red">注：闭包会大量占用内存资源（作用域链不释放），因此，能少用还是少用，要了解闭包的原理再使用，否则浪费内存。</font>

<h6 id="闭包的高级应用"><a href="#闭包的高级应用" class="headerlink" title="闭包的高级应用"></a>闭包的高级应用</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">test</span></span> () &#123;</span><br><span class="line">  var arr = [];</span><br><span class="line">  <span class="keyword">for</span> (var i = 0 ; i &lt; 10 ; i ++) &#123;</span><br><span class="line">    arr[i] = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      console.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line">var outerArr = <span class="built_in">test</span>();</span><br><span class="line"><span class="keyword">for</span> (var j = 0 ; j &lt; 10 ; j++) &#123;</span><br><span class="line">  outerArr[j]();</span><br><span class="line">&#125;</span><br><span class="line">结果是10个10 ，这是为什么呢？</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">test</span></span>() &#123;</span><br><span class="line">  var arr = [];</span><br><span class="line">  <span class="keyword">for</span> (var i = 0 ; i &lt; 10 ; i++ ) &#123;</span><br><span class="line">    arr[i] =(<span class="keyword">function</span>(j)&#123;</span><br><span class="line">      console.log(j);</span><br><span class="line">    &#125;(i))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line">var outerArr = <span class="built_in">test</span>();</span><br><span class="line"><span class="keyword">for</span> (var j = 0 ; j &lt; 10 ; j++) &#123;</span><br><span class="line">  outerArr[j]();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4、立即执行函数"><a href="#4、立即执行函数" class="headerlink" title="4、立即执行函数"></a>4、立即执行函数</h5><ul>
<li><p>此类函数没有生命，在一次执行完后立即释放，适合做初始化工作。</p>
</li>
<li><p>写法：(function())<font color="red">w3c推荐</font>  或   (function)()</p>
<pre><code>函数声明❌  函数表达式✅
只有函数表达式+()才能执行（能被执行符号执行的表达式，执行一次，函数就被忽略，不能再使用）
</code></pre></li>
<li><p>+ - ！ &amp;&amp; ||可以是一个函数声明变成一个表达式<br>+function test(){}();          —&gt;可以执行，但是再test()会报错<br>true &amp;&amp; function test(){}();   —&gt;✅<br>false || function test(){}();  —&gt;✅</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jQuery中用到的就是闭包，立即执行函数和原型</span><br><span class="line">(<span class="function"><span class="title">function</span></span> ()&#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">jQuery</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> jQuery.prototype.init();</span><br><span class="line">  &#125;</span><br><span class="line">  jQuery.prototype.init = <span class="function"><span class="title">funtcion</span></span>()&#123;...&#125;</span><br><span class="line">  jQuery.prototype.init.prototype = jQuery.prototype;</span><br><span class="line"></span><br><span class="line">  window.$ = jQuery;</span><br><span class="line">&#125;())</span><br><span class="line">这样后续，$就替代jQuery。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-2）对象"><a href="#3-2）对象" class="headerlink" title="3.2）对象"></a>3.2）对象</h4><h5 id="1、对象"><a href="#1、对象" class="headerlink" title="1、对象"></a>1、对象</h5><h6 id="1）对象的创建方法"><a href="#1）对象的创建方法" class="headerlink" title="1）对象的创建方法"></a>1）对象的创建方法</h6><ul>
<li>字面量<ul>
<li>var obj = {}</li>
<li>缺点：每创建一次只对应一个对象，比较局限。</li>
</ul>
</li>
<li>构造函数<ul>
<li>系统自带：new Object(); Array(); Number(); Boolean; Date();</li>
<li>自定义 <font color="green">一般以一个函数为构造函数，函数名要大写</font></li>
</ul>
</li>
<li>Object.create(原型)方法</li>
</ul>
<h6 id="2）属性的增删改查"><a href="#2）属性的增删改查" class="headerlink" title="2）属性的增删改查"></a>2）属性的增删改查</h6><blockquote>
<p> 增 obj.attrValue = ‘hahaha’;<br>   删 delete obj.attrValue;<br>   改 obj.haha = ‘heihei’;   obj[haha] = ‘heihei’;  obj[‘haha’] = ‘heihei’;<br>   查 obj.haha   obj[haha]  obj[‘haha’]</p>
</blockquote>
<h6 id="3）包装类"><a href="#3）包装类" class="headerlink" title="3）包装类"></a>3）包装类</h6><p>   String();<br>   Boolean();<br>   Number();</p>
<h6 id="4）对象的枚举"><a href="#4）对象的枚举" class="headerlink" title="4）对象的枚举"></a>4）对象的枚举</h6><ol>
<li><p>for （ in ）<br>不仅可以遍历对象，还可以遍历数组</p>
</li>
<li><p>对象的枚举</p>
<ul>
<li><font color="red">hasOwnProperty</font><br>是否是对象自己的属性。只对自己对象的属性为true，对自己原型上的属性为false，其他更为false。</li>
<li><font color="red">for（ in ）</font><br>可以遍历自己及原型的属性。但是，当原型是系统的Object.prototype的时候不会遍历。</li>
<li><font color="red">in</font><br>是否是对象上或者原型链上的属性。换句话说，只要对象能调用的属性就是true。</li>
<li><font color="red">instanceof</font><br>浅：A是否是B构造函数的构造出来的<br>深：A原型链上有没有B的原型</li>
</ul>
</li>
</ol>
<h5 id="2、原型及原型链"><a href="#2、原型及原型链" class="headerlink" title="2、原型及原型链"></a>2、原型及原型链</h5><h6 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h6><blockquote>
<p>定义：原型是function对象的一个属性，它定义了构造函数制造出的对象的公共祖先，通过该构造函数产生的对象，可以继承该原型的属性和方法，原型也是对象。</p>
</blockquote>
<blockquote>
<p>每个构造函数都有原型prototype，prototype也是对象<br>  每个对象都有<strong>proto</strong>属性， __proto__ 的值就是构造函数的原型prototype<br>  prototype 下有个属性：constructor指向该对象的构造函数 或 该构造函数自己。</p>
</blockquote>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Factory</span></span>()&#123;&#125;</span><br><span class="line">Factory.prototype.name = <span class="string">'wang'</span></span><br><span class="line">var obj = new Factory();</span><br><span class="line"></span><br><span class="line">obj.__proto__                  ---&gt;      &#123;name: <span class="string">"wang"</span>, constructor: ƒ&#125;</span><br><span class="line">Factory.prototype              ---&gt;      &#123;name: <span class="string">"wang"</span>, constructor: ƒ&#125;</span><br><span class="line">obj.__proto__.constructor      ---&gt;       ƒ <span class="function"><span class="title">Factory</span></span>()&#123;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>1） 构造函数.prototype.属性  是增加或修改原型的属性<br>      构造函数.prototype = {…} 是重写，覆盖本来的原型<br>  2） 构造函数构造出的对象，在<font color="green">出生（定义）</font>时就知道了原型的地址。这时是谁就是谁，你可以给我的原型prototype增加或修改属性，但是如果你在我出生后在修改构造函数的原型，就和我没关系了。我的原型还是我出生时候的原型。</p>
</blockquote>
<h6 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h6><ul>
<li><font color="red">谁调用的方法，方法内部的this就指向谁，没人调用则指向全局对象（window）</font>
</li>
<li><font color="red">绝大多数对象的最终都会继承自Object.prototype</font>
</li>
<li><p><font color="red">Object.create(null)</font>，null创建出来的对象没有原型，NoPrototies</p>
</li>
</ul>
<h5 id="3、this指向问题"><a href="#3、this指向问题" class="headerlink" title="3、this指向问题"></a>3、this指向问题</h5><p>以下结果是什么，为什么？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var num = 123;</span><br><span class="line">num.toString();</span><br></pre></td></tr></table></figure></p>
<p>结果是”123”，因为原型链中从底部向顶部查找toString()方法，数字的Number包装类里就有toString()方法，所以没有继续找Object的toString()方法。</p>
<h6 id="1）-call的实现原理"><a href="#1）-call的实现原理" class="headerlink" title="1） call的实现原理"></a>1） call的实现原理</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myCall = <span class="keyword">function</span>(thisArg, ...args) &#123;</span><br><span class="line">  <span class="keyword">if</span> (typeof this !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    throw new TypeError(<span class="string">'error'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  thisArg = thisArg || window;</span><br><span class="line">  thisArg.func = this;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">let</span> fn = thisArg.func(...args);</span><br><span class="line">  delete thisArg.func;</span><br><span class="line">  <span class="built_in">return</span> fn;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="built_in">test</span>(params) &#123;</span><br><span class="line">  console.log(this.name, params);</span><br><span class="line">&#125;</span><br><span class="line">var name = <span class="string">'全局的名字'</span>;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  name: <span class="string">'obj的名字'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">test</span>(<span class="string">'测试参数-无人调用'</span>);                    ----&gt;    全局的名字   测试参数-无人调用</span><br><span class="line">test.call(obj, <span class="string">'测试参数-obj调用'</span>);          ----&gt;    obj的名字    测试参数-obj调用</span><br></pre></td></tr></table></figure>
<h6 id="2）apply的实现原理"><a href="#2）apply的实现原理" class="headerlink" title="2）apply的实现原理"></a>2）apply的实现原理</h6><p>apply的实现原理和call一样，只不过是传入的参数不同处理不同而已。<br>其实,apply应该还要校验：参数只能有两个，且第二个参数必须是数组，否则会报错。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//Function.prototype.apply = <span class="keyword">function</span>(thisArg,args)</span><br><span class="line">//去除参数的第一个值后执行这个添加的函数</span><br><span class="line">const res = thisArg.fn(...args);//只是参数处理不用，args这里只接受数组</span><br></pre></td></tr></table></figure></p>
<h6 id="3）bind的实现原理"><a href="#3）bind的实现原理" class="headerlink" title="3）bind的实现原理"></a>3）bind的实现原理</h6><p>将绑定函数当作构造函数使用，bind 提供的 this 指向无效，但是还是可以预设参数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Test3(a, b) &#123;</span><br><span class="line">  this.a = a;</span><br><span class="line">  this.b = b;</span><br><span class="line">&#125;</span><br><span class="line">Test3.prototype.add = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="built_in">return</span> this.a + this.b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不用 bind，正常来说这样处理</span></span><br><span class="line">var t1 = new Test3(1, 2);</span><br><span class="line">t1.add(); <span class="comment"># 3, this 指向 t1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 bind</span></span><br><span class="line">var NewTest3 = Test3.bind(null, 3);</span><br><span class="line">var t2 = new NewTest3(4);</span><br><span class="line">t2.add(); <span class="comment"># 7, this 指向 t2</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind = <span class="keyword">function</span> (oThis) &#123;</span><br><span class="line">  <span class="keyword">if</span>(typeof this !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    throw new TypeError(<span class="string">'Function.prototype.bind - what is trying to bebound is noe callable'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var aArgs = Array.prototype.slice.call(arguments, 1),</span><br><span class="line">      fToBind = this,</span><br><span class="line">      fNop = <span class="function"><span class="title">function</span></span> () &#123;&#125;,</span><br><span class="line">      fBound = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        <span class="comment"># 当通过new方法调用时，this就是fNop的一个实例</span></span><br><span class="line">        <span class="built_in">return</span> fToBind.apply(this instanceof fNop ? this : (oThis || this) , aArgs.concat(Array.prototype.slice.call(arguments)));</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">  fNop.prototype = this.prototype;</span><br><span class="line">  fBound.prototype = new fNop();</span><br><span class="line">  <span class="built_in">return</span> fBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>call 、 apply 和 bind的区别：<br>1）apply、call 都是直接执行调用函数，并让this执行第一个参数<br>              二者只是传参格式不同：call(obj,arguments1, arguments2…)<br>                                apply(obj,[arguments1, arguments2…])<br>2）bind绑定this后返回一个函数闭包，不直接执行。（将绑定函数当做构造函数使用，bind 提供的 this 指向无效，但是还是可以预设参数）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;var a = 12;this.sayA = function()&#123;console.log(this.a);&#125;&#125;</span><br><span class="line">var oTest = new test()</span><br><span class="line">oTest.sayA();   ---&gt; undefined</span><br></pre></td></tr></table></figure>
<p>阿里经典面试题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;222&apos;;</span><br><span class="line">var a = &#123;</span><br><span class="line">  name: &apos;111&apos;,</span><br><span class="line">  say: function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">a.say();</span><br><span class="line">var b = &#123;</span><br><span class="line">  name: &apos;333&apos;,</span><br><span class="line">  say: function (fun) &#123;</span><br><span class="line">    fun();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">b.say(a.say);</span><br><span class="line">b.say = a.say;</span><br><span class="line">b.say();</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;foo = 2; this.foo = 4; console.log(this.foo);&#125;</span><br><span class="line">test();</span><br><span class="line">new test();</span><br><span class="line"></span><br><span class="line">function test() &#123;this.foo = 4;foo = 2; console.log(this.foo);&#125;</span><br><span class="line">test();</span><br><span class="line">new test();</span><br></pre></td></tr></table></figure>
<p>先查AO。再查GO，<br>局部变量 - this - 全局</p>
<h5 id="4、继承发展史"><a href="#4、继承发展史" class="headerlink" title="4、继承发展史"></a>4、继承发展史</h5><p>1、传统形式：会沿着原型链一脉相承，继承父辈祖辈的所有属性，但是可能很多属性是没用的。</p>
<p>2、借用构造函数：不能继承借用构造函数的原型，每次构造函数都要多走一个函数。（call/apply）</p>
<p>3、共享原型：不能随便改动自己的原型</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Fathor</span></span> () &#123;...&#125;</span><br><span class="line">var oFather = new Father();</span><br><span class="line"></span><br><span class="line">Son.prototype = Fathor.prototype;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Son</span></span> () &#123;...&#125;</span><br><span class="line">var oSon = new Son();</span><br></pre></td></tr></table></figure>
<p>这样，共用属性都放在原型里，再共享原型（继承），但是，如果其中更改了Son的原型,这样Father的原型也随之改变（如：Son.prototype.name = ‘wang’;则Father.prototype.name也会如上）。这样的相互影响有时并不是我们想要的。</p>
<p>4、圣杯模式<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Father</span></span> () &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Son</span></span> () &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> inherit (target, origin) &#123;</span><br><span class="line">  var oFn = <span class="function"><span class="title">function</span></span> () &#123;&#125;;</span><br><span class="line">  oFn.prototype = origin.prototype;</span><br><span class="line">  target.prototype =  new oFn();</span><br><span class="line">&#125;</span><br><span class="line">inherit(Son,Father);</span><br><span class="line">var oSon = new Son();</span><br><span class="line">var oFather = new Father();</span><br><span class="line"></span><br><span class="line">Son.prototype.name = <span class="string">'wang'</span>;</span><br><span class="line">oSon.name          ----&gt;    <span class="string">'wang'</span></span><br><span class="line">oFather.name       ----&gt;    undefined</span><br></pre></td></tr></table></figure></p>
<h5 id="5、模块化开发"><a href="#5、模块化开发" class="headerlink" title="5、模块化开发"></a>5、模块化开发</h5><h6 id="1）-命名空间"><a href="#1）-命名空间" class="headerlink" title="1） 命名空间"></a>1） 命名空间</h6><ol>
<li>污染全局<br>是指你在a.js中var a = 10; 在 b.js中var a = 20; 如果你同事应用a.js和b.js，那么变量a就会冲突，究竟用a.js里的a还是b.js里的a。（不同的人开发难免会出现相同命名） </li>
<li>模块化开发<br>将一个完整的项目，分解成多个模块，不同的人开发不同的模块，最后协同整合。</li>
<li>命名空间<br>模块化开发的方式，很容易发生全局变量污染的问题，因此我们需要管理变量，可以采用命名空间的方式管理变量。</li>
</ol>
<h6 id="2）-匿名函数自执行-封闭作用域"><a href="#2）-匿名函数自执行-封闭作用域" class="headerlink" title="2） 匿名函数自执行 封闭作用域"></a>2） 匿名函数自执行 封闭作用域</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var jQuery = (<span class="function"><span class="title">function</span></span> () &#123;                     <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="comment"># AO -&gt; jQuery(功能)                             # AO -&gt; jQuery(功能)            </span></span><br><span class="line">  var slice=Array.prototype.slice;                var slice = Array.prototype.slice;</span><br><span class="line">  var toString=Object,prototype.toString;         var toString = Object,prototype.toString;</span><br><span class="line">  ...                                             ...</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">jQuery</span></span> ()&#123;...使用变量slice toString&#125;     <span class="keyword">function</span> <span class="function"><span class="title">jQuery</span></span> ()&#123;...使用变量slice toString&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">return</span> jQuery;                                   window.$ = jQuery;</span><br><span class="line">&#125;)();                                            &#125;)();</span><br><span class="line">匿名函数自执行+封闭作用域+闭包                        匿名函数自执行+封闭作用域</span><br><span class="line">使原有的AO不释放，通过<span class="built_in">return</span>赋给变量                  将jQuery赋给全局变量</span><br><span class="line">该变量有函数功能，但无法使用其中的变量                  该变量有函数功能，但无法使用其中的变量</span><br></pre></td></tr></table></figure>
<ul>
<li><p>测试：这种解决办法能有效管理变量，防止变量污染</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ctl.js                                           cst.js</span><br><span class="line">(<span class="function"><span class="title">function</span></span>()&#123;                                     (<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">  var name = <span class="string">'ctl'</span>;                                var name = <span class="string">'cst'</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">show</span></span> () &#123;                               var age = 18;</span><br><span class="line">    console.log(name,  age);                       <span class="keyword">function</span> <span class="function"><span class="title">show</span></span> () &#123;</span><br><span class="line">  &#125;                                                   console.log(name,  age);&#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">change</span></span>() &#123;                              <span class="keyword">function</span> <span class="function"><span class="title">change</span></span>() &#123;</span><br><span class="line">    name += <span class="string">'10'</span>;                                     name += <span class="string">'10'</span>;</span><br><span class="line">  &#125;                                                 &#125;</span><br><span class="line"></span><br><span class="line">  window.ctlMake = &#123;show: show, change: change&#125;;    window.cstMake = &#123;show: show, change: change&#125;;</span><br><span class="line">&#125;)();                                              &#125;)();</span><br><span class="line"></span><br><span class="line">index.html</span><br><span class="line">&lt;script src = <span class="string">'ctl.js'</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src = <span class="string">'cst.js'</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  cstMake.show();           -----&gt; <span class="string">"cst"</span></span><br><span class="line">  ctlMake.show();           -----&gt; 报错：age is not defined</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><font color="red">* 每一个功能入口就是执行自己的函数，调用自己的变量，不会相互污染。</font><br>PS：当然啦，现在的前端自动化构建工具是，就不用麻烦了。</p>
</li>
</ul>
<h6 id="3）-链式调用模式"><a href="#3）-链式调用模式" class="headerlink" title="3） 链式调用模式"></a>3） 链式调用模式</h6><p>思考问题：</p>
<ol>
<li>如何实现链式调用模式（模仿jquery）</li>
<li>obj.eat().drink().play().laugh().sleep();<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var mrDeng = &#123;</span><br><span class="line">  eat: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'eat'</span>);</span><br><span class="line">    reeturn this;</span><br><span class="line">  &#125;,</span><br><span class="line">  drink: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'drink'</span>);</span><br><span class="line">    reeturn this;</span><br><span class="line">  &#125;,</span><br><span class="line">  paly: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'paly'</span>);</span><br><span class="line">    reeturn this;</span><br><span class="line">  &#125;,</span><br><span class="line">  laugh: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'laugh'</span>);</span><br><span class="line">    reeturn this;</span><br><span class="line">  &#125;,</span><br><span class="line">  sleep: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'sleep'</span>);</span><br><span class="line">    reeturn this;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>jQuery有一个经典的使用方法：通过$()将标签选中，包装成一个对象（如$(‘div’)），这个对象中有很多方法。可以调用一些方法去操作你选中的那个标签，可.css()再。css()，链式调用<br>$(‘div’).css().css().attr().addClass();</p>
<h5 id="6、克隆"><a href="#6、克隆" class="headerlink" title="6、克隆"></a>6、克隆</h5><p>判断数据类型的四种方式：typeof toString instaceof contructor </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">浅克隆：</span><br><span class="line">function cloneFactory (copy, origin) &#123;</span><br><span class="line">  copy = copy || &#123;&#125;;</span><br><span class="line">  for (var props in origin) &#123;</span><br><span class="line">    copy[props] = origin[props];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">深克隆：</span><br><span class="line">function deepClone (copy, origin) &#123;</span><br><span class="line">  copy = copy || &#123;&#125;;</span><br><span class="line">  var arrStr = &apos;[Object Array]&apos;;</span><br><span class="line">  for (var props in origin) &#123;</span><br><span class="line">    if (origin[props] !== null &amp;&amp; (origin[props] === &apos;object&apos;) ) &#123;</span><br><span class="line">      if (Object.prototype.toString.call(origin[props]) === arrStr) &#123;</span><br><span class="line">        copy[props] = [];</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         copy[props] = &#123;&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      deepClone(copy[props], origin[props]);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      copy[props] = origin[props];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">深克隆优化版本：</span><br><span class="line">function deepCloneFactory(copy, origin) &#123;</span><br><span class="line">  copy = copy || &#123;&#125;;</span><br><span class="line">  var arr = [],obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  for (var props in origin) &#123;</span><br><span class="line">    if (origin[props] === copy[props]) &#123;</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    for (var attrs in copy) &#123;</span><br><span class="line">      if (attrs === props) &#123;</span><br><span class="line">        if (Object.prototype.toString.call(origin[props]) === &apos;[object Array]&apos;) &#123;</span><br><span class="line">          arr = copy[attrs];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          obj = copy[attrs];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (origin.hasOwnProperty(props)) &#123;</span><br><span class="line">      if (origin[props] !== null &amp;&amp; typeof origin[props] === &apos;object&apos;) &#123;</span><br><span class="line">        if (Object.prototype.toString.call(origin[props] === &apos;[object Array]&apos;)) &#123;</span><br><span class="line">          copy[props] = arr;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          copy[props] = obj;</span><br><span class="line">        &#125;</span><br><span class="line">        deepCloneFactory(copy[props], origin[props]);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        copy[props] = origin[props];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JSON.parse(JSON.stringify())</p>
<h4 id="3-3）数组"><a href="#3-3）数组" class="headerlink" title="3.3）数组"></a>3.3）数组</h4><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>1、创建方式<br>  1）new Array(length/content)<br>  2）字面量</p>
<p>2、数组的读和写<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr[num]               <span class="comment"># 不可溢出读</span></span><br><span class="line">arr[num] = xxx;        <span class="comment"># 可溢出读</span></span><br></pre></td></tr></table></figure></p>
<p>3、数组的常用方法</p>
<ol>
<li><p>改变原数组<br>push     尾部加值，改变原数组，返回数组长度<br>pop      尾部弹指，改变原数组，返回被弹出的值<br>shift    首部弹值，改变原数组，返回被弹出的值<br>unshift  首部加值，改变原数组，返回数组长度<br>splice   在数组任意位加或删，返回截取的数组<br>reverse  倒序<br>sort     只能排单位数字，可</p>
<pre><code>arr.sort(function(a,b) {
  return a-b;
})
</code></pre><p><font color="red">* 让有序数组输出乱序：</font> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3,4,5,6,7,8,9];</span><br><span class="line">console.log(arr.sort(() =&gt; Math.random()-0.5));</span><br></pre></td></tr></table></figure>
</li>
<li><p>不改变原数组<br>concat    返回连接后的数组，不改变原数组<br>join -&gt; split<br>toString<br>slice</p>
<p><font color="orange">forEach</font>  只是简单的将数组遍历，类似于军人接受检阅，但是检阅结束并不会返回任何东西，也不会改变原数组,forEach的返回永远是undefind<br><font color="orange">map</font>      可以比喻成去超市买东西，你拿了一个物品清单，然后服务员帮你拿好东西，返回给你一个物品的新数组，但是对清单原数组不发生改变<br><font color="orange">filter</font>   就是让男生排队身高高于180的就归入到新数组中，最后返回一个里面装着所有180+的男生的数组，不改变原数组<br><font color="orange">reduce</font>    主要是为了对所有数组进行累加，最后返回一个值，不改变原数组，类似让男生把排队把把身高加起来<br><font color="orange">find</font>     就是你去找人想找一个180的男生帮你去搬砖，只要找到第一个就停止遍历，因为只要找一个，为了减少无用的操作，虽然其他方法也能实现同样的要过，但是最好用find()</p>
</li>
</ol>
<h5 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h5><ol>
<li>可以利用属性名模拟数组的特性</li>
<li>可以动态的增长length属性</li>
<li>如果强行让类数组调用push方法，则会根据length属性值的位置进行属性的扩充</li>
</ol>
<ul>
<li>要有索引（数字）属性，必须有length属性，最好加上push可以向数组一样用。如果再加上splice，控制台输出和数组一样。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1. 问题1:</span><br><span class="line">  var obj = &#123;</span><br><span class="line">    2: &apos;a&apos;,</span><br><span class="line">    3: &apos;b&apos;,</span><br><span class="line">    length: 2,</span><br><span class="line">    push: Array.prototype.push</span><br><span class="line">  &#125;;</span><br><span class="line">  obj.push(&apos;c&apos;);</span><br><span class="line">  obj.push(&apos;d&apos;);</span><br><span class="line">  console.log(obj);  ---&gt; &#123;2: &quot;c&quot;, 3: &quot;d&quot;, length: 4, push: ƒ&#125;</span><br><span class="line"></span><br><span class="line">2. 问题2：编写方法对所有数据类型都能判断准确。</span><br><span class="line">  function myType (myVar) &#123;</span><br><span class="line">    var cache = &#123;</span><br><span class="line">      &apos;[object Number]&apos;: &apos;number-object&apos;,</span><br><span class="line">      &apos;[object String]&apos;: &apos;string-object&apos;,</span><br><span class="line">      &apos;[object Boolean]&apos;: &apos;bool-object&apos;,</span><br><span class="line">      &apos;[object Array]&apos;: &apos;array&apos;,</span><br><span class="line">      &apos;[object Object]&apos;: &apos;object&apos;,</span><br><span class="line">    &#125;;</span><br><span class="line">    if (myVar === null) &#123;</span><br><span class="line">      return &apos;null&apos;;</span><br><span class="line">    &#125; else if (typeof myVar === &apos;object&apos;) &#123;</span><br><span class="line">      return cache[Object.prototype.toString.call(myVar)];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return typeof myVar;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></p>
<h2 id="第三节、DOM"><a href="#第三节、DOM" class="headerlink" title="第三节、DOM"></a><font color="#FF69B4">第三节、DOM</font></h2><ul>
<li>什么是DOM？</li>
</ul>
<ol>
<li>DOM  –&gt; Document Object Model</li>
<li>DOM定义了表达和修改文档所需对象，定义了这些对象之间的行为和属性以及这些对象之间的关系。<br>DOM对象即为宿主对象，由浏览器厂商定义，用来操作html和css功能的一类对象的集合。<br>也有人称DOM是对HTML以及XML的标准编程接口。</li>
</ol>
<ul>
<li>为什么要有DOM？<br>js不能直接操作html标签，但是浏览器提供了一类对象，可以作为js操作html的桥梁。</li>
</ul>
<h3 id="一、基本操作"><a href="#一、基本操作" class="headerlink" title="一、基本操作"></a>一、基本操作</h3><h4 id="1-1）DOM节点"><a href="#1-1）DOM节点" class="headerlink" title="1.1）DOM节点"></a>1.1）DOM节点</h4><h5 id="对节点的查"><a href="#对节点的查" class="headerlink" title="对节点的查"></a>对节点的查</h5><h6 id="一、查看元素节点"><a href="#一、查看元素节点" class="headerlink" title="一、查看元素节点"></a>一、查看元素节点</h6><p>  document代表整个文档</p>
<p>  document.getElementById(); 元素id在ie8以下的浏览器，不取区分id大小写，而且也返回匹配name属性的元素。<br>  document.getElementsByClassName(); ie8及以下的ie版本中没有，可以多个class一起。<br>  document.getElementsByTagName();<br>  document.getElementsByName(); 需注意，只有部分标签name可生效（表单、表单元素、img、iframe）。<br>  querySelector(); css选择器，在ie7及以下的版本中没有。<br>  querySelectorAll(); css选择器，在ie7及以下的版本中没有。</p>
  <div class="post-warning">注：querySelector和querySelectorAll选出的元素不是实时的，是一个副本，一个快照。其他方法选出的dom都是实时的。<br>    1）querySelector()只返回一个<br>    2）querySelectorAll()返回所有但不更新<br>    3）其他返回所有并更新<br>  </div>

<h6 id="二、遍历节点树"><a href="#二、遍历节点树" class="headerlink" title="二、遍历节点树"></a>二、遍历节点树</h6><p>  parentNode 父节点（最顶端的parentNode是#document）<br>  childNodes 子节点们<br>  firstChild 第一个子节点<br>  lastChild  最后一个子节点<br>  nextSibling 后一个兄弟节点<br>  previousSibling 前一个兄弟节点</p>
<p>  节点类型：<br>  元素节点  – 1<br>  属性节点  – 2<br>  文本节点  – 3<br>  注释节点  – 8<br>  document – 9<br>  DocumentFragment – 11</p>
<p>  获取节点类型 nodeType</p>
<h6 id="三、基于元素节点树的遍历"><a href="#三、基于元素节点树的遍历" class="headerlink" title="三、基于元素节点树的遍历"></a>三、基于元素节点树的遍历</h6><p>  parentElement 返回当前元素的父节点<br>  children 只返回当前元素的元素子节点<br>  node.childElementCount === node.children.length 单签蒜素节点的子元素节点个数（IE不兼容）<br>  firstElementChild 返回第一个元素节点（IE不兼容）<br>  lastElementChild 返回最后一个元素节点（IE不兼容）<br>  nextElementSibling / previousElementSibling 返回后一个/前一个兄弟元素节点（IE不兼容）</p>
<h6 id="四、节点的属性和方法"><a href="#四、节点的属性和方法" class="headerlink" title="四、节点的属性和方法"></a>四、节点的属性和方法</h6><blockquote>
<p>属性：<br>  nodeName 元素的标签名，以大写形式表示，只读<br>  nodeValue Text节点或comment节点的文本内容，可读写<br>  nodeType 该节点的类型，只读<br>  style css属性，可读写<br>  attribute Element节点的属性集合(只有元素节点才有attribute，它是整个dom节点的属性集合，是一个类数组)</p>
</blockquote>
<blockquote>
<p>方法：<br>  Node.hasChildNodes();<br>  Node.setAttribute(‘attri-xxx’,’value-xxx’);<br>  Node.getAttribute(‘attri-xxx’);</p>
</blockquote>
<h5 id="对节点的增删改"><a href="#对节点的增删改" class="headerlink" title="对节点的增删改"></a>对节点的增删改</h5><blockquote>
<p>增<br>  document.createElement();<br>  document.createTextNode();<br>  document.creeateComment();<br>  document.createDocumentFragment();</p>
</blockquote>
<blockquote>
<p>插<br>  PARENTNODE.appendChild();<br>  PARENTNODE.insertBefore(a,b);</p>
</blockquote>
<blockquote>
<p>删<br>  parent.removeChild();</p>
</blockquote>
<blockquote>
<p>替换<br>  parent.replaceChild();</p>
</blockquote>
<h4 id="1-2-DOM树"><a href="#1-2-DOM树" class="headerlink" title="1.2) DOM树"></a>1.2) DOM树</h4>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DOM树：</span><br><span class="line"></span><br><span class="line">       - Document - HTMLDocument       - HTMLHeadElement </span><br><span class="line">      |                  - Text       |- HTMLBodyElement</span><br><span class="line">      |- CharactorData -|             |- HTMLTitleElement</span><br><span class="line">Node -|                  - Comment    |- HTMLParagraphElement</span><br><span class="line">      |- Element - HTMLElement ------ |- HTMLInputElement</span><br><span class="line">      |                                - ... etc</span><br><span class="line">       - Attr</span><br></pre></td></tr></table></figure>
<p>  Document是一个构造函数，但是用户不能new Document()创建新对象。<br>  document - HTMLDocument - Document:<br>  document是HTMLDocument构造函数的实例，原型是HTMLDocument.prototype。<br>  HTMLDocument.prototype也是对象，原型是Document.prototype。<br>  HTMLDocument.prototype.__proto__ -&gt; Document.prototype 构成原型链。</p>
  <div class="post-warning">观察DOM结构树，很容易发现，若在共有原型上加属性和方法，那么下面的构造函数的对象都可用。</div>

<blockquote>
</blockquote>
<pre><code>getElementById() 定义在Document.prototype上，即Element节点上不能使用。

getElementsByName() 定义在HTMLDocument.prototype上，即非html中的document意外不能使用（xml document Element）

getElementsByTagName() 定义在Document.prototype和Element.prototype上

Document.prototype上定义了documentElement属性，指代文档的根元素，在HTML文档中，他总是指代&lt; html&gt;&lt;\/html&gt;元素（只读不可写）。

HTMLDocument.prototype定义了一些常用的属性，body、head分别指代HTML文档中的&lt; body&gt;&lt;\/body&gt;&lt; head&gt;&lt;\/head&gt;标签。

getElementsByClassName()、querySelectorAll()、querySelectorAll、querySelector在Document，Element类中均有定义。
</code></pre><ul>
<li><p>节点的一些属性和方法<br>innerHTML<br>innerText(旧版本火狐不兼容)/textContent(老版本IE不兼容，主流浏览器一般用的都是innerText)</p>
<p>ele.setAttribute();<br>ele.getAttribute();</p>
</li>
</ul>
<h4 id="1-3-DOM基本操作"><a href="#1-3-DOM基本操作" class="headerlink" title="1.3) DOM基本操作"></a>1.3) DOM基本操作</h4><h5 id="日期对象"><a href="#日期对象" class="headerlink" title="日期对象"></a>日期对象</h5><blockquote>
<p>Date<br>var oDate = new Date();</p>
<p>// 获取<br>oDate.toString();<br>oDate.getFullYear(); 年<br>oDate.getMonth(); 月<br>oDate.getDate(); 日期<br>oDate.getDay(); 天数<br>oDate.getHours(); 时<br>oDate.getMinutes(); 分<br>oDate.getSeconds(); 秒<br>oDate.getMilliseconds(); 毫秒<br>oDate.getTime(); 自1970年1月1日至今的毫秒数</p>
<p>// 设置<br>oDate.setFullYear(); 年<br>oDate.setMonth(); 月<br>oDate.setDate(); 日期<br>oDate.setDay(); 天数<br>oDate.setHours(); 时<br>oDate.setMinutes(); 分<br>oDate.setSeconds(); 秒<br>oDate.setMilliseconds(); 毫秒<br>oDate.setTime(); 自1970年1月1日至今的毫秒数</p>
</blockquote>
<h5 id="js定时器"><a href="#js定时器" class="headerlink" title="js定时器"></a>js定时器</h5><p>  setInterval();<br>  setTimeout();<br>  clearInterval();<br>  clearTimeout();</p>
<p>  全局对象window上的方法，内部函数this指向window。</p>
<h5 id="查看滚动条的滚动距离"><a href="#查看滚动条的滚动距离" class="headerlink" title="查看滚动条的滚动距离"></a>查看滚动条的滚动距离</h5><p>  window.pageXOffset、window.pageXOffset (IE及IE8以下不兼容)<br>  document.body.scrollLeft、document.body.scrollTop (兼容性比较混乱)<br>  document.documentElement.scrollLeft、 document.documentElement.scrollTop (兼容性比较混乱)</p>
<h5 id="查看视口尺寸"><a href="#查看视口尺寸" class="headerlink" title="查看视口尺寸"></a>查看视口尺寸</h5><p>  window.innerWidth、window.innerHeight (IE及IE8以下不兼容)<br>  document.documentElement.clientWidth、document.documentElement.clientHeight (标准模式下，任意浏览器都兼容)<br>  document.body.clientWidth、 document.body.clientHeight (客户可视窗口，适用于怪异模式下的浏览器)</p>
<h5 id="查看元素的几何尺寸"><a href="#查看元素的几何尺寸" class="headerlink" title="查看元素的几何尺寸"></a>查看元素的几何尺寸</h5><p>  domEle.getBoundingClientRect(); </p>
<blockquote>
<p>兼容性好，该方法返回一个对象，对象里面有left、top、right、bottom等属性。left和top代表钙元素左上角的x和y坐标，right和bottom代表元素右下角的x，y坐标</p>
</blockquote>
<h5 id="查看元素尺寸"><a href="#查看元素尺寸" class="headerlink" title="查看元素尺寸"></a>查看元素尺寸</h5><p>  domEle.offsetWidth、domEle.offsetHeight</p>
<h5 id="查看元素位置"><a href="#查看元素位置" class="headerlink" title="查看元素位置"></a>查看元素位置</h5><p>  domEle.offsetLeft、 domEle.offsetTop</p>
<blockquote>
<p>对于无定位父级的元素，返回相对于文档的坐标。对于有定位的父级的元素，返回相对于最近的有定位的父级的坐标（无论是left还是margin-left等都是距离）。</p>
</blockquote>
<p>  domEle.offsetParent<br>  返回最近的有定位的父级，若无，返回body。body.offsetParent，返回null。</p>
<h5 id="让滚动条滚动"><a href="#让滚动条滚动" class="headerlink" title="让滚动条滚动"></a>让滚动条滚动</h5><p>  window上有三个方法：scroll() scrollTo() scrollBy()</p>
<h4 id="1-4）脚本化css"><a href="#1-4）脚本化css" class="headerlink" title="1.4）脚本化css"></a>1.4）脚本化css</h4><h5 id="读写元素css属性"><a href="#读写元素css属性" class="headerlink" title="读写元素css属性"></a>读写元素css属性</h5><p>  dom.style.prop 可读写样式，没有兼容性问题，碰到float这样的关键字属性，前面应加css。eg: float -&gt; cssFloat。<br>  复合属性必须拆解，组合单词变成小驼峰式写法。<br>  写入的值必须是字符串格式。</p>
<h5 id="查询计算样式"><a href="#查询计算样式" class="headerlink" title="查询计算样式"></a>查询计算样式</h5><p>  window.getComputedStyle(ele, null); 计算样式只读，返回的计算样式的值是绝对值，没有相对单位。（IE8及以下不兼容）</p>
<h5 id="查询样式"><a href="#查询样式" class="headerlink" title="查询样式"></a>查询样式</h5><p>  ele.currentStyle(了解就可以，现在都不用了，现在使用chrome会报错)</p>
<p><br><br><br><br><br><br><br></p>
<h3 id="二、事件"><a href="#二、事件" class="headerlink" title="二、事件"></a>二、事件</h3><h4 id="绑定事件处理函数"><a href="#绑定事件处理函数" class="headerlink" title="绑定事件处理函数"></a>绑定事件处理函数</h4><ul>
<li><p>ele.onxx = function (event) {};<br>兼容性好，基本等同于句柄。<br>但是一个元素的同一事件只能绑定一个处理程序。</p>
</li>
<li><p>ele.addEventListener(type, fn ,false);<br>IE9以下不兼容。<br>true：事件句柄在捕获阶段执行，false：事件句柄在冒泡阶段执行<br>一个元素的同一事件可以绑定多个处理程序，但是不能多次绑定同一处理程序。</p>
</li>
<li><p>ele.attacEvent(‘onxxx’, fn);<br>IE独有。<br>一个元素的同一事件可以绑定多个处理程序，但是不能多次绑定同一处理程序。</p>
</li>
</ul>
<blockquote>
<p>事件处理程序的运行环境（this）<br>  1、ele.onxx this指向dom元素本身<br>  2、ele.addEventListener this指向dom元素本身<br>  3、ele.attacEvent this指向window</p>
</blockquote>
<h4 id="解除事件处理函数"><a href="#解除事件处理函数" class="headerlink" title="解除事件处理函数"></a>解除事件处理函数</h4><p>  ele.onxxx = false / ‘’ / null;<br>  ele.removeEventListener(type, fn, false);<br>  ele.detachEvent(‘onxxx’, fn);</p>
  <div class="post-warning">注：若绑定匿名函数，则无法解除。</div>

<h4 id="事件冒泡-amp-捕获-gt-事件处理模型"><a href="#事件冒泡-amp-捕获-gt-事件处理模型" class="headerlink" title="事件冒泡&amp;捕获 -&gt; 事件处理模型"></a>事件冒泡&amp;捕获 -&gt; 事件处理模型</h4><ul>
<li><p>事件冒泡<br>结构上（非视觉上）嵌套关系的元素，会存在事件冒泡的功能，即同一事件，自子元素冒泡到父元素（自底向上）。</p>
</li>
<li><p>事件捕获<br>结构上（非视觉上）嵌套关系的元素，会存在事件捕获的功能，即同一事件，自父元素捕获至子元素（事件源元素）（自顶向下）。</p>
<p>触发顺序：先捕获后冒泡。<br>focus、blur、change、submit、reset、select等时间不冒泡。<br>IE没有捕获事件，就Chrome实现了捕获。</p>
</li>
</ul>
<p><br></p>
<ul>
<li><p>取消冒泡<br>W3C标准event.stopPropagation(); 但不支持IE9以下版本<br>IE独有event.cancelBubble = true;</p>
</li>
<li><p>阻止默认事件<br>默认事件 - 表单提交， a标签跳转， 右键菜单等<br>return false; 以对象属性的方式注册的事件才生效<br>event.preventDefault(); W3C标准，IE9以下不兼容<br>event.returnValue = false; 兼容IE</p>
<div class="post-warning">例如，我们来阻止【右键出菜单】这一默认事件：<br>  1、return false;是句柄方式阻止默认事件，只有用句柄的方式绑定事件，这种方式才好使。如以addEventListener注册的时间就不好使。<br>    document.oncontextmenu = function () { return false; }<br><br>  2、document.oncontextmenu = function (e) { e.preventDefault(); }<br><br>  3、document.oncontextmenu = function (e) { e.returnValue = false; }<br></div>



</li>
</ul>
<h4 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h4><ul>
<li>event || window.event（用于IE）</li>
<li>事件源对象：<strong>event.target</strong> 火狐只有这个、chrome两个都有<br><strong>event.srcElement</strong> IE只有这个，chrome两个都有</li>
</ul>
<h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><p>  利用事件冒泡和事件源对象进行处理<br>  优点：不需要循环所有的元素，一个一个绑定事件。当有新的子元素时不需要重新绑定事件。</p>
<h4 id="事件分类"><a href="#事件分类" class="headerlink" title="事件分类"></a>事件分类</h4><ul>
<li><strong>鼠标事件</strong><blockquote>
<p>click  mousedown  mousemove  mouseup  contextmenu<br>mouseover  mouseout  mouseenter mouseleave</p>
<ol>
<li>先 mousedown， 再mouseup， 最后click</li>
<li>鼠标移入: mouseover  mouseenter(es5新出的)<br>鼠标移出: mouseout   mouseleave(es5新出的)</li>
</ol>
<div class="post-warning">移动端，mousedown和mouseup就不好用了，而是用touchstart、touchmove、touchend</div>
</blockquote>
</li>
</ul>
<p><br></p>
<ul>
<li><p><strong>键盘事件</strong></p>
<blockquote>
<p>keydown   keypress   keyup </p>
<ol>
<li>先 keydown， 再keypress， 最后keyup</li>
<li>keydown和keypress的区别：keydown可以响应任意键盘按键，keypress只可以响应字符类键盘按键。</li>
</ol>
<div class="post-warning">1. keydown可以监听处理Fn辅助键之外的所有键（which：监测108个键子），keypress只能监听字符按键。<br><br>  2. 但是keydown记录不了字符类按键，不准。<br>     如果想监听字符类按键并区分大小写，用keypress，<br>     如果监听操作类按键，只用keydown。<br><br>  3. 二者各有优缺。keypress能识别键盘上的每一个键子，但是返回的数字我们不知道对应的哪个键子，得测。而且它只能测每个键子，如：shift+a-&gt;A,他就测不准，出现的是shift和A，这样说来，keypress更准确，keydown更广泛。<br></div>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.onkeypress = function (e) &#123;</span><br><span class="line">  console.log(e.key, String.fromCharCode(e.charCode));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br></p>
<ul>
<li><p><strong>文本操作事件</strong><br>input、 focus、 blur、 change</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> id=<span class="string">'inp'</span> /&gt;</span><br><span class="line"></span><br><span class="line">const oInp = document.getElementById(<span class="string">'inp'</span>);</span><br><span class="line">oInp.oninput = <span class="keyword">function</span> (e) &#123;</span><br><span class="line">  console.log(e.data, e.target.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>窗体操作事件</strong><br>scroll load</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.onscroll = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  console.log(window.pageXOffset + <span class="string">" "</span> +window.pageYOffset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">window.onload = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  var oDiv = document.getElementsByTagName(<span class="string">'div'</span>)[0];</span><br><span class="line">  oDiv.style.width = <span class="string">'100px'</span>;</span><br><span class="line">  oDiv.style.height = <span class="string">'100px'</span>;</span><br><span class="line">  oDiv.style.backgroundColor = <span class="string">'orange'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样完全好使，但是为什么我们都不这样使用。因为无意义，速度慢。整个文档解析后，renderTree构建完成后，DOM所有文档图片信息下载完成后，整个页面完成后才能出发window.onload事件。</p>
<p>当然也有用处，用load我们知道什么时候页面加载完成，我们可以把“广告”之类的功能放在load中，页面加载完再显示广告，但绝不能把主程序放在load里。</p>
<p>js有DOMTree + css有CSSTree -&gt; 渲染树 renderTree</p>
</li>
</ul>
<p><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></p>
<h2 id="第四节、BOM"><a href="#第四节、BOM" class="headerlink" title="第四节、BOM"></a><font color="#FF69B4">第四节、BOM</font></h2><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><ol>
<li>定义：Browser Object Model（浏览器对象模型）</li>
<li>BOM对象：window、history、Nacigator、screen、location等</li>
</ol>
<div class="post-warning">注：由于浏览器厂商不同，BOM对象的兼容性极低，故我们一般只用其中的部分功能。</div>

<h3 id="二、BOM对象"><a href="#二、BOM对象" class="headerlink" title="二、BOM对象"></a>二、BOM对象</h3><h4 id="1-window对象"><a href="#1-window对象" class="headerlink" title="1. window对象"></a><font color="DodgerBlue">1. window对象</font></h4><blockquote>
<p>window对象代表浏览器中打开的窗口。 如果文档中包含框架（frame或iframe标签），浏览器会为文档创建一个window对象，并为每个框架创建一个额外的window对象。<br>注：没有应用于window对象的公开标准，不过所有浏览器都支持该对象。</p>
</blockquote>
<blockquote>
<p>window对象集合：frames[]<br>返回窗口中所有命名的框架，该集合是window对象的数组，每个window对象若窗口中含有一个框架或iframe或属性frames。length存放数组frames[]中含有的元素个数。<br>注：frames[]数组中引用的框架可能还包含框架，它们自己也具有frames[]数组</p>
</blockquote>
<h5 id="window对象的属性"><a href="#window对象的属性" class="headerlink" title="window对象的属性"></a>window对象的属性</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">closed          返回窗口是否已被关闭</span><br><span class="line">defaultStatus   设置或返回窗口状态栏中的默认文本</span><br><span class="line">document        对Document对象的只读引用，请参阅Document对象</span><br><span class="line"><span class="built_in">history</span>         对History对象的只读引用，请参阅History对象</span><br><span class="line">location        用于窗口或框架的Location对象，请参阅Location对象</span><br><span class="line">Navigator       对Navigator对象的只读引用，请参阅Navigator对象</span><br><span class="line">Screen          对Screen对象的只读引用，请参阅Screen对象</span><br><span class="line">innerheight     返回窗口文档显示区的高度</span><br><span class="line">innerwidth      返回窗口文档显示区的宽度</span><br><span class="line">length          设置或返回窗口中的框架数量</span><br><span class="line">name            设置或返回窗口的名称</span><br><span class="line">opener          返回对创建此窗口的窗口引用</span><br><span class="line">outerheight     返回窗口的外部高度（IE不支持）</span><br><span class="line">outerwidth      返回窗口的外部宽度（IE不支持）</span><br><span class="line">pageXOffset     设置或返回当前页面相对于窗口显示区左上角的x位置</span><br><span class="line">pageYOffset     设置或返回当前页面相对于窗口显示区左上角的y位置</span><br><span class="line">parent          返回父窗口</span><br><span class="line">window          window属性等价于self属性，它包含了对窗口自身的引用</span><br><span class="line">self            返回当前窗口的引用，等价于window属性</span><br><span class="line">status          设置窗口状态栏的文本</span><br><span class="line">top             返回最顶层的先辈窗口</span><br><span class="line">screenLeft      只读整数，声明了窗口的左上角在屏幕上的x坐标和y坐标</span><br><span class="line">screenTop       IE、Safari和Opera支持screenLeft和screenTop</span><br><span class="line">screenX         只读整数，声明了窗口的左上角在屏幕上的x坐标和y坐标</span><br><span class="line">screenY         FireFox和Safari支持screenX和screenY</span><br></pre></td></tr></table></figure>
<h5 id="window对象的方法"><a href="#window对象的方法" class="headerlink" title="window对象的方法"></a>window对象的方法</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">alert()          显示带有一段消息和一个确认按钮的警告框</span><br><span class="line">confirm()        显示带有一段消息以及确认按钮和去取消按钮的对话框</span><br><span class="line">createPopup()    创建一个pop-up窗口</span><br><span class="line"><span class="built_in">print</span>()          打印当前窗口的内容</span><br><span class="line">prompt()         显示可提示用户输入的对话框</span><br><span class="line">blur()           可把键盘焦点从顶层浏览器窗口移走</span><br><span class="line">focus()          把键盘焦点给予一个窗口</span><br><span class="line">setInterval()    按照指定的周期（以毫秒计算）来调用函数或计算表达式</span><br><span class="line">setTimeout()     在指定的好描述后调用函数或计算表达式</span><br><span class="line">clearInterval()  取消由setInterval()设置的interval</span><br><span class="line">clearTimeout()   取消由setTimeout()设置的timeout</span><br><span class="line">open()           打开一个新浏览器窗口</span><br><span class="line">close()          关闭浏览器窗口</span><br><span class="line">scrollBy()       按照指定的像素值来滚动内容</span><br><span class="line">scrollTo()       把内容滚动到指定的坐标</span><br><span class="line">moveBy()         可相对窗口的当前坐标吧它移动到一个指定的像素</span><br><span class="line">moveTo()         把窗口的左上角移动到指定位置</span><br><span class="line">resizeBy()       按照指定的像素调整窗口的大小</span><br><span class="line">resizeTo()       把窗口的大小调整到指定的宽度和高度</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="2-Navigator对象"><a href="#2-Navigator对象" class="headerlink" title="2. Navigator对象"></a><font color="DodgerBlue">2. Navigator对象</font></h4><blockquote>
<p>Navigator对象包含有关浏览器的信息。</p>
</blockquote>
<font color="blue">没有应用于Navigator对象的公开标准，不过所有浏览器都支持此对象</font>

<h5 id="Navigator对象集合：plugins"><a href="#Navigator对象集合：plugins" class="headerlink" title="Navigator对象集合：plugins[]"></a>Navigator对象集合：plugins[]</h5><p>返回对文档中所有嵌入式对象的引用该集合是一个Plugin对象的数组。其中的元素代表浏览器已经安装的插件，Plugin对象提供的是有关插件的信息。其中包括它所支持的MIME类型的列表。虽然plugins数组是由IE4定义的，但是在IE4中它却总是空的，因为IE4不支持插件和Plugin对象。</p>
<h5 id="Navigator对象属性"><a href="#Navigator对象属性" class="headerlink" title="Navigator对象属性"></a>Navigator对象属性</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">appCodeName       返回浏览器的代码名</span><br><span class="line">appMinorVersion   返回浏览器的次级版本</span><br><span class="line">appName           返回浏览器名称</span><br><span class="line">appVersion        返回浏览器的平台和版本信息</span><br><span class="line">browserLanguage   返回当前浏览器的语言</span><br><span class="line">cookieEnabled     返回指明浏览器中是否启用cookie的布尔值</span><br><span class="line">cpuClass          返回浏览器系统的CPU等级</span><br><span class="line">onLine            返回指明系统是否处于脱机模式的布尔值</span><br><span class="line">platform          返回运行浏览器的操作系统平台</span><br><span class="line">systemLanguage    返回OS使用的默认语言</span><br><span class="line">userLanguage      返回由客户机发送服务器的user-agent头部的值</span><br></pre></td></tr></table></figure>
<h5 id="Navigator对象方法"><a href="#Navigator对象方法" class="headerlink" title="Navigator对象方法"></a>Navigator对象方法</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javaEnabled()     规定浏览器是否启用java</span><br><span class="line">taintEnabled()    规定浏览器是否启用数据污点(data tainting)</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="3-Screen对象"><a href="#3-Screen对象" class="headerlink" title="3.Screen对象"></a><font color="DodgerBlue">3.Screen对象</font></h4><blockquote>
<p>Screen对象包含有瓜客户端显示屏幕的信息。</p>
</blockquote>
<p><br></p>
<h4 id="4-History对象"><a href="#4-History对象" class="headerlink" title="4. History对象"></a><font color="DodgerBlue">4. History对象</font></h4><blockquote>
<p>History对象包含用户（在浏览器窗口中）访问过的URL，是window对象的一部分。可通过window.history属性进行访问。<br>  <font color="blue">注：没有应用于History对象的公开标准，不过所有浏览器都支持它。</font></p>
</blockquote>
<h5 id="History对象属性"><a href="#History对象属性" class="headerlink" title="History对象属性"></a>History对象属性</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">length 返回浏览器历史列表中的数量</span><br></pre></td></tr></table></figure>
<h5 id="History对象方法"><a href="#History对象方法" class="headerlink" title="History对象方法"></a>History对象方法</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">back()     加载<span class="built_in">history</span>列表中的前一个URL</span><br><span class="line">forward()  加载<span class="built_in">history</span>列表中的下一个URL</span><br><span class="line">go()       加载<span class="built_in">history</span>列表中的某个具体页面</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="5-Location对象"><a href="#5-Location对象" class="headerlink" title="5. Location对象"></a><font color="DodgerBlue">5. Location对象</font></h4><blockquote>
<p>Location对象包含有关当前URL的信息，是window对象的一部分，可通过window.location属性来访问</p>
</blockquote>
<h5 id="Location对象属性"><a href="#Location对象属性" class="headerlink" title="Location对象属性"></a>Location对象属性</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hash</span>       设置或返回从<span class="comment">#号（#）开始的URL（锚）</span></span><br><span class="line">host       设置或返回主机名和当前URL的端口号</span><br><span class="line">hostname   设置或返回当前URL的主机名</span><br><span class="line">href       设置或返回完整的URL</span><br><span class="line">pathname   设置或返回当前URL的路径部分</span><br><span class="line">port       设置或返回当前URL的端口号</span><br><span class="line">protocol   设置或返回当前URL的协议</span><br><span class="line">search     设置或返回从问号（?）开始的URL（查询部分）</span><br></pre></td></tr></table></figure>
<h5 id="Location对象方法"><a href="#Location对象方法" class="headerlink" title="Location对象方法"></a>Location对象方法</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">assign()    加载新的文档</span><br><span class="line">reload()    重新加载当前文档</span><br><span class="line">replace()   用新的文档替换当前文档</span><br></pre></td></tr></table></figure>
<p><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></p>
<h2 id="第五节、零散知识点"><a href="#第五节、零散知识点" class="headerlink" title="第五节、零散知识点"></a><font color="red" size="5">第五节、零散知识点</font></h2><h3 id="1-正则表达式-RegExp（Regular-Expression）"><a href="#1-正则表达式-RegExp（Regular-Expression）" class="headerlink" title="1.正则表达式 RegExp（Regular Expression）"></a><font color="DodgerBlue">1.正则表达式 RegExp（Regular Expression）</font></h3><blockquote>
<p>正则表达式是匹配特殊字符或有特殊搭配原则的字符的最佳选择。</p>
</blockquote>
<h4 id="一、创建方式"><a href="#一、创建方式" class="headerlink" title="一、创建方式"></a>一、创建方式</h4><ol>
<li>直接量 (个人推荐直接量)<br>如：var reg = /^\d | \d$/igm;</li>
<li><p>new RegExp();<br>如：var reg = new RegExp(‘/^\\d | \\d$/‘);</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">注：① js字符串不许出现回车符号，但是“\\”代表转义字符。</span><br><span class="line">      如：var a = <span class="string">"aaa\</span></span><br><span class="line"><span class="string">                  bbb"</span>;</span><br><span class="line">      这样就不会报错了。</span><br><span class="line">     ②“\”代表转义字符，“\\\”代表\。“\\n”代表换行</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="二、基础语法-1"><a href="#二、基础语法-1" class="headerlink" title="二、基础语法"></a>二、基础语法</h4><blockquote>
<p>RegExp对象标识正则表达式，是对字符转执行 <strong>模式匹配</strong> 的强大工具。</p>
</blockquote>
<h5 id="1-compile-编译正则表达式"><a href="#1-compile-编译正则表达式" class="headerlink" title="1. compile  编译正则表达式"></a>1. compile  编译正则表达式</h5>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exec     检索字符串中指定的值，返回找到的值，并确定其位置</span><br><span class="line">test     检索字符串中指定的值，返回true或false， 例：reg.test(str)</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i        代表不区分大小写（执行对大小写不敏感的匹配） 例：/[abc]/i</span><br><span class="line">g        代表全局匹配(查找所有匹配，而非找到第一个匹配后停止)</span><br><span class="line">m        多行匹配</span><br></pre></td></tr></table></figure>
<h5 id="2-支持正则表达式的String对象的方法"><a href="#2-支持正则表达式的String对象的方法" class="headerlink" title="2. 支持正则表达式的String对象的方法"></a>2. 支持正则表达式的String对象的方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">search    检索与正则表达式相匹配的值</span><br><span class="line">match     找到一个或多个正则表达式的匹配 &lt;font color=&quot;red&quot;&gt;例：str.match(reg)&lt;/font&gt;</span><br><span class="line">replace   替换与正则表达式匹配的子串</span><br><span class="line">split     把字符串分割为字符串数组</span><br></pre></td></tr></table></figure>
<h5 id="3-查找某法范围内的字符"><a href="#3-查找某法范围内的字符" class="headerlink" title="3.  [] 查找某法范围内的字符"></a>3.  <strong>[]</strong> 查找某法范围内的字符</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[abc]     查找方括号之间的任何字符</span><br><span class="line">[^abc]    查找任何不在方括号之间的字符</span><br><span class="line">[0-9]     查找任何从0到9之间的数字</span><br><span class="line">[a-z]     查找任何从小写a到小写z之间的字符</span><br><span class="line">[A-Z]     查找任何从大写A到大写Z之间的字符</span><br><span class="line">[A-z]     查找任何从大写A到小写z之间的字符</span><br><span class="line">[adj]     查找给定集合内的任何字符</span><br><span class="line">[^dss]    查找给定集合外的任何字符</span><br><span class="line">(red|green|blue) 查找任何指定的选项</span><br></pre></td></tr></table></figure>
<h5 id="4-元字符-（Metacharacter）是有特殊含义的字符，简化操作。"><a href="#4-元字符-（Metacharacter）是有特殊含义的字符，简化操作。" class="headerlink" title="4. 元字符 （Metacharacter）是有特殊含义的字符，简化操作。"></a>4. <strong>元字符</strong> （Metacharacter）是有特殊含义的字符，简化操作。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.         查找单个字符，除了换行和行结束符</span><br><span class="line">\w        查找单词字符</span><br><span class="line">\W        查找非单词字符</span><br><span class="line">\d        查找数字字符</span><br><span class="line">\D        查找非数字字符</span><br><span class="line">\s        查找空白字符</span><br><span class="line">\S        查号非空白字符</span><br><span class="line">\b        查找单词边界</span><br><span class="line">\B        查找非单词边界</span><br><span class="line">\O        查找NUL字符</span><br><span class="line">\n        查找换行符</span><br><span class="line">\f        查找换页符</span><br><span class="line">\r        查找回车符</span><br><span class="line">\t        查找制表符</span><br><span class="line">\v        查找垂直制表符</span><br><span class="line">\xxx      查找以八进制数xxx规定的字符</span><br><span class="line">\xdd      查找以十六进制数dd规定的字符</span><br><span class="line">\uxxx     查找以十六极致xxxx规定的Unicode字符</span><br></pre></td></tr></table></figure>
<h5 id="5-正则匹配原则（贪心匹配原则）-量词"><a href="#5-正则匹配原则（贪心匹配原则）-量词" class="headerlink" title="5. 正则匹配原则（贪心匹配原则） 量词"></a>5. 正则匹配原则（贪心匹配原则） <strong>量词</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">n+         匹配任何包含至少一个n的字符串</span><br><span class="line">n*         匹配任何包含零个或多个n的字符串</span><br><span class="line">n?         匹配任何包含零个或一个n的字符串</span><br><span class="line">n&#123;x&#125;       匹配包含x个n的序列的字符串</span><br><span class="line">n&#123;x,y&#125;     匹配包含x至y个n的序列的字符串</span><br><span class="line">n&#123;x,&#125;      匹配包含至少x个n的字符串</span><br><span class="line">n$         匹配任何结尾为n的字符串</span><br><span class="line">^n         匹配任何开头为n的字符串</span><br><span class="line">?=n        匹配任何其后紧接指定字符串n的字符串</span><br><span class="line">?!n        匹配任何其后紧接非指定字符串n的字符串</span><br></pre></td></tr></table></figure>
<h5 id="6-RegExp对象属性"><a href="#6-RegExp对象属性" class="headerlink" title="6. RegExp对象属性"></a>6. RegExp对象属性</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ignoreCase  RegExp对象是否具有标志i</span><br><span class="line">global      RegExp对象是否具有标志g</span><br><span class="line">multiline   RegExp对象是否具有标志m</span><br><span class="line">lastIndex   一个整数，表示开始下一次匹配的字符位置</span><br><span class="line">source      正则表达式的原文本</span><br></pre></td></tr></table></figure>
<h4 id="三、进阶"><a href="#三、进阶" class="headerlink" title="三、进阶"></a>三、进阶</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. \2、\1 反向子表达式引用</span><br><span class="line">2. 正向预查功能 ?= </span><br><span class="line">   (?: )不记录该子表达式的内容</span><br></pre></td></tr></table></figure>
<h3 id="2-json"><a href="#2-json" class="headerlink" title="2.json"></a><font color="DodgerBlue">2.json</font></h3><p>json是一种传输数据的格式（以对象为模板，本质上就是对象，但用途有区别。对象就是本地使用的数据类型，json是用来传输数据的数据类型）</p>
<div class="border1"><font color="red">JSON.parse();</font> string -&gt; json<br><font color="red">JSON.stringify();</font> json -&gt; string</div>

<h3 id="3-异步加载js"><a href="#3-异步加载js" class="headerlink" title="3.异步加载js"></a><font color="DodgerBlue">3.异步加载js</font></h3><h4 id="一、js同步加载"><a href="#一、js同步加载" class="headerlink" title="一、js同步加载"></a>一、js同步加载</h4><ol>
<li>js加载的缺点：加载工具方法没必要阻塞文档，使得js加载会影响页面效率，一旦网速不好，那么整个网站将等待js加载而不进行后续渲染等工作。</li>
<li>js加载不能满足的需求：有些工具方法需要按需加载，用到时再加载，不用时不加载。</li>
<li>页面解析：加载一行，解析一行，遇到&lt; link &gt;标签，开启一个新线程，异步加载css。</li>
</ol>
<h4 id="二、js异步加载"><a href="#二、js异步加载" class="headerlink" title="二、js异步加载"></a>二、js异步加载</h4><ol>
<li><p>javascript异步加载的三种方案：<br> 1） defer异步加载，但要等到dom文档全部解析完才会被执行（只有IE能用。执行时不阻塞页面）</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">".../xxx.js"</span> defer/async&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p> 2） async异步加载，加载完就执行<br> （async只能加载外部脚本，不能将js写在script标签里，w3c标准。执行时不阻塞页面）<br> 3） 创建script，插入到DOM中，onload，兼容，加载完毕后callBack。( 按需加载 ）</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var cb = &#123;</span><br><span class="line">        <span class="built_in">test</span>:<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">            console.log(<span class="string">"回调函数"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> loadScript(url,callback)&#123;</span><br><span class="line">        var oScript = docuemnt.createElement(<span class="string">'script'</span>);</span><br><span class="line">        oScript.src=url;</span><br><span class="line">        <span class="keyword">if</span>(oScript.readyState)&#123;</span><br><span class="line">            oScript.onreadystatechange = <span class="function"><span class="title">function</span></span>()&#123;//IE</span><br><span class="line">                <span class="keyword">if</span>(oScript.readyState == <span class="string">'complete'</span> || oScript.readyState == <span class="string">'loaded'</span>)&#123;</span><br><span class="line">                    oScript.onreadystatechange = null;</span><br><span class="line">                    cb[callback]();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            oScript.onload = <span class="function"><span class="title">function</span></span>()&#123;//非IE</span><br><span class="line">                oScript.onload = null;</span><br><span class="line">                cb[callback]();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        document.body.appendChild(oScript);</span><br><span class="line">    &#125;</span><br><span class="line">    loadScript(<span class="string">"xxx.js"</span>,<span class="string">"test"</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="4-js加载时间线"><a href="#4-js加载时间线" class="headerlink" title="4.js加载时间线"></a><font color="DodgerBlue">4.js加载时间线</font></h3><ol>
<li>创建Document对象，开始解析页面。解析HTML元素和他们的文本内容后，添加Element对象和Text节点到文档中，这个阶段document.readyState = ‘loading’。</li>
<li>遇到link外部css，创建线程加载，并继续解析文档。</li>
<li>遇到script外部js并且没有设置defer或async，浏览器加载并阻塞，等待js加载完成并执行该脚本后，继续解析文档。</li>
<li>遇到script外部js并且有设置defer或async，浏览器创建线程加载，并继续解析文档。对于async属性，脚本加载完成后立即执行（异步禁止使用document.write）</li>
<li>遇到img等，先正常解析dom结构，然后浏览器开始加载src，并继续解析文档。</li>
<li>当文档解析完成，document.readyState=’interactive’（document.onreadystatechange）</li>
<li>文档解析完成后，所有设置有defer的脚本会按照顺序执行（注：与async不同，但同样禁止document.write）</li>
<li>document对象触发DOMContentloaded事件，这也标志着程序执行从同步脚本执行阶段，转换为事件驱动阶段（document.addEventListener）</li>
<li>当所有async的脚本加载完成并执行后、img等加载完成后，docuemnt.readyState = ‘complete’，window对象触发load事件。</li>
<li>从此，以异步响应方式处理用户输入，网络事件等。<br><font color="red">docuemnt.write()能清除文档流，故异步加载禁止使用document.write()</font><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    console.log(<span class="string">"1.开始解析页面，document.readyState的值为"</span>,document.readyState,<span class="string">", 2 3 4 5 解析html,css,js,img等"</span>);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    document.addEventListener(<span class="string">'DOMContentLoaded'</span>,<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        console.log(<span class="string">"8. document对象触发DOMContentloaded事件，这也标志着程序执行从同步脚本执行阶段，转换为事件驱动阶段（document.addEventListener）"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    document.onreadystatechange = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        <span class="keyword">if</span>(document.readyState == <span class="string">"interactive"</span>)&#123;</span><br><span class="line">            console.log(<span class="string">"6.当页面解析完成后，onreadystatechange事件中document.readyState变为"</span>,document.readyState,<span class="string">"，7.defer执行"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(document.readyState == <span class="string">"complete"</span>)&#123;</span><br><span class="line">            console.log(<span class="string">"9.onreadystatechange事件中document.readyState变为"</span>,document.readyState);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    document.addEventListener(<span class="string">'DOMContentLoaded'</span>,<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        console.log(<span class="string">"8. document对象触发DOMContentloaded事件，这也标志着程序执行从同步脚本执行阶段，转换为事件驱动阶段（document.addEventListener）"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    window.onload = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        console.log(<span class="string">"9.window对象触发load事件"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(<span class="string">"1.开始解析页面，document.readyState的值为"</span>,document.readyState,<span class="string">", 2 3 4 5 解析html,css,js,img等"</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><div></div></p>
<script>
    console.log("1.开始解析页面，document.readyState的值为",document.readyState,", 2 3 4 5 解析html,css,js,img等");
</script>
<script>
    document.addEventListener('DOMContentLoaded',function(){
        console.log("8. document对象触发DOMContentloaded事件，这也标志着程序执行从同步脚本执行阶段，转换为事件驱动阶段（document.addEventListener）");
    })
    document.onreadystatechange = function(){
        if(document.readyState == "interactive"){
            console.log("6.当页面解析完成后，onreadystatechange事件中document.readyState变为",document.readyState,"，7.defer执行");
        }else if(document.readyState == "complete"){
            console.log("9.onreadystatechange事件中document.readyState变为",document.readyState);
        }
    }
    document.addEventListener('DOMContentLoaded',function(){
        console.log("8. document对象触发DOMContentloaded事件，这也标志着程序执行从同步脚本执行阶段，转换为事件驱动阶段（document.addEventListener）");
    })
    window.onload = function(){
        console.log("9.window对象触发load事件");
    }
    console.log("1.开始解析页面，document.readyState的值为",document.readyState,", 2 3 4 5 解析html,css,js,img等");
</script>

<p><div class="border1">URL：<a href="https://www.baidu.com/s?ie-utf-88&amp;f=3&amp;rsv_bp=1" target="_blank" rel="noopener">https://www.baidu.com/s?ie-utf-88&amp;f=3&amp;rsv_bp=1</a></div></p>
<font color="red">资源定位符：</font>协议名(https)  主机名(域名 <a href="http://www.baidu.com&nbsp;&nbsp;路径(/s)&nbsp;&nbsp;参数名=参数值(ie-utf-88)" target="_blank" rel="noopener">www.baidu.com&nbsp;&nbsp;路径(/s)&nbsp;&nbsp;参数名=参数值(ie-utf-88)</a><br><br><font color="blue">DNS -&gt; IP -&gt; 服务端 -&gt; 客户端</font>





<h3 id="5-DOCTYPE"><a href="#5-DOCTYPE" class="headerlink" title="5.DOCTYPE"></a>5.DOCTYPE</h3><ol>
<li>渲染模式：标准模式、混杂模式（怪异模式）</li>
<li>三种标准模式的写法：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC <span class="string">"-//W3C//DTD HTML 4.01//EN"</span> <span class="string">"http://www.w3.org/TR/html4/strict.dtd"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD XHTML 1.0 Strict//EN"</span> <span class="string">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="6-for属性-gt-js中表示htmlFor"><a href="#6-for属性-gt-js中表示htmlFor" class="headerlink" title="6.for属性 -&gt; js中表示htmlFor"></a>6.<label>for属性 -&gt; js中表示htmlFor</label></h3><p>属性映射HTML属性，映射到Element属性<br>img图片预加载<br>byClassName自己定义的写法<br>Math.random和彩票程序（0-36的随机数）</p>
<h3 id="7-文档碎片"><a href="#7-文档碎片" class="headerlink" title="7.文档碎片"></a>7.文档碎片</h3><p>CDN<br>断点调试<br>typeof(new Array).<strong>proto</strong>.constructor();<br>forEach里不能用break</p>
<p><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></p>
<h1 id="第二章、-ES-6"><a href="#第二章、-ES-6" class="headerlink" title="第二章、 ES 6"></a><font color="#DC143C">第二章、 ES 6</font></h1><h2 id="第一节、-块级作用域"><a href="#第一节、-块级作用域" class="headerlink" title="第一节、 块级作用域"></a><font color="#FF69B4">第一节、 块级作用域</font></h2><blockquote>
<p>ES5，以function来划分作用域，但是{}却限定不了var的作用域。<br>ES6，增加了let和const，声明在{} -&gt; “function、if、for等”的变量作用域被限制在块级</p>
</blockquote>
<h3 id="let-和-const"><a href="#let-和-const" class="headerlink" title="let 和 const"></a>let 和 const</h3><blockquote>
<p>生命周期在块级作用域中<br>没有变量提升，不可重复声明<br>let声明变量，const声明常量</p>
</blockquote>
<ul>
<li>块级作用域的出现，实际山使用广泛的立即执行匿名函数不在必要了。防止变量污染。<br></li>
</ul>
<h2 id="第二节、-解构赋值"><a href="#第二节、-解构赋值" class="headerlink" title="第二节、 解构赋值"></a><font color="#FF69B4">第二节、 解构赋值</font></h2><h3 id="1-本质上属于模式匹配，也就是只要等号两边的模式相同，左边的变量就会被赋予对应的值。"><a href="#1-本质上属于模式匹配，也就是只要等号两边的模式相同，左边的变量就会被赋予对应的值。" class="headerlink" title="1. 本质上属于模式匹配，也就是只要等号两边的模式相同，左边的变量就会被赋予对应的值。"></a>1. 本质上属于模式匹配，也就是只要等号两边的模式相同，左边的变量就会被赋予对应的值。</h3>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var [a, b, c] = [1, 2, 3];                  // 1, 2, 3</span><br><span class="line"><span class="built_in">let</span> [foo, [[bar], bax]] = [1, [[2], 3]];    // 1, 2, 3</span><br></pre></td></tr></table></figure>
<h3 id="2-解构失败则为undefined，也存在不完全解构。"><a href="#2-解构失败则为undefined，也存在不完全解构。" class="headerlink" title="2. 解构失败则为undefined，也存在不完全解构。"></a>2. 解构失败则为undefined，也存在不完全解构。</h3>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const [a, b, c] = [1];       // 1, undefined, undefined  解构失败</span><br><span class="line"><span class="built_in">let</span> [foo, [[bar], bax]] = [1, [[2, 3], 4]];  // 1, 2, 4  不完全解构</span><br></pre></td></tr></table></figure>
<h3 id="3-赋默认值（只有右侧严格等于undefined的时候才生效）。"><a href="#3-赋默认值（只有右侧严格等于undefined的时候才生效）。" class="headerlink" title="3. 赋默认值（只有右侧严格等于undefined的时候才生效）。"></a>3. 赋默认值（只有右侧严格等于undefined的时候才生效）。</h3>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const [a, b=123, c] = [1];   // 1, 123, undefined</span><br><span class="line"><span class="built_in">let</span> [foo=1] = [null];        // null</span><br><span class="line"></span><br><span class="line">// 惰性求值</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span> () &#123; <span class="built_in">return</span> <span class="string">'abc'</span>; &#125;</span><br><span class="line"><span class="built_in">let</span> [a=fn()] = [1];          // 1</span><br><span class="line"><span class="built_in">let</span> [b=fn()] = [];           // <span class="string">'abc'</span></span><br></pre></td></tr></table></figure>
<h3 id="4-对象的解构赋值-按照属性名来决定"><a href="#4-对象的解构赋值-按照属性名来决定" class="headerlink" title="4. 对象的解构赋值(按照属性名来决定)"></a>4. 对象的解构赋值(按照属性名来决定)</h3><ul>
<li><p>注意：一个已声明的变量用于解构赋值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var x;</span><br><span class="line">&#123; x &#125; = &#123; x: 1 &#125;;    // Uncaught SyntaxError: Unexpected token <span class="string">'='</span></span><br><span class="line">                     // js引擎会将&#123;x&#125;理解成一个代码块，从而发生语法错误</span><br><span class="line">(&#123; x &#125; = &#123; x: 1 &#125;);  // ()将其转换为表达式，从而避免上述语法问题</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果变量名和属性名不一致，必须（属性名不是变量，我们可以理解成一种模式）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var &#123; foo: bar &#125; = &#123; foo: 1,  bar: 2 &#125;;</span><br><span class="line">foo;       // Uncaught ReferenceError: foo is not defined</span><br><span class="line">bar;       // 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>和数组的解构赋值一样，对象的解构赋值也可嵌套</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; P: [<span class="string">'hello'</span>, &#123;y: <span class="string">'world'</span>&#125;] &#125;;</span><br><span class="line">var &#123; P: [x, &#123;y&#125;] &#125; = obj;</span><br><span class="line"></span><br><span class="line">obj;      // &#123;P: Array(2)&#125;</span><br><span class="line">x;        // <span class="string">'hello'</span></span><br><span class="line">y;        // <span class="string">'world'</span></span><br><span class="line">P;        // Uncaught ReferenceError: P is not defined</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var &#123; x, y=x, z &#125; = &#123; x: 1 &#125;;</span><br><span class="line">x;       // 1</span><br><span class="line">y;       // 1</span><br><span class="line">z;       // undefined</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="5-字符串的解构赋值，字符串会转化成一个类数组的对象"><a href="#5-字符串的解构赋值，字符串会转化成一个类数组的对象" class="headerlink" title="5. 字符串的解构赋值，字符串会转化成一个类数组的对象"></a>5. 字符串的解构赋值，字符串会转化成一个类数组的对象</h3>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var [a,b,c,d,e,f] = <span class="string">"hello"</span>;</span><br><span class="line">var &#123; length: len &#125; = <span class="string">"hello"</span>;</span><br><span class="line">a;      // h</span><br><span class="line">b;      // e</span><br><span class="line">c;      // l</span><br><span class="line">d;      // l</span><br><span class="line">e;      // o</span><br><span class="line">f;      // undefined</span><br><span class="line">len;    // 5</span><br></pre></td></tr></table></figure>
<h3 id="6-数值和布尔值的解构赋值，如果等号右边是数值或者布尔值，则会先转为对象"><a href="#6-数值和布尔值的解构赋值，如果等号右边是数值或者布尔值，则会先转为对象" class="headerlink" title="6. 数值和布尔值的解构赋值，如果等号右边是数值或者布尔值，则会先转为对象"></a>6. 数值和布尔值的解构赋值，如果等号右边是数值或者布尔值，则会先转为对象</h3>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var &#123; toString: a &#125; = 123;</span><br><span class="line">var &#123; toString: b &#125; = <span class="literal">true</span>;</span><br><span class="line">a;                                 // ƒ <span class="function"><span class="title">toString</span></span>() &#123; [native code] &#125;</span><br><span class="line">b;                                 // ƒ <span class="function"><span class="title">toString</span></span>() &#123; [native code] &#125;</span><br><span class="line">a === Number.prototype.toString;   // <span class="literal">true</span></span><br><span class="line">b === Boolean.prototype.toString;  // <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="7-函数参数的解构赋值"><a href="#7-函数参数的解构赋值" class="headerlink" title="7. 函数参数的解构赋值"></a>7. 函数参数的解构赋值</h3>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="built_in">test</span>(&#123; x=0, y=0 &#125; = &#123;&#125;) &#123;</span><br><span class="line">  console.log([x ,y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">test</span>(&#123;x: 1, y: 2&#125;);  // [1, 2]</span><br><span class="line"><span class="built_in">test</span>(&#123;x: 1&#125;);        // [1, 0]</span><br><span class="line"><span class="built_in">test</span>(&#123;&#125;);            // [0, 0]</span><br><span class="line"><span class="built_in">test</span>();              // [0, 0]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> move(&#123; x, y &#125; = &#123;x: 0, y: 0&#125;) &#123;</span><br><span class="line">  console.log([x ,y]);</span><br><span class="line">&#125;</span><br><span class="line">move(&#123;x: 1, y: 2&#125;);  // [1, 2]</span><br><span class="line">move(&#123;x: 1&#125;);        // [1, undefined]</span><br><span class="line">move(&#123;&#125;);            // [undefined, undefined]</span><br><span class="line">move();              // [0, 0]</span><br></pre></td></tr></table></figure>
<h3 id="8-解构赋值的应用"><a href="#8-解构赋值的应用" class="headerlink" title="8. 解构赋值的应用"></a>8. 解构赋值的应用</h3><ul>
<li><p>交换变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">var b = 2;</span><br><span class="line">[a, b] = [b, a];</span><br><span class="line">a, b;            // 2, 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数参数的定义</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> fn (&#123;x=1, y, z&#125; = &#123;&#125;)&#123;console.log(x, y, z);&#125;</span><br><span class="line">fn();    // 1, undefined, undefined</span><br></pre></td></tr></table></figure>
</li>
<li><p>从函数中返回多个值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">example</span></span> () &#123;</span><br><span class="line">  <span class="built_in">return</span> [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line">const [a, b, c] = example();</span><br><span class="line">a, b, c           // 1, 2, 3</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>提交数据<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var jsonData = &#123;</span><br><span class="line">  id: 42,</span><br><span class="line">  status: 2000,</span><br><span class="line">&#125;;</span><br><span class="line">const &#123; id, status &#125; = jsonData;</span><br><span class="line">id, status;       // 42, 2000</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="第三节、-数组扩展"><a href="#第三节、-数组扩展" class="headerlink" title="第三节、 数组扩展"></a><font color="#FF69B4">第三节、 数组扩展</font></h2><h3 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h3><p>用于将两类对象转化为真正的数组</p>
<ol>
<li>类数组 （所谓类似数组的兑现个，本质上必须有length属性）</li>
<li>可遍历对象 （ES6新增Set和Map两种数据结构）</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var sameArr = &#123;</span><br><span class="line">  0: 1,</span><br><span class="line">  a: <span class="string">'b'</span>,</span><br><span class="line">  5: <span class="string">'c'</span>,</span><br><span class="line">  length: 6,</span><br><span class="line">  splice: <span class="function"><span class="title">function</span></span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">var arr = Array.from(sameArr);</span><br><span class="line"></span><br><span class="line">sameArr       // Object(6) [1, empty × 4, <span class="string">"c"</span>, a: <span class="string">"b"</span>, splice: ƒ]</span><br><span class="line">                 0: 1 5: <span class="string">"c"</span> a: <span class="string">"b"</span> length: 6 splice: ƒ ()__proto__: Object </span><br><span class="line"></span><br><span class="line">arr;          // [1, undefined, undefined, undefined, undefined, <span class="string">"c"</span>]</span><br><span class="line"></span><br><span class="line">sameArr.forEach(item =&gt; console.log(item)); // Uncaught TypeError: sameArr.forEach is not a <span class="keyword">function</span></span><br><span class="line"></span><br><span class="line">arr.forEach(item =&gt; console.log(item)); // 1  undefined undefined undefined undefined  c</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Array.from 还接受第二个参数，作用类似于数组的map方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = Array.from(sameArr, (item) =&gt; item + 123);</span><br><span class="line">arr;           // [124, NaN, NaN, NaN, NaN, <span class="string">"c123"</span>]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = new Array();            // [undefined * 10]</span><br><span class="line">var arr1 = Array.of(10, 2, 3);    // [10, 2, 3]</span><br></pre></td></tr></table></figure>
<h3 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin()"></a>copyWithin()</h3><p>  在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原来成员），然后返回当前数组，也就是说，copyWithin()方法会修改当前数组。</p>
<ul>
<li>接受三个参数：<br>target（必需）：从该位置开始替换数据<br>start（可选）：从该位置开始读取数据，默认为0，如果为负值，表示倒数。<br>end（可选）：到该位置前停止读取数据，默认等于数组长度，如果为负值，表示倒数。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];</span><br><span class="line">arr.copyWithin(0, 2, 4);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="find-和-findIndex"><a href="#find-和-findIndex" class="headerlink" title="find() 和 findIndex()"></a>find() 和 findIndex()</h3><ul>
<li>find       用于找出第一个符合条件的数组成员。没有则返回undefined。<br>findIndex  类似，返回第一个符合条件的数组成员的位置。没有则返回-1。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];</span><br><span class="line">var newArr = arr.find((item) =&gt; item &gt; 5);         // 6</span><br><span class="line">var newIndex = arr.findIndex((item) =&gt; item &gt; 5);  // 5</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h3><p>填充数组<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4, 5];</span><br><span class="line">arr.fill(<span class="string">'a'</span>);                // [<span class="string">"a"</span>, <span class="string">"a"</span>, <span class="string">"a"</span>, <span class="string">"a"</span>, <span class="string">"a"</span>]</span><br><span class="line">arr.fill(<span class="string">'a'</span>, 2);             // [1, 2, <span class="string">"a"</span>, <span class="string">"a"</span>, <span class="string">"a"</span>]</span><br><span class="line">arr.fill(<span class="string">'a'</span>, 2, 4);          // [1, 2, <span class="string">"a"</span>, <span class="string">"a"</span>, 5]</span><br></pre></td></tr></table></figure></p>
<h3 id="entries-keys-valueof"><a href="#entries-keys-valueof" class="headerlink" title="entries() keys() valueof()"></a>entries() keys() valueof()</h3><p>ES6提供三个新的方法 – entries, keys()和values() – 用于遍历数组。它们都返回一个遍历器对象，可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历,values()是对键值的遍历，entries()是对键值对的遍历。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 0 1</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> index of [<span class="string">'a'</span>, <span class="string">'b'</span>].keys()) &#123; console.log(index); &#125;</span><br><span class="line"></span><br><span class="line">// <span class="string">'a'</span> <span class="string">'b'</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> elem of [<span class="string">'a'</span>, <span class="string">'b'</span>].values()) &#123; console.log(elem); &#125;</span><br><span class="line"></span><br><span class="line">// 0 <span class="string">"a"</span>    1 <span class="string">"b"</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [index, elem] of [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123; console.log(index, elem); &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h3><p>某个数组是否包含给定的值，与字符串的includes方法类似。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, NaN];</span><br><span class="line">console.log(arr.indexOf(<span class="string">'c'</span>));    // 2</span><br><span class="line">console.log(arr.indexOf(NaN));    // -1    NaN不等于NaN</span><br><span class="line">console.log(arr.includes(<span class="string">'c'</span>));   // <span class="literal">true</span></span><br><span class="line">console.log(arr.includes(NaN));   // <span class="literal">true</span>  includes没有这个问题</span><br></pre></td></tr></table></figure></p>
<h2 id="第四节、-对象扩展"><a href="#第四节、-对象扩展" class="headerlink" title="第四节、 对象扩展"></a><font color="#FF69B4">第四节、 对象扩展</font></h2><h3 id="1-属性"><a href="#1-属性" class="headerlink" title="1. 属性"></a>1. 属性</h3><p>ES6 允许直接写入变量和函数，作为对象的属性和方法。（ES6允许在对象中，只写属性名不写属性值，这时属性值等于属性名所代表的的变量）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123; name&#125;;                                 // &#123;name: <span class="string">""</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const name = <span class="string">'hahaha'</span>;</span><br><span class="line">const obj = &#123; name &#125;;                                // &#123;name: <span class="string">"hahaha"</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const name = <span class="function"><span class="title">function</span></span>()&#123;sonsole.log(<span class="string">'name:test'</span>);&#125;;</span><br><span class="line">const obj = &#123; name &#125;;                                // &#123;name: ƒ&#125;</span><br><span class="line"></span><br><span class="line">const obj = &#123; <span class="function"><span class="title">name</span></span>()&#123;console.log(<span class="string">'name:test'</span>);&#125; &#125;;   // &#123;name: ƒ&#125;</span><br></pre></td></tr></table></figure></p>
<p>属性表达式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const name = <span class="string">'test'</span>;</span><br><span class="line">const obj = &#123;             // &#123;<span class="built_in">test</span>: <span class="string">"haha"</span>, test1: <span class="string">"heihei"</span>, test2: <span class="string">"houhou"</span>&#125;</span><br><span class="line">  [name]: <span class="string">'haha'</span>,</span><br><span class="line">  [name+<span class="string">'1'</span>]: <span class="string">'heihei'</span>,</span><br><span class="line">  [name+<span class="string">'2'</span>]: <span class="string">'houhou'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-Object-is"><a href="#2-Object-is" class="headerlink" title="2. Object.is()"></a>2. Object.is()</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+0 === -0              // <span class="literal">true</span></span><br><span class="line">NaN === NaN            // <span class="literal">false</span></span><br><span class="line">Object.is(+0, -0);     // <span class="literal">false</span></span><br><span class="line">Object.is(NaN, NaN);   // <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="3-Object-assign"><a href="#3-Object-assign" class="headerlink" title="3. Object.assign()"></a>3. Object.assign()</h3><p>对象合并（浅拷贝）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const a = &#123; a: 1, b: <span class="string">'xxx'</span> &#125;;</span><br><span class="line">const b = &#123; b: <span class="string">'bbb'</span>, c: &#123; d: 1, e: 2 &#125; &#125;;</span><br><span class="line">const f = &#123; c: &#123; d: 2, e: 2, g: 3 &#125;, h: <span class="string">'hahaha'</span> &#125;;</span><br><span class="line"></span><br><span class="line">Object.assign(f, b, a);   // &#123;c: &#123;&#123;d: 1, e: 2&#125;&#125;, h: <span class="string">"hahaha"</span>, b: <span class="string">"xxx"</span>, a: 1&#125;</span><br></pre></td></tr></table></figure></p>
<font size="1">$.extend({}) 扩展<br>$.extend({}, {}) 浅拷贝<br>$.extend(true, {}, {}) 深拷贝</font>

<h3 id="4-Object-entries-Object-keys-Object-valueof"><a href="#4-Object-entries-Object-keys-Object-valueof" class="headerlink" title="4. Object.entries()  Object.keys()  Object.valueof()"></a>4. Object.entries()  Object.keys()  Object.valueof()</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123; b: <span class="string">'bbb'</span>, c: &#123; d: 1, e: 2 &#125; &#125;;</span><br><span class="line">  </span><br><span class="line">Object.keys(obj);      // [<span class="string">"b"</span>, <span class="string">"c"</span>]</span><br><span class="line">Object.values(obj);    // [<span class="string">"bbb"</span>, &#123;d: 1, e: 2&#125;]</span><br><span class="line">Object.entries(obj);   // [[<span class="string">"b"</span>, <span class="string">"bbb"</span>], [<span class="string">"c"</span>, &#123;d: 1, e: 2&#125;]]</span><br></pre></td></tr></table></figure>
<h3 id="5-Object-getPrototypeOf-Object-setPrototypeOf"><a href="#5-Object-getPrototypeOf-Object-setPrototypeOf" class="headerlink" title="5. Object.getPrototypeOf()   Object.setPrototypeOf()"></a>5. Object.getPrototypeOf()   Object.setPrototypeOf()</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123; a: 1 &#125;;</span><br><span class="line">const obj1 = &#123; b: <span class="function"><span class="title">function</span></span>()&#123;console.log(<span class="string">'bbb'</span>);&#125; &#125;;</span><br><span class="line"></span><br><span class="line">obj.__proto__ = obj1;</span><br><span class="line">Object.setPrototypeOf(obj, obj1);</span><br><span class="line"></span><br><span class="line">obj.b();                              // <span class="string">'bbb'</span></span><br><span class="line">Object.getPrototypeOf(obj);           // &#123;b: ƒ&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-扩展运算符-…"><a href="#6-扩展运算符-…" class="headerlink" title="6. 扩展运算符 …"></a>6. 扩展运算符 …</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1,2,3];</span><br><span class="line">const arr1 = [...arr, <span class="string">'c'</span>];      // [1, 2, 3, <span class="string">"c"</span>]</span><br></pre></td></tr></table></figure>
<h2 id="第五节、-函数扩展"><a href="#第五节、-函数扩展" class="headerlink" title="第五节、 函数扩展"></a><font color="#FF69B4">第五节、 函数扩展</font></h2><h3 id="1-扩展运算符-…"><a href="#1-扩展运算符-…" class="headerlink" title="1. 扩展运算符 …"></a>1. 扩展运算符 …</h3><p>ES6韵如rest参数（形式为“…变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const a = (...values) =&gt; &#123;console.log(values);&#125;</span><br><span class="line">a(1,2,3,4,5);     // [1,2,3,4,5]</span><br><span class="line"></span><br><span class="line">const a = (a, ...values) =&gt; &#123;console.log(values);&#125;</span><br><span class="line">a(1,2,3,4,5);     // [2,3,4,5]</span><br></pre></td></tr></table></figure></p>
<h3 id="2-箭头函数"><a href="#2-箭头函数" class="headerlink" title="2. 箭头函数"></a>2. 箭头函数</h3><ol>
<li>箭头函数内的this值不会改变<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">const id = 10;</span><br><span class="line">const fn = () =&gt; &#123;console.log(this.id);&#125;   // this指向window</span><br><span class="line">const obj = &#123; id: 20, fn &#125;;</span><br><span class="line">const obj1 = &#123; id: 30 &#125;;</span><br><span class="line">fn();                          // undefined</span><br><span class="line">obj.fn();                      // undefined</span><br><span class="line">obj.fn.call(obj1);             // undefined</span><br><span class="line"></span><br><span class="line">var id = 10;</span><br><span class="line">const fn = () =&gt; &#123;console.log(this.id);&#125;</span><br><span class="line">const obj = &#123; id: 20, fn &#125;;</span><br><span class="line">const obj1 = &#123; id: 30 &#125;;</span><br><span class="line">fn();                          // 10</span><br><span class="line">obj.fn();                      // 10</span><br><span class="line">obj.fn.call(obj1);             // 10</span><br><span class="line"></span><br><span class="line">var id = 10;</span><br><span class="line">const fn = () =&gt; &#123;this.id = 1; console.log(this.id);&#125;</span><br><span class="line">const obj = &#123; id: 20, fn &#125;;</span><br><span class="line">const obj1 = &#123; id: 30 &#125;;</span><br><span class="line">fn();                          // 1</span><br><span class="line">obj.fn();                      // 1</span><br><span class="line">obj.fn.call(obj1);             // 1</span><br><span class="line"></span><br><span class="line">const id = 10;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span> () &#123;console.log(this.id);&#125;</span><br><span class="line">const obj = &#123; id: 20, fn  &#125;;</span><br><span class="line">const obj1 = &#123; id: 30 &#125;;</span><br><span class="line">obj.fn();                      // 20</span><br><span class="line">obj.fn.call(obj1);             // 30</span><br><span class="line"></span><br><span class="line">const fn1 = obj.fn;</span><br><span class="line">fn1();                         // undefined</span><br><span class="line"></span><br><span class="line">const fn2 = obj.fn.bind(obj1);</span><br><span class="line">fn2();                         // 30</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>全局定义的const和let不会被挂载到全局对象（如window）下，而是存在于块作用域（Script）中。<br>我们可以用debugger在控制台测一下</p>
<p>这里不是太理解，埋个？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 定义时</span><br><span class="line">const id = 10;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span> () &#123;setTimeout(<span class="function"><span class="title">function</span></span>()&#123;console.log(this.id)&#125;, 0);&#125;       // undefined</span><br><span class="line">const obj1 = &#123; id: 30 &#125;;</span><br><span class="line">fn.call(obj1);</span><br><span class="line"></span><br><span class="line">const id = 10;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span> () &#123;setTimeout(()=&gt;console.log(this.id), 0);&#125;               // 30</span><br><span class="line">const obj1 = &#123; id: 30 &#125;;</span><br><span class="line">fn.call(obj1);</span><br></pre></td></tr></table></figure></p>
<h2 id="第六节、-类-class"><a href="#第六节、-类-class" class="headerlink" title="第六节、 类  class"></a><font color="#FF69B4">第六节、 类  class</font></h2><h3 id="class基本语法"><a href="#class基本语法" class="headerlink" title="class基本语法"></a>class基本语法</h3><blockquote>
<p>JS的传统方法是通过构造函数，定义并生成新对象。<br>构造函数的prototype属性，在ES6的类上面继续存在（事实上，类的所有方法都定义在类的prototype属性上）。<br>类的内部所有定义的方法都是不可枚举的。<br>类的实例共享一个原型对象。<br>class 的本质是 function。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123; // 不写默认为&#123;&#125;</span><br><span class="line">    this.name = <span class="string">'Person Class'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">operate</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">'laugh smile cry fire happy sad'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const child = new Person(); // Person &#123;name: <span class="string">"Person Class"</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="class的继承"><a href="#class的继承" class="headerlink" title="class的继承"></a>class的继承</h3><p>extends supor<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Ancestors &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    this.level = <span class="string">'Ancestors Class'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">create</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'Creating the world'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Person extends Ancestors &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    super();  // 必须</span><br><span class="line">    this.name = <span class="string">'Person Class'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">operate</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">'laugh smile cry fire happy sad'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const child = new Person(); // Person &#123;level: <span class="string">"Ancestors Class"</span>, name: <span class="string">"Person Class"</span>&#125;</span><br><span class="line">child.operate();            // 可调用</span><br><span class="line">child.create();             // 可调用</span><br></pre></td></tr></table></figure></p>
<h3 id="class的静态方法-static"><a href="#class的静态方法-static" class="headerlink" title="class的静态方法 static"></a>class的静态方法 static</h3><p>不需要实例化。 ES6 中规定，Class 内部只有静态方法，没有静态属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.name = &apos;Person Class&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  operate()&#123;</span><br><span class="line">    console.log(&apos;laugh smile cry fire happy sad&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  static originLook() &#123;</span><br><span class="line">    console.log(&apos;nature is new&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const child = new Person();</span><br><span class="line">child.originLook();       // Uncaught TypeError: child.originLook is not a function</span><br></pre></td></tr></table></figure></p>
<h2 id="第七节、-Set-和-Map"><a href="#第七节、-Set-和-Map" class="headerlink" title="第七节、 Set 和 Map"></a><font color="#FF69B4">第七节、 Set 和 Map</font></h2><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><blockquote>
<p> ES6提供了新的数据结构Set，类似于数组，但是成员的值都是唯一的，没有重复的值。<br> Set本身是构造函数，用来生成Set数据结构，Set函数可以接受数组（或类数组）作为参数，用来初始化。<br>可以用来去除数组中重复的成员。</p>
</blockquote>
<blockquote>
<p>Set.prototype.constructor： 构造函数，默认就是Set函数<br>Set.prototype.size：返回Set实例的成员总数</p>
</blockquote>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1,2,3,3,3,2,1];</span><br><span class="line">const a = new Set(arr);                // Set(3) &#123;1, 2, 3&#125; </span><br><span class="line">const b = Array.from(new Set(arr));    // [1, 2, 3]   将Set结构转换为数组，也算是一种数组去重的方法</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Set数据的四个操作方法：<br>add()<br>delete()<br>has()<br>clear()</p>
</li>
<li><p>Set数据的四个遍历方法：<br>keys()<br>values()<br>entries()<br>forEach()</p>
</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。</p>
<h4 id="Maps-和-Objects-的区别"><a href="#Maps-和-Objects-的区别" class="headerlink" title="Maps 和 Objects 的区别"></a>Maps 和 Objects 的区别</h4><p>  一个 Object 的键只能是字符串或者 Symbols，但一个 Map 的<strong>键可以是任意值</strong>。<br>  Map 中的键值是<strong>有序</strong>的（FIFO 原则），而添加到对象中的键则不是。<br>  Map 的键值对个数可以从 <strong>size</strong> 属性获取，而 Object 的键值对个数只能手动计算。<br>  Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。</p>
<h4 id="key-可以是字符串、对象"><a href="#key-可以是字符串、对象" class="headerlink" title="key 可以是字符串、对象"></a>key 可以是字符串、对象</h4><ul>
<li><p>key 可以是字符串</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myMap = new Map();</span><br><span class="line">var keyString = <span class="string">"a string"</span>; </span><br><span class="line">myMap.set(keyString, <span class="string">"和键'a string'关联的值"</span>);</span><br><span class="line">myMap.get(keyString);         // <span class="string">"和键'a string'关联的值"</span></span><br><span class="line">myMap.get(<span class="string">"a string"</span>);        // <span class="string">"和键'a string'关联的值"</span>,因为 keyString === <span class="string">'a string'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>key 是对象</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myMap = new Map();</span><br><span class="line">var keyObj = &#123;&#125;, </span><br><span class="line">myMap.set(keyObj, <span class="string">"和键 keyObj 关联的值"</span>);</span><br><span class="line">myMap.get(keyObj);             // <span class="string">"和键 keyObj 关联的值"</span></span><br><span class="line">myMap.get(&#123;&#125;);                 // undefined, 因为 keyObj !== &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>key 是函数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myMap = new Map();</span><br><span class="line">var keyFunc = <span class="function"><span class="title">function</span></span> () &#123;&#125;;</span><br><span class="line">myMap.set(keyFunc, <span class="string">"和键 keyFunc 关联的值"</span>);</span><br><span class="line">myMap.get(keyFunc);              // <span class="string">"和键 keyFunc 关联的值"</span></span><br><span class="line">myMap.get(<span class="function"><span class="title">function</span></span>() &#123;&#125;)         // undefined, 因为 keyFunc !== <span class="function"><span class="title">function</span></span> () &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>key 是 NaN<br><em>虽然NaN和任何值甚至和自己都不相等，但是NaN作为Map的键来说是没有区别的。</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myMap = new Map();</span><br><span class="line">myMap.set(NaN, <span class="string">"not a number"</span>);</span><br><span class="line">myMap.get(NaN);                   // <span class="string">"not a number"</span></span><br><span class="line">var otherNaN = Number(<span class="string">"foo"</span>);</span><br><span class="line">myMap.get(otherNaN);              // <span class="string">"not a number"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Set数据的四个操作方法："><a href="#Set数据的四个操作方法：" class="headerlink" title="Set数据的四个操作方法："></a>Set数据的四个操作方法：</h4><p>  add()<br>  delete()<br>  has()<br>  clear()</p>
<h4 id="Set数据的四个遍历方法："><a href="#Set数据的四个遍历方法：" class="headerlink" title="Set数据的四个遍历方法："></a>Set数据的四个遍历方法：</h4><p>  keys()<br>  values()<br>  entries()<br>  forEach()</p>
<h2 id="第八节、-Promise"><a href="#第八节、-Promise" class="headerlink" title="第八节、 Promise"></a><font color="#FF69B4">第八节、 Promise</font></h2><p>Promise是异步编程的一种解决方案。</p>
<h3 id="1、Promise-的含义"><a href="#1、Promise-的含义" class="headerlink" title="1、Promise 的含义"></a>1、Promise 的含义</h3><p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。</p>
<ul>
<li><p><strong>对象的状态不受外界影响。</strong> Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>
</li>
<li><p><strong>一旦状态改变，就不会再变，任何时候都可以得到这个结果</strong>。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。<br>注意，为了行文方便，本章后面的resolved统一只指fulfilled状态，不包含rejected状态。</p>
</li>
</ul>
<h3 id="2、基本用法"><a href="#2、基本用法" class="headerlink" title="2、基本用法"></a>2、基本用法</h3><p>ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。</p>
<h2 id="第九节、-Iterator"><a href="#第九节、-Iterator" class="headerlink" title="第九节、 Iterator"></a><font color="#FF69B4">第九节、 Iterator</font></h2><h2 id="第十节、-Symbol"><a href="#第十节、-Symbol" class="headerlink" title="第十节、 Symbol"></a><font color="#FF69B4">第十节、 Symbol</font></h2><!-- 




1. function和箭头函数的区别
> this的指向： 使用function定义的函数，this的指向随着调用环境的变化而变化的，而箭头函数中的this指向是固定不变的，一直指向的是定义函数的环境。
>
> 构造函数： function是可以定义构造函数的，而箭头函数是不行的。
>
> 变量提升： 由于js的内存机制，function的级别最高，而用箭头函数定义函数的时候，需要var(let const定义的时候更不必说)关键词，而var所定义的变量不能得到变量提升，故箭头函数一定要定义于调用之前！

 -->

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/background10.jpg"
                alt="Lemon" />
            
              <p class="site-author-name" itemprop="name">Lemon</p>
              <p class="site-description motion-element" itemprop="description">乘风破浪</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lemon</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
