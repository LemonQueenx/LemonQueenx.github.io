<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="乘风破浪">
<meta property="og:type" content="website">
<meta property="og:title" content="小寒">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="小寒">
<meta property="og:description" content="乘风破浪">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小寒">
<meta name="twitter:description" content="乘风破浪">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>小寒</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小寒</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-窝">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            窝
          </a>
        </li>
      
        
        <li class="menu-item menu-item-类">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-档">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-于">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/13/interview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lemon">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/background2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/13/interview/" itemprop="url">interview</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-07-13T11:21:46+08:00">
                2021-07-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/专题/" itemprop="url" rel="index">
                    <span itemprop="name">专题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>每天一道面试题</p>
<h1 id="html"><a href="#html" class="headerlink" title="html"></a>html</h1><h1 id="css"><a href="#css" class="headerlink" title="css"></a>css</h1><h1 id="js"><a href="#js" class="headerlink" title="js"></a>js</h1><h2 id="回调函数，Promise，async-await的区别及理解"><a href="#回调函数，Promise，async-await的区别及理解" class="headerlink" title="回调函数，Promise，async await的区别及理解"></a>回调函数，Promise，async await的区别及理解</h2><h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><h1 id="react"><a href="#react" class="headerlink" title="react"></a>react</h1><h1 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h1><h1 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h1><h1 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h1><h1 id="数据结构-amp-算法"><a href="#数据结构-amp-算法" class="headerlink" title="数据结构&amp;算法"></a>数据结构&amp;算法</h1><h1 id="专题"><a href="#专题" class="headerlink" title="专题"></a>专题</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/05/13/nodejs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lemon">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/background2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/13/nodejs/" itemprop="url">nodejs</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-05-13T20:07:53+08:00">
                2021-05-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/框架/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h1><p>  Node.js 是一个开源与跨平台的 JavaScript 运行时环境。<br>  Node.js 在浏览器外运行 V8 JavaScript 引擎（Google Chrome 的内核）。</p>
<p>  Node.js 2009年诞生。</p>
<p>  常见的Node.js 框架和工具，比如：Express。</p>
<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><h2 id="V8-JavaScript-引擎"><a href="#V8-JavaScript-引擎" class="headerlink" title="V8 JavaScript 引擎"></a><font color="#ff99cc">V8 JavaScript 引擎</font></h2><p>  <a href="https://v8.dev/" target="_blank" rel="noopener">V8</a> 提供了执行 JavaScript 的运行时环境。 DOM 和其他 Web 平台 API 则由浏览器提供。</p>
<p>  JavaScript 引擎独立于托管它的浏览器。 这个关键的特性推动了 Node.js 的兴起。 V8 于 2009 年被选为为 Node.js 提供支持的引擎，并且随着 Node.js 的爆炸性发展，V8 成为了现在为大量的服务器端代码（使用 JavaScript 编写）提供支持的引擎。</p>
<p>  V8 使用 C++ 编写，并且不断地被改进。 它是可移植的，且可运行于 Mac、Windows、Linux 和其他一些系统。</p>
<h2 id="从命令行运行-Node-js-脚本"><a href="#从命令行运行-Node-js-脚本" class="headerlink" title="从命令行运行 Node.js 脚本"></a><font color="#ff99cc">从命令行运行 Node.js 脚本</font></h2>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node xxx.js</span><br></pre></td></tr></table></figure>
<h2 id="Node-js程序中退出"><a href="#Node-js程序中退出" class="headerlink" title="Node.js程序中退出"></a><font color="#ff99cc">Node.js程序中退出</font></h2><pre><code>命令行：Ctrl + c
程序：
1）process.exit()
  如：process.exit(1)  不写默认0。 [退出码](http://nodejs.cn/api/process.html#process_exit_codes)

  也可以设置 process.exitCode 属性：
  process.exitCode = 1
  当程序结束时，Node.js 会返回该退出码。

  当进程完成所有处理后，程序会正常地退出。
</code></pre>  <div class="post-warning">注意：process 不需要 “require”，它是自动可用的。</div>

<pre><code>2）信号
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">process.on(&apos;SIGTERM&apos;, () =&gt; &#123;</span><br><span class="line">  server.close(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;进程已终止&apos;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</code></pre>  <div class="post-warning">什么是信号？信号是一个 POSIX 内部通信系统：发送通知给进程，以告知其发生的事件。</div>

<pre><code>SIGKILL 是告诉进程要立即终止的信号，理想情况下，其行为类似于 process.exit()。

SIGTERM 是告诉进程要正常终止的信号。它是从进程管理者（如 upstart 或 supervisord）等发出的信号。

可以从程序内部另一个函数中发送此信号：
process.kill(process.pid, &apos;SIGTERM&apos;)
或从另一个正在运行的 Node.js 程序、或从系统中运行的其他任何的应用程序（能知道要终止的进程的 PID）。
</code></pre><h2 id="从-Node-js-读取环境变量"><a href="#从-Node-js-读取环境变量" class="headerlink" title="从 Node.js 读取环境变量"></a><font color="#ff99cc">从 Node.js 读取环境变量</font></h2><pre><code>Node.js 的 process 核心模块提供了 env 属性，该属性承载了在启动进程时设置的所有环境变量。
这是访问 NODE_ENV 环境变量的示例，该环境变量默认情况下被设置为 development。在脚本运行之前将其设置为 &quot;production&quot;，则可告诉 Node.js 这是生产环境。
可以用相同的方式访问设置的任何自定义的环境变量。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process.env.NODE_ENV // &quot;development&quot;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="使用-Node-js-REPL"><a href="#使用-Node-js-REPL" class="headerlink" title="使用 Node.js REPL"></a><font color="#ff99cc">使用 Node.js REPL</font></h2>  <div class="post-warning">REPL 也被称为运行评估打印循环，是一种编程语言环境（主要是控制台窗口），它使用单个表达式作为用户输入，并在执行后将结果返回到控制台。</div>

<ol>
<li><p>终端直接执行node<br>会等待js代码的输入，酷。<br>Ctrl+c 或者.exit退出程序。<br>使用 tab 键自动补全</p>
</li>
<li><p>点提示<br>尝试输入 JavaScript 类的名称，例如 Number，添加一个点号并按下 tab。REPL 会打印可以在该类上访问的所有属性和方法。<br>通过输入 global. 并按下 tab，可以检查可以访问的全局变量。</p>
</li>
<li><p>点命令<br>REPL 有一些特殊的命令，所有这些命令都以点号 . 开头。它们是：<br>.help: 显示点命令的帮助。<br>.editor: 启用编辑器模式，可以轻松地编写多行 JavaScript 代码。当处于此模式时，按下 ctrl-D 可以运行编写的代码。<br>.break: 当输入多行的表达式时，输入 .break 命令可以中止进一步的输入。相当于按下 ctrl-C。<br>.clear: 将 REPL 上下文重置为空对象，并清除当前正在输入的任何多行的表达式。<br>.load: 加载 JavaScript 文件（相对于当前工作目录）。<br>.save: 将在 REPL 会话中输入的所有内容保存到文件（需指定文件名）。<br>.exit: 退出 REPL（相当于按下两次 ctrl-C）。</p>
</li>
</ol>
<h2 id="Node-js-从命令行接收参数"><a href="#Node-js-从命令行接收参数" class="headerlink" title="Node.js 从命令行接收参数"></a><font color="#ff99cc">Node.js 从命令行接收参数</font></h2><pre><code>process 对象的argv属性。
</code></pre><h2 id="使用-Node-js-输出到命令行"><a href="#使用-Node-js-输出到命令行" class="headerlink" title="使用 Node.js 输出到命令行"></a><font color="#ff99cc">使用 Node.js 输出到命令行</font></h2><h3 id="使用控制台模块的基础输出"><a href="#使用控制台模块的基础输出" class="headerlink" title="使用控制台模块的基础输出"></a>使用控制台模块的基础输出</h3><p>   Node.js 提供了 console 模块，该模块提供了大量非常有用的与命令行交互的方法。它基本上与浏览器中的 console 对象相同。最基础、最常用的方法是 console.log()，该方法会打印传入到控制台的字符串。<br>   可以传入多个变量到 console.log，也可以通过传入变量和格式说明符来格式化用语。<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;我的%s已经%d岁&apos;, &apos;猫&apos;, 2); // 我的猫已经2岁</span><br></pre></td></tr></table></figure></p>
<pre><code>%s 会格式化变量为字符串
%d 会格式化变量为数字
%i 会格式化变量为其整数部分
%o 会格式化变量为对象
</code></pre><h3 id="清空控制台"><a href="#清空控制台" class="headerlink" title="清空控制台"></a>清空控制台</h3><pre><code>console.clear()
</code></pre><h3 id="元素计数"><a href="#元素计数" class="headerlink" title="元素计数"></a>元素计数</h3><pre><code>console.count()
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const oranges = [&apos;橙子&apos;, &apos;橙子&apos;]</span><br><span class="line">const apples = [&apos;苹果&apos;]</span><br><span class="line">oranges.forEach(fruit =&gt; &#123;</span><br><span class="line">  console.count(fruit)</span><br><span class="line">&#125;)</span><br><span class="line">apples.forEach(fruit =&gt; &#123;</span><br><span class="line">  console.count(fruit)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">橙子: 1</span><br><span class="line">橙子: 2</span><br><span class="line">苹果: 1</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="打印堆栈踪迹"><a href="#打印堆栈踪迹" class="headerlink" title="打印堆栈踪迹"></a>打印堆栈踪迹</h3><pre><code>在某些情况下，打印函数的调用堆栈踪迹很有用，console.trace()
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const function2 = () =&gt; console.trace()</span><br><span class="line">const function1 = () =&gt; function2()</span><br><span class="line">function1()</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="计算耗时"><a href="#计算耗时" class="headerlink" title="计算耗时"></a>计算耗时</h3>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const doSomething = () =&gt; console.log(&apos;测试&apos;)</span><br><span class="line">const measureDoingSomething = () =&gt; &#123;</span><br><span class="line">  console.time(&apos;开始&apos;)</span><br><span class="line">  //做点事，并测量所需的时间。</span><br><span class="line">  doSomething()</span><br><span class="line">  console.timeEnd(&apos;开始&apos;)</span><br><span class="line">&#125;</span><br><span class="line">measureDoingSomething()</span><br><span class="line"></span><br><span class="line">开始: 10401.35498046875 ms</span><br></pre></td></tr></table></figure>
<h3 id="stdout-和-stderr"><a href="#stdout-和-stderr" class="headerlink" title="stdout 和 stderr"></a>stdout 和 stderr</h3><pre><code>console.log 非常适合在控制台中打印消息。 这就是所谓的标准输出（或称为 stdout）。
console.error 会打印到 stderr 流。
它不会出现在控制台中，但是会出现在错误日志中。
</code></pre><h3 id="为输出着色"><a href="#为输出着色" class="headerlink" title="为输出着色"></a>为输出着色</h3><p>   1）可以使用转义序列在控制台中为文本的输出着色。 转义序列是一组标识颜色的字符。<br>    console.log(‘\033[30m%s\033[0m’, ‘你好’) // 黑色<br>    console.log(‘\033[31m%s\033[0m’, ‘你好’) // 红色<br>    console.log(‘\033[32m%s\033[0m’, ‘你好’) // 绿色<br>    console.log(‘\033[33m%s\033[0m’, ‘你好’) // 黄色<br>    console.log(‘\033[34m%s\033[0m’, ‘你好’) // 深蓝<br>    console.log(‘\033[35m%s\033[0m’, ‘你好’) // 深粉<br>    console.log(‘\033[36m%s\033[0m’, ‘你好’) // 浅蓝<br>    console.log(‘\033[37m%s\033[0m’, ‘你好’) // 白色<br>    console.log(‘\x1b[33m%s\x1b[0m’, ‘你好’)  // 黄色</p>
<p>  2） 为控制台输出着色的最简单方法是使用库。 Chalk 是一个这样的库，除了为其着色外，它还有助于其他样式的设置（例如使文本变为粗体、斜体或带下划线）。<br>      可以使用 npm install chalk 进行安装，然后就可以使用它：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const chalk = require(&apos;chalk&apos;)</span><br><span class="line">console.log(chalk.yellow(&apos;你好&apos;))</span><br></pre></td></tr></table></figure></p>
<h3 id="创建进度条"><a href="#创建进度条" class="headerlink" title="创建进度条"></a>创建进度条</h3><p>   Progress 是一个很棒的软件包，可在控制台中创建进度条。 使用 npm install progress 进行安装。</p>
<p>   以下代码段会创建一个 10 步的进度条，每 100 毫秒完成一步。 当进度条结束时，则清除定时器：<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const ProgressBar = require(&apos;progress&apos;)</span><br><span class="line"></span><br><span class="line">const bar = new ProgressBar(&apos;:bar&apos;, &#123; total: 10 &#125;)</span><br><span class="line">const timer = setInterval(() =&gt; &#123;</span><br><span class="line">  bar.tick()</span><br><span class="line">  if (bar.complete) &#123;</span><br><span class="line">    clearInterval(timer)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, 100)</span><br></pre></td></tr></table></figure></p>
<h2 id="在-Node-js-中从命令行接收输入"><a href="#在-Node-js-中从命令行接收输入" class="headerlink" title="在 Node.js 中从命令行接收输入"></a><font color="#ff99cc">在 Node.js 中从命令行接收输入</font></h2><p>  从版本 7 开始，Node.js 提供了 readline <a href="http://nodejs.cn/api/readline.html" target="_blank" rel="noopener">模块</a>来执行以下操作：每次一行地从可读流（例如 process.stdin 流，在 Node.js 程序执行期间该流就是终端输入）获取输入。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const readline = require(&apos;readline&apos;).createInterface(&#123;</span><br><span class="line">  input: process.stdin,</span><br><span class="line">  output: process.stdout</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">readline.question(`你叫什么名字?`, name =&gt; &#123;</span><br><span class="line">  console.log(`你好 $&#123;name&#125;!`)</span><br><span class="line">  readline.close()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const inquirer = require(&apos;inquirer&apos;)</span><br><span class="line"></span><br><span class="line">var questions = [</span><br><span class="line">  &#123;</span><br><span class="line">    type: &apos;input&apos;,</span><br><span class="line">    name: &apos;name&apos;,</span><br><span class="line">    message: &quot;你叫什么名字?&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">inquirer.prompt(questions).then(answers =&gt; &#123;</span><br><span class="line">  console.log(`你好 $&#123;answers[&apos;name&apos;]&#125;!`)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>  Inquirer.js 可以执行许多操作，例如询问多项选择、展示单选按钮、确认等。</p>
<h2 id="使用-exports-从-Node-js-文件中公开功能"><a href="#使用-exports-从-Node-js-文件中公开功能" class="headerlink" title="使用 exports 从 Node.js 文件中公开功能"></a><font color="#ff99cc">使用 exports 从 Node.js 文件中公开功能</font></h2><pre><code>Node.js 具有内置的模块系统。
1) 第一种方式是将对象赋值给 module.exports（这是模块系统提供的对象），这会使文件只导出该对象：
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const car = &#123;</span><br><span class="line">  brand: &apos;Ford&apos;,</span><br><span class="line">  model: &apos;Fiesta&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = car</span><br><span class="line"></span><br><span class="line">//在另一个文件中</span><br><span class="line"></span><br><span class="line">const car = require(&apos;./car&apos;)</span><br></pre></td></tr></table></figure>

2) 第二种方式是将要导出的对象添加为 exports 的属性。这种方式可以导出多个对象、函数或数据：
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const car = &#123;</span><br><span class="line">  brand: &apos;Ford&apos;,</span><br><span class="line">  model: &apos;Fiesta&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.car = car</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在另一个文件中，则通过引用导入的属性来使用它：</span><br><span class="line">const items = require(&apos;./items&apos;)</span><br><span class="line">items.car</span><br><span class="line">或</span><br><span class="line">const car = require(&apos;./items&apos;).car</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li>module.exports 和 exports 之间有什么区别？<br>  前者公开了它指向的对象。 后者公开了它指向的对象的属性。</li>
</ul>
<h2 id="npm-包管理器简介"><a href="#npm-包管理器简介" class="headerlink" title="npm 包管理器简介"></a><font color="#ff99cc">npm 包管理器简介</font></h2><p>  npm 是 Node.js 标准的软件包管理器。</p>
  <div class="post-warning">Yarn 是 npm 的一个替代选择。</div>

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">npm install  // 如果项目具有 package.json 文件，则通过运行此命令可安装全部依赖</span><br><span class="line">npm install xxx</span><br><span class="line"> npm install &lt;package-name&gt;@0.0.1</span><br><span class="line">npm i --save</span><br><span class="line">npm i --save-dev</span><br><span class="line">npm update</span><br><span class="line">npm update &lt;package-name&gt;</span><br><span class="line">npm run &lt;task-name&gt; // 运行script命令</span><br></pre></td></tr></table></figure>
<h2 id="npm-将软件包安装到哪里"><a href="#npm-将软件包安装到哪里" class="headerlink" title="npm 将软件包安装到哪里"></a><font color="#ff99cc">npm 将软件包安装到哪里</font></h2><ul>
<li><p>本地安装<br>软件包会被安装到当前文件树中的 node_modules 子文件夹下。</p>
</li>
<li><p>全局安装<br>在这种情况下，npm 不会将软件包安装到本地文件夹下，而是使用全局的位置。<br>npm root -g 命令会告知其在计算机上的确切位置。</p>
<p>在 macOS 或 Linux 上，此位置可能是 /usr/local/lib/node_modules。 在 Windows 上，可能是 C:\Users\YOU\AppData\Roaming\npm\node_modules。</p>
</li>
</ul>
<h2 id="如何使用或执行-npm-安装的软件包"><a href="#如何使用或执行-npm-安装的软件包" class="headerlink" title="如何使用或执行 npm 安装的软件包"></a><font color="#ff99cc">如何使用或执行 npm 安装的软件包</font></h2><h2 id="package-json-指南"><a href="#package-json-指南" class="headerlink" title="package.json 指南"></a><font color="#ff99cc">package.json 指南</font></h2><p>  package.json 文件是项目的清单。 它可以做很多完全互不相关的事情。 例如，它是用于工具的配置中心。 它也是 npm 和 yarn 存储所有已安装软件包的名称和版本的地方。</p>
<h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>  对于package.json 文件中的内容没有固定的要求，唯一的要求是必须遵守 JSON 格式。</p>
<h3 id="属性分类"><a href="#属性分类" class="headerlink" title="属性分类"></a>属性分类</h3><pre><code>- name
- author
- contributors
- bugs
- homepage
- version
- license
- keywords
- description
- repository
- main
- private
- scripts
- dependencies
- devDependencies
- engines
- browserslist
- 命令特有的属性
  package.json 文件还可以承载命令特有的配置，例如 Babel、ESLint 等。
  每个都有特有的属性，例如 eslintConfig、babel 等。 它们是命令特有的，可以在相应的命令/项目文档中找到如何使用它们。
</code></pre><h3 id="软件包版本"><a href="#软件包版本" class="headerlink" title="软件包版本"></a>软件包版本</h3><ul>
<li>在上面的描述中，已经看到类似以下的版本号：〜0.13.0 或 ^0.13.0。 它们是什么意思，还可以使用哪些其他的版本说明符？<br>该符号指定了软件包能从该依赖接受的更新。<br>如果写入的是 〜0.13.0，则只更新补丁版本：即 0.13.1 可以，但 0.14.0 不可以。<br>如果写入的是 ^0.13.0，则要更新补丁版本和次版本：即 0.13.1、0.14.0、依此类推。<br>如果写入的是 0.13.0，则始终使用确切的版本。</li>
</ul>
<h2 id="package-lock-json-文件"><a href="#package-lock-json-文件" class="headerlink" title="package-lock.json 文件"></a><font color="#ff99cc">package-lock.json 文件</font></h2><pre><code>package-lock.json 会固化当前安装的每个软件包的版本，当运行 npm install时，npm 会使用这些确切的版本。
package-lock.json 文件需要被提交到 Git 仓库，以便被其他人获取（如果项目是公开的或有合作者，或者将 Git 作为部署源）。
当运行 npm update 时，package-lock.json 文件中的依赖的版本会被更新。
&lt;div class=&apos;post-warning&apos;&gt;如果指定确切的版本，例如示例中的 0.13.0，则不会受到此问题的影响。如果指定确切的版本，例如示例中的 0.13.0，则不会受到此问题的影响。&lt;/div&gt;
</code></pre><h2 id="npm-包"><a href="#npm-包" class="headerlink" title="npm 包"></a><font color="#ff99cc">npm 包</font></h2><h3 id="查看-npm-包安装的版本"><a href="#查看-npm-包安装的版本" class="headerlink" title="查看 npm 包安装的版本"></a>查看 npm 包安装的版本</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm list  // 查看所有已安装的 npm 软件包（包括它们的依赖包），也可以打开 package-lock.json 文件，但这需要进行一些视觉扫描。</span><br><span class="line">npm list -g  // 也一样，但适用于全局安装的软件包。</span><br><span class="line">npm list --depth=0  // 仅获取顶层的软件包</span><br><span class="line">npm list &lt;package-name&gt; // 获取特定软件包的版本</span><br><span class="line">npm view [package_name] version // 查看软件包在 npm 仓库上最新的可用版本</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="安装-npm-包的旧版本"><a href="#安装-npm-包的旧版本" class="headerlink" title="安装 npm 包的旧版本"></a>安装 npm 包的旧版本</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install &lt;package&gt;@&lt;version&gt;  // 安装指定版本</span><br><span class="line">npm view &lt;package&gt; versions  // 查看包的所有版本</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="npm包更新"><a href="#npm包更新" class="headerlink" title="npm包更新"></a>npm包更新</h3><pre><code>npm update，则!或~已安装的版本会被更新，并且 package-lock.json 文件会被新版本填充。package.json 则保持不变。
主版本永远不会被这种方式更新，因为它们（根据定义）会引入重大的更改，npm 希望为你减少麻烦。
若要发觉软件包的新版本，则运行 npm outdated。
</code></pre><h3 id="npm的语义版本控制"><a href="#npm的语义版本控制" class="headerlink" title="npm的语义版本控制"></a>npm的语义版本控制</h3><pre><code>语义版本控制的概念很简单：所有的版本都有 3 个数字：x.y.z。
- 第一个数字是主版本。进行不兼容的 API 更改。
- 第二个数字是次版本。以向后兼容的方式添加功能。
- 第三个数字是补丁版本。进行向后兼容的缺陷修复。

规则：
  ^: 只会执行不更改最左边非零数字的更新。 如果写入的是 ^0.13.0，则当运行 npm update 时，可以更新到 0.13.1、0.13.2 等，但不能更新到 0.14.0 或更高版本。 如果写入的是 ^1.13.0，则当运行 npm update 时，可以更新到 1.13.1、1.14.0 等，但不能更新到 2.0.0 或更高版本。
  ~: 如果写入的是 〜0.13.0，则当运行 npm update 时，会更新到补丁版本：即 0.13.1 可以，但 0.14.0 不可以。
  &gt;: 接受高于指定版本的任何版本。
  &gt;=: 接受等于或高于指定版本的任何版本。
  &lt;=: 接受等于或低于指定版本的任何版本。
  &lt;: 接受低于指定版本的任何版本。
  =: 接受确切的版本。
  -: 接受一定范围的版本。例如：2.1.0 - 2.6.2。
  ||: 组合集合。例如 &lt; 2.1 || &gt; 2.6。
  可以合并其中的一些符号，例如 1.0.0 || &gt;=1.1.0 &lt;1.2.0，即使用 1.0.0 或从 1.1.0 开始但低于 1.2.0 的版本。

  还有其他的规则：
  无符号: 仅接受指定的特定版本（例如 1.2.1）。
  latest: 使用可用的最新版本。
</code></pre><h3 id="卸载-npm-软件包"><a href="#卸载-npm-软件包" class="headerlink" title="卸载 npm 软件包"></a>卸载 npm 软件包</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall &lt;package-name&gt;</span><br><span class="line"></span><br><span class="line">如果使用 -S 或 --save 标志，则此操作还会移除 package.json 文件中的引用:</span><br><span class="line">npm uninstall -S &lt;package-name&gt;</span><br><span class="line">npm uninstall -D &lt;package-name&gt;  // -D 或 --save-dev</span><br><span class="line"></span><br><span class="line">如果该软件包是全局安装的，则需要添加 -g 或 --global 标志：</span><br><span class="line">npm uninstall -g &lt;package-name&gt;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="Node-js-包运行器-npx"><a href="#Node-js-包运行器-npx" class="headerlink" title="Node.js 包运行器 npx"></a><font color="#ff99cc">Node.js 包运行器 npx</font></h2><pre><code>npx 是一个非常强大的命令，从 npm 的 5.2 版本（发布于 2017 年 7 月）开始可用。
</code></pre><h3 id="轻松地运行本地命令"><a href="#轻松地运行本地命令" class="headerlink" title="轻松地运行本地命令"></a>轻松地运行本地命令</h3><pre><code>运行 npx commandname 会自动地在项目的 node_modules 文件夹中找到命令的正确引用，而无需知道确切的路径，也不需要在全局和用户路径中安装软件包。
</code></pre><h3 id="无需安装的命令执行"><a href="#无需安装的命令执行" class="headerlink" title="无需安装的命令执行"></a>无需安装的命令执行</h3><pre><code>npx 的另一个重要的特性是，无需先安装命令即可运行命令。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npx 可以运行该 npm 命令，而无需在本地安装：</span><br><span class="line">npx cowsay &quot;你好&quot;</span><br></pre></td></tr></table></figure>

其他场景有：
  运行 vue CLI 工具以创建新的应用程序并运行它们：npx @vue/cli create my-vue-app。
  使用 create-react-app 创建新的 React 应用：npx create-react-app my-react-app。
  还有更多其他的场景。

  当被下载完，则下载的代码会被擦除。
</code></pre><h3 id="使用不同的-Node-js-版本运行代码"><a href="#使用不同的-Node-js-版本运行代码" class="headerlink" title="使用不同的 Node.js 版本运行代码"></a>使用不同的 Node.js 版本运行代码</h3><pre><code>使用 @ 指定版本，并将其与 node npm 软件包 结合使用,这有助于避免使用 nvm 之类的工具或其他 Node.js 版本管理工具。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npx node@10 -v #v10.18.1</span><br><span class="line">npx node@12 -v #v12.14.1</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="直接从-URL-运行任意代码片段"><a href="#直接从-URL-运行任意代码片段" class="headerlink" title="直接从 URL 运行任意代码片段"></a>直接从 URL 运行任意代码片段</h3><h2 id="Node-js-事件循环"><a href="#Node-js-事件循环" class="headerlink" title="Node.js 事件循环"></a><font color="#ff99cc">Node.js 事件循环</font></h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><pre><code>Node.js JavaScript 代码运行在单个线程上。 每次只处理一件事。
这个限制实际上非常有用，因为它大大简化了编程方式，而不必担心并发问题。
</code></pre><h3 id="阻塞事件循环"><a href="#阻塞事件循环" class="headerlink" title="阻塞事件循环"></a>阻塞事件循环</h3><h3 id="调用堆栈"><a href="#调用堆栈" class="headerlink" title="调用堆栈"></a>调用堆栈</h3><pre><code>调用堆栈是一个 LIFO 队列（后进先出）。
事件循环不断地检查调用堆栈，以查看是否需要运行任何函数。
</code></pre><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><pre><code>setTimeout(() =&gt; {}, 0) 的用例是调用一个函数，但是是在代码中的每个其他函数已被执行之后。
事件循环会赋予调用堆栈优先级，它首先处理在调用堆栈中找到的所有东西，一旦其中没有任何东西，便开始处理消息队列中的东西。
我们不必等待诸如 setTimeout、fetch、或其他的函数来完成它们自身的工作，因为它们是由浏览器提供的，并且位于它们自身的线程中。 例如，如果将 setTimeout 的超时设置为 2 秒，但不必等待 2 秒，等待发生在其他地方。
</code></pre><h3 id="作业队列"><a href="#作业队列" class="headerlink" title="作业队列"></a>作业队列</h3><pre><code>ECMAScript 2015 引入了作业队列的概念，Promise 使用了该队列（也在 ES6/ES2015 中引入）。 这种方式会尽快地执行异步函数的结果，而不是放在调用堆栈的末尾。

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const bar = () =&gt; console.log(&apos;bar&apos;)</span><br><span class="line">const baz = () =&gt; console.log(&apos;baz&apos;)</span><br><span class="line"></span><br><span class="line">const foo = () =&gt; &#123;</span><br><span class="line">  console.log(&apos;foo&apos;)</span><br><span class="line">  setTimeout(bar, 0)</span><br><span class="line">  new Promise((resolve, reject) =&gt;&#123;</span><br><span class="line">    console.log(&apos;🍉&apos;);</span><br><span class="line">    resolve(&apos;应该在 baz 之后、bar 之前&apos;);</span><br><span class="line">  &#125;).then(resolve =&gt; console.log(resolve))</span><br><span class="line">  baz()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

  foo
  🍉
  baz
  应该在 baz 之后、bar 之前
  bar

这是 Promise（以及基于 promise 构建的 async/await）与通过 setTimeout() 或其他平台 API 的普通的旧异步函数之间的巨大区别。
</code></pre><h2 id="了解-process-nextTick"><a href="#了解-process-nextTick" class="headerlink" title="了解 process.nextTick()"></a><font color="#ff99cc">了解 process.nextTick()</font></h2><p>  每当事件循环进行一次完整的行程时，我们都将其称为一个滴答。<br>  当将一个函数传给 process.nextTick() 时，则指示引擎在当前操作结束（在下一个事件循环滴答开始之前）时调用此函数：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick(() =&gt; &#123;</span><br><span class="line">  //做些事情</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>  当该操作结束时，JS 引擎会运行在该操作期间传给 nextTick 调用的所有函数。<br>  这是可以告诉 JS 引擎异步地（在当前函数之后）处理函数的方式，但是尽快执行而不是将其排入队列。<br>  调用 setTimeout(() =&gt; {}, 0) 会在下一个滴答结束时执行该函数，比使用 nextTick()（其会优先执行该调用并在下一个滴答开始之前执行该函数）晚得多。<br>  当要确保在下一个事件循环迭代中代码已被执行，则使用 nextTick()。</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const bar = () =&gt; console.log(&apos;bar&apos;)</span><br><span class="line">const baz = () =&gt; console.log(&apos;baz&apos;)</span><br><span class="line"></span><br><span class="line">const foo = () =&gt; &#123;</span><br><span class="line">  console.log(&apos;foo&apos;)</span><br><span class="line">  process.nextTick(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;滴答🐦&apos;)</span><br><span class="line">  &#125;)</span><br><span class="line">  setTimeout(bar, 0)</span><br><span class="line">  new Promise((resolve, reject) =&gt;&#123;</span><br><span class="line">    console.log(&apos;🍉&apos;);</span><br><span class="line">    resolve(&apos;应该在 baz 之后、bar 之前&apos;);</span><br><span class="line">  &#125;).then(resolve =&gt; console.log(resolve))</span><br><span class="line">  baz()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>
<pre><code>foo
🍉
baz
滴答🐦
应该在 baz 之后、bar 之前
bar
</code></pre><h2 id="了解-setImmediate"><a href="#了解-setImmediate" class="headerlink" title="了解 setImmediate()"></a><font color="#ff99cc">了解 setImmediate()</font></h2><pre><code>作为 setImmediate() 参数传入的任何函数都是在事件循环的下一个迭代中执行的回调。
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(() =&gt; &#123;</span><br><span class="line">  //运行一些东西</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

setImmediate() 与 setTimeout(() =&gt; {}, 0)（传入 0 毫秒的超时）、process.nextTick() 有何不同？
传给 process.nextTick() 的函数会在事件循环的当前迭代中（当前操作结束之后）被执行。 这意味着它会始终在 setTimeout 和 setImmediate 之前执行。
延迟 0 毫秒的 setTimeout() 回调与 setImmediate() 非常相似。 执行顺序取决于各种因素，但是它们都会在事件循环的下一个迭代中运行。
</code></pre><h2 id="探索-JavaScript-定时器"><a href="#探索-JavaScript-定时器" class="headerlink" title="探索 JavaScript 定时器"></a><font color="#ff99cc">探索 JavaScript 定时器</font></h2><h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout()"></a>setTimeout()</h3><pre><code>该语法定义了一个新的函数。 可以在其中调用所需的任何其他函数，也可以传入现有的函数名称和一组参数：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const myFunction = (firstParam, secondParam) =&gt; &#123;</span><br><span class="line">  // 做些事情</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2 秒之后运行</span><br><span class="line">const id = setTimeout(myFunction, 2000, firstParam, secondParam)</span><br><span class="line"></span><br><span class="line">clearTimeout(id)</span><br></pre></td></tr></table></figure>

setTimeout 会返回定时器的 id。 通常不使用它，但是可以保存此 id，并在要删除此安排的函数执行时清除它。

- 零延迟

&lt;div class=&apos;post-warning&apos;&gt;
  某些浏览器（IE 和 Edge）实现的 setImmediate() 方法具有相同的确切功能，但是不是标准的，并且在其他浏览器上不可用。但是在 Node.js 中它是标准的函数。
  Node.js 还提供 setImmediate()（相当于使用 setTimeout(() =&gt; {}, 0)），通常用于与 Node.js 事件循环配合使用。
&lt;/div&gt;
</code></pre><h3 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval()"></a>setInterval()</h3><pre><code>除非使用 clearInterval 告诉它停止（传入 setInterval 返回的间隔定时器 id），否则它会在指定的特定时间间隔（以毫秒为单位）一直地运行回调函数，而不是只运行一次：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const id = setInterval(() =&gt; &#123;</span><br><span class="line">  // 每 2 秒运行一次</span><br><span class="line">&#125;, 2000)</span><br><span class="line"></span><br><span class="line">clearInterval(id)</span><br></pre></td></tr></table></figure>

  通常在 setInterval 回调函数中调用 clearInterval，以使其自行判断是否应该再次运行或停止。 例如，此代码会运行某些事情，除非 App.somethingIWait 具有值 arrived：
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const interval = setInterval(() =&gt; &#123;</span><br><span class="line">  if (App.somethingIWait === &apos;arrived&apos;) &#123;</span><br><span class="line">    clearInterval(interval)</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  // 否则做些事情</span><br><span class="line">&#125;, 100)</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="JavaScript-异步编程与回调"><a href="#JavaScript-异步编程与回调" class="headerlink" title="JavaScript 异步编程与回调"></a><font color="#ff99cc">JavaScript 异步编程与回调</font></h2><pre><code>程序在内部会使用中断，一种被发送到处理器以获取系统关注的信号。
当程序正在等待来自网络的响应时，则它无法在请求完成之前停止处理器。

JS在默认情况下是同步的，并且是单线程的。这意味着代码无法创建新的线程并且不能并行运行。
</code></pre><h3 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h3><pre><code>JavaScript 诞生于浏览器内部，一开始的主要工作是响应用户的操作，例如 onClick、onMouseOver、onChange、onSubmit 等。
- 使用同步的编程模型该如何做到这一点？
  答案就在于它的环境。 浏览器通过提供一组可以处理这种功能的 API 来提供了一种实现方式。

  Node.js 引入了非阻塞的 I/O 环境，以将该概念扩展到文件访问、网络调用等。
</code></pre><h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><pre><code>回调是一个简单的函数，会作为值传给另一个函数，并且仅在事件发生时才被执行。之所以这样做，是因为JS具有顶级的函数，这些函数可以被分配给变量并传给其他函数（成为高阶函数）。

- 处理回调中的错误
  一种非常常见的策略是使用 Node.js 所采用的方式：任何回调函数中的第一个参数为错误对象（即错误优先的回调）。
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(&apos;/文件.json&apos;, (err, data) =&gt; &#123;</span><br><span class="line">  if (err !== null) &#123;</span><br><span class="line">    //处理错误</span><br><span class="line">    console.log(err)</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //没有错误，则处理数据。</span><br><span class="line">  console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

- 回调的问题
  回调适用于简单的场景！
  回调复杂时可能会是回调地狱。。。

- 回调的替代方法
  从 ES6 开始，JavaScript 引入了一些特性，可以帮助处理异步代码而不涉及使用回调：Promise（ES6）和 Async/Await（ES2017）。
</code></pre><h2 id="了解-JavaScript-Promise"><a href="#了解-JavaScript-Promise" class="headerlink" title="了解 JavaScript Promise"></a><font color="#ff99cc">了解 JavaScript Promise</font></h2><pre><code>Promise通常被定义为**最终会被变为可用值的代理**。  

当promise被调用后，它会以处理中状态开始。这意味着调用的函数会继续执行，而promise仍处于处理中直到解决未知，从而为调用的函数提供所请求的任何数据。

被创建的promise最终会以**被解决状态**或**被拒绝状态**结束，并在完成时调用相应的回调函数（then或catch）。
resolve -&gt; then
rejecte -&gt; catch
如果在执行路径中从未调用过这些函数之一，则 promise 会保持处理中(pending)状态。

一种被称为 Promisifying 的技术。 这项技术能够使用经典的 JavaScript 函数来接受回调并使其返回 promise：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">const getFile = (fileName) =&gt; &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    fs.readFile(fileName, (err, data) =&gt; &#123;</span><br><span class="line">      if (err) &#123;</span><br><span class="line">        reject(err)  // 调用 `reject` 会导致 promise 失败，无论是否传入错误作为参数，</span><br><span class="line">        return        // 且不再进行下去。</span><br><span class="line">      &#125;</span><br><span class="line">      resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getFile(&apos;/etc/passwd&apos;)</span><br><span class="line">.then(data =&gt; console.log(data))</span><br><span class="line">.catch(err =&gt; console.error(err))</span><br></pre></td></tr></table></figure>
</code></pre>  <div class="post-warning">在最新版本的 Node.js 中，无需为大多数 API 进行手动地转换。如果需要 promisifying 的函数具有正确的签名，则 util 模块中有一个 promisifying 函数可以完成此操作。</div>

<h3 id="链式-promise"><a href="#链式-promise" class="headerlink" title="链式 promise"></a>链式 promise</h3><p>  Promise 可以返回到另一个 promise，从而创建一个 promise 链。</p>
<p>  Fetch API 是基于 promise 的机制，调用 fetch() 相当于使用 new Promise() 来定义 promsie。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const status = response =&gt; &#123;</span><br><span class="line">  if (response.status &gt;= 200 &amp;&amp; response.status &lt; 300) &#123;</span><br><span class="line">    return Promise.resolve(response)</span><br><span class="line">  &#125;</span><br><span class="line">  return Promise.reject(new Error(response.statusText))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const json = response =&gt; response.json()</span><br><span class="line"></span><br><span class="line">fetch(&apos;/todos.json&apos;)</span><br><span class="line">  .then(status)    // 注意，`status` 函数实际上在这里被调用，并且同样返回 promise，</span><br><span class="line">  .then(json)      // 这里唯一的区别是的 `json` 函数会返回解决时传入 `data` 的 promise，</span><br><span class="line">  .then(data =&gt; &#123;  // 这是 `data` 会在此处作为匿名函数的第一个参数的原因。</span><br><span class="line">    console.log(&apos;请求成功获得 JSON 响应&apos;, data)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(error =&gt; &#123;</span><br><span class="line">    console.log(&apos;请求失败&apos;, error)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h3><p>  当 promise 链中的任何内容失败并引发错误或拒绝 promise 时，则控制权会转到链中最近的 catch() 语句。</p>
<p>  如果再catch内部发生错误，则可以附加第二个catch来处理，以此类推。</p>
<h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><p>  如果需要同步不同的 promise，则 Promise.all() 可以帮助定义 promise 列表，并在所有 promise 都被解决后执行一些操作。</p>
<p>  示例：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const f1 = fetch(&apos;/something.json&apos;)</span><br><span class="line">const f2 = fetch(&apos;/something2.json&apos;)</span><br><span class="line"></span><br><span class="line">Promise.all([f1, f2])</span><br><span class="line">  .then(res =&gt; &#123;</span><br><span class="line">    console.log(&apos;结果的数组&apos;, res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(err =&gt; &#123;</span><br><span class="line">    console.error(err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p>
<pre><code>ES2015 解构赋值语法也可以执行：
</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.all([f1, f2]).then(([res1, res2]) =&gt; &#123;</span><br><span class="line">  console.log(&apos;结果&apos;, res1, res2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<pre><code>当然，不限于使用 fetch，任何 promise 都可以以这种方式使用。
</code></pre><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><p>  当传给其的首个 promise 被解决时，则 Promise.race() 开始运行，并且只运行一次附加的回调（传入第一个被解决的 promise 的结果）。</p>
<p>  示例：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const first = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(resolve, 500, &apos;第一个&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">const second = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(resolve, 100, &apos;第二个&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Promise.race([first, second]).then(result =&gt; &#123;</span><br><span class="line">  console.log(result) // 第二个</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="常见的错误"><a href="#常见的错误" class="headerlink" title="常见的错误"></a>常见的错误</h3><pre><code>- Uncaught TypeError: undefined is not a promise
如果在控制台中收到 Uncaught TypeError: undefined is not a promise 错误，则请确保使用 new Promise() 而不是 Promise()。

- UnhandledPromiseRejectionWarning
这意味着调用的 promise 被拒绝，但是没有用于处理错误的 catch。 在 then 之后添加 catch 则可以正确地处理。
</code></pre><h2 id="具有-Async-和-Await-的现代异步-JavaScript"><a href="#具有-Async-和-Await-的现代异步-JavaScript" class="headerlink" title="具有 Async 和 Await 的现代异步 JavaScript"></a><font color="#ff99cc">具有 Async 和 Await 的现代异步 JavaScript</font></h2><pre><code>Promise 被引入了用于解决著名的回调地狱问题，但是它们自身引入了复杂性以及语法复杂性。
它们使代码看起来像是同步的，但它是异步的并且在后台无阻塞。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const doSomethingAsync = () =&gt; &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    console.log(&apos;+1&apos;);resolve(&apos;做些事情&apos;);console.log(&apos;+2&apos;);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const doSomething = async () =&gt; &#123;</span><br><span class="line">  console.log(&apos;+3&apos;);</span><br><span class="line">  console.log(await doSomethingAsync());</span><br><span class="line">  console.log(&apos;+4&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(&apos;之前&apos;);</span><br><span class="line">doSomething();</span><br><span class="line">console.log(&apos;之后&apos;);</span><br><span class="line"></span><br><span class="line">// 之前  +3   +1   +2   之后 做些事情 +4</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="Promise-所有事情"><a href="#Promise-所有事情" class="headerlink" title="Promise 所有事情"></a>Promise 所有事情</h3><pre><code>在任何函数之前加上 async 关键字意味着该函数会返回 promise。即使没有显式地这样做，它也会在内部使它返回 promise。
这就是为什么此代码有效的原因：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const aFunction = async () =&gt; &#123;</span><br><span class="line">  return &apos;测试&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">aFunction().then(alert) // 这会 alert &apos;测试&apos;</span><br></pre></td></tr></table></figure>

等同于：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const aFunction = () =&gt; &#123;</span><br><span class="line">  return Promise.resolve(&apos;测试&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">aFunction().then(alert) // 这会 alert &apos;测试&apos;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="代码更容易阅读"><a href="#代码更容易阅读" class="headerlink" title="代码更容易阅读"></a>代码更容易阅读</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const getFirstUserData = () =&gt; &#123;</span><br><span class="line">  return fetch(&apos;/users.json&apos;) // 获取用户列表</span><br><span class="line">    .then(response =&gt; response.json()) // 解析 JSON</span><br><span class="line">    .then(users =&gt; users[0]) // 选择第一个用户</span><br><span class="line">    .then(user =&gt; fetch(`/users/$&#123;user.name&#125;`)) // 获取用户数据</span><br><span class="line">    .then(userResponse =&gt; userResponse.json()) // 解析 JSON</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getFirstUserData()</span><br></pre></td></tr></table></figure>

这是使用 await/async 提供的相同功能：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const getFirstUserData = async () =&gt; &#123;</span><br><span class="line">  const response = await fetch(&apos;/users.json&apos;) // 获取用户列表</span><br><span class="line">  const users = await response.json() // 解析 JSON</span><br><span class="line">  const user = users[0] // 选择第一个用户</span><br><span class="line">  const userResponse = await fetch(`/users/$&#123;user.name&#125;`) // 获取用户数据</span><br><span class="line">  const userData = await userResponse.json() // 解析 JSON</span><br><span class="line">  return userData</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getFirstUserData()</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="多个异步函数串联"><a href="#多个异步函数串联" class="headerlink" title="多个异步函数串联"></a>多个异步函数串联</h3><pre><code>异步函数可以很容易地链接起来，并且语法比普通的 promise 更具可读性。例子略，有需要见官网。
</code></pre><h3 id="更容易调试"><a href="#更容易调试" class="headerlink" title="更容易调试"></a>更容易调试</h3><pre><code>调试 promise 很难，因为调试器不会跳过异步的代码。

Async/await 使这非常容易，因为对于编译器而言，它就像同步代码一样。
</code></pre><h2 id="Node-js-事件触发器"><a href="#Node-js-事件触发器" class="headerlink" title="Node.js 事件触发器"></a><font color="#ff99cc">Node.js 事件触发器</font></h2><pre><code>在后端，Node.js 也提供了使用 events 模块构建类似系统的选项。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const EventEmitter = require(&apos;events&apos;)</span><br><span class="line">const eventEmitter = new EventEmitter()</span><br></pre></td></tr></table></figure>

- 该对象公开了 on 和 emit 方法。
  emit 用于触发事件。
  on 用于添加回调函数（会在事件被触发时执行）。

可传参：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eventEmitter.on(&apos;start&apos;, (start, end) =&gt; &#123;</span><br><span class="line">  console.log(`从 $&#123;start&#125; 到 $&#123;end&#125;`)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">eventEmitter.emit(&apos;start&apos;, 1, 100);</span><br></pre></td></tr></table></figure>

- EventEmitter 对象还公开了其他几个与事件进行交互的方法，例如：
  once(): 添加单次监听器。
  removeListener() / off(): 从事件中移除事件监听器。
  removeAllListeners(): 移除事件的所有监听器。
  可以在[事件模块](http://nodejs.cn/api/events.html)的页面上阅读其所有详细信息。
</code></pre><h2 id="搭建-HTTP-服务器"><a href="#搭建-HTTP-服务器" class="headerlink" title="搭建 HTTP 服务器"></a><font color="#ff99cc">搭建 HTTP 服务器</font></h2><pre><code>这是一个简单的 HTTP web 服务器的示例：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http&apos;)</span><br><span class="line"></span><br><span class="line">const port = 3000</span><br><span class="line"></span><br><span class="line">const server = http.createServer((req, res) =&gt; &#123;</span><br><span class="line">  res.statusCode = 200</span><br><span class="line">  res.setHeader(&apos;Content-Type&apos;, &apos;text/plain&apos;)</span><br><span class="line">  res.end(&apos;你好世界\n&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(port, () =&gt; &#123;</span><br><span class="line">  console.log(`服务器运行在 http://$&#123;hostname&#125;:$&#123;port&#125;/`)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="使用-Node-js-发送-HTTP-请求"><a href="#使用-Node-js-发送-HTTP-请求" class="headerlink" title="使用 Node.js 发送 HTTP 请求"></a><font color="#ff99cc">使用 Node.js 发送 HTTP 请求</font></h2><pre><code>- 执行 GET 请求
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const https = require(&apos;https&apos;)</span><br><span class="line">const options = &#123;</span><br><span class="line">  hostname: &apos;nodejs.cn&apos;,</span><br><span class="line">  port: 443,</span><br><span class="line">  path: &apos;/todos&apos;,</span><br><span class="line">  method: &apos;GET&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const req = https.request(options, res =&gt; &#123;</span><br><span class="line">  console.log(`状态码: $&#123;res.statusCode&#125;`)</span><br><span class="line"></span><br><span class="line">  res.on(&apos;data&apos;, d =&gt; &#123;</span><br><span class="line">    process.stdout.write(d)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">req.on(&apos;error&apos;, error =&gt; &#123;</span><br><span class="line">  console.error(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">req.end()</span><br></pre></td></tr></table></figure>

- 执行 POST 请求
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">const https = require(&apos;https&apos;)</span><br><span class="line"></span><br><span class="line">const data = JSON.stringify(&#123;</span><br><span class="line">  todo: &apos;做点事情&apos;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const options = &#123;</span><br><span class="line">  hostname: &apos;nodejs.cn&apos;,</span><br><span class="line">  port: 443,</span><br><span class="line">  path: &apos;/todos&apos;,</span><br><span class="line">  method: &apos;POST&apos;,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    &apos;Content-Type&apos;: &apos;application/json&apos;,</span><br><span class="line">    &apos;Content-Length&apos;: data.length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const req = https.request(options, res =&gt; &#123;</span><br><span class="line">  console.log(`状态码: $&#123;res.statusCode&#125;`)</span><br><span class="line"></span><br><span class="line">  res.on(&apos;data&apos;, d =&gt; &#123;</span><br><span class="line">    process.stdout.write(d)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">req.on(&apos;error&apos;, error =&gt; &#123;</span><br><span class="line">  console.error(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">req.write(data)</span><br><span class="line">req.end()</span><br></pre></td></tr></table></figure>


- PUT 和 DELETE
  PUT 和 DELETE 请求使用相同的 POST 请求格式，只需更改 options.method 的值即可。
</code></pre><h2 id="使用-Node-js-发送-HTTP-POST-请求"><a href="#使用-Node-js-发送-HTTP-POST-请求" class="headerlink" title="使用 Node.js 发送 HTTP POST 请求"></a><font color="#ff99cc">使用 Node.js 发送 HTTP POST 请求</font></h2><pre><code>在 Node.js 中，有多种方式可以执行 HTTP POST 请求，具体取决于要使用的抽象级别。

使用 Node.js 执行 HTTP 请求的最简单的方式是使用 Axios 库：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const axios = require(&apos;axios&apos;)</span><br><span class="line"></span><br><span class="line">axios</span><br><span class="line">  .post(&apos;http://nodejs.cn/todos&apos;, &#123;</span><br><span class="line">    todo: &apos;做点事情&apos;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(res =&gt; &#123;</span><br><span class="line">    console.log(`状态码: $&#123;res.statusCode&#125;`)</span><br><span class="line">    console.log(res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(error =&gt; &#123;</span><br><span class="line">    console.error(error)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

Axios 需要使用第三方的库。
也可以只使用 Node.js 的标准模块来发送 POST 请求，尽管它比前面的选择冗长些：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">const https = require(&apos;https&apos;)</span><br><span class="line"></span><br><span class="line">const data = JSON.stringify(&#123;</span><br><span class="line">  todo: &apos;做点事情&apos;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const options = &#123;</span><br><span class="line">  hostname: &apos;nodejs.cn&apos;,</span><br><span class="line">  port: 443,</span><br><span class="line">  path: &apos;/todos&apos;,</span><br><span class="line">  method: &apos;POST&apos;,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    &apos;Content-Type&apos;: &apos;application/json&apos;,</span><br><span class="line">    &apos;Content-Length&apos;: data.length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const req = https.request(options, res =&gt; &#123;</span><br><span class="line">  console.log(`状态码: $&#123;res.statusCode&#125;`)</span><br><span class="line"></span><br><span class="line">  res.on(&apos;data&apos;, d =&gt; &#123;</span><br><span class="line">    process.stdout.write(d)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">req.on(&apos;error&apos;, error =&gt; &#123;</span><br><span class="line">  console.error(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">req.write(data)</span><br><span class="line">req.end()</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="使用-Node-js-获取-HTTP-请求的正文数据"><a href="#使用-Node-js-获取-HTTP-请求的正文数据" class="headerlink" title="使用 Node.js 获取 HTTP 请求的正文数据"></a><font color="#ff99cc">使用 Node.js 获取 HTTP 请求的正文数据</font></h2><pre><code>如果使用的是 Express，则非常简单：使用 body-parser Node.js 模块。

例如，获取此请求的正文：
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const axios = require(&apos;axios&apos;)</span><br><span class="line"></span><br><span class="line">axios.post(&apos;http://nodejs.cn/todos&apos;, &#123;</span><br><span class="line">  todo: &apos;做点事情&apos;</span><br><span class="line">&#125;)</span><br><span class="line">这是对应的服务器端代码：</span><br><span class="line"></span><br><span class="line">const express = require(&apos;express&apos;)</span><br><span class="line">const app = express()</span><br><span class="line"></span><br><span class="line">app.use(</span><br><span class="line">  express.urlencoded(&#123;</span><br><span class="line">    extended: true</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">app.use(express.json())</span><br><span class="line"></span><br><span class="line">app.post(&apos;/todos&apos;, (req, res) =&gt; &#123;</span><br><span class="line">  console.log(req.body.todo)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

  如果不使用 Express 并想在普通的 Node.js 中执行此操作，则需要做多一点的工作，因为 Express 抽象了很多工作。

  要理解的关键是，当使用 http.createServer() 初始化 HTTP 服务器时，服务器会在获得所有 HTTP 请求头（而不是请求正文时）时调用回调。

  在连接回调中传入的 request 对象是一个流。

  因此，必须监听要处理的主体内容，并且其是按数据块处理的。

  首先，通过监听流的 data 事件来获取数据，然后在数据结束时调用一次流的 end 事件：

  const server = http.createServer((req, res) =&gt; {
    // 可以访问 HTTP 请求头
    req.on(&apos;data&apos;, chunk =&gt; {
      console.log(`可用的数据块: ${chunk}`)
    })
    req.on(&apos;end&apos;, () =&gt; {
      //数据结束
    })
  })
  因此，若要访问数据（假设期望接收到字符串），则必须将其放入数组中：

  const server = http.createServer((req, res) =&gt; {
    let data = &apos;&apos;;
    req.on(&apos;data&apos;, chunk =&gt; {
      data += chunk;
    })
    req.on(&apos;end&apos;, () =&gt; {
      JSON.parse(data).todo // &apos;做点事情&apos;
    })
  })
</code></pre><h2 id="在-Node-js-中使用文件描述符"><a href="#在-Node-js-中使用文件描述符" class="headerlink" title="在 Node.js 中使用文件描述符"></a><font color="#ff99cc">在 Node.js 中使用文件描述符</font></h2><pre><code>文件描述符是使用 fs 模块提供的 open() 方法打开文件后返回的：
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">fs.open(&apos;/Users/joe/test.txt&apos;, &apos;r&apos;, (err, fd) =&gt; &#123;</span><br><span class="line">  //fd 是文件描述符。</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

注意，将 r 作为 fs.open() 调用的第二个参数。
该标志意味着打开文件用于读取。

其他常用的标志有：
r+ 打开文件用于读写。
w+ 打开文件用于读写，将流定位到文件的开头。如果文件不存在则创建文件。
a 打开文件用于写入，将流定位到文件的末尾。如果文件不存在则创建文件。
a+ 打开文件用于读写，将流定位到文件的末尾。如果文件不存在则创建文件。

也可以使用 fs.openSync 方法打开文件，该方法会返回文件描述符（而不是在回调中提供）：
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  const fd = fs.openSync(&apos;/Users/joe/test.txt&apos;, &apos;r&apos;)</span><br><span class="line">&#125; catch (err) &#123;</span><br><span class="line">  console.error(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

一旦获得文件描述符，就可以以任何方式执行所有需要它的操作，例如调用 fs.open() 以及许多与文件系统交互的其他操作。
</code></pre><h2 id="Node-js-文件属性"><a href="#Node-js-文件属性" class="headerlink" title="Node.js 文件属性"></a><font color="#ff99cc">Node.js 文件属性</font></h2><pre><code>每个文件都带有一组详细信息，可以使用 Node.js 进行检查。具体地说，使用 fs 模块提供的 stat() 方法。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line">fs.stat(&apos;/Users/joe/test.txt&apos;, (err, stats) =&gt; &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    console.error(err)</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stats.isFile() //true</span><br><span class="line">  stats.isDirectory() //false</span><br><span class="line">  stats.isSymbolicLink() //false</span><br><span class="line">  stats.size //1024000 //= 1MB</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

Node.js 也提供了同步的方法，该方法会阻塞线程，直到文件属性准备就绪为止：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line">try &#123;</span><br><span class="line">  const stats = fs.statSync(&apos;/Users/joe/test.txt&apos;)</span><br><span class="line">&#125; catch (err) &#123;</span><br><span class="line">  console.error(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="Node-js-文件路径"><a href="#Node-js-文件路径" class="headerlink" title="Node.js 文件路径"></a><font color="#ff99cc">Node.js 文件路径</font></h2><pre><code>- 从路径中获取信息
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const notes = &apos;/users/joe/notes.txt&apos;</span><br><span class="line"></span><br><span class="line">path.dirname(notes) // /users/joe   获取文件的父文件夹。</span><br><span class="line">path.basename(notes) // notes.txt   获取文件名部分。</span><br><span class="line">path.extname(notes) // .txt         获取文件的扩展名。</span><br><span class="line">path.basename(notes, path.extname(notes)) //notes  可以通过为 basename 指定第二个参数来获取不带扩展名的文件名：</span><br></pre></td></tr></table></figure>

- 使用路径
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">连接路径:</span><br><span class="line">const name = &apos;joe&apos;</span><br><span class="line">path.join(&apos;/&apos;, &apos;users&apos;, name, &apos;notes.txt&apos;) // &apos;/users/joe/notes.txt&apos;</span><br><span class="line"></span><br><span class="line">path.resolve() 获得相对路径的绝对路径:</span><br><span class="line">path.resolve(&apos;joe.txt&apos;) // &apos;/Users/joe/joe.txt&apos; 如果从主文件夹运行。</span><br><span class="line">path.resolve(&apos;tmp&apos;, &apos;joe.txt&apos;) // &apos;/Users/joe/tmp/joe.txt&apos;    如果从主文件夹运行。</span><br><span class="line">path.resolve(&apos;/etc&apos;, &apos;joe.txt&apos;) // &apos;/etc/joe.txt&apos;   如果第一个参数以斜杠开头，则表示它是绝对路径</span><br><span class="line"></span><br><span class="line">path.normalize() 是另一个有用的函数，当包含诸如 .、.. 或双斜杠之类的相对说明符时，其会尝试计算实际的路径：</span><br><span class="line">path.normalize(&apos;/users/joe/..//test.txt&apos;) // &apos;/users/test.txt&apos;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="使用-Node-js-读取文件"><a href="#使用-Node-js-读取文件" class="headerlink" title="使用 Node.js 读取文件"></a><font color="#ff99cc">使用 Node.js 读取文件</font></h2><pre><code>在 Node.js 中读取文件最简单的方式是使用 fs.readFile() 方法，向其传入文件路径、编码、以及会带上文件数据（以及错误）进行调用的回调函数：
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">fs.readFile(&apos;/Users/joe/test.txt&apos;, &apos;utf8&apos; , (err, data) =&gt; &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    console.error(err)</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


另外，也可以使用同步的版本 fs.readFileSync()：
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  const data = fs.readFileSync(&apos;/Users/joe/test.txt&apos;, &apos;utf8&apos;)</span><br><span class="line">  console.log(data)</span><br><span class="line">&#125; catch (err) &#123;</span><br><span class="line">  console.error(err)</span><br><span class="line">&#125;</span><br><span class="line">fs.readFile() 和 fs.readFileSync() 都会在返回数据之前将文件的全部内容读取到内存中。</span><br></pre></td></tr></table></figure>

这意味着大文件会对内存的消耗和程序执行的速度产生重大的影响。

在这种情况下，更好的选择是使用流来读取文件的内容。
</code></pre><h2 id="使用-Node-js-写入文件"><a href="#使用-Node-js-写入文件" class="headerlink" title="使用 Node.js 写入文件"></a><font color="#ff99cc">使用 Node.js 写入文件</font></h2>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line">const content = &apos;一些内容&apos;</span><br><span class="line"></span><br><span class="line">fs.writeFile(&apos;/Users/joe/test.txt&apos;, content, err =&gt; &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    console.error(err)</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  //文件写入成功。</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<pre><code>另外，也可以使用同步的版本 fs.writeFileSync()：
</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">const content = &apos;一些内容&apos;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  const data = fs.writeFileSync(&apos;/Users/joe/test.txt&apos;, content)</span><br><span class="line">  //文件写入成功。</span><br><span class="line">&#125; catch (err) &#123;</span><br><span class="line">  console.error(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>默认情况下，此 API 会替换文件的内容（如果文件已经存在）。可以通过指定标志来修改默认的行为：
</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.writeFile(&apos;/Users/joe/test.txt&apos;, content, &#123; flag: &apos;a+&apos; &#125;, err =&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure>
<pre><code>可能会使用的标志有：
r+ 打开文件用于读写。
w+ 打开文件用于读写，将流定位到文件的开头。如果文件不存在则创建文件。
a 打开文件用于写入，将流定位到文件的末尾。如果文件不存在则创建文件。
a+ 打开文件用于读写，将流定位到文件的末尾。如果文件不存在则创建文件。
(可以在 http://nodejs.cn/api/fs.html#fs_file_system_flags 中查看更多标志)
</code></pre><ul>
<li><p>追加到文件<br>将内容追加到文件末尾的便捷方法是 fs.appendFile()（及其对应的 fs.appendFileSync()）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const content = &apos;一些内容&apos;</span><br><span class="line"></span><br><span class="line">fs.appendFile(&apos;file.log&apos;, content, err =&gt; &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    console.error(err)</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  //完成！</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用流<br>所有这些方法都是在将全部内容写入文件之后才会将控制权返回给程序（在异步的版本中，这意味着执行回调）。</p>
<p>在这种情况下，更好的选择是使用流写入文件的内容。</p>
<h2 id="Node-js-文件系统模块"><a href="#Node-js-文件系统模块" class="headerlink" title="Node.js 文件系统模块"></a><font color="#ff99cc">Node.js 文件系统模块</font></h2><p>fs 模块提供了许多非常实用的函数来访问文件系统并与文件系统进行交互。<br>无需安装。 作为 Node.js 核心的组成部分，可以通过简单地引用来使用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;)</span><br></pre></td></tr></table></figure>
<p>其所有的方法，包括：<br>fs.access(): 检查文件是否存在，以及 Node.js 是否有权限访问。<br>fs.appendFile(): 追加数据到文件。如果文件不存在，则创建文件。<br>fs.chmod(): 更改文件（通过传入的文件名指定）的权限。相关方法：fs.lchmod()、fs.fchmod()。<br>fs.chown(): 更改文件（通过传入的文件名指定）的所有者和群组。相关方法：fs.fchown()、fs.lchown()。<br>fs.close(): 关闭文件描述符。<br>fs.copyFile(): 拷贝文件。<br>fs.createReadStream(): 创建可读的文件流。<br>fs.createWriteStream(): 创建可写的文件流。<br>fs.link(): 新建指向文件的硬链接。<br>fs.mkdir(): 新建文件夹。<br>fs.mkdtemp(): 创建临时目录。<br>fs.open(): 设置文件模式。<br>fs.readdir(): 读取目录的内容。<br>fs.readFile(): 读取文件的内容。相关方法：fs.read()。<br>fs.readlink(): 读取符号链接的值。<br>fs.realpath(): 将相对的文件路径指针（.、..）解析为完整的路径。<br>fs.rename(): 重命名文件或文件夹。<br>fs.rmdir(): 删除文件夹。<br>fs.stat(): 返回文件（通过传入的文件名指定）的状态。相关方法：fs.fstat()、fs.lstat()。<br>fs.symlink(): 新建文件的符号链接。<br>fs.truncate(): 将传递的文件名标识的文件截断为指定的长度。相关方法：fs.ftruncate()。<br>fs.unlink(): 删除文件或符号链接。<br>fs.unwatchFile(): 停止监视文件上的更改。<br>fs.utimes(): 更改文件（通过传入的文件名指定）的时间戳。相关方法：fs.futimes()。<br>fs.watchFile(): 开始监视文件上的更改。相关方法：fs.watch()。<br>fs.writeFile(): 将数据写入文件。相关方法：fs.write()。</p>
<p>关于 fs 模块的特殊之处是，所有的方法默认情况下都是异步的，但是通过在前面加上 Sync 也可以同步地工作。<br>例如：</p>
<pre><code>fs.rename()
fs.renameSync()
fs.write()
fs.writeSync()
</code></pre><p>这在应用程序流程中会产生巨大的差异。</p>
</li>
</ul>
<h2 id="Node-js-路径模块"><a href="#Node-js-路径模块" class="headerlink" title="Node.js 路径模块"></a><font color="#ff99cc">Node.js 路径模块</font></h2><p>  path 模块提供了许多非常实用的函数来访问文件系统并与文件系统进行交互。<br>  无需安装。 作为 Node.js 核心的组成部分，可以通过简单地引用来使用它：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;)</span><br></pre></td></tr></table></figure></p>
<p>  该模块提供了 path.sep（作为路径段分隔符，在 Windows 上是 \，在 Linux/macOS 上是 /）和 path.delimiter（作为路径定界符，在 Windows 上是 ;，在 Linux/macOS 上是 :）。</p>
<p>  还有这些 path 方法：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">path.basename()  返回路径的最后一部分。 第二个参数可以过滤掉文件的扩展名：</span><br><span class="line">  require(&apos;path&apos;).basename(&apos;/test/something&apos;) //something</span><br><span class="line">  require(&apos;path&apos;).basename(&apos;/test/something.txt&apos;) //something.txt</span><br><span class="line">  require(&apos;path&apos;).basename(&apos;/test/something.txt&apos;, &apos;.txt&apos;) //something</span><br><span class="line"></span><br><span class="line">path.dirname()  返回路径的目录部分：</span><br><span class="line">  require(&apos;path&apos;).dirname(&apos;/test/something&apos;) // /test</span><br><span class="line">  require(&apos;path&apos;).dirname(&apos;/test/something/file.txt&apos;) // /test/something</span><br><span class="line"></span><br><span class="line">path.extname()  返回路径的扩展名部分。</span><br><span class="line">  require(&apos;path&apos;).extname(&apos;/test/something&apos;) // &apos;&apos;</span><br><span class="line">  require(&apos;path&apos;).extname(&apos;/test/something/file.txt&apos;) // &apos;.txt&apos;</span><br><span class="line"></span><br><span class="line">path.isAbsolute()  如果是绝对路径，则返回 true。</span><br><span class="line">  require(&apos;path&apos;).isAbsolute(&apos;/test/something&apos;) // true</span><br><span class="line">  require(&apos;path&apos;).isAbsolute(&apos;./test/something&apos;) // false</span><br><span class="line"></span><br><span class="line">path.join()  连接路径的两个或多个部分：</span><br><span class="line">  const name = &apos;joe&apos;</span><br><span class="line">  require(&apos;path&apos;).join(&apos;/&apos;, &apos;users&apos;, name, &apos;notes.txt&apos;) //&apos;/users/joe/notes.txt&apos;</span><br><span class="line"></span><br><span class="line">path.normalize()  当包含类似 .、.. 或双斜杠等相对的说明符时，则尝试计算实际的路径：</span><br><span class="line">  require(&apos;path&apos;).normalize(&apos;/users/joe/..//test.txt&apos;) //&apos;/users/test.txt&apos;</span><br><span class="line"></span><br><span class="line">path.parse()</span><br><span class="line">  解析对象的路径为组成其的片段：</span><br><span class="line">    root: 根路径。</span><br><span class="line">    dir: 从根路径开始的文件夹路径。</span><br><span class="line">    base: 文件名 + 扩展名</span><br><span class="line">    name: 文件名</span><br><span class="line">    ext: 文件扩展名</span><br><span class="line">  </span><br><span class="line">  require(&apos;path&apos;).parse(&apos;/users/test.txt&apos;)</span><br><span class="line">    结果是：</span><br><span class="line">    &#123;</span><br><span class="line">      root: &apos;/&apos;,</span><br><span class="line">      dir: &apos;/users&apos;,</span><br><span class="line">      base: &apos;test.txt&apos;,</span><br><span class="line">      ext: &apos;.txt&apos;,</span><br><span class="line">      name: &apos;test&apos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">path.relative() 接受 2 个路径作为参数。 基于当前工作目录，返回从第一个路径到第二个路径的相对路径。</span><br><span class="line">  require(&apos;path&apos;).relative(&apos;/Users/joe&apos;, &apos;/Users/joe/test.txt&apos;) //&apos;test.txt&apos;</span><br><span class="line">  require(&apos;path&apos;).relative(&apos;/Users/joe&apos;, &apos;/Users/joe/something/test.txt&apos;) //&apos;something/test.txt&apos;</span><br><span class="line"></span><br><span class="line">path.resolve() 可以使用 path.resolve() 获得相对路径的绝对路径计算：</span><br><span class="line">  path.resolve(&apos;joe.txt&apos;) //&apos;/Users/joe/joe.txt&apos; 如果从主文件夹运行</span><br><span class="line"> </span><br><span class="line">  通过指定第二个参数，resolve 会使用第一个参数作为第二个参数的基准：</span><br><span class="line">  path.resolve(&apos;tmp&apos;, &apos;joe.txt&apos;) //&apos;/Users/joe/tmp/joe.txt&apos; 如果从主文件夹运行</span><br><span class="line">   </span><br><span class="line">  如果第一个参数以斜杠开头，则表示它是绝对路径：</span><br><span class="line">  path.resolve(&apos;/etc&apos;, &apos;joe.txt&apos;) //&apos;/etc/joe.txt&apos;</span><br></pre></td></tr></table></figure></p>
<h2 id="Node-js-操作系统模块"><a href="#Node-js-操作系统模块" class="headerlink" title="Node.js 操作系统模块"></a><font color="#ff99cc">Node.js 操作系统模块</font></h2><pre><code>该模块提供了许多函数，可用于从底层的操作系统和程序运行所在的计算机上检索信息并与其进行交互。
  os.arch()
  os.cpus()
  os.endianness()
  os.freemem()
  os.homedir()
  os.hostname()
  os.loadavg()
  os.networkInterfaces()
  os.platform()
  os.release()
  os.tmpdir()
  os.totalmem()
  os.type()
  os.uptime()
  os.userInfo()
</code></pre><h2 id="Node-js-事件模块"><a href="#Node-js-事件模块" class="headerlink" title="Node.js 事件模块"></a><font color="#ff99cc">Node.js 事件模块</font></h2><pre><code>events 模块为提供了 EventEmitter 类，这是在 Node.js 中处理事件的关键。
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const EventEmitter = require(&apos;events&apos;)</span><br><span class="line">const emitter = new EventEmitter()</span><br></pre></td></tr></table></figure>

  emitter.addListener()
  emitter.emit()
  emitter.eventNames()
  emitter.getMaxListeners()
  emitter.listenerCount()
  emitter.listeners()
  emitter.off()
  emitter.on()
  emitter.once()
  emitter.prependListener()
  emitter.prependOnceListener()
  emitter.removeAllListeners()
  emitter.removeListener()
  emitter.setMaxListeners()
</code></pre><h2 id="Node-js-http-模块"><a href="#Node-js-http-模块" class="headerlink" title="Node.js http 模块"></a><font color="#ff99cc">Node.js http 模块</font></h2><pre><code>HTTP 核心模块是 Node.js 网络的关键模块。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http&apos;)</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="Node-js-Buffer"><a href="#Node-js-Buffer" class="headerlink" title="Node.js Buffer"></a><font color="#ff99cc">Node.js Buffer</font></h2><pre><code>Buffer 是内存区域，由 Node.js Buffer 类实现。 它表示在 V8 JavaScript 引擎外部分配的固定大小的内存块（无法调整大小）。

Buffer 与流紧密相连。 当流处理器接收数据的速度快于其消化的速度时，则会将数据放入 buffer 中。

- 创建buffer：
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Buffer.from()、Buffer.alloc() 和 Buffer.allocUnsafe() 方法可以创建 buffer。</span><br><span class="line">  const buf = Buffer.from(&apos;Hey!&apos;)</span><br><span class="line">  Buffer.from(array)</span><br><span class="line">  Buffer.from(arrayBuffer[, byteOffset[, length]])</span><br><span class="line">  Buffer.from(buffer)</span><br><span class="line">  Buffer.from(string[, encoding])</span><br><span class="line">  </span><br><span class="line">也可以只初始化 buffer（传入大小）。 以下会创建一个 1KB 的 buffer：</span><br><span class="line">  const buf = Buffer.alloc(1024)</span><br><span class="line">  //或</span><br><span class="line">  const buf = Buffer.allocUnsafe(1024) </span><br><span class="line"></span><br><span class="line">（allocUnsafe 不安全的原因，在使用它时必须格外小心。）</span><br></pre></td></tr></table></figure>

  &lt;div class=&apos;post-warning&apos;&gt;注意，如果使用数字（设置其大小）初始化 buffer，则可以访问到包含随机数据的已预初始化的内存（而不是空的 buffer）&lt;/div&gt;

- 使用 buffer
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Buffer（字节数组）可以像数组一样被访问：</span><br><span class="line">  const buf = Buffer.from(&apos;Hey!&apos;)</span><br><span class="line">  buf[0] //72   Unicode 码</span><br><span class="line">  buf[1] //101  Unicode 码</span><br><span class="line">  buf[2] //121  Unicode 码</span><br><span class="line">  buf.toString()  // Hey!</span><br><span class="line"></span><br><span class="line">获取 buffer 的长度：buf.length // 4</span><br><span class="line"></span><br><span class="line">遍历 buffer 的内容：</span><br><span class="line">  for (const item of buf) &#123;</span><br><span class="line">    console.log(item) //72 101 121 33</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">更改 buffer 的内容：</span><br><span class="line">  const buf = Buffer.alloc(4)</span><br><span class="line">  buf.write(&apos;Hey!&apos;)</span><br><span class="line">  或</span><br><span class="line">  buf[1] = 111 //o</span><br><span class="line">  console.log(buf.toString()) //Hoy</span><br><span class="line"></span><br><span class="line">复制 buffer：</span><br><span class="line">  const buf = Buffer.from(&apos;Hey!&apos;)</span><br><span class="line">  let bufcopy = Buffer.alloc(4) //分配 4 个字节。</span><br><span class="line">  buf.copy(bufcopy)</span><br><span class="line">  bufcopy.toString()  // &apos;Hey!&apos;</span><br><span class="line"></span><br><span class="line">  默认情况下，会复制整个 buffer。 另外的 3 个参数可以定义开始位置、结束位置、以及新的 buffer 长度：</span><br><span class="line">  const buf = Buffer.from(&apos;Hey!&apos;)</span><br><span class="line">  let bufcopy = Buffer.alloc(2) //分配 2 个字节。</span><br><span class="line">  buf.copy(bufcopy, 0, 0, 2)</span><br><span class="line">  bufcopy.toString() //&apos;He&apos;</span><br><span class="line"></span><br><span class="line">切片 buffer</span><br><span class="line">  如果要创建 buffer 的局部视图，则可以创建切片。 切片不是副本：原始 buffer 仍然是真正的来源。 如果那改变了，则切片也会改变。</span><br><span class="line">  使用 slice() 方法创建它。 第一个参数是起始位置，可以指定第二个参数作为结束位置：</span><br><span class="line"></span><br><span class="line">  const buf = Buffer.from(&apos;Hey!&apos;)</span><br><span class="line">  buf.slice(0).toString() //Hey!</span><br><span class="line">  const slice = buf.slice(0, 2)</span><br><span class="line">  console.log(slice.toString()) //He</span><br><span class="line">  buf[1] = 111 //o</span><br><span class="line">  console.log(slice.toString()) //Ho</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="Node-js-流"><a href="#Node-js-流" class="headerlink" title="Node.js 流"></a><font color="#ff99cc">Node.js 流</font></h2><h3 id="什么是流"><a href="#什么是流" class="headerlink" title="什么是流"></a>什么是流</h3><pre><code>流是为Node.js应用程序提供动力的基本概念之一。它们是一种以高效的方式处理读/写文件，网络通信，或任何类型的端到端的信息交换。
流不是Nodejs特有的概念。它们是几十年前在Unix操作系统中引入的，程序可以通过管道运算符（|）对流进行相互交互。

例如，在传统的方式中，当告诉程序读取文件时，这会将文件从头到尾读入内存，然后进行处理。使用流，则可以逐个片段地读取。

Node.js的 Stream 模块 提供了构建所有流 API 的基础。所有的流都是 EventEmitter 的实例。

相对于其他的数据处理方式，流具有两大优点：
1）内存效率：无需加载大量的数据到内存就可以进行处理。
2）时间效率：当获得数据之后即可立即开始处理数据，这样所需的时间更是，而不必等到整个数据的有效负载可用才开始。
</code></pre><h3 id="流的示例"><a href="#流的示例" class="headerlink" title="流的示例"></a>流的示例</h3><pre><code>一个典型的例子是从磁盘读取文件。

- 使用 Node.js 的 fs 模块，可以读取文件，并在与 HTTP 服务器建立新连接时通过 HTTP 提供文件：
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http&apos;)</span><br><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">const server = http.createServer(function(req, res) &#123;</span><br><span class="line">  fs.readFile(__dirname + &apos;/data.txt&apos;, (err, data) =&gt; &#123;</span><br><span class="line">    res.end(data)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(3000)</span><br></pre></td></tr></table></figure>

  readFile() 读取文件的全部内容，并在完成时调用回调函数。回调中的 res.end(data) 会返回文件的内容给 HTTP 客户端。

- 如果文件很大，则该操作会花费较多的时间。 以下是使用流编写的相同内容：
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http&apos;)</span><br><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">const server = http.createServer((req, res) =&gt; &#123;</span><br><span class="line">  const stream = fs.createReadStream(__dirname + &apos;/data.txt&apos;)</span><br><span class="line">  stream.pipe(res)</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(3000)</span><br></pre></td></tr></table></figure>

  当要发送的数据块已获得时就立即开始将其流式传输到 HTTP 客户端，而不是等待直到文件被完全读取。
</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code>- pipe()
  它是获取来源流，并将其通过管道传输到目标流。

  在来源流上调用pipe()，在上面的示例中，文件流通过管道传输到HTTP响应。
  pipe()返回的是目标流，可以链式调用：
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">src.pipe(dest1).pipe(dest2)</span><br><span class="line">此构造相对于：</span><br><span class="line"></span><br><span class="line">src.pipe(dest1)</span><br><span class="line">dest1.pipe(dest2)</span><br></pre></td></tr></table></figure>

- 流驱动的 Node.js API
  由于它们的优点，许多 Node.js 核心模块提供了原生的流处理功能，最值得注意的有：
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">process.stdin 返回连接到 stdin 的流。</span><br><span class="line">process.stdout 返回连接到 stdout 的流。</span><br><span class="line">process.stderr 返回连接到 stderr 的流。</span><br><span class="line">fs.createReadStream() 创建文件的可读流。</span><br><span class="line">fs.createWriteStream() 创建到文件的可写流。</span><br><span class="line">net.connect() 启动基于流的连接。</span><br><span class="line">http.request() 返回 http.ClientRequest 类的实例，该实例是可写流。</span><br><span class="line">zlib.createGzip() 使用 gzip（压缩算法）将数据压缩到流中。</span><br><span class="line">zlib.createGunzip() 解压缩 gzip 流。</span><br><span class="line">zlib.createDeflate() 使用 deflate（压缩算法）将数据压缩到流中。</span><br><span class="line">zlib.createInflate() 解压缩 deflate 流。</span><br></pre></td></tr></table></figure>

- 流分为四类：
  Readable: 可以通过管道读取、但不能通过管道写入的流（可以接收数据，但不能向其发送数据）。 当推送数据到可读流中时，会对其进行缓冲，直到使用者开始读取数据为止。
  Writable: 可以通过管道写入、但不能通过管道读取的流（可以发送数据，但不能从中接收数据）。
  Duplex: 可以通过管道写入和读取的流，基本上相对于是可读流和可写流的组合。
  Transform: 类似于双工流、但其输出是其输入的转换的转换流。

- 创建可读流：
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const Stream = require(&apos;stream&apos;)</span><br><span class="line">const readableStream = new Stream.Readable()</span><br><span class="line"></span><br><span class="line">readableStream._read = () =&gt; &#123;&#125;</span><br><span class="line">或</span><br><span class="line">const readableStream = new Stream.Readable(&#123;</span><br><span class="line">  read() &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">现在，流已初始化，可以向其发送数据了：</span><br><span class="line">readableStream.push(&apos;hi!&apos;)</span><br><span class="line">readableStream.push(&apos;ho!&apos;)</span><br></pre></td></tr></table></figure>

- 创建可写流
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const Stream = require(&apos;stream&apos;)</span><br><span class="line">const writableStream = new Stream.Writable()</span><br><span class="line"></span><br><span class="line">writableStream._write = (chunk, encoding, next) =&gt; &#123;</span><br><span class="line">  console.log(chunk.toString())</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">现在，可以通过以下方式传输可读流：</span><br><span class="line">process.stdin.pipe(writableStream)</span><br></pre></td></tr></table></figure>

- 从可读流中获取数据
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const Stream = require(&apos;stream&apos;)</span><br><span class="line">const readableStream = new Stream.Readable(&#123;</span><br><span class="line">  read() &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line">const writableStream = new Stream.Writable()</span><br><span class="line"></span><br><span class="line">writableStream._write = (chunk, encoding, next) =&gt; &#123;</span><br><span class="line">  console.log(chunk.toString())</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">readableStream.pipe(writableStream)</span><br><span class="line"></span><br><span class="line">readableStream.push(&apos;hi!&apos;)</span><br><span class="line">readableStream.push(&apos;ho!&apos;)</span><br><span class="line">也可以使用 readable 事件直接地消费可读流：</span><br><span class="line"></span><br><span class="line">readableStream.on(&apos;readable&apos;, () =&gt; &#123;</span><br><span class="line">  console.log(readableStream.read())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

- 发送数据到可写流
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writableStream.write(&apos;hey!\n&apos;)</span><br></pre></td></tr></table></figure>

- 使用信号通知已结束写入的可写流
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const Stream = require(&apos;stream&apos;)</span><br><span class="line"></span><br><span class="line">const readableStream = new Stream.Readable(&#123;</span><br><span class="line">  read() &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line">const writableStream = new Stream.Writable()</span><br><span class="line"></span><br><span class="line">writableStream._write = (chunk, encoding, next) =&gt; &#123;</span><br><span class="line">  console.log(chunk.toString())</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">readableStream.pipe(writableStream)</span><br><span class="line"></span><br><span class="line">readableStream.push(&apos;hi!&apos;)</span><br><span class="line">readableStream.push(&apos;ho!&apos;)</span><br><span class="line"></span><br><span class="line">writableStream.end()</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="Node-js-开发环境与生产环境的区别"><a href="#Node-js-开发环境与生产环境的区别" class="headerlink" title="Node.js 开发环境与生产环境的区别"></a><font color="#ff99cc">Node.js 开发环境与生产环境的区别</font></h2><pre><code>此环境变量是一个约定，在外部库中也广泛使用。

设置环境为 production 通常可以确保：
- 日志记录保持在最低水平。
- 更高的缓存级别以优化性能。

最好将其放在的 shell 配置文件中（例如，使用 Bash shell 的 .bash_profile），否则当系统重启时，该设置不会被保留。
也可以通过将环境变量放在应用程序的初始化命令之前来应用它：NODE_ENV=production node app.js

可以使用条件语句在不同的环境中执行代码：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (process.env.NODE_ENV === &quot;development&quot;) &#123;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br><span class="line">if (process.env.NODE_ENV === &quot;production&quot;) &#123;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br><span class="line">if([&apos;production&apos;, &apos;staging&apos;].indexOf(process.env.NODE_ENV) &gt;= 0) &#123;</span><br><span class="line">  //...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


例如，在 Express 应用中，可以使用此工具为每个环境设置不同的错误处理程序：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (process.env.NODE_ENV === &quot;development&quot;) &#123;</span><br><span class="line">  app.use(express.errorHandler(&#123; dumpExceptions: true, showStack: true &#125;))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">if (process.env.NODE_ENV === &quot;production&quot;) &#123;</span><br><span class="line">  app.use(express.errorHandler())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="Node-js-中的错误处理"><a href="#Node-js-中的错误处理" class="headerlink" title="Node.js 中的错误处理"></a><font color="#ff99cc">Node.js 中的错误处理</font></h2><h3 id="创建异常"><a href="#创建异常" class="headerlink" title="创建异常"></a>创建异常</h3><pre><code>使用 throw 关键字创建异常：throw value
一旦 JavaScript 执行到此行，则常规的程序流会被停止，且控制会被交给最近的异常处理程序。

通常，在客户端代码中，value 可以是任何 JavaScript 值（包括字符串、数字、或对象）。
在 Node.js 中，我们不抛出字符串，而仅抛出 Error 对象。
</code></pre><h3 id="错误对象"><a href="#错误对象" class="headerlink" title="错误对象"></a>错误对象</h3><pre><code>错误对象是 Error 对象的实例、或者继承自 Error 类（由 Error 核心模块提供）：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">throw new Error(&apos;错误信息&apos;)</span><br><span class="line">或：</span><br><span class="line"></span><br><span class="line">class NotEnoughCoffeeError extends Error &#123;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br><span class="line">throw new NotEnoughCoffeeError()</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h3><pre><code>异常处理程序是 try/catch 语句。
</code></pre><h3 id="捕获未捕获的异常"><a href="#捕获未捕获的异常" class="headerlink" title="捕获未捕获的异常"></a>捕获未捕获的异常</h3><pre><code>如果在程序执行过程中引发了未捕获的异常，则程序会崩溃。

若要解决此问题，则监听 process 对象上的 uncaughtException 事件：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">process.on(&apos;uncaughtException&apos;, err =&gt; &#123;</span><br><span class="line">  console.error(&apos;有一个未捕获的错误&apos;, err)</span><br><span class="line">  process.exit(1) //强制性的（根据 Node.js 文档）</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

无需为此导入 process 核心模块，因为它是自动注入的。
</code></pre><h3 id="Promise-的异常"><a href="#Promise-的异常" class="headerlink" title="Promise 的异常"></a>Promise 的异常</h3><ul>
<li>使用 promise 可以链接不同的操作，并在最后处理错误：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">doSomething1()</span><br><span class="line">  .then(doSomething2)</span><br><span class="line">  .then(doSomething3)</span><br><span class="line">  .catch(err =&gt; console.error(err))</span><br><span class="line">你怎么知道错误发生在哪里？ 你并不知道，但是你可以处理所调用的每个函数（doSomethingX）中的错误，并且在错误处理程序内部抛出新的错误，这就会调用外部的 catch 处理程序：</span><br><span class="line"></span><br><span class="line">const doSomething1 = () =&gt; &#123;</span><br><span class="line">  //...</span><br><span class="line">  try &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    //... 在本地处理</span><br><span class="line">    throw new Error(err.message)</span><br><span class="line">  &#125;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>- 为了能够在本地（而不是在调用的函数中）处理错误，则可以断开链条，在每个 then() 函数中创建函数并处理异常：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">doSomething1()</span><br><span class="line">  .then(() =&gt; &#123;</span><br><span class="line">    return doSomething2().catch(err =&gt; &#123;</span><br><span class="line">      //处理错误</span><br><span class="line">      throw err //打断链条</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(() =&gt; &#123;</span><br><span class="line">    return doSomething2().catch(err =&gt; &#123;</span><br><span class="line">      //处理错误</span><br><span class="line">      throw err //打断链条</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(err =&gt; console.error(err))</span><br></pre></td></tr></table></figure>

### async/await 的错误处理
  使用 async/await 时，仍然需要捕获错误，可以通过以下方式进行操作：

  async function someFunction() {
    try {
      await someOtherFunction()
    } catch (err) {
      console.error(err.message)
    }
  }
</code></pre><h2 id="在-Node-js-中如何记录对象"><a href="#在-Node-js-中如何记录对象" class="headerlink" title="在 Node.js 中如何记录对象"></a><font color="#ff99cc">在 Node.js 中如何记录对象</font></h2><pre><code>在达到一定嵌套级别之前一切都很好。 在经过两个级别的嵌套后，Node.js 会放弃并打印 [Object] 作为占位符：
如何打印整个对象？

最好的方法（同时保留漂亮的打印效果）是使用：
console.log(JSON.stringify(obj, null, 2))
其中 2 是用于缩进的空格数。

另一种选择是使用：
require(&apos;util&apos;).inspect.defaultOptions.depth = null
console.log(obj)
但是有个问题，第 2 级之后的嵌套对象会被展平，这可能是复杂对象的问题。
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/04/22/workReward/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lemon">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/background2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/22/workReward/" itemprop="url">workReward</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-22T17:39:33+08:00">
                2021-04-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/四院/" itemprop="url" rel="index">
                    <span itemprop="name">四院</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="js"><a href="#js" class="headerlink" title="js"></a>js</h1><h2 id="ES5-map循环：循环遍历竟然出现逗号！"><a href="#ES5-map循环：循环遍历竟然出现逗号！" class="headerlink" title="ES5 map循环：循环遍历竟然出现逗号！"></a>ES5 map循环：循环遍历竟然出现逗号！</h2>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = document.getElementById(&apos;root&apos;);</span><br><span class="line">var b = [1,2,3,4,5,6].map( item =&gt; item);</span><br><span class="line">a.innerText = b;   //  1,2,3,4,5,6</span><br></pre></td></tr></table></figure>
<p>  原来:利用map插入到DOM时 map最终返回的数组因为拼接+=调用了toString方法. 数组结构[1, 2, 3] 里面居然是这个逗号, 转换的时候把它带上了！<br>  我们知道了原因之后就非常方便解决了。我们可以巧妙地利用join方法：join()可以切开一个数组, 指定要使用的分隔符。如果省略该参数，则使用逗号作为分隔符。</p>
<h2 id="模板字符串中-n失效问题"><a href="#模板字符串中-n失效问题" class="headerlink" title="模板字符串中\n失效问题"></a>模板字符串中\n失效问题</h2><pre><code>white-space: pre-line;
</code></pre><h2 id="forEach不遍历内部为空的数组，函数内的代码也不执行。"><a href="#forEach不遍历内部为空的数组，函数内的代码也不执行。" class="headerlink" title="forEach不遍历内部为空的数组，函数内的代码也不执行。"></a>forEach不遍历内部为空的数组，函数内的代码也不执行。</h2><pre><code>为空是指Empty，不是null或undefined。可以改写成for循环。
</code></pre><h2 id="判断用户输入数据是否是JSON格式："><a href="#判断用户输入数据是否是JSON格式：" class="headerlink" title="判断用户输入数据是否是JSON格式："></a>判断用户输入数据是否是JSON格式：</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const checkJson = (d: string) =&gt; &#123;</span><br><span class="line">  if (typeof d !== &apos;string&apos;) &#123;</span><br><span class="line">    message.warning(&apos;非 JSON 格式&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  try &#123;</span><br><span class="line">    const obj = JSON.parse(d);</span><br><span class="line">    if (typeof obj === &apos;object&apos; &amp;&amp; obj) &#123;</span><br><span class="line">      message.warning(&apos;是 JSON 格式&apos;);</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    message.warning(&apos;非 JSON 格式&apos;);</span><br><span class="line">    return false;</span><br><span class="line">  &#125; catch (info) &#123;</span><br><span class="line">    message.warning(&apos;非 JSON 格式&apos;);</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="JSON-stringify-…"><a href="#JSON-stringify-…" class="headerlink" title="JSON.stringify(…)"></a>JSON.stringify(…)</h2><pre><code>JSON.stringify(…)用于将对象转换成字符串，但是注意JSON.stringify(…)也会转译引号。
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(&#123;&#125;)  === “&#123;&#125;”                       <span class="literal">true</span></span><br><span class="line">JSON.stringify(‘123<span class="string">')  === 123                     false</span></span><br><span class="line"><span class="string">JSON.stringify(‘123'</span>)  === <span class="string">"\"123\””               true</span></span><br><span class="line"><span class="string">JSON.stringify(&#123;a: 1&#125;)  === "</span>&#123;\<span class="string">"a\":1&#125;”            true</span></span><br><span class="line"><span class="string">JSON.stringify(&#123;a: '123’&#125;) === "</span>&#123;\<span class="string">"a\":\"123\"&#125;”   true</span></span><br></pre></td></tr></table></figure>
</code></pre><h2 id="switch…case和else…if"><a href="#switch…case和else…if" class="headerlink" title="switch…case和else…if"></a>switch…case和else…if</h2><pre><code>switch…case和else…if的根本区别在于，switch…case会生成一个和索引和switch变量相等的跳转表来指向实际的case分支地址，而else…if需要一条一条地遍历。如此看来， switch…case的效率会更高。
switch…case只能判断byte,short,int或是char类型，if的条件会更灵活

详解：switch...case会生成一份大小（表项数）为最大case常量＋1的跳表，程序首先判断switch变量是否大于最大case 常量，若大于，则跳到default分支处理；否则取得索引号为switch变量大小的跳表项的地址（即跳表的起始地址＋表项大小＊索引号），程序接着跳到此地址执行，到此完成了分支的跳转。
</code></pre><p>  ## </p>
<h1 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h1><h2 id="微信小程序扫码跳转指定页面"><a href="#微信小程序扫码跳转指定页面" class="headerlink" title="微信小程序扫码跳转指定页面"></a>微信小程序扫码跳转指定页面</h2><p>  微信公众平台 - 开发 - 开发管理 - 开发设置 - 扫普通链接二维码打开小程序 - 添加</p>
<p>  填写规则信息 - 将校验文件放在服务器对应目录下 - 选择测试范围（非线上版本最多可添加5个测试链接，规则发布后将不受限制）</p>
<h2 id="小程序登录"><a href="#小程序登录" class="headerlink" title="小程序登录"></a>小程序登录</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wx.login(code)                                    -&gt;  </span><br><span class="line">                                                  -&gt; 后端接口（session_key,openId  storage） -&gt;  后端接口（用户信息）</span><br><span class="line">Button(getPhoneNumber - iv,encryptedData storage) -&gt;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="微信小程序登录问题–第一次登录失败，第二次登录成功问题"><a href="#微信小程序登录问题–第一次登录失败，第二次登录成功问题" class="headerlink" title="微信小程序登录问题–第一次登录失败，第二次登录成功问题"></a>微信小程序登录问题–第一次登录失败，第二次登录成功问题</h2><p>  出现这样的问题都是先获取用户信息（getPhoneNumber）encryptedData与iv，再进行登录wx.login（）获取code。是因为每次获取code会产生一个新的session_key，这时的session_key会与encryptedData解密出来的session_key不同，所以就失败了。正确的做法是先获取code再获取encryptedData。也就是实线wx.login（），这样在getPhoneNumber的时候就没问题了。</p>
<h1 id="周边"><a href="#周边" class="headerlink" title="周边"></a>周边</h1><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><p>  别名，甚至是你想改本地的npm包的代码，奈何生效的只是压缩后的代码，未压缩代码修改后不生效。<br>  此时，alias小可爱就可以帮你解决这个问题，nice。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      &apos;tblh-validate-upload&apos;: path.resolve(process.cwd(), &apos;node_modules&apos;, &apos;tblh-validate-upload/src/index.tsx&apos;),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin https://github.com/LemonQueenx/summer.git</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>
<h3 id="pull-request"><a href="#pull-request" class="headerlink" title="pull request"></a>pull request</h3><p>  我们有需求想改别人的github仓库代码的bug时，需要提pull request。流程是我们fork一下对方的仓库到我们账号下，clone到本地，新建个分支，造作后提交到远程，然后提pull request给对方。对方如果看到，并且愿意采纳你的修改，就会merge，合并到他的项目中。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fork -&gt; </span><br><span class="line">git clone xxx</span><br><span class="line">cd xxx/</span><br><span class="line">git checkout -b fix_jyy</span><br><span class="line">git add .</span><br><span class="line">git commit -m &apos;yyy&apos;</span><br><span class="line">git push --set-upstream origin fix_jyy</span><br></pre></td></tr></table></figure></p>
<p>  完成修改之后，回到 test-pr 分支，点击旁边绿色的 Compare &amp; pull request 按钮</p>
<h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>  npm get registry<br>  npm config set registry xxx<br>  npm adduser –registry xxx<br>  npm profile set password –registry xxx</p>
<p>  npm publish<br>  发布📢：</p>
<ul>
<li>发布之前记得build编译，小包使用rollup打包很简单</li>
<li><p>发布在公司内源的话，需要改变项目的npm源。.npmrc registry=’xxx’</p>
<p>npm view npm包 versions</p>
</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="excel-csv文件的校验并上传"><a href="#excel-csv文件的校验并上传" class="headerlink" title="excel\csv文件的校验并上传"></a>excel\csv文件的校验并上传</h2><p>  基于antd-upload + exceljs二次封装</p>
<ul>
<li>browser引入与使用：<br>（1）npm install exceljs –save<br>（2）import * as ExcelJS from ‘exceljs/dist/exceljs.bare’<br>（3）declare module ‘exceljs/dist/exceljs.bare’</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &apos;react&apos;;</span><br><span class="line">import &#123; Upload, Modal, Button &#125; from &apos;antd&apos;;</span><br><span class="line">const ExcelJS = require(&apos;exceljs/dist/exceljs.bare&apos;);</span><br><span class="line">const Papa = require(&apos;papaparse&apos;);</span><br><span class="line">const jschardet = require(&apos;jschardet&apos;);</span><br><span class="line">const atob = require(&apos;atob&apos;);</span><br><span class="line"></span><br><span class="line">const &#123; Dragger &#125; = Upload as any;</span><br><span class="line">/**类型定义 */</span><br><span class="line">interface IProps &#123;</span><br><span class="line">  sheetProps?: ISheetProps;</span><br><span class="line">  handleMoreValidate?: (rows: any, worksheet?: any) =&gt; string,</span><br><span class="line">  dragProps?: object,</span><br><span class="line">  style?: object,</span><br><span class="line">  children?: React.ReactNode | string,</span><br><span class="line">  uploadToolTip?: React.ReactNode | string,</span><br><span class="line">  resultTitle?: string,</span><br><span class="line">  type?: &apos;excel&apos; | &apos;csv&apos;, // 默认excel</span><br><span class="line">&#125;;</span><br><span class="line">type IType = &apos;list&apos; | &apos;number&apos; | &apos;text&apos; | &apos;custome&apos;; </span><br><span class="line">interface ISheetProps &#123;</span><br><span class="line">  [key: string]: &#123;</span><br><span class="line">    colTitle: string;</span><br><span class="line">    type: IType,</span><br><span class="line">    allowBlank: boolean;</span><br><span class="line">    valueErrorMessage?: string;</span><br><span class="line">    formulae?: any;</span><br><span class="line">    isUnique?: boolean;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">interface ICellErrorInfo &#123;</span><br><span class="line">    cellIndex: string;</span><br><span class="line">    errorMessage: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 工具函数</span><br><span class="line">* @returns </span><br><span class="line">*/</span><br><span class="line">function getEN() &#123;</span><br><span class="line">    var arr = [null] as any;</span><br><span class="line">    for(var i = 65; i &lt; 91; i++)&#123;</span><br><span class="line">        arr.push(String.fromCharCode(i));</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function isInteger(value: number) &#123;</span><br><span class="line">    return value % 1 === 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function dataValidation(value: any, validation: any) &#123;</span><br><span class="line">    if (!validation) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!validation.allowBlank &amp;&amp; !String(value)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //  默认规则</span><br><span class="line">    if (value &amp;&amp; validation.type === &apos;list&apos; &amp;&amp; !validation.formulae.includes(String(value))) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (value &amp;&amp; validation.type === &apos;number&apos; &amp;&amp; !isInteger(Number(value))) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (value &amp;&amp; validation.type === &apos;custom&apos; &amp;&amp; !validation.formulae.test(value)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (value &amp;&amp; validation.type === &apos;text&apos; &amp;&amp; validation.formulae &amp;&amp; value.length &gt; validation.formulae) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const A2Zarray = getEN();</span><br><span class="line"></span><br><span class="line">function checkEncoding(base64Str: any) &#123;</span><br><span class="line">    // 这种方式得到的是一种二进制串</span><br><span class="line">    let str = atob(base64Str.split(&apos;;base64,&apos;)[1]);</span><br><span class="line">    // console.log(str);</span><br><span class="line">    // 要用二进制格式</span><br><span class="line">    let encoding = jschardet.detect(str);</span><br><span class="line">    encoding = encoding.encoding;</span><br><span class="line">    // console.log( encoding );</span><br><span class="line">    if (encoding === &apos;windows-1252&apos;) &#123;</span><br><span class="line">      // 有时会识别错误（如UTF8的中文二字）</span><br><span class="line">      encoding = &apos;ANSI&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    return encoding;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function getFileReaderResult(file: any) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        const fileReader = new FileReader()</span><br><span class="line">        fileReader.readAsDataURL(file);</span><br><span class="line">        fileReader.onload = (e: any) =&gt; &#123;</span><br><span class="line">            const result = e.target.result;</span><br><span class="line">            const encoding = checkEncoding(result);</span><br><span class="line">            resolve(&#123;</span><br><span class="line">                file,</span><br><span class="line">                encoding,</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function getJsonFromCsv(file: any) &#123;</span><br><span class="line">    const data = await getFileReaderResult(file) as any;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        Papa.parse(data.file, &#123;</span><br><span class="line">            encoding: data.encoding,</span><br><span class="line">            complete: function(results: any) &#123;</span><br><span class="line">                resolve(results.data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 组件</span><br><span class="line">* @param props </span><br><span class="line">* @returns </span><br><span class="line">*/</span><br><span class="line">const Demo = (props: IProps) =&gt; &#123;</span><br><span class="line">    const &#123; sheetProps, type=&apos;excel&apos; &#125; = props;</span><br><span class="line">    const [modal, setModal] = React.useState(&#123;</span><br><span class="line">        visible: false,</span><br><span class="line">        resultContent: &apos;&apos;,</span><br><span class="line">    &#125;);</span><br><span class="line">    const dragProps = &#123;</span><br><span class="line">        name: &apos;file&apos;,</span><br><span class="line">        multiple: true,</span><br><span class="line">        accept: &apos;.csv,.xlsx&apos;,</span><br><span class="line">        action: &apos;https://www.mocky.io/v2/5cc8019d300000980a055e76&apos;,</span><br><span class="line">        beforeUpload: async (file: any) =&gt; &#123;</span><br><span class="line">            if (!sheetProps) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            return new Promise(async (resolve, reject) =&gt; &#123;</span><br><span class="line">                if (type === &apos;csv&apos;) &#123;</span><br><span class="line">                    const json = await getJsonFromCsv(file) as any;</span><br><span class="line">                    const csvInfo = &#123;</span><br><span class="line">                        bodyErrorInfo: [],</span><br><span class="line">                        titleError: [],</span><br><span class="line">                        isEmptyCsv: false,</span><br><span class="line">                        extraErrorInfo: &apos;&apos;,</span><br><span class="line">                    &#125; as any;</span><br><span class="line">                    // isEmpty</span><br><span class="line">                    if (!json.length) &#123;</span><br><span class="line">                        csvInfo.isEmptyCsv = true;</span><br><span class="line">                        // setModal(&#123;</span><br><span class="line">                        //     visible: true,</span><br><span class="line">                        //     resultContent: `$&#123;modal.resultContent&#125;\n上传为空表，请检查`,</span><br><span class="line">                        // &#125;);</span><br><span class="line">                        // reject(false);</span><br><span class="line">                    &#125;</span><br><span class="line">                    // isErrorTitle</span><br><span class="line">                    Object.values(sheetProps).forEach((item: any, index: number) =&gt; &#123;</span><br><span class="line">                        if (item.colTitle !== json[0][index]) &#123;</span><br><span class="line">                            csvInfo.titleError = (csvInfo.titleError || []).concat(index);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    // isErrorbody</span><br><span class="line">                    json.forEach((item: any, index: number) =&gt; &#123;</span><br><span class="line">                        if (index) &#123;</span><br><span class="line">                            item.forEach((value: any, i: number) =&gt; &#123;</span><br><span class="line">                                if (!dataValidation(value, sheetProps[A2Zarray[i + 1]])) &#123;</span><br><span class="line">                                    csvInfo.bodyErrorInfo.push(&#123;</span><br><span class="line">                                        cellIndex: `$&#123;index + 1&#125;行 $&#123;A2Zarray[i + 1]&#125;列`,</span><br><span class="line">                                        errorMessage: sheetProps[A2Zarray[i + 1]].valueErrorMessage || &apos;值为空或类型错误，请检查&apos;,</span><br><span class="line">                                    &#125;);</span><br><span class="line">                                &#125;;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    // extraInfo</span><br><span class="line">                    if (props.handleMoreValidate) &#123;</span><br><span class="line">                        csvInfo.extraErrorInfo = props.handleMoreValidate(json);</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 来吧，展示</span><br><span class="line">                    let errorInfo = &apos;&apos;;</span><br><span class="line">                    if (csvInfo.isEmptyCsv) &#123;</span><br><span class="line">                        errorInfo += &apos;上传为空表，请检查&apos;;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (csvInfo.titleError.length) &#123;</span><br><span class="line">                        errorInfo += `\n列标题错误，请检查$&#123;csvInfo.titleError&#125;`;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (csvInfo.bodyErrorInfo.length) &#123;</span><br><span class="line">                        errorInfo += `\n内容错误，错误信息如下：\n$&#123;csvInfo.bodyErrorInfo.map((i: any) =&gt; (`$&#123;i.cellIndex&#125;:$&#123;i.errorMessage&#125;\n`)).join(&apos;&apos;)&#125;`;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (csvInfo.extraErrorInfo) &#123;</span><br><span class="line">                        errorInfo += `\n$&#123;csvInfo.extraErrorInfo&#125;`;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (errorInfo) &#123;</span><br><span class="line">                        setModal(&#123;</span><br><span class="line">                            visible: true,</span><br><span class="line">                            resultContent: errorInfo,</span><br><span class="line">                        &#125;);</span><br><span class="line">                        reject(false);</span><br><span class="line">                    &#125;</span><br><span class="line">                    resolve(true);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                // 以下是对excel的处理</span><br><span class="line">                const buffer = file.arrayBuffer();</span><br><span class="line">                const workbook = new ExcelJS.Workbook();</span><br><span class="line">                await workbook.xlsx.load(buffer);</span><br><span class="line">                let sheetInfo = &#123;&#125; as any;</span><br><span class="line">                workbook.eachSheet(async function(worksheet: any, sheetId: any) &#123;</span><br><span class="line">                    // 先获取当前sheet中的有效数据</span><br><span class="line">                    // 校验列标题和列号是不是正确的</span><br><span class="line">                    // 遍历body每一行数据，校验每个cell</span><br><span class="line">                    sheetInfo[sheetId] = &#123;</span><br><span class="line">                        name: worksheet.name,</span><br><span class="line">                    &#125;;</span><br><span class="line">                    // let breakRowNumber = null as any;</span><br><span class="line">                    let errorTitleIndex = [] as any;</span><br><span class="line">                    let isEmptySheet = false;</span><br><span class="line">                    // 检查主规则</span><br><span class="line">                    let bodyErrorInfo: ICellErrorInfo[] = [];</span><br><span class="line">                    worksheet.eachRow(&#123; includeEmpty: true &#125;, function(row: any, rowNumber: any) &#123;</span><br><span class="line">                        // 检查头部</span><br><span class="line">                        if (rowNumber === 1) &#123;</span><br><span class="line">                            row.values.forEach((title: string, index: number) =&gt; &#123;</span><br><span class="line">                                if (index &amp;&amp; sheetProps[A2Zarray[index]] &amp;&amp; sheetProps[A2Zarray[index]].colTitle !== title) &#123;</span><br><span class="line">                                    errorTitleIndex.push(A2Zarray[index]);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 检查是否是空表</span><br><span class="line">                        if (rowNumber === 1 &amp;&amp; !row.values.length) &#123;</span><br><span class="line">                            isEmptySheet = true;</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 截取有效数据部分</span><br><span class="line">                        if (rowNumber &gt; 1) &#123;</span><br><span class="line">                            row.values.forEach((value: any, index: number) =&gt; &#123;</span><br><span class="line">                                const colIndex = A2Zarray[index];</span><br><span class="line">                                const cellIndex = `$&#123;rowNumber&#125;行 $&#123;colIndex&#125;列`;</span><br><span class="line">                                if (!dataValidation(value, sheetProps[colIndex])) &#123;</span><br><span class="line">                                    bodyErrorInfo.push(&#123;</span><br><span class="line">                                        cellIndex,</span><br><span class="line">                                        errorMessage: sheetProps[colIndex].valueErrorMessage || &apos;值为空或类型错误，请检查&apos;,</span><br><span class="line">                                    &#125;);</span><br><span class="line">                                &#125;;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    // 检查唯一性</span><br><span class="line">                    /////////////// ......</span><br><span class="line">                    // 检查额外逻辑的处理</span><br><span class="line">                    let extraErrorInfo: string = &apos;&apos;;</span><br><span class="line">                    if (props.handleMoreValidate) &#123;</span><br><span class="line">                        const rows = worksheet._rows.map((e: any) =&gt; Array.isArray(e.values) &amp;&amp; e.values.slice(1));</span><br><span class="line">                        extraErrorInfo = props.handleMoreValidate(rows, worksheet);</span><br><span class="line">                    &#125;</span><br><span class="line">                    sheetInfo[sheetId] = &#123;</span><br><span class="line">                        ...sheetInfo[sheetId],</span><br><span class="line">                        isEmptySheet,</span><br><span class="line">                        // breakRowNumber,</span><br><span class="line">                        errorTitleIndex,</span><br><span class="line">                        bodyErrorInfo,</span><br><span class="line">                        extraErrorInfo,</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;);</span><br><span class="line">                let errorInfo = &apos;&apos;;</span><br><span class="line">                // 对结果进行提示</span><br><span class="line">                Object.keys(sheetInfo).forEach((key: string | number) =&gt; &#123;</span><br><span class="line">                    if (sheetInfo[key].isEmptySheet) &#123;</span><br><span class="line">                        errorInfo +=  `$&#123;sheetInfo[key].name&#125;为空表`;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (sheetInfo[key].errorTitleIndex.length) &#123;</span><br><span class="line">                        errorInfo +=  `\n$&#123;sheetInfo[key].name&#125;表标题错误，请检查，列如下：\n$&#123;sheetInfo[key].errorTitleIndex&#125;`;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (sheetInfo[key].bodyErrorInfo.length) &#123;</span><br><span class="line">                        errorInfo +=  `\n$&#123;sheetInfo[key].name&#125;表内容错误，请检查，单元格如下：\n$&#123;sheetInfo[key].bodyErrorInfo.map((i: any) =&gt; (`$&#123;i.cellIndex&#125;:$&#123;i.errorMessage&#125;\n`)).join(&apos;&apos;)&#125;`;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (sheetInfo[key].extraErrorInfo) &#123;</span><br><span class="line">                        errorInfo +=  `\n$&#123;sheetInfo[key].extraErrorInfo&#125;`;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                if (errorInfo) &#123;</span><br><span class="line">                    setModal(&#123;</span><br><span class="line">                        visible: true,</span><br><span class="line">                        resultContent: errorInfo,</span><br><span class="line">                    &#125;);</span><br><span class="line">                    reject(false);</span><br><span class="line">                &#125;</span><br><span class="line">                resolve(true);</span><br><span class="line">                return;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        onChange(info: any) &#123;</span><br><span class="line">          const &#123; status &#125; = info.file;</span><br><span class="line">          if (status !== &apos;uploading&apos;) &#123;</span><br><span class="line">            // console.log(info.file, info.fileList);</span><br><span class="line">          &#125;</span><br><span class="line">          if (status === &apos;done&apos;) &#123;</span><br><span class="line">            // message.success(`$&#123;info.file.name&#125; file uploaded successfully.`);</span><br><span class="line">          &#125; else if (status === &apos;error&apos;) &#123;</span><br><span class="line">            // message.error(`$&#123;info.file.name&#125; file upload failed.`);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        ...props.dragProps || &#123;&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    const handleCancelModal = () =&gt; &#123;</span><br><span class="line">        setModal(&#123;</span><br><span class="line">            visible: false,</span><br><span class="line">            resultContent: &apos;&apos;,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return (</span><br><span class="line">        &lt;div style=&#123;props.style || &#123;&#125;&#125;&gt;</span><br><span class="line">            &#123; props.children || null &#125;</span><br><span class="line">            &lt;Modal</span><br><span class="line">              style=&#123;&#123; whiteSpace: &apos;pre-line&apos; &#125;&#125;</span><br><span class="line">              visible=&#123;modal.visible&#125; title=&#123;props.resultTitle || &apos;校验结果&apos;&#125;</span><br><span class="line">              footer = &#123; &lt;Button  type = &quot;primary&quot; onClick = &#123; handleCancelModal &#125;&gt;确定&lt;/Button&gt; &#125;</span><br><span class="line">            &gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    modal.resultContent</span><br><span class="line">                &#125;</span><br><span class="line">            &lt;/Modal&gt;</span><br><span class="line">            &lt;Dragger &#123;...dragProps&#125;&gt;</span><br><span class="line">                &lt;p&gt;</span><br><span class="line">                    &#123; props.uploadToolTip || &apos;Support CSV and EXCEL file for analysis&apos; &#125;</span><br><span class="line">                &lt;/p&gt;</span><br><span class="line">            &lt;/Dragger&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Demo;</span><br></pre></td></tr></table></figure>
<h2 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h2><pre><code>a标签的download属性，想必大家都知道它的意义是改变文件下载的名称。但是当跨域下载远程文件的时候，这个属性会存在失效问题。我们今天就来看看，在不用服务器协调的情况下，前端如何自行处理这个问题。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">const handleDownLoad = () =&gt; &#123;</span><br><span class="line">const template = &apos;https://festatic-1254389369.cos.ap-guangzhou.myqcloud.com/science/otms/importTemplatestationCreate.csv&apos;;</span><br><span class="line">const download = &apos;模板.csv&apos;;</span><br><span class="line"></span><br><span class="line">const x = new XMLHttpRequest();</span><br><span class="line">x.open(&apos;GET&apos;, template, true);</span><br><span class="line">x.responseType = &apos;blob&apos;;</span><br><span class="line">x.onload = () =&gt; &#123;</span><br><span class="line">  const url = window.URL.createObjectURL(x.response);</span><br><span class="line">  const a = document.createElement(&apos;a&apos;);</span><br><span class="line">  a.href = url;</span><br><span class="line">  a.download = download;</span><br><span class="line">  a.click();</span><br><span class="line">&#125;;</span><br><span class="line">x.send();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const handleDownLoad = async () =&gt; &#123;</span><br><span class="line">const template = &apos;https://festatic-1254389369.cos.ap-guangzhou.myqcloud.com/science/otms/importTemplatestationCreate.csv&apos;;</span><br><span class="line">const download = &apos;模板.csv&apos;;</span><br><span class="line"></span><br><span class="line">const response = await fetch(template);</span><br><span class="line">const blob = await response.blob();</span><br><span class="line">const objectUrl = window.URL.createObjectURL(blob);</span><br><span class="line">const a = document.createElement(&apos;a&apos;);</span><br><span class="line">a.href = objectUrl;</span><br><span class="line">a.download = download;</span><br><span class="line">document.body.appendChild(a);</span><br><span class="line">a.click();</span><br><span class="line">setTimeout(() =&gt; document.body.removeChild(a), 1000);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

&lt;div class=&apos;post-warning&apos;&gt;注意：代码中对创建的&lt;a\&gt; 进行的 appendChild 和 remove 操作主要是为了兼容 FireFox 浏览器，在 FireFox 浏览器下调用该方法如果不将创建的&lt;a\&gt;标签添加到 body 里，点击链接不会有任何反应，无法触发下载，而在 Chrome 浏览器中则不受此影响。&lt;/div&gt;
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/04/06/qiankun/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lemon">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/background2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/06/qiankun/" itemprop="url">qiankun</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-06T17:52:30+08:00">
                2021-04-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/专题/" itemprop="url" rel="index">
                    <span itemprop="name">专题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>  微前端是现在前端很火的一个概念，主要是为了解决企业级中后台系统过大所带来的性能问题的解决方案。目前，稍成熟的方案主要有single-spa和qiankun，qiankun是基于single-spa，我们选择qiankun + react，Let’s  start ~</p>
  <canvas id="qiankun" width="500" height="500"></canvas>

<h1 id="一、快速上手"><a href="#一、快速上手" class="headerlink" title="一、快速上手"></a>一、快速上手</h1><p>  主应用</p>
<ol>
<li><p>安装 qiankun<br>$ yarn add qiankun # 或者 npm i qiankun -S</p>
</li>
<li><p>在主应用中注册微应用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import &#123; registerMicroApps, start &#125; from &apos;qiankun&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// qiankun 注册微应用</span><br><span class="line">registerMicroApps([</span><br><span class="line">  &#123;</span><br><span class="line">    name: &apos;service_activity_app&apos;, // app name registered</span><br><span class="line">    entry: process.env.NODE_ENV === &apos;production&apos; ? &apos;&apos; : &apos;http://localhost:8080&apos;,</span><br><span class="line">    container: &apos;#subContainer&apos;,</span><br><span class="line">    activeRule: (location) =&gt; location.href.includes(&apos;/microApp/serviceActivityApp&apos;),</span><br><span class="line">  &#125;,</span><br><span class="line">]);</span><br><span class="line">start();</span><br><span class="line"></span><br><span class="line">&lt;div id=&apos;subContainer&apos;&gt;微前端&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>name：必选，微应用的名称，与微应用package.json中name属性值一致，微应用之间必须确保唯一；<br>entry：必选，微应用的入口访问地址，需要区分本地调试环境还是线上环境；<br>container：必选，微应用的容器节点的选择器或者 Element 实例，一般是主应用提供的用于承载微应用的容器节点。</p>
<pre><code>如&apos;#subContainer&apos; 或 document.querySelector(&apos;#subContainer&apos;)。
</code></pre><p>activeRule：string | (location: Location) =&gt; boolean | Array<string | (location: location)> boolean - 必选，微应用的激活规则。<br>支持直接配置字符串或字符串数组，如 _activeRule: ‘/app1’ _或 activeRule: activeRule: [‘/app1’, ‘/app2’]当配置为字符串时会直接跟 url 中的路径部分做前缀匹配，匹配成功表明当前应用会被激活<br>支持配置一个 active function 函数或一组 active function。函数会传入当前 location 作为参数，函数返回 true 时表明当前微应用会被激活。如 location =&gt; location.pathname.startsWith(‘/app1’)</string></p>
<p>很重要的一点是，主应用记得配置微应用的代理。</p>
</li>
</ol>
<ol start="3">
<li><p>子应用中的配置</p>
<ol>
<li><p>导出相应的生命周期钩子<br>微应用需要在自己的入口 js (通常就是你配置的 webpack 的 entry js) 导出 bootstrap、mount、unmount 三个生命周期钩子，以供主应用在适当的时机调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">* bootstrap 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。</span><br><span class="line">* 通常我们可以在这里做一些全局变量的初始化，比如不会在 unmount 阶段被销毁的应用级别的缓存等。</span><br><span class="line">export async function bootstrap() &#123;</span><br><span class="line">  console.log(&apos;react app bootstraped&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">* 应用每次进入都会调用 mount 方法，通常我们在这里触发应用的渲染方法</span><br><span class="line">export async function mount(props) &#123;</span><br><span class="line">  ReactDOM.render(&lt;App /&gt;, props.container ? props.container.querySelector(&apos;#root&apos;) : document.getElementById(&apos;root&apos;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">* 应用每次 切出/卸载 会调用的方法，通常在这里我们会卸载微应用的应用实例</span><br><span class="line">export async function unmount(props) &#123;</span><br><span class="line">  ReactDOM.unmountComponentAtNode(</span><br><span class="line">    props.container ? props.container.querySelector(&apos;#root&apos;) : document.getElementById(&apos;root&apos;),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">* 可选生命周期钩子，仅使用 loadMicroApp 方式加载微应用时生效</span><br><span class="line">export async function update(props) &#123;</span><br><span class="line">  console.log(&apos;update props&apos;, props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>qiankun 基于 single-spa，所以你可以在<a href="https://single-spa.js.org/docs/building-applications/#registered-application-lifecycle" target="_blank" rel="noopener">这里</a>找到更多关于微应用生命周期相关的文档说明。</p>
</li>
</ol>
</li>
</ol>
<pre><code>2. 配置微应用的打包工具
  除了代码中暴露出相应的生命周期钩子之外，为了让主应用能正确识别微应用暴露出来的一些信息，微应用的打包工具需要增加如下配置：

  webpack:
  const packageName = require(&apos;./package.json&apos;).name;

  module.exports = {
    output: {
      ...
      publicPath: &apos;http://localhost:8080/&apos;
      library: `${packageName}-[name]`,
      libraryTarget: &apos;umd&apos;,
      jsonpFunction: `webpackJsonp_${packageName}`,
    },
  };

3. package.json
  name 保持一致且唯一
</code></pre><h1 id="二、父子应用通信"><a href="#二、父子应用通信" class="headerlink" title="二、父子应用通信"></a>二、父子应用通信</h1><h2 id="qiankun-Actions"><a href="#qiankun-Actions" class="headerlink" title="qiankun - Actions"></a>qiankun - Actions</h2><pre><code>qiankun官方提供了父子应用通信的方法，使用简单，适用于业务划分清晰，父子应用通信少的场景。
initGlobalState方法：初始化globalState的值。
setGlobalState方法：设置globalState的值，内部进行浅检查，如果检查到globalState发生改变时，通知所有的观察者函数。
onGlobalStateChange事件：观察者函数。在globalState发生改变时触发该函数。
offGlobalStateChange：取消观察者函数。
</code></pre>  <canvas id="pic" width="500" height="400"></canvas>

<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">主应用：</span><br><span class="line">const actions: MicroAppStateActions = initGlobalState(&#123;&#125;);</span><br><span class="line">actions.setGlobalState(&#123;</span><br><span class="line">  publicInfo: &#123;</span><br><span class="line">    name: &apos;origin&apos;,</span><br><span class="line">    authCode: [999],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">actions.onGlobalStateChange((state: any) =&gt; &#123;</span><br><span class="line">  console.log(&apos;主应用&apos;, state);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">子应用：</span><br><span class="line">export async function mount(props) &#123;</span><br><span class="line">  props.setGlobalState(&#123; publicInfo: &apos;123&apos; &#125;);</span><br><span class="line">  props.onGlobalStateChange((state, pre) =&gt; &#123;</span><br><span class="line">    console.log(&apos;子应用-onGlobalStateChange&apos;, state, pre);</span><br><span class="line">  &#125;);</span><br><span class="line">  ······</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="redux-Shared"><a href="#redux-Shared" class="headerlink" title="redux - Shared"></a>redux - Shared</h2><h1 id="三、公共资源引入"><a href="#三、公共资源引入" class="headerlink" title="三、公共资源引入"></a>三、公共资源引入</h1><p>  微前端可以让子应用拥有自己的独立的依赖，互不打扰。乾坤官方也有提到：</p>
<p>  <div class="post-warning">不要共享运行时，即便所有团队都是用同一框架</div><br>  虽然共享依赖并不建议，但如果你真的有这个需求，你可以在微应用中将公共依赖配置成 external，然后在主应用中导入这些公共依赖。</p>
<h2 id="公共依赖"><a href="#公共依赖" class="headerlink" title="公共依赖"></a>公共依赖</h2><p>  如果不同的项目有用到相同的包的相同版本，重复加载就会存在浪费内存和降低性能的问题，所以我们考虑复用公共依赖。</p>
<p>  我们对于公共依赖的复用，有两点期望：一是集合时，主应用可以加载，子应用不再重复加载，二是子应用独立运行时可以正常加载运行。</p>
<h3 id="1）集合时，主应用加载公共依赖，子用主"><a href="#1）集合时，主应用加载公共依赖，子用主" class="headerlink" title="1）集合时，主应用加载公共依赖，子用主"></a>1）集合时，主应用加载公共依赖，子用主</h3><p>  子项目原本需要加载的公共部分，全部由主项目调度，配合webpack的externals功能通过外链的方式按需加载，一旦有一个子项目加载过，下一个子项目就不需要再加载，这样一来每个子项目的dist文件里就只有子项目自己的业务代码；</p>
<p>  主子项目的index.html 中公共依赖的 script 和 link 标签加上 ignore 属性，有了这个属性，qiankun 便不会再去加载这个 js/css。子项目独立运行时，加载自己的公共依赖的 script 和 link资源即可。</p>
  <canvas id="dependencies" width="600" height="300"></canvas>

<p>  为了实现主应用加载公共资源，我们可以维护一个子应用所需公共依赖的集合，在全局微应用的beforeUpload中，通过插入script标签的方式，加载对于子应用所需的js资源。具体实现如下：</p>
<p>  主应用：primary-app<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  1. 定义子应用的公共依赖</span></span><br><span class="line"><span class="keyword">const</span> dependencies: any = &#123;</span><br><span class="line">  summer: [<span class="string">'react'</span>, <span class="string">'react-dom'</span>], <span class="comment">// 子应用summer，这里以react和react-dom两个基础依赖为例</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> getDependencies = <span class="function">(<span class="params">appName: string</span>) =&gt;</span> dependencies[appName];</span><br><span class="line"><span class="comment">// 构建script标签</span></span><br><span class="line"><span class="keyword">const</span> loadScript = <span class="function">(<span class="params">url: string</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">  script.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">  script.src = url;</span><br><span class="line">  script.setAttribute(<span class="string">'ignore'</span>, <span class="string">'true'</span>); <span class="comment">// 避免重复加载</span></span><br><span class="line">  script.onerror = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`加载失败<span class="subst">$&#123;url&#125;</span>，请刷新重试`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2：注册子应用</span></span><br><span class="line">registerMicroApps([</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'summer'</span>, <span class="comment">// app name registered</span></span><br><span class="line">    entry: process.env.NODE_ENV === <span class="string">'production'</span> ? <span class="string">''</span> : <span class="string">'http://localhost:8083/'</span>,</span><br><span class="line">    container: <span class="string">'#router-view'</span>,</span><br><span class="line">    activeRule: [<span class="string">'/systemManage'</span>, <span class="string">'/orderManage'</span>],</span><br><span class="line">  &#125;], &#123;</span><br><span class="line">  beforeLoad: [</span><br><span class="line">    app =&gt; <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolved: any</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'[LifeCycle] before load %c%s'</span>, <span class="string">'color: green;'</span>, app.name);</span><br><span class="line">      getDependencies(app.name).forEach(<span class="function">(<span class="params">dependency: string</span>) =&gt;</span> &#123;</span><br><span class="line">        loadScript(<span class="string">`<span class="subst">$&#123;<span class="built_in">window</span>.location.origin&#125;</span>/<span class="subst">$&#123;dependency&#125;</span>.js`</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">      resolved(<span class="literal">true</span>);</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br><span class="line">);</span><br><span class="line">start();</span><br></pre></td></tr></table></figure></p>
<p>  这里还要注意通过 webpack 来生产好相应的依赖资源，我们使用的是 copy-webpack-plugin 插件将 node_modules 下的 release 资源转换成包成可以通过独立 URL 访问的资源。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackExternalsPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-externals-plugin'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackExternalsPlugin(&#123;</span><br><span class="line">      externals: [&#123;</span><br><span class="line">        <span class="built_in">module</span>: <span class="string">'react'</span>,</span><br><span class="line">        entry: &#123;</span><br><span class="line">          path: <span class="string">'umd/react.development.js'</span>,</span><br><span class="line">          attributes: &#123; <span class="attr">ignore</span>: <span class="string">'true'</span> &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        global: <span class="string">'React'</span>,</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        <span class="built_in">module</span>: <span class="string">'react-dom'</span>,</span><br><span class="line">        entry: &#123;</span><br><span class="line">          path: <span class="string">'umd/react-dom.development.js'</span>,</span><br><span class="line">          attributes: &#123; <span class="attr">ignore</span>: <span class="string">'true'</span> &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        global: <span class="string">'ReactDOM'</span>,</span><br><span class="line">      &#125;],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2）子应用在独立运行时又可加载正常运行"><a href="#2）子应用在独立运行时又可加载正常运行" class="headerlink" title="2）子应用在独立运行时又可加载正常运行"></a>2）子应用在独立运行时又可加载正常运行</h3><p>  子应用将主应用已经定义的公共依赖通过 html-webpack-externals-plugin 这个插件使用 external 的方式独立出来，不打包到 Webpack bundle 中，同时通过插件的配置，给 &lt; script &gt; 标签加上 ignore 属性，那么在 qiankun 加载这个子应用时使用，qiankun 依赖的 import-html-entry 插件分析到 &lt; script &gt; 标签时，会忽略加载有 ignore 属性的 &lt; script &gt; 标签，而独立访问时子应用本身可以正常加载这个 Javascript 资源。<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackExternalsPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-externals-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">   plugins: [</span><br><span class="line">     ...</span><br><span class="line">     <span class="keyword">new</span> HtmlWebpackExternalsPlugin(&#123;</span><br><span class="line">       externals: [&#123;</span><br><span class="line">         <span class="built_in">module</span>: <span class="string">'react'</span>,</span><br><span class="line">         entry: &#123;</span><br><span class="line">           path: <span class="string">'umd/react.development.js'</span>,</span><br><span class="line">           attributes: &#123; <span class="attr">ignore</span>: <span class="string">'true'</span> &#125;,</span><br><span class="line">         &#125;,</span><br><span class="line">         global: <span class="string">'React'</span>,</span><br><span class="line">       &#125;, &#123;</span><br><span class="line">         <span class="built_in">module</span>: <span class="string">'react-dom'</span>,</span><br><span class="line">         entry: &#123;</span><br><span class="line">           path: <span class="string">'umd/react-dom.development.js'</span>,</span><br><span class="line">           attributes: &#123; <span class="attr">ignore</span>: <span class="string">'true'</span> &#125;,</span><br><span class="line">         &#125;,</span><br><span class="line">         global: <span class="string">'ReactDOM'</span>,</span><br><span class="line">       &#125;],</span><br><span class="line">     &#125;),</span><br><span class="line">   ],</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></p>
<p>  <strong>踩坑记录</strong>：<br>  1）安装copy-webpack-plugin时，可能会遇到版本兼容问题，这时候安装合适的版本可以解决。<br>  2）安装html-webpack-externals-plugin时，遇到了：Super expression must either be null or a function, not undefined报错。<br>     解决：试了切换版本后还是不行，有说是React.Component的大小写写错了，但是我并没有用到React.Component。最后发现是HtmlWebpackExternalsPlugin.externals配置项的module和global配置出现问题。大家遇到了一些奇怪的问题也可以检查此配置项。</p>
<p>  copy-webpack-plugin 在构建过程中复制源树中已经存在的文件。<br>  HtmlWebpackExternalsPlugin : 基础库不打包，直接URL（CDN）引入。</p>
<p>  这里需要注意的是，<a href="https://github.com/mmiller42/html-webpack-externals-plugin" target="_blank" rel="noopener">HtmlWebpackExternalsPlugin</a>插件目前已经被弃用，不再维护：<br>  <div class="post-warning">Sorry, this module is no longer maintained, and its functionality is baked into wonderful plugins by jharris4, html-webpack-tags-plugin and html-webpack-deploy-plugin.</div><br>  但是很遗憾 <a href="https://github.com/jharris4/html-webpack-deploy-plugin" target="_blank" rel="noopener">html-webpack-tags-plugin</a>和<a href="https://github.com/jharris4/html-webpack-deploy-plugin" target="_blank" rel="noopener">html-webpack-deploy-plugin</a>的3.x版本都要求使用webpack5.0或更高版本。我们的基座应用primary-app的webpack版本是4.x版本，且被二次封装过，暂无法体验这两个插件。</p>
<p>  不过这个插件不再维护，且我们用目前的版本遇到无法解决的问题的话，我们拆开来配也行：<br>  这个插件非常简单，只是封装了另外两个 Webpack 插件来完成繁重的工作。它：<br>    在运行时修改您的 Webpack 配置以将您的供应商模块添加到externals属性中。<br>    运行copy-webpack-plugin将您的供应商模块资产复制到输出路径中。<br>    运行html-webpack-include-assets-plugin将您的供应商模块包添加到 HTML 输出。</p>
<p>  ModuleFederationPlugin</p>
<h2 id="公共组件"><a href="#公共组件" class="headerlink" title="公共组件"></a>公共组件</h2><pre><code>1) npm包的方式
  NPM 或者 Git Tag、Git Submodule 来管理

2）父子项目间的组件共享
</code></pre><h1 id="四、常见问题"><a href="#四、常见问题" class="headerlink" title="四、常见问题"></a>四、常见问题</h1><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>  问题： Access to fetch at ‘<a href="http://localhost:8083/&#39;" target="_blank" rel="noopener">http://localhost:8083/&#39;</a> from origin ‘<a href="http://localhost:3032&#39;" target="_blank" rel="noopener">http://localhost:3032&#39;</a> has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource. If an opaque response serves your needs, set the request’s mode to ‘no-cors’ to fetch the resource with CORS disabled.</p>
<p>  解决：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.all(&apos;*&apos;, (_req, res, next) =&gt; &#123;</span><br><span class="line">  res.header(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="主应用和子应用冲突"><a href="#主应用和子应用冲突" class="headerlink" title="主应用和子应用冲突"></a>主应用和子应用冲突</h2><p>  问题： cjs 和 esm 等兼容性问题<br>        You are loading the CommonJS build of React Router on a page that is already running the ES modules build, so things won’t work right. </p>
<p>  解决：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  mainFields: [&apos;browser&apos;, &apos;jsnext:main&apos;, &apos;main&apos;],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<h2 id="加载子应用失败"><a href="#加载子应用失败" class="headerlink" title="加载子应用失败"></a>加载子应用失败</h2><p>  问题：Application died in status LOADING_SOURCE_CODE: You need to export the functional lifecycles in xxx entry<br>  解决： <a href="https://qiankun.umijs.org/zh/faq" target="_blank" rel="noopener">常见问题</a></p>
<h2 id="子应用渲染问题"><a href="#子应用渲染问题" class="headerlink" title="子应用渲染问题"></a>子应用渲染问题</h2><p>  问题：子应用首次渲染，切换回主应用或其他子应用后再切回来，就只加载到子应用根节点，根节点里面的内容就不插入到根节点中了？？？<br>  解决：在生命周期的mount函数中挂在时，也要判断是否有container，有的话挂在在container节点上。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const &#123; container &#125; = props;</span><br><span class="line">if (container) &#123;</span><br><span class="line">  Render(container.querySelector(&apos;#root&apos;));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  Render(document.getElementById(&apos;root&apos;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="父子应用切换"><a href="#父子应用切换" class="headerlink" title="父子应用切换"></a>父子应用切换</h2><p>  问题：如果一个应用在父应用中有两个路由页面。从子应用的页面1，通过父应用菜单切换到父应用，再通过父应用菜单切换到子应用的页面2，此时页面加载的是子应用的页面1。<br>  解决：在菜单Menu的click方法中，加上key<br>       <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useHistory &#125; from &apos;react-router-dom&apos;;</span><br><span class="line"></span><br><span class="line">const CustomMenu = memo((props: InjectedIntlProps) =&gt; &#123;</span><br><span class="line">  const history = useHistory();</span><br><span class="line"></span><br><span class="line">  const onClick = (menuItem: any) =&gt; &#123;</span><br><span class="line">    ···</span><br><span class="line">    history.push(key, &#123;&#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return (&lt;Menu onClick=&#123;onClick&#125;&gt; ··· &lt;/Menu&gt;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default CustomMenu;</span><br></pre></td></tr></table></figure></p>
<h2 id="output-jsonpFunctionn"><a href="#output-jsonpFunctionn" class="headerlink" title="output.jsonpFunctionn"></a>output.jsonpFunctionn</h2><p>  webpack5删除了该属性，替换为output.chunkLoadingGlobal。</p>
<p>  资料：<br>  <a href="https://www.zhihu.com/column/c_1250900868893462528" target="_blank" rel="noopener">微前端-知乎</a></p>
  <script>
    const oCanvas = document.getElementById("pic");
    const oPen = oCanvas.getContext('2d');
    oPen.textAlign = "left";
    oPen.textBaseLine = "hanging";
    oPen.fillStyle = "deeppink";
    oPen.font = '18px sans-serif';
    oPen.fillText("主应用", 30,50);
    oPen.fillText("···", 160,50);
    oPen.fillText("子应用1", 240,50);
    oPen.fillText("子应用2", 390,50);
    oPen.fillStyle = "green";
    oPen.fillText("父子应用更新globalState", 160,200);
    oPen.fillStyle = "blue";
    oPen.fillText("父应用初始化globalState", 160,320);
    oPen.fillStyle = "deeppink";
    oPen.font = '12px sans-serif';
    oPen.fillText("onGlobalStateChange", 0, 65);
    oPen.fillText("onGlobalStateChange", 210,65);
    oPen.fillText("onGlobalStateChange", 360,65);
    oPen.fillStyle = "green";
    oPen.fillText("setGlobalState", 220,215);
    oPen.fillText("↑", 260,160);
    oPen.fillText("更新", 280,160);
    oPen.fillStyle = "blue";
    oPen.fillText("initGlobalState", 220,335);
    oPen.fillText("↑", 260,295);
    oPen.fillText("初始化", 280,295);
    oPen.closePath();


    // oPen.fillText("Hello World!" , 70 ,50);
    // oPen.strokeText("Hello World!" , 320 ,50);

    const oQiankun = document.getElementById("qiankun");
    const oContext = oQiankun.getContext('2d');
    oContext.textAlign = "left";
    oContext.textBaseLine = "hanging";
    oContext.fillStyle = "orange";
    oContext.font = '30px sans-serif';
    oContext.fillText("微前端", 200, 230);
    oContext.fillStyle = "black";
    oContext.font = '20px sans-serif';
    oContext.fillText("js沙箱", 218, 40);
    oContext.fillText("样式隔离", 360, 100);
    oContext.fillText("HTML Entry", 380, 200);
    oContext.fillText("Config Entry", 350, 300);
    oContext.fillText("按需加载", 340, 390);
    oContext.fillText("公共依赖加载", 190, 450);
    oContext.fillText("预加载", 100, 390);
    oContext.fillText("父子应用通讯", 30, 300);
    oContext.fillText("子应用嵌套", 10, 200);
    oContext.fillText("子应用并行", 40, 100);


    const oDependencies = document.getElementById("dependencies");
    const oPen1 = oDependencies.getContext('2d');
    oPen1.textAlign = "left";
    oPen1.textBaseLine = "hanging";
    oContext.fillStyle = "orange";
    oPen1.font = '16px sans-serif';
    oPen1.fillText("主项目", 80, 20);
    oPen1.fillText("node_modules", 50, 45);
    oPen1.fillText("↓", 100, 100);
    oPen1.fillText("js", 130, 100);
    oPen1.fillText("主项目", 200, 20);
    oPen1.fillText("<script src='xxx.js' ignore>", 10, 150);
    oPen1.fillText("子项目", 380, 20);
    oPen1.fillText("node_modules", 350, 45);
    oPen1.fillText("↓", 400, 100);
    oPen1.fillText("js", 430, 100);
    oPen1.fillText("<script src='xxx.js' ignore>", 310, 150);
    oPen1.fillText("↘", 120, 200);
    oPen1.fillText("↙", 380, 200);
    oPen1.fillText("主 子共同运行时，取主。子独立运行时，取子。", 100, 250);
  </script>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/30/summer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lemon">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/background2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/30/summer/" itemprop="url">summer</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-30T17:05:30+08:00">
                2021-03-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/框架/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、-搭建过程"><a href="#一、-搭建过程" class="headerlink" title="一、 搭建过程"></a>一、 搭建过程</h1><h2 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h2><ul>
<li><p>package.json<br>npm init初始化或者手动创建一个package.json。<br>因为暂时github总是无法访问，所以暂时不git init或者创建远程git仓库了。也不配置.gitignore文件了</p>
</li>
<li><p>README.md<br>touch 初始化或者手动创建一个README.md。</p>
</li>
<li><p>建立文件目录</p>
</li>
<li><p>配置webpack<br>webpack-cli init初始化或者手动创建webpack配置文件。<br>webpack –config ‘webpack配置文件’。<br><br></p>
</li>
</ul>
<h2 id="2-启动-server"><a href="#2-启动-server" class="headerlink" title="2. 启动 server"></a>2. 启动 server</h2><p>  可以直接使用内置的webpack-dev-server命令，也可以通过express搭建服务器。</p>
<h3 id="express"><a href="#express" class="headerlink" title="express"></a>express</h3><pre><code>npm install express --save-dev

start.js
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&quot;express&quot;);</span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">app.get(&apos;/&apos;, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(&apos;nodeJS服务器搭建成功！&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(8083, () =&gt; &#123;</span><br><span class="line">  console.log(&apos;Server is running at http://localhost:8083&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

执行node start.js，即可启动服务器。页面显示：&apos;nodeJS服务器搭建成功！&apos;。
</code></pre><h3 id="express-html模板-热重载热更新"><a href="#express-html模板-热重载热更新" class="headerlink" title="express+html模板+热重载热更新"></a>express+html模板+热重载热更新</h3><pre><code>npm install --save webpack
npm install --save-dev webpack-dev-middleware webpack-hot-middleware
npm install --save html-webpack-plugin

- webpack-dev-middleware 插件，该插件对更改的文件进行监控，编译。
- 一般和 webpack-hot-middleware[https://github.com/webpack-contrib/webpack-hot-middleware] 配合使用，实现热加载功能
- HtmlWebpackPlugin
HtmlWebpackPlugin 简化了 HTML 文件的创建，以便为你的 webpack 包提供服务。这对于那些文件名中包含哈希值，并且哈希值会随着每次编译而改变的 webpack 包特别有用。你可以让该插件为你生成一个 HTML 文件，使用 lodash 模板提供模板，或者使用你自己的 loader。


webpack配置：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const webpack = require(&apos;webpack&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: [&apos;webpack-hot-middleware/client?path=/__webpack_hmr&amp;timeout=20000&apos;, path.resolve(__dirname, &apos;../src/index.js&apos;)],</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;bundle.js&apos;,</span><br><span class="line">    path: path.resolve(__dirname, &apos;../dist&apos;),</span><br><span class="line">    publicPath: &apos;/&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mode: &apos;development&apos;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      inject: true,</span><br><span class="line">      filename: &apos;index.html&apos;,</span><br><span class="line">      template: path.resolve(process.cwd(), &apos;public&apos;, &apos;index.html&apos;),</span><br><span class="line">    &#125;),</span><br><span class="line">    new webpack.HotModuleReplacementPlugin(),</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

start.js 配置
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&quot;express&quot;);</span><br><span class="line">const path = require(&quot;path&quot;);</span><br><span class="line">const webpack = require(&quot;webpack&quot;);</span><br><span class="line">const webpackConfig = require(&quot;../config/webpack.base.config&quot;);</span><br><span class="line">const webpackHotMiddleware = require(&quot;webpack-hot-middleware&quot;);</span><br><span class="line">const webpackDevMiddleware = require(&quot;webpack-dev-middleware&quot;);</span><br><span class="line"></span><br><span class="line">const compiler = webpack(webpackConfig);</span><br><span class="line">const middleware = webpackDevMiddleware(compiler, &#123;</span><br><span class="line">  //绑定中间件的公共路径,与webpack配置的路径相同</span><br><span class="line">  publicPath: webpackConfig.output.publicPath,</span><br><span class="line">&#125;);</span><br><span class="line">const app = express();</span><br><span class="line">const fs = middleware.context.outputFileSystem;</span><br><span class="line"></span><br><span class="line">app.use(middleware);</span><br><span class="line">app.use(webpackHotMiddleware(compiler));</span><br><span class="line">app.get(&apos;*&apos;, (req, res) =&gt; &#123;</span><br><span class="line">  fs.readFile(path.join(compiler.outputPath, &apos;index.html&apos;), (err, file) =&gt; &#123;</span><br><span class="line">    if (err) &#123;</span><br><span class="line">      res.sendStatus(404);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      res.send(file.toString());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(8083, () =&gt; &#123;</span><br><span class="line">  console.log(&apos;Server is running at http://localhost:8083&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

index.js
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import a from &apos;./containers/Demo/index.js&apos;;</span><br><span class="line"></span><br><span class="line">const handleTest = () =&gt; &#123;</span><br><span class="line">  console.log(&apos;a:&apos;, a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 开发模式下热加载</span><br><span class="line">if (module.hot) &#123;</span><br><span class="line">  module.hot.accept([&apos;./containers/Demo/index.js&apos;], function () &#123; </span><br><span class="line">    handleTest();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleTest();</span><br></pre></td></tr></table></figure>

node start.js或在package.json中配置script脚步命令（&quot;start&quot;: &quot;node scripts/start.js &quot;）。
</code></pre><p>  <br></p>
<h2 id="3-react-ts-antd"><a href="#3-react-ts-antd" class="headerlink" title="3.react + ts + antd"></a>3.react + ts + antd</h2><p>  npm install  -S  babel-loader thread-loader cache-loader<br>                  ts-loader css-loader style-loader url-loader<br>                  less less-loader typescript<br>                  @babel/preset-react  @babel/core</p>
<h3 id="react"><a href="#react" class="headerlink" title="react"></a>react</h3><h4 id="配置webpack"><a href="#配置webpack" class="headerlink" title="配置webpack"></a>配置webpack</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: /\.js$/,</span><br><span class="line">      exclude: /node_moduåles/,</span><br><span class="line">      use: [</span><br><span class="line">        &apos;cache-loader&apos;,</span><br><span class="line">        &apos;thread-loader&apos;,</span><br><span class="line">        &#123;</span><br><span class="line">          loader: &apos;babel-loader&apos;,</span><br><span class="line">          options: &#123;</span><br><span class="line">            cacheDirectory: true</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: /\.(ts|tsx)$/,</span><br><span class="line">      exclude: /node_modules/,</span><br><span class="line">      use: [</span><br><span class="line">        &apos;cache-loader&apos;,</span><br><span class="line">        &apos;thread-loader&apos;,</span><br><span class="line">        &#123;</span><br><span class="line">          loader: &apos;ts-loader&apos;,</span><br><span class="line">          options: &#123; transpileOnly: true, happyPackMode: true &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: /\.less$/,</span><br><span class="line">      exclude: /node_modules/,</span><br><span class="line">      use: [</span><br><span class="line">        &apos;style-loader&apos;,</span><br><span class="line">        &apos;css-loader&apos;,</span><br><span class="line">        &#123;</span><br><span class="line">          loader: &apos;less-loader&apos;,</span><br><span class="line">          options: &#123;</span><br><span class="line">            lessOptions: &#123;</span><br><span class="line">              javascriptEnabled: true,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: /\.css$/,</span><br><span class="line">      exclude: /node_modules/,</span><br><span class="line">      use: [</span><br><span class="line">        &apos;style-loader&apos;,</span><br><span class="line">        &apos;css-loader&apos;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: /\.(jpg|jpeg|png|gif|webp)$/,</span><br><span class="line">      exclude: /node_modules/,</span><br><span class="line">      use: [</span><br><span class="line">        &#123;</span><br><span class="line">          loader: &apos;url-loader&apos;,</span><br><span class="line">          options: &#123;</span><br><span class="line">            // Inline files smaller than 10 kB</span><br><span class="line">            limit: 10 * 1024,</span><br><span class="line">            name: &apos;static/assets/[name].[ext]&apos;,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="引入react"><a href="#引入react" class="headerlink" title="引入react"></a>引入react</h4><pre><code>index.js
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &apos;react&apos;;</span><br><span class="line">import * as ReactDOM from &apos;react-dom&apos;;</span><br><span class="line"></span><br><span class="line">import Main from &apos;./containers/Main&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const Render = ()  =&gt; &#123;</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    &lt;Main /&gt;,</span><br><span class="line">    document.getElementById(&apos;root&apos;),</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 开发模式下热加载</span><br><span class="line">if (module.hot) &#123;</span><br><span class="line">  module.hot.accept([&apos;./containers/Main&apos;], function () &#123; </span><br><span class="line">    Render();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Render();</span><br></pre></td></tr></table></figure>

src/containers/Main/index.js
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">const Main = () =&gt; &#123;</span><br><span class="line">  return (&lt;div&gt;Main&lt;/div&gt;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Main;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="typescript"><a href="#typescript" class="headerlink" title="typescript"></a>typescript</h3><p>  以上，我们已经引入了react，可以使用jsx语法。现在我们来尝试引入ts。</p>
<h4 id="1-webapck配置"><a href="#1-webapck配置" class="headerlink" title="1. webapck配置"></a>1. webapck配置</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: /\.(ts|tsx)$/,</span><br><span class="line">    exclude: /node_modules/,</span><br><span class="line">    use: [</span><br><span class="line">      &apos;cache-loader&apos;,</span><br><span class="line">      &apos;thread-loader&apos;,</span><br><span class="line">      &#123;</span><br><span class="line">        loader: &quot;ts-loader&quot;,</span><br><span class="line">        options: &#123; transpileOnly: true, happyPackMode: true &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

问题1：Could not find a declaration file for module &apos;react&apos;。
      Could not find a declaration file for module &apos;react-dom&apos;.
解决：npm install @types/react @types/react-dom --save-dev

问题2：Field &apos;browser&apos; doesn&apos;t contain a valid alias configuration。
webapck配置:尝试按顺序解析这些后缀名。如果有多个文件有相同的名字，但后缀名不同，webpack 会解析列在数组首位的后缀的文件 并跳过其余的后缀。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  extensions: [&quot;.tsx&quot;, &quot;.js&quot;, &quot;.jsx&quot;, &quot;.react.js&quot;, &quot;.ts&quot;, &quot;.json&quot;],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="2-tsconfig-json"><a href="#2-tsconfig-json" class="headerlink" title="2. tsconfig.json"></a>2. tsconfig.json</h4><pre><code>首先我们得装一个typescript，这就跟我们在用babel前需要先装一个babel-core是一个道理。
npx tsc --init生成tsconfig.json或手动创建。

报错：Cannot use JSX unless the &apos;--jsx&apos; flag is prodided.提示不能使用jsx的语法
解决：去tsconfig配置一下即可。
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;:&#123;</span><br><span class="line">    &quot;jsx&quot;: &quot;react&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

jsx这个配置项有三个值可选择，分别是&quot;preserve&quot;,&quot;react-native&quot;和&quot;react&quot;。在preserve和react-native模式下生成代码中会保留JSX以供后续的转换操作使用（比如：Babel）。另外，preserve输出文件会带有.jsx扩展名，而react-native是.js拓展名。react模式会生成React.createElement，在使用前不需要再进行转换操作了，输出文件的扩展名为.js。
</code></pre><table>
<thead>
<tr>
<th>模式</th>
<th>输入</th>
<th>输出</th>
<th>输出文件扩展名</th>
</tr>
</thead>
<tbody>
<tr>
<td>preserve</td>
<td>&lt; div /&gt;</td>
<td>&lt; div /&gt;</td>
<td>.jsx</td>
</tr>
<tr>
<td>react</td>
<td>&lt; div /&gt;</td>
<td>React.createElement(“div”)</td>
<td>.js</td>
</tr>
<tr>
<td>react-native</td>
<td>&lt; div /&gt;</td>
<td>&lt; div /&gt;</td>
<td>.js</td>
</tr>
</tbody>
</table>
<h3 id="antd-style-componets-样式管理"><a href="#antd-style-componets-样式管理" class="headerlink" title="antd + style-componets 样式管理"></a>antd + style-componets 样式管理</h3><h4 id="antd"><a href="#antd" class="headerlink" title="antd"></a>antd</h4><p>   npm install antd –save</p>
<p>   之后要引入antd的样式<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &apos;antd/dist/antd.css&apos;; // or &apos;antd/dist/antd.less&apos;</span><br><span class="line"></span><br><span class="line">此时遇到报错：</span><br><span class="line">引入的是css时: ERROR in ./node_modules/antd/dist/antd.css 13:6</span><br><span class="line">              Module parse failed: Unexpected token (13:6)</span><br><span class="line">引入的是less时: ERROR in ./node_modules/antd/dist/antd.less 1:0</span><br><span class="line">              Module parse failed: Unexpected character &apos;@&apos; (1:0)</span><br><span class="line"></span><br><span class="line">解决办法：在webpack中的css或less配置一个 include: /node_modules/即可。</span><br></pre></td></tr></table></figure></p>
<h4 id="style-componets"><a href="#style-componets" class="headerlink" title="style-componets"></a>style-componets</h4><p>   npm install -S styled-components</p>
<p><br></p>
<h2 id="4-状态管理"><a href="#4-状态管理" class="headerlink" title="4. 状态管理"></a>4. 状态管理</h2><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p>  redux-toolkit  + redux-saga<br>  Redux &amp; Mobx =&gt; Redux; 但是由于使用Redux样板代码过多，因此最终选用的是redux-toolkit，redux-toolkit只是对redux以及部分中间件进行进一步封装，并不是中间件也不是新的解决方案；</p>
<p>  npm i -S react-redux @reduxjs/toolkit redux-saga redux-injectors<br>  npm i -S whatwg-fetch qs</p>
<h3 id="公共状态"><a href="#公共状态" class="headerlink" title="公共状态"></a>公共状态</h3><pre><code>1. 公共状态指整个应用所共用的，一般有以下数据：
2. 全局状态标识：loading, Error, 初始化等状态；
3. 公共Layout状态；
4. 登录用户信息：基础信息等；
5. 路由数据；
6. 通用基础数据；
</code></pre><h3 id="数据取用"><a href="#数据取用" class="headerlink" title="数据取用"></a>数据取用</h3><p>  取数据使用的是<strong>reselect</strong>，数据的所有复合、计算也是在这一层进行，这使得我们能够在store中存储最原子、最简洁的数据，且reselect会进行数据缓存，如若关联数据没有变化不会再行计算。</p>
<p>  redux-toolkit也集成了reselect，鸡贼的直接导出了reselect的createSelector；</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// selectors.ts</span></span><br><span class="line"><span class="keyword">import</span> selectorsFactory <span class="keyword">from</span> <span class="string">'utils/selectorsFactory'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createSelector &#125; <span class="keyword">from</span> <span class="string">'@reduxjs/toolkit'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; NAMESPACE &#125; <span class="keyword">from</span> <span class="string">'./constants'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; initialState &#125; <span class="keyword">from</span> <span class="string">'./slice'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; IPageState &#125; <span class="keyword">from</span> <span class="string">'./types'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动生成一级数据的selector，使用selectors.name调用，如需要更进一步的计算再自行添加selector</span></span><br><span class="line"><span class="keyword">const</span> selectors = selectorsFactory&lt;IPageState&gt;(NAMESPACE, initialState);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如，需要单独Select modal的data，或者更进一步的计算某些数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> selectModalData = createSelector(</span><br><span class="line">  selectors.mainModal,</span><br><span class="line">  mainModal =&gt; mainModal.data,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> selectors;</span><br></pre></td></tr></table></figure>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Modal.tsx</span></span><br><span class="line"><span class="keyword">import</span> &#123; useDispatch, useSelector &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> selectors <span class="keyword">from</span> <span class="string">'../selectors'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MainModal</span>(<span class="params">props: InjectedIntlProps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dispatch = useDispatch();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> modalData = useSelector(selectors.mainModal);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  从示例代码中可以看到，为了减少样板代码，我们开发了selectorsFactory方法，用以自动生成一级selector，可以通过selectors.mainModal实现数据的取用，其实这也表示，我们期待更扁平的Store结构设计，并不提倡嵌套层次过多；</p>
<h2 id="5-路由-菜单-面包屑"><a href="#5-路由-菜单-面包屑" class="headerlink" title="5. 路由+菜单+面包屑"></a>5. 路由+菜单+面包屑</h2><p>  通过路由配置，自动寻找对应文件，动态加载。并且完成路由、菜单和面包屑三项的同步。</p>
<p>  我们的页面文件结构选择的是平铺的方式，这完全有利于上述方案的实施。嵌套的文件结构不利于扩展和更改，灵活性不够，所以推荐平铺。<br>  也就是页面间的父子、兄弟关系仅靠路由配置维护，而在文件层级上均为兄弟关系。</p>
<h3 id="路由-Loading-NotFoundPage"><a href="#路由-Loading-NotFoundPage" class="headerlink" title="路由 + Loading + NotFoundPage"></a>路由 + Loading + NotFoundPage</h3><p>  connected-react-router是一个绑定react-router到redux的组件，来实现双向绑定router的数据到redux store中，这么做的好处就是让应用更Redux化，可以在action中实现对路由的操作。</p>
<p>  npm i -S react-router react-router-dom  react-redux connected-react-router history react-router-cache-route</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &apos;react&apos;;</span><br><span class="line">import &#123; Router &#125; from &apos;react-router&apos;;</span><br><span class="line">import &#123; CacheRoute, CacheSwitch &#125; from &apos;react-router-cache-route&apos;;</span><br><span class="line">import &#123; createBrowserHistory &#125; from &apos;history&apos;;</span><br><span class="line"></span><br><span class="line">import menuData from &apos;configs/router.conf&apos;;    </span><br><span class="line"> </span><br><span class="line">const history = createBrowserHistory();</span><br><span class="line"></span><br><span class="line">function traversMenu(arr: IMenuDataItem[], keyPath: string[] = []) &#123;</span><br><span class="line">  let leafsArray: IMenuItem[] = [];</span><br><span class="line"></span><br><span class="line">  arr.forEach(item =&gt; &#123;</span><br><span class="line">    const newKeyPath = keyPath.concat([item.path]);</span><br><span class="line">    if (item.children) &#123;</span><br><span class="line">      if (item.exist) &#123;</span><br><span class="line">        leafsArray.push(&#123;</span><br><span class="line">          path: item.route,</span><br><span class="line">          componentName: item.componentName || `$&#123;item.path.substring(0, 1).toUpperCase()&#125;$&#123;item.path.substring(1)&#125;`,</span><br><span class="line">          isDetail: !!item.isDetail,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      leafsArray = leafsArray.concat(traversMenu(item.children, [...newKeyPath]));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      leafsArray.push(&#123;</span><br><span class="line">        path: item.route,</span><br><span class="line">        componentName: item.componentName || `$&#123;item.path.substring(0, 1).toUpperCase()&#125;$&#123;item.path.substring(1)&#125;`,</span><br><span class="line">        isDetail: !!item.isDetail,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  return leafsArray;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">function getLazyComponent(item: IMenuItem) &#123;</span><br><span class="line">  const comp = React.lazy(() =&gt; import(`../../containers/$&#123;item.componentName&#125;/index.tsx`).catch(err =&gt; &#123;</span><br><span class="line">    // 如果路径不存在，则降级为首页；</span><br><span class="line">    return import(&apos;../../containers/HomePage/index&apos;);</span><br><span class="line">  &#125;));</span><br><span class="line">  return comp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const pathToComponentArr = traversMenu(menuData, []);</span><br><span class="line">&lt;Router history=&#123;history&#125;&gt;</span><br><span class="line">  &lt;React.Suspense fallback=&#123;&lt;LoadingIndicator /&gt;&#125;&gt;</span><br><span class="line">    &lt;CacheSwitch&gt;</span><br><span class="line">      &lt;CacheRoute</span><br><span class="line">        exact</span><br><span class="line">        path=&quot;/&quot;</span><br><span class="line">        key=&quot;default&quot;</span><br><span class="line">        component=&#123;getLazyComponent(&#123;</span><br><span class="line">          path: &apos;../../containers/HomePage/index&apos;,</span><br><span class="line">          componentName: &apos;HomePage&apos;</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        pathToComponentArr.map((item: IMenuItem) =&gt; (</span><br><span class="line">          &lt;CacheRoute</span><br><span class="line">            exact</span><br><span class="line">            cacheKey=&#123;() =&gt; item.isDetail ? window.location.pathname + window.location.search : item.path&#125;</span><br><span class="line">            multiple=&#123;item.isDetail&#125;</span><br><span class="line">            key=&#123;item.path&#125;</span><br><span class="line">            className=&apos;main-content-wrap&apos;</span><br><span class="line">            path=&#123;item.isDetail ? `$&#123;item.path&#125;/:id` : item.path&#125;</span><br><span class="line">            component=&#123;getLazyComponent(item)&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        ))</span><br><span class="line">      &#125;</span><br><span class="line">      &lt;CacheRoute path=&quot;*&quot; component=&#123;NotFoundPage&#125; /&gt;</span><br><span class="line">    &lt;/CacheSwitch&gt;</span><br><span class="line">  &lt;/React.Suspense&gt;</span><br><span class="line">&lt;/Router&gt;</span><br></pre></td></tr></table></figure>
<h3 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h3><h3 id="面包屑"><a href="#面包屑" class="headerlink" title="面包屑"></a>面包屑</h3><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><h3 id="tabs"><a href="#tabs" class="headerlink" title="tabs"></a>tabs</h3><h3 id="ErrorBoundary"><a href="#ErrorBoundary" class="headerlink" title="ErrorBoundary"></a>ErrorBoundary</h3><h3 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a>eslint</h3><p>  <a href="https://eslint.org/docs/user-guide/getting-started" target="_blank" rel="noopener">eslint</a><br>  npm install eslint –save-dev<br>  npm eslint –init</p>
<p>  airbnb<br>  eslint-plugin-jsx-a11y<br>  eslint-plugin-import</p>
<h3 id="骨架屏"><a href="#骨架屏" class="headerlink" title="骨架屏"></a>骨架屏</h3><h3 id="react-dev-inspector"><a href="#react-dev-inspector" class="headerlink" title="react-dev-inspector"></a>react-dev-inspector</h3><h2 id="打包部署"><a href="#打包部署" class="headerlink" title="打包部署"></a>打包部署</h2><p>  1） 执行webpack命令<br>  2） webpack –config ‘webpack配置文件’。<br>  3） 配置script命令（”start”: “webpack –config ./config/webpack.base.config.js”），后执行</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/17/fq/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lemon">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/background2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/17/fq/" itemprop="url">fq</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-17T20:19:55+08:00">
                2021-03-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/四院/" itemprop="url" rel="index">
                    <span itemprop="name">四院</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ShadowscoksX + banwagong Server 翻墙：</p>
<ol>
<li>Shadowscoks可以在github中搜到，windows下载-win版，mac下载-X版。<br>（<a href="https://github.com/yangfeicheung/Shadowsocks-X/releases/）" target="_blank" rel="noopener">https://github.com/yangfeicheung/Shadowsocks-X/releases/）</a></li>
<li>购买服务器：可以在搬瓦工上购买<a href="https://bwh88.net/，根据需求购买。" target="_blank" rel="noopener">https://bwh88.net/，根据需求购买。</a></li>
<li>购买成功之后，查看Services-&gt;Login to KiwiVM Control Oanel -&gt;Root password modification获取密码。之后进行Shadowsocks配置即可。</li>
<li>114.34.187.46 29309 PeD593bsZMSM</li>
<li>144.34.191.186 28890 WPQbfuTpny5X</li>
<li>由于搬瓦工后台的shadowsocks的服务器配置被墙了，所以只能通过软件进行配置了，下载putty，（<a href="https://www.ttrar.com/mac/soft/1295.html）" target="_blank" rel="noopener">https://www.ttrar.com/mac/soft/1295.html）</a></li>
</ol>
<p>下载putty：<a href="http://pan.baidu.com/s/1jI0T5Fw或者直接在百度搜putty下载解压运行putty.exe，" target="_blank" rel="noopener">http://pan.baidu.com/s/1jI0T5Fw或者直接在百度搜putty下载解压运行putty.exe，</a></p>
<ol start="7">
<li><p>填入刚才查到的主机地址和端口号，前面图中有介绍。<br>如果这里有对话框弹出，选择是，然后在全黑的屏幕上输入 root ，回车。等五秒，按提示输入root的密码，密码就是前面刚刚重置的root密码。<br>copy你的密码，粘贴至putty（粘贴方式为单击鼠标右键，只需要右键单击一次，这里不会显示任何内容，其实是已经输入了），回车。<br>SSR脚本安装正式开始，等到出现root@host~字样，复制下面脚本第1条命令，回车：<br>脚本命令1：wget –no-check-certificate -O shadowsocks-all.sh <a href="https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh" target="_blank" rel="noopener">https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh</a><br>（备注：国外服务器运行脚本时容易出错，如出现错误提示 bash: wget: command not found，可以请先执行 yum -y install wget 命令。成功后，再执行上面的命令。如果没提示错误，请略过）</p>
</li>
<li><p>等出现了上图显示后，输入第2条脚本命令，回车：<br>脚本命令2：chmod +x shadowsocks-all.sh</p>
</li>
<li><p>等出现了上图显示后，输入第3条脚本命令，回车：<br>脚本命令3：./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log</p>
<p>出现以上画面，根据需要选择，不懂的话直接选1，或者默认回车</p>
</li>
<li><p>下面会提示你输入你的SS SERVER的密码，和端口。不输入就是默认。跑完命令后会出来你的SS客户端的信息。</p>
<p>输入后，回车！</p>
<p>特别注意，由于iphone端的的wingy目前只支持到cfb，所以我们选择aes-256-cfb，即7 ，回车</p>
<p>这一步按回车继续，然后需要几分钟的安装过程，请耐心等待出现下面的画面！</p>
</li>
<li><p>请立即copy下来加以保存。上面的命令全部回车执行后，如果没有报错，即为执行成功，出现确认提示的时候，输入 y 后，回车即可。安装完成后，脚本提示如下：<br>Congratulations, Shadowsocks-Python server install completed!<br>Your Server IP : IP地址<br>Your Server Port : 端口<br>Your Password : 密码<br>Your Encryption Method: aes-256-gcm<br>Your QR Code: (For Shadowsocks Windows, OSX, Android and iOS clients)<br>ss://YWVzLTsadsa206YnVkZHkyMDA4QDEwNC4yMjQuMTM1Ldfghdfgk=<br>Your QR Code has been saved as a PNG file path:<br>/root/shadowsocks_python_qr.png<br>Welcome to visit: <a href="https://teddysun.com/486.html" target="_blank" rel="noopener">https://teddysun.com/486.html</a><br>Enjoy it!</p>
<p>Starting Shadowsocks success</p>
<p>记录保存好你的上述信息：Server IP、Server Port、Password、Encryption Method<br>这时你的专属ss已经搭好了，开始使用吧。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/03/webpack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lemon">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/background2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/03/webpack/" itemprop="url">webpack</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-03T16:12:35+08:00">
                2021-03-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/基础/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="文档学习"><a href="#文档学习" class="headerlink" title="文档学习"></a><font color="#b300b2">文档学习</font></h1><p>打包工具。当 webpack 处理应用程序时，会在内部构建一个依赖图，此依赖图对应映射到项目所需的每个模块，并生成一个或多个bundle。<br>核心概念：entry、output、loader、plugin、mode、浏览器兼容性(browser compatibility)、environment。</p>
<h2 id="入口起点（entry-points）"><a href="#入口起点（entry-points）" class="headerlink" title="入口起点（entry points）"></a>入口起点（entry points）</h2><p>  入口是配置webpack构建内部依赖图的起点模块。</p>
<p>  用法：entry: string | [string] | 对象语法</p>
<p>  动态加载的模块 不是 入口起点。<br>  简单规则：每个 HTML 页面都有一个入口起点。单页应用(SPA)：一个入口起点，多页应用(MPA)：多个入口起点。</p>
<p>  <strong>Naming</strong><br>  如果传入一个字符串或字符串数组，chunk 会被命名为 main。如果传入一个对象，则每个属性的键(key)会是 chunk 的名称，该属性的值描述了 chunk 的入口点。</p>
<h2 id="输出（output）"><a href="#输出（output）" class="headerlink" title="输出（output）"></a>输出（output）</h2><p>  output属性是配置webpack打包后的文件名称及存放位置。</p>
<h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>  webpack本身只能解析js和json文件。<br>  loader可以让webpack能够解析其他类型的文件，并将它们转换为有效的模块，以供程序员使用，并将其添加到依赖图中。<br>  test定义识别哪种类型的文件，use定义使用哪些loader去解析这种类型的文件。</p>
<p>  <strong>三种使用 loader 的方式：</strong><br>  配置方式（推荐）：在 webpack.config.js 文件中指定 loader。<br>  内联方式：在每个 import 语句中显式指定 loader。<br>  CLI 方式：在 shell 命令中指定它们。</p>
<p>  <strong>loader 特性：</strong><br>  loader 支持链式调用。链中的每个 loader 会将转换应用在已处理过的资源上。一组链式的 loader 将按照相反的顺序执行。链中的第一个 loader 将其结果（也就是应用过转换后的资源）传递给下一个 loader，依此类推。最后，链中的最后一个 loader，返回 webpack 所期望的 JavaScript。<br>  loader 可以是同步的，也可以是异步的。<br>  loader 运行在 Node.js 中，并且能够执行任何操作。<br>  loader 可以通过 options 对象配置（仍然支持使用 query 参数来设置选项，但是这种方式已被废弃）。<br>  除了常见的通过 package.json 的 main 来将一个 npm 模块导出为 loader，还可以在 module.rules 中使用 loader 字段直接引用一个模块。<br>  插件(plugin)可以为 loader 带来更多特性。<br>  loader 能够产生额外的任意文件。</p>
<h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h2><p>  loader用于转换某种类型的文件，plugin则用来执行更广泛的任务，如：注入环境变量、资源管理、打包优化等。</p>
<p>  插件目的在于解决 loader 无法实现的其他事。</p>
<p>  用法：</p>
<ul>
<li>配置方式（webpack.config.js）</li>
<li>Node API 方式</li>
</ul>
<h2 id="配置（Configuration）"><a href="#配置（Configuration）" class="headerlink" title="配置（Configuration）"></a>配置（Configuration）</h2><h2 id="模块（Modules）"><a href="#模块（Modules）" class="headerlink" title="模块（Modules）"></a>模块（Modules）</h2><p>  webpack 提供了可定制，强大且丰富的 API，允许在 任何技术栈 中使用，同时支持在开发、测试和生产环境的工作流中做到 无侵入性。</p>
<p>  与 Node.js 模块相比，webpack _模块_能以各种方式表达它们的依赖关系。下面是一些示例：</p>
<ul>
<li>ES2015 import 语句</li>
<li>CommonJS require() 语句</li>
<li>AMD define 和 require 语句</li>
<li>css/sass/less 文件中的 @import 语句。</li>
<li>stylesheet url(…) 或者 HTML &lt; img src=…&gt; 文件中的图片链接。</li>
</ul>
<p>  webpack 天生支持如下模块类型：</p>
<ul>
<li>ECMAScript 模块</li>
<li>CommonJS 模块</li>
<li>AMD 模块</li>
<li>Assets</li>
<li>WebAssembly 模块</li>
</ul>
<p>  通过 loader 可以使 webpack 支持多种语言和预处理器语法编写的模块。loader 向 webpack 描述了如何处理非原生模块，并将相关依赖引入到你的 bundles中。 webpack 社区已经为各种流行的语言和预处理器创建了 loader，其中包括：</p>
<ul>
<li>CoffeeScript</li>
<li>TypeScript</li>
<li>ESNext (Babel)</li>
<li>Sass</li>
<li>Less</li>
<li>Stylus</li>
<li>Elm</li>
</ul>
<h2 id="模块解析（Module-Resolution）"><a href="#模块解析（Module-Resolution）" class="headerlink" title="模块解析（Module Resolution）"></a>模块解析（Module Resolution）</h2><p>  resolver 是一个帮助寻找模块绝对路径的库。</p>
<p>  使用 enhanced-resolve，webpack 能解析三种文件路径：</p>
<ul>
<li>绝对路径 </li>
<li>相对路径 </li>
<li><p>模块路径<br>在 resolve.modules 中指定的所有目录检索模块。<br>在 resolve.alias 置别名</p>
<p>一旦根据上述规则解析路径后，resolver 将会检查路径是指向文件还是文件夹。<br>如果路径指向文件：</p>
<ul>
<li>如果文件具有扩展名，则直接将文件打包。</li>
<li>否则，将使用 resolve.extensions 选项作为文件扩展名来解析，此选项会告诉解析器在解析中能够接受哪些扩展名（例如 .js，.jsx）。</li>
</ul>
<p>如果路径指向一个文件夹，则进行如下步骤寻找具有正确扩展名的文件：</p>
<ul>
<li>如果文件夹中包含 package.json 文件，则会根据 resolve.mainFields 配置中的字段顺序查找，并根据 package.json 中的符合配置要求的第一个字段来确定文件路径。<br>如果不存在 package.json 文件或 resolve.mainFields 没有返回有效路径，则会根据 resolve.mainFiles 配置选项中指定的文件名顺序查找，看是否能在 import/require 的目录下匹配到一个存在的文件名。<br>然后使用 resolve.extensions 选项，以类似的方式解析文件扩展名。</li>
</ul>
</li>
</ul>
<h2 id="Module-Federation"><a href="#Module-Federation" class="headerlink" title="Module Federation"></a>Module Federation</h2><h2 id="依赖图-dependency-graph"><a href="#依赖图-dependency-graph" class="headerlink" title="依赖图(dependency graph)"></a>依赖图(dependency graph)</h2><h2 id="target"><a href="#target" class="headerlink" title="target"></a>target</h2><h2 id="manifest"><a href="#manifest" class="headerlink" title="manifest"></a>manifest</h2><h2 id="模块热替换（Module-Hot-Replacement）"><a href="#模块热替换（Module-Hot-Replacement）" class="headerlink" title="模块热替换（Module Hot Replacement）"></a>模块热替换（Module Hot Replacement）</h2><h2 id="为什么选择webpack"><a href="#为什么选择webpack" class="headerlink" title="为什么选择webpack"></a>为什么选择webpack</h2><p>  想要理解为什么要使用 webpack，我们先回顾下历史，在打包工具出现之前，我们是如何在 web 中使用 JavaScript 的。<br>  在浏览器中运行 JavaScript 有两种方法。第一种方式，引用一些脚本来存放每个功能；此解决方案很难扩展，因为加载太多脚本会导致网络瓶颈。第二种方式，使用一个包含所有项目代码的大型 .js 文件，但是这会导致作用域、文件大小、可读性和可维护性方面的问题。</p>
<p>  <font color="#ff4d4d"><strong>立即调用函数表达式(IIFE) - Immediately invoked function expressions</strong></font><br>  IIFE 解决大型项目的作用域问题；当脚本文件被封装在 IIFE 内部时，你可以安全地拼接或安全地组合所有文件，而不必担心作用域冲突。<br>  IIFE 使用方式产生出 Make, Gulp, Grunt, Broccoli 或 Brunch 等工具。这些工具称为任务执行器，它们将所有项目文件拼接在一起。<br>  但是，修改一个文件意味着必须重新构建整个文件。拼接可以做到很容易地跨文件重用脚本，但是却使构建结果的优化变得更加困难。如何判断代码是否实际被使用？<br>  即使你只用到 lodash 中的某个函数，也必须在构建结果中加入整个库，然后将它们压缩在一起。如何 treeshake 代码依赖？难以大规模地实现延迟加载代码块，这需要开发人员手动地进行大量工作。</p>
<p>  <font color="#ff4d4d"><strong>感谢 Node.js，JavaScript 模块诞生了</strong></font><br>  Node.js 是一个 JavaScript 运行时，可以在浏览器环境之外的计算机和服务器中使用。webpack 运行在 Node.js 中。<br>  当 Node.js 发布时，一个新的时代开始了，它带来了新的挑战。既然不是在浏览器中运行 JavaScript，现在已经没有了可以添加到浏览器中的 html 文件和 script 标签。那么 Node.js 应用程序要如何加载新的代码 chunk 呢？<br>  CommonJS 问世并引入了 require 机制，它允许你在当前文件中加载和使用某个模块。导入需要的每个模块，这一开箱即用的功能，帮助我们解决了作用域问题。</p>
<p>  <font color="#ff4d4d"><strong>npm + Node.js + modules - 大规模分发模块 </strong></font><br>  JavaScript 已经成为一种语言、一个平台和一种快速开发和创建快速应用程序的方式，接管了整个 JavaScript 世界。<br>  但 CommonJS 没有浏览器支持。没有 live binding(实时绑定)。循环引用存在问题。同步执行的模块解析加载器速度很慢。虽然 CommonJS 是 Node.js 项目的绝佳解决方案，但浏览器不支持模块，因而产生了 Browserify, RequireJS 和 SystemJS 等打包工具，允许我们编写能够在浏览器中运行的 CommonJS 模块。</p>
<p>  <font color="#ff4d4d"><strong>ESM - ECMAScript 模块</strong></font><br>  来自 Web 项目的好消息是，模块正在成为 ECMAScript 标准的官方功能。然而，浏览器支持不完整，版本迭代速度也不够快，目前还是推荐上面那些早期模块实现。</p>
<p>  <font color="#ff4d4d"><strong>依赖自动收</strong></font><br>  传统的任务构建工具基于 Google 的 Closure 编译器都要求你手动在顶部声明所有的依赖。然而像 webpack 一类的打包工具自动构建并基于你所引用或导出的内容推断出依赖的图谱。这个特性与其它的如插件 and 加载器一道让开发者的体验更好。</p>
<p>  <font color="#ff4d4d"><strong>看起来都不是很好……</strong> </font><br>  是否可以有一种方式，不仅可以让我们编写模块，而且还支持任何模块格式（至少在我们到达 ESM 之前），并且可以同时处理资源和资产？</p>
<p>  这就是 webpack 存在的原因。它是一个工具，可以打包你的 JavaScript 应用程序（支持 ESM 和 CommonJS），可以扩展为支持许多不同的资产，例如：images, fonts 和 stylesheets。</p>
<p>  webpack 关心性能和加载时间；它始终在改进或添加新功能，例如：异步地加载 chunk 和预取，以便为你的项目和用户提供最佳体验。</p>
<h2 id="揭示内部原理"><a href="#揭示内部原理" class="headerlink" title="揭示内部原理"></a>揭示内部原理</h2><p>  打包，是指处理某些文件并将其输出为某些文件的能力。<br>  但是在输入和输出之间，还存在着模块、入口起点、chunk、chunk组和许多其他中间部分。</p>
<p>  <strong>主要部分</strong><br>  项目中使用的每个文件都是一个模块。</p>
<p>  通过相互引用，这些模块会形成一个图（ModuleGraph）数据结构。<br>  在打包的过程中，文件会被合并成chunk。chunk合并成chunk组，并形成一个通过模块连接的图（ModuleGraph）。</p>
<h1 id="API"><a href="#API" class="headerlink" title="API"></a><font color="#b300b2">API</font></h1><h2 id="命令行接口（CLI）"><a href="#命令行接口（CLI）" class="headerlink" title="命令行接口（CLI）"></a>命令行接口（CLI）</h2><p>   CLI中传入的任何参数会在配置文件中映射为对应的参数。</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a><font color="#b300b2">配置</font></h1><h2 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h2><p>  development    会将 DefinePlugin 中 process.env.NODE_ENV 的值设置为 development。<br>  production    会将 DefinePlugin 中 process.env.NODE_ENV 的值设置为 production。<br>  none    不使用任何默认优化选项</p>
<h1 id="question"><a href="#question" class="headerlink" title="question"></a><font color="#b300b2">question</font></h1><h2 id="loader和plugin的区别"><a href="#loader和plugin的区别" class="headerlink" title="loader和plugin的区别"></a>loader和plugin的区别</h2><pre><code>loader 模块转换器 （less-&gt;css）
plugin 是扩展插件，如HtmlWebpackPlugin

常见的loader和plugin有哪些？
Loader:
babel-loader：把 ES6 转换成 ES5
css-loader：加载 CSS，支持模块化、压缩、文件导入等特性
style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。
file-loader (png|jpg|jpeg|gif) 开发
url-loader, 生产
vue-loader

Plugin:
IgnorePlugin 避免引入无用模块
HotModuleReplacementPlugin 热更新
define-plugin：定义环境变量
commons-chunk-plugin：提取公共代码
uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/19/younontknowjs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lemon">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/background2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/19/younontknowjs/" itemprop="url">younontknowjs</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-02-19T10:36:26+08:00">
                2021-02-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/基础/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第一部分-作用域和闭包"><a href="#第一部分-作用域和闭包" class="headerlink" title="第一部分 作用域和闭包"></a><font color="#ffd11a">第一部分 作用域和闭包</font></h1><h2 id="作用域是什么"><a href="#作用域是什么" class="headerlink" title="作用域是什么"></a>作用域是什么</h2><p>   存储和访问变量的规则，称为作用域。</p>
<p>   一、  编译原理<br>   事实上，js是一门编译语言，但又与传统的编译语言不同，它不是提前编译的，编译结果也不能在分布式系统中进行移植。</p>
<p>   传统的而变异与雅安在执行前会经历三个步骤，统称为“编译”。<br>   1）分词/词法分析（Tokenizing/Lexing）<br>      这个过程是将由字符组成的字符串，分解成（对编程语言来说）有意义的代码块，这些代码块称为词法单元。例如：var a = 2;。会被分解成 var、  a、 =、 2、；具体空格是否会被解析成词法单元，取决于空格在这门语言中是否具有意义。<br>   2）解析/语法分析（Parsing）</p>
<h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><h2 id="函数作用域和块作用域"><a href="#函数作用域和块作用域" class="headerlink" title="函数作用域和块作用域"></a>函数作用域和块作用域</h2><h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2><h2 id="作用域闭包"><a href="#作用域闭包" class="headerlink" title="作用域闭包"></a>作用域闭包</h2><h1 id="第二部分-this和对象原型"><a href="#第二部分-this和对象原型" class="headerlink" title="第二部分 this和对象原型"></a><font color="#ffd11a">第二部分 this和对象原型</font></h1><h2 id="关于-this"><a href="#关于-this" class="headerlink" title="关于 this"></a>关于 this</h2><h2 id="this全面解析"><a href="#this全面解析" class="headerlink" title="this全面解析"></a>this全面解析</h2><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h2 id="混合对象“类”"><a href="#混合对象“类”" class="headerlink" title="混合对象“类”"></a>混合对象“类”</h2><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h2 id="行为委托"><a href="#行为委托" class="headerlink" title="行为委托"></a>行为委托</h2><h1 id="第三部分-类型和语法"><a href="#第三部分-类型和语法" class="headerlink" title="第三部分 类型和语法"></a><font color="#ffd11a">第三部分 类型和语法</font></h1><h1 id="第四部分-异步和性能"><a href="#第四部分-异步和性能" class="headerlink" title="第四部分 异步和性能"></a><font color="#ffd11a">第四部分 异步和性能</font></h1><h2 id="异步：现在与将来"><a href="#异步：现在与将来" class="headerlink" title="异步：现在与将来"></a>异步：现在与将来</h2><p>   事实上，程序中现在运行和将来运行的部分之间的关系就是异步编程的核心。</p>
<p>   <font color="red">分块的程序</font><br>   最常见的块单位是函数。</p>
<p>   <font color="red">事件循环</font><br>   js引擎本身并没有时间的概念，只是一个按需执行js任意代码片段的环境。<br>   “事件”调度总是由包含它的环境进行。<br>   以Ajax回调举例，如果js程序发出一个Ajax请求，js引擎会通知宿主环境：‘hello，你一旦完成网络请求，拿到了数据，就请调用这个回调函数’。然后浏览器就会设置侦听来自网络的响应，拿到数据之后就会把回调函数插入到事件循环中，以此实现对这个回调的调度执行。</p>
<p>   <font color="red">并行线程</font><br>   异步和并行的意义完全是不同的。异步是关于现在和将来的时间间隙，而并行是关于能能够同时发生的事情。<br>   并行计算最常见的工具就是进程和线程。进程和线程独立运行，并可能同时运行：在不同的处理器，甚至不同的计算机上，但多个线程能够共享单个进程的内存。<br>   事件循环把自身的工作分成一个个任务并顺序执行，不允许对共享内存的并行访问和修改。通过分立线程中彼此合作的事件循环，并行和顺序执行可以共存。并行线程的交替执行和异步事件的交替调度，其粒度是完全不同的。<br>   js从不跨线程共享数据，这意味着不需要考虑这一层次的不确定性。但是这并不意味着js总是确定性的。<br>   在js的特性中，函数顺序带来的不确定性就是通常所说的“竞态条件”。</p>
<p>   <font color="red">并发</font><br>   并发是指两个或多个事件链随时间发展交替执行，以至于从更高的层次来看，就像是同时在运行（尽管在任意时刻只处理一个事件）。通常需要对并发的程序进行某种形式的交互协调，比如需要确保执行顺序或者需要防止竞态出现。</p>
<p>   <font color="red">任务队列</font><br>   对于任务队列最好的理解方式就是，它是挂在事件循环队列的每个tick之后的一个队列。在事件循环的每个tick中，可能出现的异步动作不会导致一个完整的新事件添加到事件循环队列中，而会在当前tick的任务的任务队列末尾添加一个项目（一个任务）。<br>   类似于游乐园游戏：玩过一个游戏之后，你需要重新到队尾排队才能再玩一次，而任务队列类似于玩过了游戏之后，插队接着继续玩。</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;A&apos;);</span><br><span class="line"></span><br><span class="line">setTimeout(()=&gt;console.log(&apos;B&apos;), 0);</span><br><span class="line"></span><br><span class="line">schedule(function() &#123;</span><br><span class="line">   console.log(&apos;C&apos;);</span><br><span class="line">   schedule(function()&#123;</span><br><span class="line">      console.log(&apos;D&apos;);</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>   <font color="red">语句顺序</font><br>   js引擎会在编译期间执行优化。尽管我们是看不到的，但是代码编写的方式（从上到下的模式）和编译后执行的方式之间的联系非常脆弱，理解这一点能够更好地理解异步js代码流问题。编译器语句重排序几乎就是并发和交互的微型隐喻。</p>
<p>   <font color="yellow">异步控制台：</font><br>   并没有什么规范或一组需求制定console.*方法族如何工作–它们并不是js正式的一部分，而是由宿主环境添加到js中的。因此，不同的浏览器和js环境可以按照自己的医院来实现。尤其要提出的是，在某些条件下，某些浏览器的console.log(..)会在后台异步处理控制台I/O，以提高性能。如果遇见这种少见的情况，最好的选择是在js调试器中使用断点，次优的方案是把对象序列化到一个字符串中，以强制执行一次“快照”，比如通过JSON.stringfy(..)。</p>
<h2 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h2><p>   回调函数是js异步的基本单元，但是因为它一不符合我们大脑的思考方式（线性的、阻塞的、单线程），二是存在控制反转的信任问题，即使可以尝试挽救回调，但是可能会产生更笨重，更难以维护的代码。所以回调已经在异步编程领域不够用了。</p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h3 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise"></a>什么是Promise</h3><p>   Promise封装了依赖时间的状态–等待底层值的完成或拒绝，所以Promise本身是与时间无关的。因此，Promise可以按照可预测的方式组成（组合），而不关心时序和底层的结果，</p>
<p>   Promise（一旦决议）一直保持其决议结果（完成或拒绝）不变，可以按照需要多次查看。</p>
<h3 id="具有then方法的亚子类型"><a href="#具有then方法的亚子类型" class="headerlink" title="具有then方法的亚子类型"></a>具有then方法的亚子类型</h3><p>   p instaceof Promise 无法识别和判断真正的Promise。</p>
<p>   thenable</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (p!==null &amp;&amp; (typeof p === &apos;object&apos; || typeof p ==== &apos;function&apos;) &amp;&amp; typeof p.then === &apos;function&apos;)&#123;</span><br><span class="line">  // 假定则是一个thenable</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  // 不是 thenable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><h2 id="程序性能"><a href="#程序性能" class="headerlink" title="程序性能"></a>程序性能</h2><h2 id="性能测试与调优"><a href="#性能测试与调优" class="headerlink" title="性能测试与调优"></a>性能测试与调优</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/20/es6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lemon">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/background2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/20/es6/" itemprop="url">es6</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-20T14:33:08+08:00">
                2021-01-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/基础/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第一节、-块级作用域"><a href="#第一节、-块级作用域" class="headerlink" title="第一节、 块级作用域"></a><font color="#1B90D6">第一节、 块级作用域</font></h2><blockquote>
<p>ES5，以function来划分作用域，但是{}却限定不了var的作用域。<br>ES6，增加了let和const，声明在{} -&gt; “function、if、for等”的变量作用域被限制在块级</p>
</blockquote>
<h3 id="let-和-const"><a href="#let-和-const" class="headerlink" title="let 和 const"></a>let 和 const</h3><blockquote>
<p>生命周期在块级作用域中<br>没有变量提升，不可重复声明<br>let声明变量，const声明常量</p>
</blockquote>
<ul>
<li>块级作用域的出现，实际上使用广泛的立即执行匿名函数不在必要了。防止变量污染。<br></li>
</ul>
<h2 id="第二节、-解构赋值"><a href="#第二节、-解构赋值" class="headerlink" title="第二节、 解构赋值"></a><font color="#1B90D6">第二节、 解构赋值</font></h2><ol>
<li><p>本质上属于模式匹配，也就是只要等号两边的模式相同，左边的变量就会被赋予对应的值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var [a, b, c] = [1, 2, 3];                  // 1, 2, 3</span><br><span class="line"><span class="built_in">let</span> [foo, [[bar], bax]] = [1, [[2], 3]];    // 1, 2, 3</span><br></pre></td></tr></table></figure>
</li>
<li><p>解构失败则为undefined，也存在不完全解构。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const [a, b, c] = [1];       // 1, undefined, undefined  解构失败</span><br><span class="line"><span class="built_in">let</span> [foo, [[bar], bax]] = [1, [[2, 3], 4]];  // 1, 2, 4  不完全解构</span><br></pre></td></tr></table></figure>
</li>
<li><p>赋默认值（只有右侧严格等于undefined的时候才生效）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const [a, b=123, c] = [1];   // 1, 123, undefined</span><br><span class="line"><span class="built_in">let</span> [foo=1] = [null];        // null</span><br><span class="line"></span><br><span class="line">// 惰性求值</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span> () &#123; <span class="built_in">return</span> <span class="string">'abc'</span>; &#125;</span><br><span class="line"><span class="built_in">let</span> [a=fn()] = [1];          // 1</span><br><span class="line"><span class="built_in">let</span> [b=fn()] = [];           // <span class="string">'abc'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对象的解构赋值(按照属性名来决定)</p>
<ul>
<li><p>注意：一个已声明的变量用于解构赋值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var x;</span><br><span class="line">&#123; x &#125; = &#123; x: 1 &#125;;    // Uncaught SyntaxError: Unexpected token <span class="string">'='</span></span><br><span class="line">                     // js引擎会将&#123;x&#125;理解成一个代码块，从而发生语法错误</span><br><span class="line">(&#123; x &#125; = &#123; x: 1 &#125;);  // ()将其转换为表达式，从而避免上述语法问题</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果变量名和属性名不一致，必须（属性名不是变量，我们可以理解成一种模式）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var &#123; foo: bar &#125; = &#123; foo: 1,  bar: 2 &#125;;</span><br><span class="line">foo;       // Uncaught ReferenceError: foo is not defined</span><br><span class="line">bar;       // 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>和数组的解构赋值一样，对象的解构赋值也可嵌套</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; P: [<span class="string">'hello'</span>, &#123;y: <span class="string">'world'</span>&#125;] &#125;;</span><br><span class="line">var &#123; P: [x, &#123;y&#125;] &#125; = obj;</span><br><span class="line"></span><br><span class="line">obj;      // &#123;P: Array(2)&#125;</span><br><span class="line">x;        // <span class="string">'hello'</span></span><br><span class="line">y;        // <span class="string">'world'</span></span><br><span class="line">P;        // Uncaught ReferenceError: P is not defined</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var &#123; x, y=x, z &#125; = &#123; x: 1 &#125;;</span><br><span class="line">x;       // 1</span><br><span class="line">y;       // 1</span><br><span class="line">z;       // undefined</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>字符串的解构赋值，字符串会转化成一个类数组的对象</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var [a,b,c,d,e,f] = <span class="string">"hello"</span>;</span><br><span class="line">var &#123; length: len &#125; = <span class="string">"hello"</span>;</span><br><span class="line">a;      // h</span><br><span class="line">b;      // e</span><br><span class="line">c;      // l</span><br><span class="line">d;      // l</span><br><span class="line">e;      // o</span><br><span class="line">f;      // undefined</span><br><span class="line">len;    // 5</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="6">
<li><p>数值和布尔值的解构赋值，如果等号右边是数值或者布尔值，则会先转为对象</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var &#123; toString: a &#125; = 123;</span><br><span class="line">var &#123; toString: b &#125; = <span class="literal">true</span>;</span><br><span class="line">a;                                 // ƒ <span class="function"><span class="title">toString</span></span>() &#123; [native code] &#125;</span><br><span class="line">b;                                 // ƒ <span class="function"><span class="title">toString</span></span>() &#123; [native code] &#125;</span><br><span class="line">a === Number.prototype.toString;   // <span class="literal">true</span></span><br><span class="line">b === Boolean.prototype.toString;  // <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数参数的解构赋值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="built_in">test</span>(&#123; x=0, y=0 &#125; = &#123;&#125;) &#123;</span><br><span class="line">  console.log([x ,y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">test</span>(&#123;x: 1, y: 2&#125;);  // [1, 2]</span><br><span class="line"><span class="built_in">test</span>(&#123;x: 1&#125;);        // [1, 0]</span><br><span class="line"><span class="built_in">test</span>(&#123;&#125;);            // [0, 0]</span><br><span class="line"><span class="built_in">test</span>();              // [0, 0]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> move(&#123; x, y &#125; = &#123;x: 0, y: 0&#125;) &#123;</span><br><span class="line">  console.log([x ,y]);</span><br><span class="line">&#125;</span><br><span class="line">move(&#123;x: 1, y: 2&#125;);  // [1, 2]</span><br><span class="line">move(&#123;x: 1&#125;);        // [1, undefined]</span><br><span class="line">move(&#123;&#125;);            // [undefined, undefined]</span><br><span class="line">move();              // [0, 0]</span><br></pre></td></tr></table></figure>
</li>
<li><p>解构赋值的应用</p>
<ul>
<li><p>交换变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">var b = 2;</span><br><span class="line">[a, b] = [b, a];</span><br><span class="line">a, b;            // 2, 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数参数的定义</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> fn (&#123;x=1, y, z&#125; = &#123;&#125;)&#123;console.log(x, y, z);&#125;</span><br><span class="line">fn();    // 1, undefined, undefined</span><br></pre></td></tr></table></figure>
</li>
<li><p>从函数中返回多个值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">example</span></span> () &#123;</span><br><span class="line">  <span class="built_in">return</span> [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line">const [a, b, c] = example();</span><br><span class="line">a, b, c           // 1, 2, 3</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ul>
<li>提交数据<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var jsonData = &#123;</span><br><span class="line">  id: 42,</span><br><span class="line">  status: 2000,</span><br><span class="line">&#125;;</span><br><span class="line">const &#123; id, status &#125; = jsonData;</span><br><span class="line">id, status;       // 42, 2000</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="第三节、-数组扩展"><a href="#第三节、-数组扩展" class="headerlink" title="第三节、 数组扩展"></a><font color="#1B90D6">第三节、 数组扩展</font></h2><h3 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h3><p>用于将两类对象转化为真正的数组</p>
<ol>
<li>类数组 （所谓类似数组的对象，本质上必须有length属性）</li>
<li>可遍历对象 （ES6新增Set和Map两种数据结构）</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var sameArr = &#123;</span><br><span class="line">  0: 1,</span><br><span class="line">  a: <span class="string">'b'</span>,</span><br><span class="line">  5: <span class="string">'c'</span>,</span><br><span class="line">  length: 6,</span><br><span class="line">  splice: <span class="function"><span class="title">function</span></span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">var arr = Array.from(sameArr);</span><br><span class="line"></span><br><span class="line">sameArr       // Object(6) [1, empty × 4, <span class="string">"c"</span>, a: <span class="string">"b"</span>, splice: ƒ]</span><br><span class="line">                 0: 1 5: <span class="string">"c"</span> a: <span class="string">"b"</span> length: 6 splice: ƒ ()__proto__: Object </span><br><span class="line"></span><br><span class="line">arr;          // [1, undefined, undefined, undefined, undefined, <span class="string">"c"</span>]</span><br><span class="line"></span><br><span class="line">sameArr.forEach(item =&gt; console.log(item)); // Uncaught TypeError: sameArr.forEach is not a <span class="keyword">function</span></span><br><span class="line"></span><br><span class="line">arr.forEach(item =&gt; console.log(item)); // 1  undefined undefined undefined undefined  c</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Array.from 还接受第二个参数，作用类似于数组的map方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = Array.from(sameArr, (item) =&gt; item + 123);</span><br><span class="line">arr;           // [124, NaN, NaN, NaN, NaN, <span class="string">"c123"</span>]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = new Array();            // [undefined * 10]</span><br><span class="line">var arr1 = Array.of(10, 2, 3);    // [10, 2, 3]</span><br></pre></td></tr></table></figure>
<h3 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin()"></a>copyWithin()</h3><p>  在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原来成员），然后返回当前数组，也就是说，copyWithin()方法会修改当前数组。</p>
<ul>
<li>接受三个参数：<br>target（必需）：从该位置开始替换数据<br>start（可选）：从该位置开始读取数据，默认为0，如果为负值，表示倒数。<br>end（可选）：到该位置前停止读取数据，默认等于数组长度，如果为负值，表示倒数。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];</span><br><span class="line">arr.copyWithin(0, 2, 4);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="find-和-findIndex"><a href="#find-和-findIndex" class="headerlink" title="find() 和 findIndex()"></a>find() 和 findIndex()</h3><ul>
<li>find       用于找出第一个符合条件的数组成员。没有则返回undefined。<br>findIndex  类似，返回第一个符合条件的数组成员的位置。没有则返回-1。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];</span><br><span class="line">var newArr = arr.find((item) =&gt; item &gt; 5);         // 6</span><br><span class="line">var newIndex = arr.findIndex((item) =&gt; item &gt; 5);  // 5</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h3><p>填充数组<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4, 5];</span><br><span class="line">arr.fill(<span class="string">'a'</span>);                // [<span class="string">"a"</span>, <span class="string">"a"</span>, <span class="string">"a"</span>, <span class="string">"a"</span>, <span class="string">"a"</span>]</span><br><span class="line">arr.fill(<span class="string">'a'</span>, 2);             // [1, 2, <span class="string">"a"</span>, <span class="string">"a"</span>, <span class="string">"a"</span>]</span><br><span class="line">arr.fill(<span class="string">'a'</span>, 2, 4);          // [1, 2, <span class="string">"a"</span>, <span class="string">"a"</span>, 5]</span><br></pre></td></tr></table></figure></p>
<h3 id="entries-keys-valueof"><a href="#entries-keys-valueof" class="headerlink" title="entries() keys() valueof()"></a>entries() keys() valueof()</h3><p>ES6提供三个新的方法 – entries, keys()和values() – 用于遍历数组。它们都返回一个遍历器对象，可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历,values()是对键值的遍历，entries()是对键值对的遍历。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> index of [<span class="string">'a'</span>, <span class="string">'b'</span>].keys()) &#123; console.log(index); &#125;     // 0 1</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> elem of [<span class="string">'a'</span>, <span class="string">'b'</span>].values()) &#123; console.log(elem); &#125;      // <span class="string">'a'</span> <span class="string">'b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [index, elem] of [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123; console.log(index, elem); &#125;      // 0 <span class="string">"a"</span>    1 <span class="string">"b"</span></span><br></pre></td></tr></table></figure></p>
<h3 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h3><p>某个数组是否包含给定的值，与字符串的includes方法类似。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, NaN];</span><br><span class="line">console.log(arr.indexOf(<span class="string">'c'</span>));    // 2</span><br><span class="line">console.log(arr.indexOf(NaN));    // -1    NaN不等于NaN</span><br><span class="line">console.log(arr.includes(<span class="string">'c'</span>));   // <span class="literal">true</span></span><br><span class="line">console.log(arr.includes(NaN));   // <span class="literal">true</span>  includes没有这个问题</span><br></pre></td></tr></table></figure></p>
<h2 id="第四节、-对象扩展"><a href="#第四节、-对象扩展" class="headerlink" title="第四节、 对象扩展"></a><font color="#1B90D6">第四节、 对象扩展</font></h2><h3 id="1-属性"><a href="#1-属性" class="headerlink" title="1. 属性"></a>1. 属性</h3><p>ES6 允许直接写入变量和函数，作为对象的属性和方法。（ES6允许在对象中，只写属性名不写属性值，这时属性值等于属性名所代表的的变量）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123; name&#125;;                                 // &#123;name: <span class="string">""</span>&#125;</span><br><span class="line"></span><br><span class="line">const name = <span class="string">'hahaha'</span>;</span><br><span class="line">const obj = &#123; name &#125;;                                // &#123;name: <span class="string">"hahaha"</span>&#125;</span><br><span class="line"></span><br><span class="line">const name = <span class="function"><span class="title">function</span></span>()&#123;sonsole.log(<span class="string">'name:test'</span>);&#125;;</span><br><span class="line">const obj = &#123; name &#125;;                                // &#123;name: ƒ&#125;</span><br><span class="line"></span><br><span class="line">const obj = &#123; <span class="function"><span class="title">name</span></span>()&#123;console.log(<span class="string">'name:test'</span>);&#125; &#125;;   // &#123;name: ƒ&#125;</span><br></pre></td></tr></table></figure></p>
<p>属性表达式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const name = <span class="string">'test'</span>;</span><br><span class="line">const obj = &#123;             // &#123;<span class="built_in">test</span>: <span class="string">"haha"</span>, test1: <span class="string">"heihei"</span>, test2: <span class="string">"houhou"</span>&#125;</span><br><span class="line">  [name]: <span class="string">'haha'</span>,</span><br><span class="line">  [name+<span class="string">'1'</span>]: <span class="string">'heihei'</span>,</span><br><span class="line">  [name+<span class="string">'2'</span>]: <span class="string">'houhou'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-Object-is"><a href="#2-Object-is" class="headerlink" title="2. Object.is()"></a>2. Object.is()</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+0 === -0              // <span class="literal">true</span></span><br><span class="line">NaN === NaN            // <span class="literal">false</span></span><br><span class="line">Object.is(+0, -0);     // <span class="literal">false</span></span><br><span class="line">Object.is(NaN, NaN);   // <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="3-Object-assign"><a href="#3-Object-assign" class="headerlink" title="3. Object.assign()"></a>3. Object.assign()</h3><p>对象合并（浅拷贝）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const a = &#123; a: 1, b: <span class="string">'xxx'</span> &#125;;</span><br><span class="line">const b = &#123; b: <span class="string">'bbb'</span>, c: &#123; d: 1, e: 2 &#125; &#125;;</span><br><span class="line">const f = &#123; c: &#123; d: 2, e: 2, g: 3 &#125;, h: <span class="string">'hahaha'</span> &#125;;</span><br><span class="line"></span><br><span class="line">Object.assign(f, b, a);   // &#123;c: &#123;&#123;d: 1, e: 2&#125;&#125;, h: <span class="string">"hahaha"</span>, b: <span class="string">"xxx"</span>, a: 1&#125;</span><br></pre></td></tr></table></figure></p>
<font size="1">$.extend({}) 扩展<br>$.extend({}, {}) 浅拷贝<br>$.extend(true, {}, {}) 深拷贝</font>

<h3 id="4-Object-entries-Object-keys-Object-valueof"><a href="#4-Object-entries-Object-keys-Object-valueof" class="headerlink" title="4. Object.entries()  Object.keys()  Object.valueof()"></a>4. Object.entries()  Object.keys()  Object.valueof()</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123; b: <span class="string">'bbb'</span>, c: &#123; d: 1, e: 2 &#125; &#125;;</span><br><span class="line">  </span><br><span class="line">Object.keys(obj);      // [<span class="string">"b"</span>, <span class="string">"c"</span>]</span><br><span class="line">Object.values(obj);    // [<span class="string">"bbb"</span>, &#123;d: 1, e: 2&#125;]</span><br><span class="line">Object.entries(obj);   // [[<span class="string">"b"</span>, <span class="string">"bbb"</span>], [<span class="string">"c"</span>, &#123;d: 1, e: 2&#125;]]</span><br></pre></td></tr></table></figure>
<h3 id="5-Object-getPrototypeOf-Object-setPrototypeOf"><a href="#5-Object-getPrototypeOf-Object-setPrototypeOf" class="headerlink" title="5. Object.getPrototypeOf()   Object.setPrototypeOf()"></a>5. Object.getPrototypeOf()   Object.setPrototypeOf()</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123; a: 1 &#125;;</span><br><span class="line">const obj1 = &#123; b: <span class="function"><span class="title">function</span></span>()&#123;console.log(<span class="string">'bbb'</span>);&#125; &#125;;</span><br><span class="line"></span><br><span class="line">obj.__proto__ = obj1;</span><br><span class="line">Object.setPrototypeOf(obj, obj1);</span><br><span class="line"></span><br><span class="line">obj.b();                              // <span class="string">'bbb'</span></span><br><span class="line">Object.getPrototypeOf(obj);           // &#123;b: ƒ&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-扩展运算符-…"><a href="#6-扩展运算符-…" class="headerlink" title="6. 扩展运算符 …"></a>6. 扩展运算符 …</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1,2,3];</span><br><span class="line">const arr1 = [...arr, <span class="string">'c'</span>];      // [1, 2, 3, <span class="string">"c"</span>]</span><br></pre></td></tr></table></figure>
<h2 id="第五节、-函数扩展"><a href="#第五节、-函数扩展" class="headerlink" title="第五节、 函数扩展"></a><font color="#1B90D6">第五节、 函数扩展</font></h2><h3 id="1-扩展运算符-…"><a href="#1-扩展运算符-…" class="headerlink" title="1. 扩展运算符 …"></a>1. 扩展运算符 …</h3><p>ES6韵如rest参数（形式为“…变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const a = (...values) =&gt; &#123;console.log(values);&#125;</span><br><span class="line">a(1,2,3,4,5);     // [1,2,3,4,5]</span><br><span class="line"></span><br><span class="line">const a = (a, ...values) =&gt; &#123;console.log(values);&#125;</span><br><span class="line">a(1,2,3,4,5);     // [2,3,4,5]</span><br></pre></td></tr></table></figure></p>
<h3 id="2-箭头函数"><a href="#2-箭头函数" class="headerlink" title="2. 箭头函数"></a>2. 箭头函数</h3><ol>
<li>箭头函数内的this值不会改变<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">const id = 10;</span><br><span class="line">const fn = () =&gt; &#123;console.log(this.id);&#125;   // this指向window</span><br><span class="line">const obj = &#123; id: 20, fn &#125;;</span><br><span class="line">const obj1 = &#123; id: 30 &#125;;</span><br><span class="line">fn();                          // undefined</span><br><span class="line">obj.fn();                      // undefined</span><br><span class="line">obj.fn.call(obj1);             // undefined</span><br><span class="line"></span><br><span class="line">var id = 10;</span><br><span class="line">const fn = () =&gt; &#123;console.log(this.id);&#125;</span><br><span class="line">const obj = &#123; id: 20, fn &#125;;</span><br><span class="line">const obj1 = &#123; id: 30 &#125;;</span><br><span class="line">fn();                          // 10</span><br><span class="line">obj.fn();                      // 10</span><br><span class="line">obj.fn.call(obj1);             // 10</span><br><span class="line"></span><br><span class="line">var id = 10;</span><br><span class="line">const fn = () =&gt; &#123;this.id = 1; console.log(this.id);&#125;</span><br><span class="line">const obj = &#123; id: 20, fn &#125;;</span><br><span class="line">const obj1 = &#123; id: 30 &#125;;</span><br><span class="line">fn();                          // 1</span><br><span class="line">obj.fn();                      // 1</span><br><span class="line">obj.fn.call(obj1);             // 1</span><br><span class="line"></span><br><span class="line">const id = 10;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span> () &#123;console.log(this.id);&#125;</span><br><span class="line">const obj = &#123; id: 20, fn  &#125;;</span><br><span class="line">const obj1 = &#123; id: 30 &#125;;</span><br><span class="line">obj.fn();                      // 20</span><br><span class="line">obj.fn.call(obj1);             // 30</span><br><span class="line"></span><br><span class="line">const fn1 = obj.fn;</span><br><span class="line">fn1();                         // undefined</span><br><span class="line"></span><br><span class="line">const fn2 = obj.fn.bind(obj1);</span><br><span class="line">fn2();                         // 30</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>全局定义的const和let不会被挂载到全局对象（如window）下，而是存在于块作用域（Script）中。<br>我们可以用debugger在控制台测一下</p>
<p>这里不是太理解，埋个？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 定义时</span><br><span class="line">const id = 10;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span> () &#123;setTimeout(<span class="function"><span class="title">function</span></span>()&#123;console.log(this.id)&#125;, 0);&#125;       // undefined</span><br><span class="line">const obj1 = &#123; id: 30 &#125;;</span><br><span class="line">fn.call(obj1);</span><br><span class="line"></span><br><span class="line">const id = 10;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span> () &#123;setTimeout(()=&gt;console.log(this.id), 0);&#125;               // 30</span><br><span class="line">const obj1 = &#123; id: 30 &#125;;</span><br><span class="line">fn.call(obj1);</span><br></pre></td></tr></table></figure></p>
<h2 id="第六节、-类-class"><a href="#第六节、-类-class" class="headerlink" title="第六节、 类  class"></a><font color="#1B90D6">第六节、 类  class</font></h2><h3 id="class基本语法"><a href="#class基本语法" class="headerlink" title="class基本语法"></a>class基本语法</h3><blockquote>
<p>JS的传统方法是通过构造函数，定义并生成新对象。<br>构造函数的prototype属性，在ES6的类上面继续存在（事实上，类的所有方法都定义在类的prototype属性上）。<br>类的内部所有定义的方法都是不可枚举的。<br>类的实例共享一个原型对象。<br>class 的本质是 function。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123; // 不写默认为&#123;&#125;</span><br><span class="line">    this.name = <span class="string">'Person Class'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">operate</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">'laugh smile cry fire happy sad'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const child = new Person(); // Person &#123;name: <span class="string">"Person Class"</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="class的继承"><a href="#class的继承" class="headerlink" title="class的继承"></a>class的继承</h3><p>extends supor<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Ancestors &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    this.level = <span class="string">'Ancestors Class'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">create</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'Creating the world'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Person extends Ancestors &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    super();  // 必须</span><br><span class="line">    this.name = <span class="string">'Person Class'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">operate</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">'laugh smile cry fire happy sad'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const child = new Person(); // Person &#123;level: <span class="string">"Ancestors Class"</span>, name: <span class="string">"Person Class"</span>&#125;</span><br><span class="line">child.operate();            // 可调用</span><br><span class="line">child.create();             // 可调用</span><br></pre></td></tr></table></figure></p>
<h3 id="class的静态方法-static"><a href="#class的静态方法-static" class="headerlink" title="class的静态方法 static"></a>class的静态方法 static</h3><p>不需要实例化。 ES6 中规定，Class 内部只有静态方法，没有静态属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.name = &apos;Person Class&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  operate()&#123;</span><br><span class="line">    console.log(&apos;laugh smile cry fire happy sad&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  static originLook() &#123;</span><br><span class="line">    console.log(&apos;nature is new&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const child = new Person();</span><br><span class="line">child.originLook();       // Uncaught TypeError: child.originLook is not a function</span><br></pre></td></tr></table></figure></p>
<h2 id="第七节、-Set-和-Map"><a href="#第七节、-Set-和-Map" class="headerlink" title="第七节、 Set 和 Map"></a><font color="#1B90D6">第七节、 Set 和 Map</font></h2><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><blockquote>
<p> ES6提供了新的数据结构Set，类似于数组，但是成员的值都是唯一的，没有重复的值。<br> Set本身是构造函数，用来生成Set数据结构，Set函数可以接受数组（或类数组）作为参数，用来初始化。<br>可以用来去除数组中重复的成员。</p>
</blockquote>
<blockquote>
<p>Set.prototype.constructor： 构造函数，默认就是Set函数<br>Set.prototype.size：返回Set实例的成员总数</p>
</blockquote>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1,2,3,3,3,2,1];</span><br><span class="line">const a = new Set(arr);                // Set(3) &#123;1, 2, 3&#125; </span><br><span class="line">const b = Array.from(new Set(arr));    // [1, 2, 3]   将Set结构转换为数组，也算是一种数组去重的方法</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Set数据的四个操作方法：<br>add()<br>delete()<br>has()<br>clear()</p>
</li>
<li><p>Set数据的四个遍历方法：<br>keys()<br>values()<br>entries()<br>forEach()</p>
</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。</p>
<h4 id="Maps-和-Objects-的区别"><a href="#Maps-和-Objects-的区别" class="headerlink" title="Maps 和 Objects 的区别"></a>Maps 和 Objects 的区别</h4><p>  一个 Object 的键只能是字符串或者 Symbols，但一个 Map 的<strong>键可以是任意值</strong>。<br>  Map 中的键值是<strong>有序</strong>的（FIFO 原则），而添加到对象中的键则不是。<br>  Map 的键值对个数可以从 <strong>size</strong> 属性获取，而 Object 的键值对个数只能手动计算。<br>  Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。</p>
<h4 id="key-可以是字符串、对象"><a href="#key-可以是字符串、对象" class="headerlink" title="key 可以是字符串、对象"></a>key 可以是字符串、对象</h4><ul>
<li><p>key 可以是字符串</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myMap = new Map();</span><br><span class="line">var keyString = <span class="string">"a string"</span>; </span><br><span class="line">myMap.set(keyString, <span class="string">"和键'a string'关联的值"</span>);</span><br><span class="line">myMap.get(keyString);         // <span class="string">"和键'a string'关联的值"</span></span><br><span class="line">myMap.get(<span class="string">"a string"</span>);        // <span class="string">"和键'a string'关联的值"</span>,因为 keyString === <span class="string">'a string'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>key 是对象</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myMap = new Map();</span><br><span class="line">var keyObj = &#123;&#125;, </span><br><span class="line">myMap.set(keyObj, <span class="string">"和键 keyObj 关联的值"</span>);</span><br><span class="line">myMap.get(keyObj);             // <span class="string">"和键 keyObj 关联的值"</span></span><br><span class="line">myMap.get(&#123;&#125;);                 // undefined, 因为 keyObj !== &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>key 是函数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myMap = new Map();</span><br><span class="line">var keyFunc = <span class="function"><span class="title">function</span></span> () &#123;&#125;;</span><br><span class="line">myMap.set(keyFunc, <span class="string">"和键 keyFunc 关联的值"</span>);</span><br><span class="line">myMap.get(keyFunc);              // <span class="string">"和键 keyFunc 关联的值"</span></span><br><span class="line">myMap.get(<span class="function"><span class="title">function</span></span>() &#123;&#125;)         // undefined, 因为 keyFunc !== <span class="function"><span class="title">function</span></span> () &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>key 是 NaN<br><em>虽然NaN和任何值甚至和自己都不相等，但是NaN作为Map的键来说是没有区别的。</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myMap = new Map();</span><br><span class="line">myMap.set(NaN, <span class="string">"not a number"</span>);</span><br><span class="line">myMap.get(NaN);                   // <span class="string">"not a number"</span></span><br><span class="line">var otherNaN = Number(<span class="string">"foo"</span>);</span><br><span class="line">myMap.get(otherNaN);              // <span class="string">"not a number"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Set数据的四个操作方法："><a href="#Set数据的四个操作方法：" class="headerlink" title="Set数据的四个操作方法："></a>Set数据的四个操作方法：</h4><p>  add()<br>  delete()<br>  has()<br>  clear()</p>
<h4 id="Set数据的四个遍历方法："><a href="#Set数据的四个遍历方法：" class="headerlink" title="Set数据的四个遍历方法："></a>Set数据的四个遍历方法：</h4><p>  keys()<br>  values()<br>  entries()<br>  forEach()</p>
<h2 id="第八节、-Promise"><a href="#第八节、-Promise" class="headerlink" title="第八节、 Promise"></a><font color="#1B90D6">第八节、 Promise</font></h2><p>Promise是异步编程的一种解决方案。</p>
<h3 id="1、Promise-的含义"><a href="#1、Promise-的含义" class="headerlink" title="1、Promise 的含义"></a>1、Promise 的含义</h3><p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。</p>
<ul>
<li><p><strong>对象的状态不受外界影响。</strong> Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>
</li>
<li><p><strong>一旦状态改变，就不会再变，任何时候都可以得到这个结果</strong>。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。<br>注意，为了行文方便，本章后面的resolved统一只指fulfilled状态，不包含rejected状态。</p>
</li>
</ul>
<h3 id="2、基本用法"><a href="#2、基本用法" class="headerlink" title="2、基本用法"></a>2、基本用法</h3><p>ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。</p>
<h2 id="第九节、-Iterator"><a href="#第九节、-Iterator" class="headerlink" title="第九节、 Iterator"></a><font color="#1B90D6">第九节、 Iterator</font></h2><h2 id="第十节、-Symbol"><a href="#第十节、-Symbol" class="headerlink" title="第十节、 Symbol"></a><font color="#1B90D6">第十节、 Symbol</font></h2><!-- 




1. function和箭头函数的区别
> this的指向： 使用function定义的函数，this的指向随着调用环境的变化而变化的，而箭头函数中的this指向是固定不变的，一直指向的是定义函数的环境。
>
> 构造函数： function是可以定义构造函数的，而箭头函数是不行的。
>
> 变量提升： 由于js的内存机制，function的级别最高，而用箭头函数定义函数的时候，需要var(let const定义的时候更不必说)关键词，而var所定义的变量不能得到变量提升，故箭头函数一定要定义于调用之前！

 -->
<p><style>.post-tip{background-color: #eaf8ff;color: #4e7182;border-left: 5px solid #1eb4ff;padding: 10px;}</style><br><!-- 
  一级 #0472B4
  二级 #1B90D6
--></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/13/html-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lemon">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/background2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/13/html-1/" itemprop="url">你不知道的html</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-13T15:14:18+08:00">
                2021-01-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/四院/" itemprop="url" rel="index">
                    <span itemprop="name">四院</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="a标签的download属性"><a href="#a标签的download属性" class="headerlink" title="a标签的download属性"></a>a标签的download属性</h1><p>a标签的download属性，想必大家都知道它的意义是改变文件下载的名称。但是当跨域下载远程文件的时候，这个属性会存在失效问题。我们今天就来看看，在不用服务器协调的情况下，前端如何自行处理这个问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">const handleDownLoad = () =&gt; &#123;</span><br><span class="line">  const template = &apos;https://festatic-1254389369.cos.ap-guangzhou.myqcloud.com/science/otms/importTemplatestationCreate.csv&apos;;</span><br><span class="line">  const download = &apos;模板.csv&apos;;</span><br><span class="line"></span><br><span class="line">  const x = new XMLHttpRequest();</span><br><span class="line">  x.open(&apos;GET&apos;, template, true);</span><br><span class="line">  x.responseType = &apos;blob&apos;;</span><br><span class="line">  x.onload = () =&gt; &#123;</span><br><span class="line">    const url = window.URL.createObjectURL(x.response);</span><br><span class="line">    const a = document.createElement(&apos;a&apos;);</span><br><span class="line">    a.href = url;</span><br><span class="line">    a.download = download;</span><br><span class="line">    a.click();</span><br><span class="line">  &#125;;</span><br><span class="line">  x.send();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const handleDownLoad = async () =&gt; &#123;</span><br><span class="line">  const template = &apos;https://festatic-1254389369.cos.ap-guangzhou.myqcloud.com/science/otms/importTemplatestationCreate.csv&apos;;</span><br><span class="line">  const download = &apos;模板.csv&apos;;</span><br><span class="line"></span><br><span class="line">  const response = await fetch(template);</span><br><span class="line">  const blob = await response.blob();</span><br><span class="line">  const objectUrl = window.URL.createObjectURL(blob);</span><br><span class="line">  const a = document.createElement(&apos;a&apos;);</span><br><span class="line">  a.href = objectUrl;</span><br><span class="line">  a.download = download;</span><br><span class="line">  document.body.appendChild(a);</span><br><span class="line">  a.click();</span><br><span class="line">  setTimeout(() =&gt; document.body.removeChild(a), 1000);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="post-warning">注意：代码中对创建的&lt;a> 进行的 appendChild 和 remove 操作主要是为了兼容 FireFox 浏览器，在 FireFox 浏览器下调用该方法如果不将创建的&lt;a>标签添加到 body 里，点击链接不会有任何反应，无法触发下载，而在 Chrome 浏览器中则不受此影响。</div>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/background2.jpg" alt="Lemon">
            
              <p class="site-author-name" itemprop="name">Lemon</p>
              <p class="site-description motion-element" itemprop="description">乘风破浪</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lemon</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
