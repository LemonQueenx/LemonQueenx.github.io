<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="乘风破浪">
<meta property="og:type" content="website">
<meta property="og:title" content="小寒">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="小寒">
<meta property="og:description" content="乘风破浪">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小寒">
<meta name="twitter:description" content="乘风破浪">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>小寒</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小寒</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-窝">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            窝
          </a>
        </li>
      
        
        <li class="menu-item menu-item-类">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-档">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-于">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/11/23/charles/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lemon">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/background22.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/11/23/charles/" itemprop="url">charles</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-11-23T14:57:18+08:00">
                2021-11-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Https配置"><a href="#Https配置" class="headerlink" title="Https配置"></a>Https配置</h1><ol>
<li>电脑端安装证书，Help–&gt;SSL proxying–&gt;Install Charles Root Certificate，安装证书，直接都下一步即可</li>
<li>手机端安装证书，打开Charles 的help菜单 –&gt; SSL Proxying –&gt; Install Charles Root Certificate on a Mobile Device or Remote Browser</li>
<li>电脑端配置，Proxy–&gt;SSL Proxying Settings,添加Host为”*.com”,Port为443，后保存。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/10/28/npm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lemon">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/background22.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/10/28/npm/" itemprop="url">npm</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-10-28T17:59:21+08:00">
                2021-10-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/专题/" itemprop="url" rel="index">
                    <span itemprop="name">专题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h1><p>  npm get registry<br>  npm config set registry xxx<br>  npm adduser –registry xxx<br>  npm profile set password –registry xxx</p>
<p>  npm publish<br>  发布📢：</p>
<ul>
<li>发布之前记得build编译，小包使用rollup打包很简单</li>
<li><p>发布在公司内源的话，需要改变项目的npm源。.npmrc registry=’xxx’</p>
<p>npm view npm包 versions</p>
</li>
</ul>
<h1 id="npm包"><a href="#npm包" class="headerlink" title="npm包"></a>npm包</h1><p>  # </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/23/react源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lemon">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/background22.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/23/react源码解析/" itemprop="url">react源码解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-23T15:00:59+08:00">
                2021-08-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/框架/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><pre><code>我们每天都在使用react，但是对于react的实现原理却不一定知其所以然。

于是我们打开react包（17.0.2），发现，咦，为什么只有3000多行代码❓

很快，我们就会意识到，原来是分包了（2015-10），还有react-dom（17.0.2），一打开，26000多行，哦哦，对的。

因为react不止针对web了，还有移动端（react-native），所以就分包了。react实现主干逻辑，react-dom针对 dom 的平台实现，主要用于在 web 端进行渲染。

3000+26000多行代码，令人头大，不管了，🔥 热情来了，说干就干。就从最眼熟的开始（ReactDOM.render）下手，杀熟 😎。就问你这 🍉 保熟吗？。
</code></pre><h2 id="直接看源码"><a href="#直接看源码" class="headerlink" title="直接看源码"></a>直接看源码</h2><h3 id="ReactDOM-render"><a href="#ReactDOM-render" class="headerlink" title="ReactDOM.render"></a>ReactDOM.render</h3><pre><code>尽量乱中有序。
我们一点一点看，首先，整体来看ReactDOM，最外层是一个立即执行函数iife，写源码或者写jquery的时候，一般都是用iife的模块化方式。（当时的想法）
</code></pre><p>  <code>(function (a, b) {……}(c, d))</code></p>
<pre><code>借着细看，这个立即函数有两个参数，一个对象，一个函数。立即函数的内容是判断多种条件下，给参数函数传参后执行。
</code></pre>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">global, factory</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">typeof</span> exports === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span> !== <span class="string">'undefined'</span> ? factory(exports, <span class="built_in">require</span>(<span class="string">'react'</span>)) :</span><br><span class="line">  <span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd ? define([<span class="string">'exports'</span>, <span class="string">'react'</span>], factory) :</span><br><span class="line">  (global = global || self, factory(global.ReactDOM = &#123;&#125;, global.React));</span><br><span class="line">&#125;(<span class="keyword">this</span>, (<span class="function"><span class="keyword">function</span> (<span class="params">exports, React</span>) </span>&#123; </span><br><span class="line">  ...</span><br><span class="line">  exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;</span><br><span class="line">  exports.createPortal = createPortal$<span class="number">1</span>;</span><br><span class="line">  exports.findDOMNode = findDOMNode;</span><br><span class="line">  exports.flushSync = flushSync;</span><br><span class="line">  exports.hydrate = hydrate;</span><br><span class="line">  exports.render = render;</span><br><span class="line">  exports.unmountComponentAtNode = unmountComponentAtNode;</span><br><span class="line">  exports.unstable_batchedUpdates = batchedUpdates$<span class="number">1</span>;</span><br><span class="line">  exports.unstable_createPortal = unstable_createPortal;</span><br><span class="line">  exports.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;</span><br><span class="line">  exports.version = ReactVersion;</span><br><span class="line">&#125;)));</span><br></pre></td></tr></table></figure>
<pre><code>看到这段代码，我们好像知道点啥，但是又说不清。不管可，先关心主要问题，看看 ReactDOM.render 到底做了什么。于是梳理了两遍，写了3页笔记。。。

只是大抵看了调用关系，但是并没有搞清楚每一行代码，因为真的是太多了（看我的3页笔记），真要靠光看源码去看懂框架，真的是需要投入大量的时间。甚至仅通过查看代码的方法很难真正理解react。

不过也不要太灰心，看了一遍，多多少少还是有点收获的，先记录一下这点可怜的收获：
</code></pre><h4 id="1、ReactDOM-render"><a href="#1、ReactDOM-render" class="headerlink" title="1、ReactDOM.render"></a>1、ReactDOM.render</h4><pre><code>整体来看，先返回了一个FiberRootNode，FiberRootNode上绑定了所有支持的事件，之后执行了updateContainer。

updateContainer里，我们还能看到createUpdate创建更新，enqueueUpdate排序标记更新优先级，scheduleUpdateOnFiber调度更新到Fiber上，以及commit阶段提交优先级，这里还能看到一些时间（expirationTime）的计算。

具体来看：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM = &#123;</span><br><span class="line">  render(</span><br><span class="line">    element: React$Element&lt;any&gt;,</span><br><span class="line">    container: DOMContainer,</span><br><span class="line">    callback: ?Function,</span><br><span class="line">  ) &#123;</span><br><span class="line">    return legacyRenderSubtreeIntoContainer(</span><br><span class="line">      null,</span><br><span class="line">      element,</span><br><span class="line">      container,</span><br><span class="line">      false,</span><br><span class="line">      callback,</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 首先会创建ReactRoot对象，然后调用他的render方法</span><br><span class="line"># 创建ReactRoot的时候会调用DOMRenderer.createContainer创建FiberRoot，在后期调度更新的过程中这个节点非常重要</span><br><span class="line"></span><br><span class="line">function legacyRenderSubtreeIntoContainer(</span><br><span class="line">  parentComponent: ?React$Component&lt;any, any&gt;,</span><br><span class="line">  children: ReactNodeList,</span><br><span class="line">  container: DOMContainer,</span><br><span class="line">  forceHydrate: boolean,</span><br><span class="line">  callback: ?Function,</span><br><span class="line">) &#123;</span><br><span class="line">  var root = container._reactRootContainer;</span><br><span class="line">  var fiberRoot;</span><br><span class="line"></span><br><span class="line">  if (!root) &#123;</span><br><span class="line">    // Initial mount</span><br><span class="line">    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate);</span><br><span class="line">    fiberRoot = root._internalRoot;</span><br><span class="line"></span><br><span class="line">    if (typeof callback === &apos;function&apos;) &#123;</span><br><span class="line">      var originalCallback = callback;</span><br><span class="line"></span><br><span class="line">      callback = function () &#123;</span><br><span class="line">        var instance = getPublicRootInstance(fiberRoot);</span><br><span class="line">        originalCallback.call(instance);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125; // Initial mount should not be batched.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    unbatchedUpdates(function () &#123;</span><br><span class="line">      updateContainer(children, fiberRoot, parentComponent, callback);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    fiberRoot = root._internalRoot;</span><br><span class="line"></span><br><span class="line">    if (typeof callback === &apos;function&apos;) &#123;</span><br><span class="line">      var _originalCallback = callback;</span><br><span class="line"></span><br><span class="line">      callback = function () &#123;</span><br><span class="line">        var instance = getPublicRootInstance(fiberRoot);</span><br><span class="line"></span><br><span class="line">        _originalCallback.call(instance);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125; // Update</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    updateContainer(children, fiberRoot, parentComponent, callback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return getPublicRootInstance(fiberRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function legacyCreateRootFromDOMContainer(</span><br><span class="line">  container: DOMContainer,</span><br><span class="line">  forceHydrate: boolean,</span><br><span class="line">): Root &#123;</span><br><span class="line">  var shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container); // First clear any existing content.</span><br><span class="line"></span><br><span class="line">  if (!shouldHydrate) &#123;</span><br><span class="line">    var warned = false;</span><br><span class="line">    var rootSibling;</span><br><span class="line"></span><br><span class="line">    while (rootSibling = container.lastChild) &#123;</span><br><span class="line">      &#123;</span><br><span class="line">        if (!warned &amp;&amp; rootSibling.nodeType === ELEMENT_NODE &amp;&amp; rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) &#123;</span><br><span class="line">          warned = true;</span><br><span class="line"></span><br><span class="line">          error(&apos;render(): Target node has markup rendered by React, but there &apos; + &apos;are unrelated nodes as well. This is most commonly caused by &apos; + &apos;white-space inserted around server-rendered markup.&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      container.removeChild(rootSibling);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    if (shouldHydrate &amp;&amp; !forceHydrate &amp;&amp; !warnedAboutHydrateAPI) &#123;</span><br><span class="line">      warnedAboutHydrateAPI = true;</span><br><span class="line"></span><br><span class="line">      warn(&apos;render(): Calling ReactDOM.render() to hydrate server-rendered markup &apos; + &apos;will stop working in React v18. Replace the ReactDOM.render() call &apos; + &apos;with ReactDOM.hydrate() if you want React to attach to the server HTML.&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return new ReactDOMBlockingRoot(container, LegacyRoot, options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ReactDOMBlockingRoot(container, tag, options) &#123;</span><br><span class="line">  this._internalRoot = createRootImpl(container, tag, options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOMRoot.prototype.render = ReactDOMBlockingRoot.prototype.render = function (children) &#123;</span><br><span class="line">  var root = this._internalRoot;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    if (typeof arguments[1] === &apos;function&apos;) &#123;</span><br><span class="line">      error(&apos;render(...): does not support the second callback argument. &apos; + &apos;To execute a side effect after rendering, declare it in a component body with useEffect().&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var container = root.containerInfo;</span><br><span class="line"></span><br><span class="line">    if (container.nodeType !== COMMENT_NODE) &#123;</span><br><span class="line">      var hostInstance = findHostInstanceWithNoPortals(root.current);</span><br><span class="line"></span><br><span class="line">      if (hostInstance) &#123;</span><br><span class="line">        if (hostInstance.parentNode !== container) &#123;</span><br><span class="line">          error(&apos;render(...): It looks like the React-rendered content of the &apos; + &apos;root container was removed without using React. This is not &apos; + &apos;supported and will cause errors. Instead, call &apos; + &quot;root.unmount() to empty a root&apos;s container.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  updateContainer(children, root, null, null);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ReactDOMRoot.prototype.unmount = ReactDOMBlockingRoot.prototype.unmount = function () &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    if (typeof arguments[0] === &apos;function&apos;) &#123;</span><br><span class="line">      error(&apos;unmount(...): does not support a callback argument. &apos; + &apos;To execute a side effect after rendering, declare it in a component body with useEffect().&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var root = this._internalRoot;</span><br><span class="line">  var container = root.containerInfo;</span><br><span class="line">  updateContainer(null, root, null, function () &#123;</span><br><span class="line">    unmarkContainerAsRoot(container);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function createRootImpl(container, tag, options) &#123;</span><br><span class="line">  // Tag is either LegacyRoot or Concurrent Root</span><br><span class="line">  var hydrate = options != null &amp;&amp; options.hydrate === true;</span><br><span class="line">  var hydrationCallbacks = options != null &amp;&amp; options.hydrationOptions || null;</span><br><span class="line">  var mutableSources = options != null &amp;&amp; options.hydrationOptions != null &amp;&amp; options.hydrationOptions.mutableSources || null;</span><br><span class="line">  var root = createContainer(container, tag, hydrate);</span><br><span class="line">  markContainerAsRoot(root.current, container);</span><br><span class="line">  var containerNodeType = container.nodeType;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;</span><br><span class="line">    listenToAllSupportedEvents(rootContainerElement);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (mutableSources) &#123;</span><br><span class="line">    for (var i = 0; i &lt; mutableSources.length; i++) &#123;</span><br><span class="line">      var mutableSource = mutableSources[i];</span><br><span class="line">      registerMutableSourceForHydration(root, mutableSource);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createContainer(containerInfo, tag, hydrate, hydrationCallbacks) &#123;</span><br><span class="line">  return createFiberRoot(containerInfo, tag, hydrate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks) &#123;</span><br><span class="line">  var root = new FiberRootNode(containerInfo, tag, hydrate);</span><br><span class="line">  // stateNode is any.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  var uninitializedFiber = createHostRootFiber(tag);</span><br><span class="line">  root.current = uninitializedFiber;</span><br><span class="line">  uninitializedFiber.stateNode = root;</span><br><span class="line">  initializeUpdateQueue(uninitializedFiber);</span><br><span class="line">  return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function FiberRootNode(containerInfo, tag, hydrate) &#123;</span><br><span class="line">  this.tag = tag;</span><br><span class="line">  this.containerInfo = containerInfo;</span><br><span class="line">  this.pendingChildren = null;</span><br><span class="line">  this.current = null;</span><br><span class="line">  this.pingCache = null;</span><br><span class="line">  this.finishedWork = null;</span><br><span class="line">  this.timeoutHandle = noTimeout;</span><br><span class="line">  this.context = null;</span><br><span class="line">  this.pendingContext = null;</span><br><span class="line">  this.hydrate = hydrate;</span><br><span class="line">  this.callbackNode = null;</span><br><span class="line">  this.callbackPriority = NoLanePriority;</span><br><span class="line">  this.eventTimes = createLaneMap(NoLanes);</span><br><span class="line">  this.expirationTimes = createLaneMap(NoTimestamp);</span><br><span class="line">  this.pendingLanes = NoLanes;</span><br><span class="line">  this.suspendedLanes = NoLanes;</span><br><span class="line">  this.pingedLanes = NoLanes;</span><br><span class="line">  this.expiredLanes = NoLanes;</span><br><span class="line">  this.mutableReadLanes = NoLanes;</span><br><span class="line">  this.finishedLanes = NoLanes;</span><br><span class="line">  this.entangledLanes = NoLanes;</span><br><span class="line">  this.entanglements = createLaneMap(NoLanes);</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    this.mutableSourceEagerHydrationData = null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    this.interactionThreadID = unstable_getThreadID();</span><br><span class="line">    this.memoizedInteractions = new Set();</span><br><span class="line">    this.pendingInteractionMap = new Map();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    switch (tag) &#123;</span><br><span class="line">      case BlockingRoot:</span><br><span class="line">        this._debugRootType = &apos;createBlockingRoot()&apos;;</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">      case ConcurrentRoot:</span><br><span class="line">        this._debugRootType = &apos;createRoot()&apos;;</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">      case LegacyRoot:</span><br><span class="line">        this._debugRootType = &apos;createLegacyRoot()&apos;;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function listenToAllSupportedEvents(rootContainerElement) &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    if (rootContainerElement[listeningMarker]) &#123;</span><br><span class="line">      // Performance optimization: don&apos;t iterate through events</span><br><span class="line">      // for the same portal container or root node more than once.</span><br><span class="line">      // TODO: once we remove the flag, we may be able to also</span><br><span class="line">      // remove some of the bookkeeping maps used for laziness.</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rootContainerElement[listeningMarker] = true;</span><br><span class="line">    allNativeEvents.forEach(function (domEventName) &#123;</span><br><span class="line">      if (!nonDelegatedEvents.has(domEventName)) &#123;</span><br><span class="line">        listenToNativeEvent(domEventName, false, rootContainerElement, null);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      listenToNativeEvent(domEventName, true, rootContainerElement, null);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 其中DOMRenderer是react-reconciler/src/ReactFiberReconciler，他的updateContainer如下在这里计算了一个时间，这个时间叫做expirationTime，顾名思义就是这次更新的 超时时间。</span><br><span class="line"></span><br><span class="line"># 然后调用了updateContainerAtExpirationTime，在这个方法里调用了scheduleRootUpdate就非常重要了</span><br><span class="line"></span><br><span class="line">export function updateContainer(</span><br><span class="line">  element: ReactNodeList,</span><br><span class="line">  container: OpaqueRoot,</span><br><span class="line">  parentComponent: ?React$Component&lt;any, any&gt;,</span><br><span class="line">  callback: ?Function,</span><br><span class="line">): ExpirationTime &#123;</span><br><span class="line">  const current = container.current</span><br><span class="line">  const currentTime = requestCurrentTime()</span><br><span class="line">  const expirationTime = computeExpirationForFiber(currentTime, current)</span><br><span class="line">  return updateContainerAtExpirationTime(</span><br><span class="line">    element,</span><br><span class="line">    container,</span><br><span class="line">    parentComponent,</span><br><span class="line">    expirationTime,</span><br><span class="line">    callback,</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function updateContainerAtExpirationTime(</span><br><span class="line">  element: ReactNodeList,</span><br><span class="line">  container: OpaqueRoot,</span><br><span class="line">  parentComponent: ?React$Component&lt;any, any&gt;,</span><br><span class="line">  expirationTime: ExpirationTime,</span><br><span class="line">  callback: ?Function,</span><br><span class="line">) &#123;</span><br><span class="line">  // TODO: If this is a nested container, this won&apos;t be the root.</span><br><span class="line">  const current = container.current</span><br><span class="line">  const context = getContextForSubtree(parentComponent)</span><br><span class="line">  if (container.context === null) &#123;</span><br><span class="line">    container.context = context</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    container.pendingContext = context</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return scheduleRootUpdate(current, element, expirationTime, callback)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 开始调度</span><br><span class="line"># 首先要生成一个update，不管你是setState还是ReactDOM.render造成的 React 更新，都会生成一个叫update的对象，并且会赋值给Fiber.updateQueue</span><br><span class="line"># 然后就是调用scheduleWork。注意到这里之前setState和ReactDOM.render是不一样，但进入schedulerWork之后，就是任务调度的事情了，跟之前你是怎么调用的没有任何关系</span><br><span class="line"></span><br><span class="line">function scheduleRootUpdate(</span><br><span class="line">  current: Fiber,</span><br><span class="line">  element: ReactNodeList,</span><br><span class="line">  expirationTime: ExpirationTime,</span><br><span class="line">  callback: ?Function,</span><br><span class="line">) &#123;</span><br><span class="line">  const update = createUpdate(expirationTime)</span><br><span class="line"></span><br><span class="line">  update.payload = &#123; element &#125;</span><br><span class="line"></span><br><span class="line">  callback = callback === undefined ? null : callback</span><br><span class="line">  if (callback !== null) &#123;</span><br><span class="line">    warningWithoutStack(</span><br><span class="line">      typeof callback === &apos;function&apos;,</span><br><span class="line">      &apos;render(...): Expected the last optional `callback` argument to be a &apos; +</span><br><span class="line">        &apos;function. Instead received: %s.&apos;,</span><br><span class="line">      callback,</span><br><span class="line">    )</span><br><span class="line">    update.callback = callback</span><br><span class="line">  &#125;</span><br><span class="line">  enqueueUpdate(current, update)</span><br><span class="line"></span><br><span class="line">  scheduleWork(current, expirationTime)</span><br><span class="line">  return expirationTime</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="2、cjs、amd、umd和esm"><a href="#2、cjs、amd、umd和esm" class="headerlink" title="2、cjs、amd、umd和esm"></a>2、cjs、amd、umd和esm</h4><pre><code>JavaScript最初仅用于交互式浏览器。与Node一起，可在非浏览器上下文中使用。由于这个因素和其他因素，模块的格式不兼容。CJS、AMD、UMD 和 ESM都是给 Javascript 添加模块化的方法，还有其他方法，但这些是比较通用的。
</code></pre><p>  <strong>CJS</strong> ，CommonJS，是同步导入模块，描述了 exports 对象的使用。 NodeJS是CommonJS格式的最流行实现。不允许在交互式浏览器中加载CommonJS模块，它必须经过转换和打包。<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入：都可以起作用,当 CJS 导入时，它会给你一个导入对象的副本。</span></span><br><span class="line"><span class="keyword">const</span> doSomething = <span class="built_in">require</span>(<span class="string">'./doSomething.js'</span>); 或 <span class="keyword">const</span> React = <span class="built_in">require</span>(<span class="string">'react'</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出：</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;...&#125;;</span><br></pre></td></tr></table></figure></p>
<pre><code>每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。
CommonJS规范加载模块是同步的，由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用
</code></pre><blockquote>
<p>主要特点：<br>所有代码都运行在模块作用域，不会污染全局作用域<br>模块可以多次加载，但是只会在第一次加载的时候执行，然后会缓存一份，后面再引用返回的都是缓存<br>模块加载的顺序是按照出现的位置来定<br>因为被输出的是拷贝值，则如果在外部对模块代码就行修改则不会生效<br>一般用于服务端的规范</p>
</blockquote>
<p>  <strong>AMD</strong>，Asynchronously  Module Definition，异步模块定义，描述了如何在假定将JavaScript模块加载到交互式浏览器中的情况下捆绑JavaScript模块。</p>
<p>  跟CJS并称量大通用模块规范，主要用于客户端，因为客户端在加载的时候主要看中加载速度，如果像是CJS那样同步执行的话，在加载一个很大的组件的情况下会相当的耽误时间，所以催生了AMD客户端的异步规范。<br>  第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">'lodash'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">lh</span>) </span>&#123;</span><br><span class="line">  lo.isArray([]);</span><br><span class="line">  <span class="comment">// Define the module value by returning a value.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>  <strong>UMD</strong>，Universal Module Definition，通用模块定义，是一种尝试制作可被使用的模块的模式。为了同时支持CJS和AMD的规范，判断谁的规范支持就使用谁的规范，他的最外层是一个iife。<br>    在前端和后端都适用（“通用”因此得名）<br>    与 CJS 或 AMD 不同，UMD 更像是一种配置多个模块系统的模式。这里可以找到更多的模式<br>    当使用 Rollup/Webpack 之类的打包器时，UMD 通常用作备用模块<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">root, factory</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">"function"</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">    define([<span class="string">"jquery"</span>, <span class="string">"underscore"</span>], factory);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> exports === <span class="string">"object"</span>) &#123;</span><br><span class="line">    <span class="built_in">module</span>.exports = factory(<span class="built_in">require</span>(<span class="string">"jquery"</span>), <span class="built_in">require</span>(<span class="string">"underscore"</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    root.Requester = factory(root.$, root._);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params">$, _</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// this is where I defined my module implementation</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> Requester = &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Requester;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure></p>
<pre><code>恍然，因为我打开的是umd/react-dom.development.js，所以上面那么写，其实叫umd规范写法。哈哈哈。
</code></pre><p>  <strong>ESM</strong>，ECMAScript Module，2015定义了 export 和 import 语法（不同于上述所有内容）以支持模块。<br>    它兼具两方面的优点：具有 CJS 的简单语法和 AMD 的异步<br>    得益于 ES6 的静态模块结构，可以进行 Tree Shaking<br>    ESM 允许像 Rollup 这样的打包器，删除不必要的代码，减少代码包可以获得更快的加载<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;foo, bar&#125; <span class="keyword">from</span> <span class="string">'./myLib'</span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// your Function</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> function1() &#123;...&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> function2() &#123;...&#125;;</span><br></pre></td></tr></table></figure></p>
<p>  ESM由于具有简单的语法，异步加载的特性，以及Tree-shakeable的特性，因此被广泛使用。<br>  UMD可以在任何环境下使用，并且在ESM不能使用的情况下选择UMD。<br>  CJS是同步的，适用于后端环境。<br>  AMD是异步的，适用于前端环境。</p>
<p>  到这里，我们再看直接看源码的第一步，为什么会这样写，这就是umd规范吖。因为我打开的是umd/react-dom.development.js，虽然之前也不是十分了解umd到底是什么，但是就是觉得应该看umd的。哈哈哈。<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">global, factory</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">typeof</span> exports === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span> !== <span class="string">'undefined'</span> ? factory(exports, <span class="built_in">require</span>(<span class="string">'react'</span>)) :</span><br><span class="line">  <span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd ? define([<span class="string">'exports'</span>, <span class="string">'react'</span>], factory) :</span><br><span class="line">  (global = global || self, factory(global.ReactDOM = &#123;&#125;, global.React));</span><br><span class="line">&#125;(<span class="keyword">this</span>, (<span class="function"><span class="keyword">function</span> (<span class="params">exports, React</span>) </span>&#123; </span><br><span class="line">  ...</span><br><span class="line">  exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;</span><br><span class="line">  exports.createPortal = createPortal$<span class="number">1</span>;</span><br><span class="line">  exports.findDOMNode = findDOMNode;</span><br><span class="line">  exports.flushSync = flushSync;</span><br><span class="line">  exports.hydrate = hydrate;</span><br><span class="line">  exports.render = render;</span><br><span class="line">  exports.unmountComponentAtNode = unmountComponentAtNode;</span><br><span class="line">  exports.unstable_batchedUpdates = batchedUpdates$<span class="number">1</span>;</span><br><span class="line">  exports.unstable_createPortal = unstable_createPortal;</span><br><span class="line">  exports.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;</span><br><span class="line">  exports.version = ReactVersion;</span><br><span class="line">&#125;)));</span><br></pre></td></tr></table></figure></p>
<p>  其实对于这个模块化话题，还可以探索地更深，但是我们的主题是react源码，就先到这了。</p>
<h4 id="3、其他小点"><a href="#3、其他小点" class="headerlink" title="3、其他小点"></a>3、其他小点</h4><p>  <code>节点类型 nodeType</code></p>
<table>
<thead>
<tr>
<th>节点类型</th>
<th>描述</th>
<th>子节点</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 Element</td>
<td>代表元素</td>
<td>Element, Text, Comment, ProcessingInstruction, CDATASection, EntityReference</td>
</tr>
<tr>
<td>2 Attr</td>
<td>代表属性</td>
<td>Text, EntityReference</td>
</tr>
<tr>
<td>3 Text</td>
<td>代表元素或属性中的文本内容。</td>
<td>None</td>
</tr>
<tr>
<td>4 CDATASection</td>
<td>代表文档中的 CDATA 部分（不会由解析器解析的文本）。</td>
<td>None</td>
</tr>
<tr>
<td>5 EntityReference</td>
<td>代表实体引用。</td>
<td>Element, ProcessingInstruction, Comment, Text, CDATASection, EntityReference</td>
</tr>
<tr>
<td>6 Entity</td>
<td>代表实体。</td>
<td>Element, ProcessingInstruction, Comment, Text, CDATASection, EntityReference</td>
</tr>
<tr>
<td>7 ProcessingInstruction</td>
<td>代表处理指令。</td>
<td>None</td>
</tr>
<tr>
<td>8 Comment</td>
<td>代表注释。</td>
<td>None</td>
</tr>
<tr>
<td>9 Document</td>
<td>代表整个文档（DOM 树的根节点）。</td>
<td>Element, ProcessingInstruction, Comment, DocumentType</td>
</tr>
<tr>
<td>10 DocumentType</td>
<td>向为文档定义的实体提供接口</td>
<td>None</td>
</tr>
<tr>
<td>11 DocumentFragment</td>
<td>代表轻量级的 Document 对象，能够容纳文档的某个部分</td>
<td>Element, ProcessingInstruction, Comment, Text, CDATASection, EntityReference</td>
</tr>
<tr>
<td>12 Notation</td>
<td>代表 DTD 中声明的符号。</td>
<td>None</td>
</tr>
</tbody>
</table>
<p>  <code>{ } 封闭作用域</code><br>  <code>!! 真假</code><br>  <code>‘’ + ‘’ 拼接长字符串</code><br>  <code>‘xxx’ + Math.random.toString(36).slice(2) 打标识</code></p>
<p>  开啃之后就会发现，小丑 🤡 果然还是自己，直接上口真是吃不消，还是要有方法去看这种大框架源码。<br>  不是一朝一夕的事情，要有足够的耐心和时间才行。</p>
<h2 id="怎么学react源码"><a href="#怎么学react源码" class="headerlink" title="怎么学react源码"></a>怎么学react源码</h2><pre><code>直接看源码，就像是盲人摸象，不，应该是盲蚂蚁 🐜 摸象 🐘， 这不是一朝一夕就能完成的事情。
痛定思痛：一定要先找出我们的大方向，循序渐进。
边看成熟的结论，边看源码实现，相辅相成，反复验证。
</code></pre>  <!-- - 前人的肩膀推荐：
    [React 源码解析](https://react.jokcy.me/) ，从API的角度解析react。
    [全栈潇晨-react源码解析](https://xiaochen1024.com/courseware/60b1b2f6cf10a4003b634718/60b1b311cf10a4003b634719)，从API和抽象角度解析react。
    [React官方-实现说明](https://zh-hans.reactjs.org/docs/implementation-notes.html)
  - 源码可以直接 download react 源码，也可以直接看包中的umd的development.js。 -->
<p>  看我们带着什么样的目的去看react源码</p>
<p><br><br><br><br><br><br><br></p>
<h1 id="二、react源码框架总览"><a href="#二、react源码框架总览" class="headerlink" title="二、react源码框架总览"></a>二、react源码框架总览</h1><p>  我们一步一步深入了解，然后制定出相对满意的长期学习计划。从上帝视角，俯冲向下，直至一个个平民。<br>  <div class="post-desc">react的核心可以用ui = fn(state)来表示，更详细可以用：<br>    const state = reconcile (update);<br>    const UI = commit (state);<br>  </div></p>
<p>  状态更新视图，调度器，协调器，渲染器。<br>  <canvas id="react-zong" width="500" height="390"></canvas></p>
  <script>const oReactZong = document.getElementById('react-zong');const oReactZongPen = oReactZong.getContext('2d');oReactZongPen.fillText('jsx', 28, 220);oReactZongPen.fillText('task2', 155, 133);oReactZongPen.fillText('中优先级', 150, 146);oReactZongPen.fillText('task3', 155, 165);oReactZongPen.fillText('低优先级', 150, 175);oReactZongPen.fillText('task1', 268, 133);oReactZongPen.fillText('高优先级', 260, 146);oReactZongPen.fillStyle='blue';oReactZongPen.fillText('mount/update', 2, 190);oReactZongPen.fillText('render阶段', 250, 100);oReactZongPen.fillText('在内存中进行', 180, 350);oReactZongPen.fillText('commit阶段', 410, 100);oReactZongPen.font = '14px sans-serif';oReactZongPen.fillText('Scheduler', 135, 210);oReactZongPen.fillText('（调度器）', 130, 225);oReactZongPen.fillText('Reconciler', 245, 210);oReactZongPen.fillText('（协调器）', 239, 225);oReactZongPen.fillText('Renderer', 409, 210);oReactZongPen.fillText('（渲染器）', 405, 225);oReactZongPen.lineWidth = 0.5;oReactZongPen.strokeStyle = 'black';oReactZongPen.beginPath();oReactZongPen.setLineDash([2]);oReactZongPen.strokeRect( 5 , 203 , 60, 30 );oReactZongPen.stroke();oReactZongPen.beginPath();oReactZongPen.arc(305, 90, 20, -Math.PI/2 , Math.PI, true);oReactZongPen.arc(265, 90, 20, 0, -Math.PI/2, true);oReactZongPen.font = '10px sans-serif';oReactZongPen.fillStyle='black';oReactZongPen.fillText('根据update计算state', 240, 40);oReactZongPen.fillText('diff算法', 270, 52);oReactZongPen.fillText('给Fiber打上Flags', 250, 64);oReactZongPen.lineTo(233, 70);oReactZongPen.lineTo(233, 25);oReactZongPen.lineTo(343, 25);oReactZongPen.lineTo(343, 70);oReactZongPen.closePath();oReactZongPen.stroke();oReactZongPen.beginPath();oReactZongPen.arc(460, 90, 20, -Math.PI/2 , Math.PI, true);oReactZongPen.arc(420, 90, 20, 0, -Math.PI/2, true);oReactZongPen.fillText('react-dom', 415, 28);oReactZongPen.fillText('react-art', 415, 40);oReactZongPen.fillText('......', 420, 52);oReactZongPen.fillText('操作DOM', 415, 64);oReactZongPen.lineTo(400, 70);oReactZongPen.lineTo(400, 15);oReactZongPen.lineTo(480, 15);oReactZongPen.lineTo(480, 70);oReactZongPen.closePath();oReactZongPen.stroke();oReactZongPen.beginPath();oReactZongPen.arc(150, 90, 20, -Math.PI/2 , Math.PI, true);oReactZongPen.arc(110, 90, 20, 0, -Math.PI/2, true);oReactZongPen.font = '10px sans-serif';oReactZongPen.fillStyle='black';oReactZongPen.fillText('如果低优先级task被打断，', 75, 40);oReactZongPen.fillText('也只是发生在内存中，', 85, 52);oReactZongPen.fillText('不影响真实节点', 95, 64);oReactZongPen.lineTo(64, 70);oReactZongPen.lineTo(64, 25);oReactZongPen.lineTo(200, 25);oReactZongPen.lineTo(200, 70);oReactZongPen.closePath();oReactZongPen.stroke();oReactZongPen.beginPath();oReactZongPen.strokeRect( 98 , 85 , 260 , 280 );oReactZongPen.stroke();oReactZongPen.beginPath();oReactZongPen.setLineDash([]);oReactZongPen.lineTo(65, 220);oReactZongPen.lineTo(123, 220);oReactZongPen.fillStyle='black';oReactZongPen.fillText('→' , 119, 223);oReactZongPen.stroke();oReactZongPen.beginPath();oReactZongPen.strokeRect( 130 , 120 , 80 , 200 );oReactZongPen.setLineDash([2]);oReactZongPen.lineTo(130, 150);oReactZongPen.lineTo(210, 150);oReactZongPen.stroke();oReactZongPen.beginPath();oReactZongPen.lineTo(130, 180);oReactZongPen.lineTo(210, 180);oReactZongPen.stroke();oReactZongPen.beginPath();oReactZongPen.setLineDash([]);oReactZongPen.strokeRect( 240 , 120 , 80 , 200 );oReactZongPen.setLineDash([2]);oReactZongPen.lineTo(240, 150);oReactZongPen.lineTo(320, 150);oReactZongPen.stroke();oReactZongPen.beginPath();oReactZongPen.setLineDash([]);oReactZongPen.strokeRect( 400 , 120 , 80 , 200 );</script>


<p>  <img src="https://img-blog.csdnimg.cn/img_convert/f81d27cf172e1ea3718b9d54cdf8e307.png" alt="tusods"></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">创建更新</span><br><span class="line">    ReactDOM.render</span><br><span class="line">    setState &amp; forceUpdate</span><br><span class="line">    expirationTime 计算</span><br><span class="line">任务调度</span><br><span class="line">    全局变量</span><br><span class="line">    scheduleWork</span><br><span class="line">    react-scheduler</span><br><span class="line">    performWork</span><br><span class="line">    performUnitOfWork</span><br><span class="line">    renderRoot</span><br><span class="line">    beginWork</span><br><span class="line">    reconcileChildren</span><br><span class="line">commit 阶段</span><br><span class="line">    commitRoot</span><br><span class="line">    invokeGuardedCallback</span><br><span class="line">    commitBeforeMutationLifecycles</span><br><span class="line">    commitAllHostEffects</span><br><span class="line">    commitPlacement</span><br><span class="line">功能</span><br><span class="line">    context</span><br><span class="line">    hydrate</span><br><span class="line">    ref</span><br><span class="line">    事件系统初始化</span><br><span class="line">    事件绑定</span><br><span class="line">    事件触发</span><br><span class="line">    事件对象生成</span><br><span class="line">    Suspense</span><br><span class="line">    挂起任务的含义</span><br><span class="line">    lazy 组件</span><br></pre></td></tr></table></figure>
<p>  fiberRoot是整个项目的根节点，只存在一个，rootFiber是应用的根节点，可能存在多个，例如多个ReactDOM.render(&lt; App /&gt;, document.getElementById(“root”));创建多个应用节点</p>
<h2 id="jsx"><a href="#jsx" class="headerlink" title="jsx"></a>jsx</h2><p>  <code>jsx</code> 声明式地编写我们想要的UI效果，本质上是React.createElement的语法糖。语法糖的意思就是二者本质是等价的，只是裹了一层糖衣（写起来更甜更简单直接）。这层糖衣就是babel来做的，react通过babel词法解析，将jsx转换成React.createElement。</p>
<p>  React.createElement方法返回virtual dom对象（内存中用来描述dom阶段的对象）。</p>
<h2 id="Fiber双缓存"><a href="#Fiber双缓存" class="headerlink" title="Fiber双缓存"></a>Fiber双缓存</h2><pre><code>Fiber对象映射节点信息。Fiber对象（FiberRootNode、FiberNode）上保存了这个节点的属性、类型、dom（child、sibling）等，Fiber通过child、sibling、return（指向父节点）来形成Fiber树。还保存了更新状态时用于计算state的updateQueue，updateQueue是一种链表结构，上面可能存在多个未计算的update，update也是一种数据结构，上面包含了更新的数据、优先级等，除了这些之外，上面还有和副作用有关的信息。

双缓存是指有两棵Fiber树，current Fiber树描述了当前已经呈现的dom树，workInProgress Fiber树是正在更新的Fiber树。当workInProgress Fiber树构建完成后，会将其作为current Fiber树更新到真实Dom树上。

在mount（装载，首次渲染）时，会根据jsx对象（class component的render函数或者Function Component的返回值）生成workInProgress Fiber树，把workInProgress Fiber切换成current Fiber，Current Fiber树应用到真实的dom上。在update（状态更新，如setState）时，会根据状态更新后的jsx对象和Current fiber树作对比逐渐形成新的workInProgress Fiber树，workInProgress Fiber构建完成后会替换成Current Fiber，更新到真实的dom上。而这一切都是在内存中进行的，减少真实dom渲染耗性能。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line">  return (</span><br><span class="line">    &lt;h1</span><br><span class="line">      onClick=&#123;() =&gt; &#123;</span><br><span class="line">        setCount(() =&gt; count + 1);</span><br><span class="line">      &#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">        &lt;p title=&#123;count&#125;&gt;&#123;count&#125;&lt;/p&gt; jyy</span><br><span class="line">    &lt;/h1&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById(&quot;root&quot;));</span><br></pre></td></tr></table></figure>
</code></pre>  <canvas id="react-fiber" width="600" height="500"></canvas>

  <script>const oReactFiber = document.getElementById('react-fiber');const oReactFiberPen = oReactFiber.getContext('2d');oReactFiberPen.font = '14px sans-serif';oReactFiberPen.fillStyle='black';oReactFiberPen.strokeRect(245, 10, 110, 40);oReactFiberPen.strokeRect(160, 120, 90, 40);oReactFiberPen.strokeRect(160, 210, 90, 40);oReactFiberPen.strokeRect(160, 300, 90, 40);oReactFiberPen.strokeRect(160, 390, 90, 40);oReactFiberPen.strokeRect(30, 391, 50, 38);oReactFiberPen.strokeRect(348, 120, 90, 40);oReactFiberPen.strokeRect(348, 210, 90, 40);oReactFiberPen.strokeRect(348, 300, 90, 40);oReactFiberPen.strokeRect(348, 390, 90, 40);oReactFiberPen.strokeRect(520, 391, 50, 38);oReactFiberPen.beginPath();oReactFiberPen.lineTo(245, 50);oReactFiberPen.lineTo(180, 120);oReactFiberPen.lineTo(181, 111);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(180, 120);oReactFiberPen.lineTo(190, 117);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(220, 120);oReactFiberPen.lineTo(285, 50);oReactFiberPen.lineTo(284, 59);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(285, 50);oReactFiberPen.lineTo(275, 54);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(200, 160);oReactFiberPen.lineTo(200, 210);oReactFiberPen.lineTo(196, 206);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(200, 210);oReactFiberPen.lineTo(204, 206);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(200, 250);oReactFiberPen.lineTo(200, 300);oReactFiberPen.lineTo(196, 296);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(200, 300);oReactFiberPen.lineTo(204, 296);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(200, 340);oReactFiberPen.lineTo(200, 391);oReactFiberPen.lineTo(196, 387);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(200, 391);oReactFiberPen.lineTo(204, 387);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(220, 210);oReactFiberPen.lineTo(220, 160);oReactFiberPen.lineTo(216, 164);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(220, 160);oReactFiberPen.lineTo(224, 164);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(220, 300);oReactFiberPen.lineTo(220, 250);oReactFiberPen.lineTo(216, 254);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(220, 250);oReactFiberPen.lineTo(224, 254);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(220, 391);oReactFiberPen.lineTo(220, 340);oReactFiberPen.lineTo(216, 344);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(220, 340);oReactFiberPen.lineTo(224, 344);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(388, 160);oReactFiberPen.lineTo(388, 210);oReactFiberPen.lineTo(384, 206);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(388, 210);oReactFiberPen.lineTo(392, 206);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(388, 250);oReactFiberPen.lineTo(388, 300);oReactFiberPen.lineTo(384, 296);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(388, 300);oReactFiberPen.lineTo(392, 296);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(388, 340);oReactFiberPen.lineTo(388, 391);oReactFiberPen.lineTo(384, 387);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(388, 391);oReactFiberPen.lineTo(392, 387);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(408, 210);oReactFiberPen.lineTo(408, 160);oReactFiberPen.lineTo(404, 164);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(408, 160);oReactFiberPen.lineTo(412, 164);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(408, 300);oReactFiberPen.lineTo(408, 250);oReactFiberPen.lineTo(404, 254);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(408, 250);oReactFiberPen.lineTo(412, 254);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(408, 391);oReactFiberPen.lineTo(408, 340);oReactFiberPen.lineTo(404, 344);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(408, 340);oReactFiberPen.lineTo(412, 344);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(160, 410);oReactFiberPen.lineTo(80, 410);oReactFiberPen.lineTo(85, 406);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(80, 410);oReactFiberPen.lineTo(85, 414);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(60, 391);oReactFiberPen.lineTo(160, 320);oReactFiberPen.lineTo(150, 324);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(160, 320);oReactFiberPen.lineTo(153, 329);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(438, 410);oReactFiberPen.lineTo(520, 410);oReactFiberPen.lineTo(515, 406);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(520, 410);oReactFiberPen.lineTo(515, 414);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(540, 391);oReactFiberPen.lineTo(438, 320);oReactFiberPen.lineTo(443, 328);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(438, 320);oReactFiberPen.lineTo(448, 322);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(250, 140);oReactFiberPen.lineTo(348, 140);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(250, 230);oReactFiberPen.lineTo(348, 230);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(250, 320);oReactFiberPen.lineTo(348, 320);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(250, 410);oReactFiberPen.lineTo(348, 410);oReactFiberPen.stroke();oReactFiberPen.setLineDash([2]);oReactFiberPen.strokeRect(20, 76, 250, 400);oReactFiberPen.strokeRect(330, 76, 250, 400);oReactFiberPen.fillStyle='#4F2F64';oReactFiberPen.fillText('fiberRootNode', 253, 35);oReactFiberPen.fillText('rootFiber', 175, 144);oReactFiberPen.fillText('App', 192, 234);oReactFiberPen.fillText('h1', 198, 325);oReactFiberPen.fillText('p', 202, 414);oReactFiberPen.fillText('jyy', 45, 415);oReactFiberPen.fillText('rootFiber', 365, 144);oReactFiberPen.fillText('App', 378, 234);oReactFiberPen.fillText('h1', 384, 325);oReactFiberPen.fillText('p', 390, 414);oReactFiberPen.fillText('jyy', 536, 415);oReactFiberPen.fillStyle='#E22312';oReactFiberPen.fillText('Current Fiber', 60, 58);oReactFiberPen.fillText('WorkInProgress Fiber', 400, 58);oReactFiberPen.fillStyle='#21AFF2';oReactFiberPen.fillText('current', 150, 100);oReactFiberPen.fillText('stateNode', 249, 100);oReactFiberPen.fillText('child', 166, 190);oReactFiberPen.fillText('return ', 225, 190);oReactFiberPen.fillText('child', 166, 281);oReactFiberPen.fillText('return', 225, 281);oReactFiberPen.fillText('child', 166, 368);oReactFiberPen.fillText('return', 225, 368);oReactFiberPen.fillText('sibling', 104, 405);oReactFiberPen.fillText('return', 63, 355);oReactFiberPen.fillText('child', 353, 190);oReactFiberPen.fillText('return ', 412, 190);oReactFiberPen.fillText('child', 353, 281);oReactFiberPen.fillText('return', 412, 281);oReactFiberPen.fillText('child', 353, 368);oReactFiberPen.fillText('return', 412, 368);oReactFiberPen.fillText('sibling', 462, 405);oReactFiberPen.fillText('return', 495, 355);oReactFiberPen.fillText('alternate', 272, 136);oReactFiberPen.fillText('alternate', 272, 226);oReactFiberPen.fillText('alternate', 272, 316);oReactFiberPen.fillText('alternate', 272, 406);</script>


<h2 id="scheduler"><a href="#scheduler" class="headerlink" title="scheduler"></a>scheduler</h2><pre><code>Scheduler的作用是调度任务，react15没有Scheduler这部分，所以所有任务没有优先级，也不能中断，只能同步执行。

我们知道了要实现异步可中断的更新，需要浏览器指定一个时间，如果没有时间剩余了就需要暂停任务，requestIdleCallback貌似是个不错的选择，但是它存在兼容和触发不稳定的原因，react17中采用MessageChannel来实现。

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoopConcurrent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Perform work until Scheduler asks us to yield</span></span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span> &amp;&amp; !shouldYield()) &#123;</span><br><span class="line">    performUnitOfWork(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

在Scheduler中的每的每个任务的优先级使用过期时间表示的，如果一个任务的过期时间离现在很近，说明它马上就要过期了，优先级很高，如果过期时间很长，那它的优先级就低，没有过期的任务存放在timerQueue中，过期的任务存放在taskQueue中，timerQueue和timerQueue都是小顶堆，所以peek取出来的都是离现在时间最近也就是优先级最高的那个任务，然后优先执行它。
</code></pre>  <!-- ## Lane模型 -->
<h2 id="reconciler（render-阶段）"><a href="#reconciler（render-阶段）" class="headerlink" title="reconciler（render 阶段）"></a>reconciler（render 阶段）</h2><pre><code>协调器是在render阶段工作的，简单一句话概括就是Reconciler会创建或者更新Fiber节点。在mount的时候会根据jsx生成Fiber对象，在update的时候会根据最新的state形成的jsx对象和current Fiber树对比构建workInProgress Fiber树，这个对比的过程就是diff算法。

diff算法发生在render阶段的reconcileChildFibers函数中，diff算法分为单节点的diff和多节点的diff（例如一个节点中包含多个子节点就属于多节点的diff），单节点会根据节点的key和type，props等来判断节点是复用还是直接新创建节点，多节点diff会涉及节点的增删和节点位置的变化。

reconcile时会在这些Fiber上打上Flags标签，这些标签代表节点的增删改，在commit阶段把这些标签应用到真实dom上。

render阶段遍历Fiber树类似dfs的过程，‘捕获’阶段发生在beginWork函数中，该函数做的主要工作是创建Fiber节点，计算state和diff算法，‘冒泡’阶段发生在completeWork中，该函数主要是做一些收尾工作，例如处理节点的props、和形成一条effectList的链表，该链表是被标记了更新的节点形成的链表。（可以看上面 Fiber双缓存 那张图，自上而下的是beginWork，自下而上是completeWork）
</code></pre><h2 id="renderer（commit-阶段）"><a href="#renderer（commit-阶段）" class="headerlink" title="renderer（commit 阶段）"></a>renderer（commit 阶段）</h2><pre><code>Renderer是在commit阶段工作的，commit阶段会遍历render阶段形成的effectList，并执行真实dom节点的操作和一些生命周期，不同平台对应的Renderer不同，例如浏览器对应的就是react-dom。

commit阶段发生在commitRoot函数中，该函数主要遍历effectList，分别用三个函数来处理effectList上的节点，这三个函数是commitBeforeMutationEffects、commitMutationEffects、commitLayoutEffects，他们主要做的事情如下，后面会详细研究，现在在大脑里有一个结构就行。
</code></pre><h2 id="concurrent"><a href="#concurrent" class="headerlink" title="concurrent"></a>concurrent</h2><pre><code>它是一类功能的合集（如fiber、schduler、lane、suspense），其目的是为了提高应用的响应速度，使应用cpu密集型的更新不再那么卡顿，其核心是实现了一套异步可中断、带优先级的更新。

一般浏览器的fps是60Hz，也就是每16.6ms会刷新一次，而js执行线程和GUI（也就是浏览器的绘制）是互斥的，因为js可以操作dom，影响最后呈现的结果，所以如果js执行的时间过长，会导致浏览器没时间绘制dom，造成卡顿。react17会在每一帧分配一个时间（时间片）给js执行，如果在这个时间内js还没执行完，那就要暂停它的执行，等下一帧继续执行，把执行权交回给浏览器去绘制。
</code></pre>  <div class="post-warning">FPS （Frames Per Second, 每秒传输帧数）， FPS是图像领域中的定义，是指画面每秒传输帧数，通俗来讲就是指动画或视频的画面数。FPS是测量用于保存、显示动态视频的信息数量。每秒钟帧数越多，所显示的动作就会越流畅。60Hz的刷新率刷也就是指屏幕一秒内只扫描60次，即60帧/秒。而当刷新率太低时我们肉眼都能感觉到屏幕的闪烁，不连贯，对图像显示效果和视觉感观产生不好的影响。</div>

  <canvas id="concurrent-browser" width="600" height="300"></canvas>

  <script>const oConcurrent = document.getElementById('concurrent-browser');const oConcurrentPen = oConcurrent.getContext('2d');oConcurrentPen.font = '14px sans-serif';oConcurrentPen.fillStyle='black';oConcurrentPen.fillText('js执行', 16, 245);oConcurrentPen.fillText('重排', 70, 245);oConcurrentPen.fillText('重绘', 122, 245);oConcurrentPen.fillText('js执行', 68, 125);oConcurrentPen.fillText('js执行', 218, 125);oConcurrentPen.fillText('重排', 422, 125);oConcurrentPen.fillText('重绘', 471, 125);oConcurrentPen.fillText('16.6ms', 65, 93);oConcurrentPen.fillText('16.6ms', 218, 93);oConcurrentPen.fillText('16.6ms', 65, 213);oConcurrentPen.font = '10px sans-serif';oConcurrentPen.fillText('......很长一段时间', 320, 93);oConcurrentPen.fillText('没时间执行', 435, 93);oConcurrentPen.strokeRect(10, 220, 50, 40);oConcurrentPen.strokeRect(60, 220, 50, 40);oConcurrentPen.strokeRect(110, 220, 50, 40);oConcurrentPen.strokeRect(10, 100, 150, 40);oConcurrentPen.strokeRect(160, 100, 150, 40);oConcurrentPen.strokeRect(410, 100, 50, 40);oConcurrentPen.strokeRect(460, 100, 50, 40);oConcurrentPen.beginPath();oConcurrentPen.lineTo(10, 82);oConcurrentPen.lineTo(10, 94);oConcurrentPen.stroke();oConcurrentPen.beginPath();oConcurrentPen.lineTo(160, 82);oConcurrentPen.lineTo(160, 94);oConcurrentPen.stroke();oConcurrentPen.beginPath();oConcurrentPen.lineTo(10, 88);oConcurrentPen.lineTo(55, 88);oConcurrentPen.stroke();oConcurrentPen.beginPath();oConcurrentPen.lineTo(115, 88);oConcurrentPen.lineTo(160, 88);oConcurrentPen.stroke();oConcurrentPen.beginPath();oConcurrentPen.lineTo(310, 82);oConcurrentPen.lineTo(310, 94);oConcurrentPen.stroke();oConcurrentPen.beginPath();oConcurrentPen.lineTo(160, 88);oConcurrentPen.lineTo(205, 88);oConcurrentPen.stroke();oConcurrentPen.beginPath();oConcurrentPen.lineTo(265, 88);oConcurrentPen.lineTo(310, 88);oConcurrentPen.stroke();oConcurrentPen.beginPath();oConcurrentPen.lineTo(410, 82);oConcurrentPen.lineTo(410, 94);oConcurrentPen.stroke();oConcurrentPen.beginPath();oConcurrentPen.lineTo(510, 82);oConcurrentPen.lineTo(510, 94);oConcurrentPen.stroke();oConcurrentPen.beginPath();oConcurrentPen.lineTo(410, 88);oConcurrentPen.lineTo(430, 88);oConcurrentPen.stroke();oConcurrentPen.beginPath();oConcurrentPen.lineTo(490, 88);oConcurrentPen.lineTo(510, 88);oConcurrentPen.stroke();oConcurrentPen.beginPath();oConcurrentPen.lineTo(10, 202);oConcurrentPen.lineTo(10, 214);oConcurrentPen.stroke();oConcurrentPen.beginPath();oConcurrentPen.lineTo(160, 202);oConcurrentPen.lineTo(160, 214);oConcurrentPen.stroke();oConcurrentPen.beginPath();oConcurrentPen.lineTo(10, 208);oConcurrentPen.lineTo(55, 208);oConcurrentPen.stroke();oConcurrentPen.beginPath();oConcurrentPen.lineTo(115, 208);oConcurrentPen.lineTo(160, 208);oConcurrentPen.stroke();</script>


<h1 id="三、react源码深入解析"><a href="#三、react源码深入解析" class="headerlink" title="三、react源码深入解析"></a>三、react源码深入解析</h1><p>  直接看react源码，就像是一个人站在你面前，他就在你面前，面面相觑，你不了解他。<br>  接下来，这一part我们听别人去讲他，我们去理解，再亲自去验证，深入理解他。</p>
<h2 id="源码目录结构和调试"><a href="#源码目录结构和调试" class="headerlink" title="源码目录结构和调试"></a>源码目录结构和调试</h2><ol>
<li>源码中主要包括如下部分<br> fixtures：为代码贡献者提供的测试React<br> packages：主要部分，包含Scheduler，reconciler等<br> scripts：react构建相关</li>
<li>packages主要包含的模块</li>
</ol>
<pre><code>- react：核心Api，如：React.createElement、React.Component都在这

- 和平台相关render相关的文件夹： 
  react-art：如canvas svg的渲染 
  react-dom：浏览器环境 
  react-native-renderer：原生相关 react-noop-renderer：调试或者fiber用

- 试验性的包
  react-server: ssr相关
  react-fetch: 请求相关
  react-interactions: 和事件如点击事件相关
  react-reconciler: 构建节点

- shared：包含公共方法和变量

- 辅助包：
  react-is : 判断类型
  react-client: 流相关
  react-fetch: 数据请求相关
  react-refresh: 热加载相关
  scheduler：调度器相关
  React-reconciler：在render阶段用它来构建fiber节点
</code></pre><ul>
<li>调试方法</li>
</ul>
<p>  方法一：这种方法我没走通，直接走的野路子方法二。</p>
<ol>
<li>clone源码：git clone <a href="https://github.com/facebook/react.git" target="_blank" rel="noopener">https://github.com/facebook/react.git</a></li>
<li>依赖安装：npm install or yarn</li>
<li>build源码：npm run build react/index,react/jsx,react-dom/index,scheduler –type=NODE<br>为源码建立软链：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build/node_modules/react</span><br><span class="line">npm link</span><br><span class="line"><span class="built_in">cd</span> build/node_modules/react-dom</span><br><span class="line">npm link</span><br><span class="line">create-react-app创建项目</span><br><span class="line"></span><br><span class="line">npx create-react-app demo</span><br><span class="line">npm link react react-dom</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>方法二：野路子，直捣黄龙</p>
<ol>
<li>npm i react react-dom</li>
<li><p>同目录创建html文件，script方式使用react和react-dom</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">'./node_modules/react/umd/react.development.js'</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">'./node_modules/react-dom/umd/react-dom.development.js'</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;div id=<span class="string">'root'</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">    <span class="string">'app'</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> a = <span class="string">'abc'</span>;</span><br><span class="line">  <span class="comment">// ReactDOM.render(null, document.getElementById('root'));</span></span><br><span class="line">  ReactDOM.render(React.createElement(<span class="string">'h1'</span>, &#123;<span class="attr">className</span>: <span class="string">'name'</span>, <span class="attr">onClick</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">'点我干嘛'</span>);&#125;&#125;, [<span class="string">'abc'</span>, React.createElement(<span class="string">'div'</span>, &#123;<span class="attr">key</span>: <span class="string">'num'</span>&#125;, <span class="string">'123456'</span>)]), <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>直接些jsx不可以，没有探索babel有没有cdn的使用方式，直接React.createElememt粗暴代替。</p>
</li>
</ol>
<h2 id="jsx-1"><a href="#jsx-1" class="headerlink" title="jsx"></a>jsx</h2><h3 id="virtual-Dom-是什么"><a href="#virtual-Dom-是什么" class="headerlink" title="virtual Dom 是什么"></a>virtual Dom 是什么</h3><p>  virtual Dom是一个js对象，描述了dom信息。更新就是渲染更新后的js对象到真实dom，这个对象是React.createElement()返回的结果。</p>
<h3 id="为什么用virtual-Dom"><a href="#为什么用virtual-Dom" class="headerlink" title="为什么用virtual Dom"></a>为什么用virtual Dom</h3><p>  真实DOM更新渲染，很小的更新就可能引起页面的重绘重排，耗时耗性能。<br>  js对象是在内存中处理的，很快，并通过diff算法比较virtual dom的变化，能做到批量，异步，最小化的dom变更，有效提升性能。</p>
<h3 id="jsx-amp-createElement"><a href="#jsx-amp-createElement" class="headerlink" title="jsx&amp;createElement"></a>jsx&amp;createElement</h3><p>  jsx是Class component的render函数的返回值或Function component的返回值，用来表示组件，声明式地描述视图。经过babel转义成React.createElement。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jsx结构:</span><br><span class="line">&lt;h1 class=&quot;name&quot; onClick=&#123;() =&gt; &#123;console.log(&apos;点我干嘛&apos;)&#125;&#125;&gt;</span><br><span class="line">  abc</span><br><span class="line">  &lt;div&gt;123456&lt;/div&gt;</span><br><span class="line">&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">经过babel转移成React.createElement</span><br><span class="line">React.createElement(</span><br><span class="line">  &apos;h1&apos;, &#123;className: &apos;name&apos;, onClick: () =&gt; &#123;console.log(&apos;点我干嘛&apos;);&#125;&#125;, </span><br><span class="line">    [&apos;abc&apos;, React.createElement(&apos;div&apos;, &#123;key: &apos;num&apos;&#125;, &apos;123456&apos;)])</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>  PS：这就是为什么jsx文件要声明import React from ‘react’的原因（现在我还不知道为什么react17之后不用导入？）</p>
<p>  React.createElement(810):</p>
<ul>
<li>处理config，把除了保留属性外的其他config赋值给props</li>
<li>把children处理后赋值给props.children</li>
<li>处理defaultProps</li>
<li>调用ReactElement(724)返回一个jsx对象(virtual-dom)</li>
</ul>
<p>  我们来看一下jsx对象：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  $$typeof: Symbol(react.element),</span><br><span class="line">  key: null,</span><br><span class="line">  props: &#123;</span><br><span class="line">    children: [</span><br><span class="line">      &quot;abc&quot;,</span><br><span class="line">      &#123;</span><br><span class="line">        $$typeof: Symbol(react.element),</span><br><span class="line">        key: &quot;num&quot;,</span><br><span class="line">        props: &#123;</span><br><span class="line">          children: &quot;123456&quot;,</span><br><span class="line">          key: undefined,</span><br><span class="line">          get key: ƒ (),</span><br><span class="line">          ref: null,</span><br><span class="line">          type: &quot;div&quot;,</span><br><span class="line">          _owner: null,</span><br><span class="line">          _store: &#123;validated: false&#125;,</span><br><span class="line">          _self: null,</span><br><span class="line">          _source: null,</span><br><span class="line">        &#125;  </span><br><span class="line">      &#125;,</span><br><span class="line">      length: 2,</span><br><span class="line">    ],</span><br><span class="line">    className: &quot;name&quot;,</span><br><span class="line">    onClick: () =&gt; &#123;console.log(&apos;点我干嘛&apos;);&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  ref: null,</span><br><span class="line">  type: &quot;h1&quot;,</span><br><span class="line">  _owner: null,</span><br><span class="line">  _store: &#123;validated: false&#125;,</span><br><span class="line">  _self: null,</span><br><span class="line">  _source: null,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  $$typeof表示的是组件的类型，例如在源码中有一个检查是否是合法Element的函数(isValidElement902)，就是根object.$$typeof === REACT_ELEMENT_TYPE来判断的</p>
<p>  看到这里，对jsx豁然开朗，至于babel是怎么转译的，以后有机会再做学习。<br>  <code>jsx -&gt; Virtual Dom(jsx对象，Fiber) -&gt; Dom</code><br>  还有个疑问，jsx对象和Fiber对象的关系？接着来大致看一下Fiber</p>
<blockquote>
<p>jsx对象上没有优先级、状态、effectTag等标记，这些标记在Fiber对象上，在mount时Fiber根据jsx对象来构建，在update时根据最新状态的jsx和current Fiber对比，形成新的workInProgress Fiber，最后workInProgress Fiber切换成current Fiber。</p>
</blockquote>
<p>  小结：jsx是React.createElement的语法糖，jsx通过babel转化成React.createElement函数，React.createElement执行之后返回jsx对象，也叫virtual-dom，Fiber会根据jsx对象和current Fiber进行对比形成workInProgress Fiber<br>  <!-- ## legacy和concurrent模式入口函数 --></p>
<h2 id="Fiber架构"><a href="#Fiber架构" class="headerlink" title="Fiber架构"></a>Fiber架构</h2><p>  react 15 在render阶段的reconcile过程是同步不可中断的，当进行大量节点的reconcile时就可能产生卡顿等，因为js执行是单线程的，一直在执行js，不放出执行权，浏览器要等到js执行完成后才能进行绘制和重排，这样的用户体验一定是不好的。</p>
<p>  react 16 增加了scheduler对时间片进行管理，分割task，给每个task（工作单元）一定的时间执行，时间到了没执行完也要交出执行权给到浏览器进行重绘重排。这种异步可中断的数据结构就是Fiber。</p>
<p>  Fiber：</p>
<ul>
<li><strong>工作单元 任务分解</strong>：这是Fiber最重要的工作，保存节点对应的信息，以指针的形式形成Fiber树。</li>
<li><strong>增量渲染</strong>：通过jsx对象和Current Fiber进行对比，生成最小的差异补丁，应用到真实节点上。</li>
<li><strong>保存状态</strong>：因为Fiber能保存状态和更新的信息，所以就能实现函数组件的状态更新，也就是hooks</li>
<li><strong>根据优先级暂停、继续、排列优先级</strong>：Fiber节点上保存了优先级，能通过不同节点优先级的对比达到此目的，也为上层批量更新、Suspense提供了基础。</li>
</ul>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FiberNode</span>(<span class="params">tag, pendingProps, key, mode</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 作为静态的数据结构 保存节点的信息 </span></span><br><span class="line">  <span class="keyword">this</span>.tag = tag; <span class="comment">// 对应组件的类型</span></span><br><span class="line">  <span class="keyword">this</span>.key = key;</span><br><span class="line">  <span class="keyword">this</span>.elementType = <span class="literal">null</span>; <span class="comment">// 元素类型</span></span><br><span class="line">  <span class="keyword">this</span>.type = <span class="literal">null</span>; <span class="comment">// class或Function</span></span><br><span class="line">  <span class="keyword">this</span>.stateNode = <span class="literal">null</span>; <span class="comment">// Fiber，真实DOM节点</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 作为fiber树架构 连接成fiber树</span></span><br><span class="line">  <span class="keyword">this</span>.return = <span class="literal">null</span>; <span class="comment">// 指向父节点</span></span><br><span class="line">  <span class="keyword">this</span>.child = <span class="literal">null</span>; <span class="comment">// 指向孩子</span></span><br><span class="line">  <span class="keyword">this</span>.sibling = <span class="literal">null</span>; <span class="comment">// 指向兄弟节点</span></span><br><span class="line">  <span class="keyword">this</span>.index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.ref = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 作为工作单元 来计算state</span></span><br><span class="line">  <span class="keyword">this</span>.pendingProps = pendingProps;</span><br><span class="line">  <span class="keyword">this</span>.memoizedProps = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.updateQueue = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.memoizedState = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.dependencies = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.mode = mode; <span class="comment">// Effects</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// effect相关</span></span><br><span class="line">  <span class="keyword">this</span>.flags = NoFlags;</span><br><span class="line">  <span class="keyword">this</span>.nextEffect = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.firstEffect = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.lastEffect = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 优先级相关</span></span><br><span class="line">  <span class="keyword">this</span>.lanes = NoLanes;</span><br><span class="line">  <span class="keyword">this</span>.childLanes = NoLanes;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// current和workInProgress的指针</span></span><br><span class="line">  <span class="keyword">this</span>.alternate = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>  <canvas id="fiber" width="600" height="460"></canvas>

<script>const oFiber = document.getElementById('fiber');const oFiberPen = oFiber.getContext('2d');oFiberPen.font = '14px sans-serif';oFiberPen.fillStyle='black';oFiberPen.strokeRect(150, 10, 100, 50);oFiberPen.strokeRect(150, 140, 100, 50);oFiberPen.strokeRect(150, 260, 100, 50);oFiberPen.strokeRect(150, 380, 100, 50);oFiberPen.strokeRect(460, 380, 100, 50);oFiberPen.beginPath();oFiberPen.lineTo(185, 60);oFiberPen.lineTo(185, 140);oFiberPen.lineTo(180, 135);oFiberPen.stroke();oFiberPen.beginPath();oFiberPen.lineTo(185, 140);oFiberPen.lineTo(190, 135);oFiberPen.stroke();oFiberPen.beginPath();oFiberPen.lineTo(185, 190);oFiberPen.lineTo(185, 260);oFiberPen.lineTo(180, 255);oFiberPen.stroke();oFiberPen.beginPath();oFiberPen.lineTo(185, 260);oFiberPen.lineTo(190, 255);oFiberPen.stroke();oFiberPen.beginPath();oFiberPen.lineTo(185, 310);oFiberPen.lineTo(185, 380);oFiberPen.lineTo(180, 375);oFiberPen.stroke();oFiberPen.beginPath();oFiberPen.lineTo(185, 380);oFiberPen.lineTo(190, 375);oFiberPen.stroke();oFiberPen.beginPath();oFiberPen.lineTo(215, 140);oFiberPen.lineTo(215, 60);oFiberPen.lineTo(210, 65);oFiberPen.stroke();oFiberPen.beginPath();oFiberPen.lineTo(215, 60);oFiberPen.lineTo(220, 65);oFiberPen.stroke();oFiberPen.beginPath();oFiberPen.lineTo(215, 260);oFiberPen.lineTo(215, 190);oFiberPen.lineTo(210, 195);oFiberPen.stroke();oFiberPen.beginPath();oFiberPen.lineTo(215, 190);oFiberPen.lineTo(220, 195);oFiberPen.stroke();oFiberPen.beginPath();oFiberPen.lineTo(215, 380);oFiberPen.lineTo(215, 310);oFiberPen.lineTo(210, 315);oFiberPen.stroke();oFiberPen.beginPath();oFiberPen.lineTo(215, 310);oFiberPen.lineTo(220, 315);oFiberPen.stroke();oFiberPen.beginPath();oFiberPen.lineTo(250, 405);oFiberPen.lineTo(460, 405);oFiberPen.lineTo(455, 400);oFiberPen.stroke();oFiberPen.beginPath();oFiberPen.lineTo(460, 405);oFiberPen.lineTo(455, 410);oFiberPen.stroke();oFiberPen.beginPath();oFiberPen.lineTo(510, 380);oFiberPen.lineTo(250, 295);oFiberPen.lineTo(257, 302);oFiberPen.stroke();oFiberPen.beginPath();oFiberPen.lineTo(250, 295);oFiberPen.lineTo(260, 296);oFiberPen.stroke();oFiberPen.fillText('rootFiber', 170, 40);oFiberPen.fillText('App', 188, 168);oFiberPen.fillText('h1', 193, 290);oFiberPen.fillText('p', 198, 408);oFiberPen.fillText('jyy', 503, 408);oFiberPen.fillText('child', 153, 105);oFiberPen.fillText('return ', 218, 105);oFiberPen.fillText('child', 153, 227);oFiberPen.fillText('return', 218, 227);oFiberPen.fillText('child', 153, 348);oFiberPen.fillText('return', 218, 348);oFiberPen.fillText('sibling', 340, 399);oFiberPen.fillText('return', 365, 330);</script>

<blockquote>
<p>在mount时：创建fiberRoot和rootFiber，然后根据jsx创建workInProgress Fiber，把workInProgress Fiber切换成current Fiber。</p>
</blockquote>
<blockquote>
<p>在update时：会根据新的状态形成的jsx（ClassComponent的render或者FuncComponent的返回值）和current Fiber对比形（diff算法）成一棵workInProgress Fiber树，然后将fiberRoot的current指向workInProgress树，此时workInProgress就变成了current Fiber。</p>
</blockquote>
<pre><code>fiberRoot：指整个应用的根节点，只存在一个

rootFiber：ReactDOM.render或者ReactDOM.unstable_createRoot创建出来的应用的节点，可以存在多个。
</code></pre><h2 id="render阶段"><a href="#render阶段" class="headerlink" title="render阶段"></a>render阶段</h2><pre><code>render阶段的主要工作是构建Fiber树和生成effectList链表。
</code></pre><h3 id="react启动模式"><a href="#react启动模式" class="headerlink" title="react启动模式"></a>react启动模式</h3><pre><code>几个月之前，刚开始看react源码的时候，最新版本还是17.0.2，现在（2021-11-04）React 18版本就已经发布了 Alpha 版本。

React 18 带来了什么，我们可以参看官网的[发布计划](https://zh-hans.reactjs.org/blog/2021/06/08/the-plan-for-react-18.html)。

这里对18比较感兴趣的是并发渲染（concurrent rendering）机制，只有由新特性触发的更新会启用并发渲染。如果没用到新属性，即使用了ReactDOM.createRoot(rootNode).render(...)，也会走原路。

试着用了一下react 18版本，reactDom.render会报Warning：ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it&apos;s running React 17。

这就是react新的启动模式：
1）legacy 模式： ReactDOM.render(&lt;App /&gt;, rootNode)。在react18中使用这种模式与react17完全相同，但是会有一条警告，表明它已被弃用并切换到新的 Root API。
2）concurrent 模式： ReactDOM.createRoot(rootNode).render(&lt;App /&gt;)。并发模式，这个模式开启了所有的新功能。




还发现一个hydrateRoot，不知道是做什么的，但是看起来和createRoot很像，也可以这样用，渲染页面：
ReactDOM.hydrateRoot(rootNode).render(&lt;App /&gt;);暂留
</code></pre><h4 id="两种模式函数主要执行过程"><a href="#两种模式函数主要执行过程" class="headerlink" title="两种模式函数主要执行过程"></a>两种模式函数主要执行过程</h4>  <canvas id="primary-progress" width="500" height="400"></canvas>

  <script>
    const oMain = document.getElementById('primary-progress');
    const oMainPen = oMain.getContext('2d');oMainPen.font = '14px sans-serif';oMainPen.strokeRect(92, 10, 320, 30);oMainPen.strokeRect(30, 80, 450, 30);oMainPen.strokeRect(93, 150, 316, 30);oMainPen.strokeRect(10, 220, 480, 30);oMainPen.strokeRect(160, 290, 180, 30);oMainPen.fillText('createContainer（创建fiberRootNode、rootFiber）', 96, 30);oMainPen.fillText('updateContainer（创建update对象，保存在updateQueue环状链表中）', 34, 100);oMainPen.fillText('scheduleUpdateOnFiber（在Fiber上调度update）', 95, 163);oMainPen.fillText('ensureRootIsScheduled（调度根节点）', 125, 177);oMainPen.fillText('commitRoot（commit阶段）', 164, 310);oMainPen.fillStyle='blue';oMainPen.fillText('performSyncWorkOnRoot | performConcurrentWorkOnRoot（render阶段）', 12, 240);oMainPen.fillStyle='black';oMainPen.beginPath();oMainPen.lineTo(252, 40);oMainPen.lineTo(252, 75);oMainPen.stroke();oMainPen.beginPath();oMainPen.lineTo(248, 75);oMainPen.lineTo(256, 75);oMainPen.lineTo(252, 80);oMainPen.closePath();oMainPen.fill();oMainPen.beginPath();oMainPen.lineTo(252, 110);oMainPen.lineTo(252, 145);oMainPen.stroke();oMainPen.beginPath();oMainPen.lineTo(248, 145);oMainPen.lineTo(256, 145);oMainPen.lineTo(252, 150);oMainPen.closePath();oMainPen.fill();oMainPen.beginPath();oMainPen.lineTo(252, 180);oMainPen.lineTo(252, 215);oMainPen.stroke();oMainPen.beginPath();oMainPen.lineTo(248, 215);oMainPen.lineTo(256, 215);oMainPen.lineTo(252, 220);oMainPen.closePath();oMainPen.fill();oMainPen.beginPath();oMainPen.lineTo(252, 250);oMainPen.lineTo(252, 285);oMainPen.stroke();oMainPen.beginPath();oMainPen.lineTo(248, 285);oMainPen.lineTo(256, 285);oMainPen.lineTo(252, 290);oMainPen.closePath();oMainPen.fill();
  </script>

<h4 id="legacy模式"><a href="#legacy模式" class="headerlink" title="legacy模式"></a>legacy模式</h4><p>  render调用legacyRenderSubtreeIntoContainer，createContainer调用createFiberRoot创建fiberRootNode，调用createHostRootFiber创建rootFiber。其中fiberRootNode是整个项目的根节点，rootFiber是当前应用挂载的节点，也就是ReactDom.render调用后的根节点。<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最上层的节点是整个项目的根节点fiberRootNode</span></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById("root")); // rootFiber</span><br><span class="line"></span><br><span class="line">fiberRootNode.current = rootFiber;</span><br><span class="line">rootFiber.stateNode = fiberRootNode;</span><br></pre></td></tr></table></figure></p>
<p>  创建完fiber节点后，legacyRenderSubtreeIntoContainer调用updateContainer创建Update对象挂载到updateQueue环状链表上，然后执行scheduleUpdateOnFiber调用performSyncWorkOnRoot进入render阶段和commit阶段。</p>
<h4 id="concurrent模式"><a href="#concurrent模式" class="headerlink" title="concurrent模式"></a>concurrent模式</h4><p>  createRoot调用createContainer创建fiberRootNode和rootFiber。创建完fiber节点后，return new ReactDOMRoot(root); 调用ReactDOMRoot.propertype.render执行updateContainer，然后异步调度scheduleUpdateOnFiber，performConcurrentWorkOnRoot进入render阶段和commit阶段。</p>
<h4 id="两种模式的不同点"><a href="#两种模式的不同点" class="headerlink" title="两种模式的不同点"></a>两种模式的不同点</h4><p>  1）createContainer中传入的第二个参数tag不一样 一个是LegacyRoot 0，一个是ConcurrentRoot 1。<br>  2）requestUpdateLane中获取的lane的优先级不同。<br>  3) 在函数scheduleUpdateOnFiber中根据不同优先级进入不同分支，legacy模式进入performSyncWorkOnRoot，concurrent模式 <strong>异步调度</strong> performConcurrentWorkOnRoot。</p>
<h3 id="两种模式的函数调用过程"><a href="#两种模式的函数调用过程" class="headerlink" title="两种模式的函数调用过程"></a>两种模式的函数调用过程</h3>  <canvas id="renderTransfer" width="650" height="600"></canvas>

  <script>const oRenderTransfer = document.getElementById('renderTransfer');const oRenderTransferPen = oRenderTransfer.getContext('2d');oRenderTransferPen.font = '12px sans-serif';oRenderTransferPen.fillStyle='black';oRenderTransferPen.fillText('Lagacy', 205, 15);oRenderTransferPen.fillText('Concurrent', 412, 15);oRenderTransferPen.fillText('render', 210, 50);oRenderTransferPen.fillText('createRoot', 408, 50);oRenderTransferPen.fillText('ReactDOMRoot.prototype.render', 360, 191);oRenderTransferPen.fillText('createUpdate', 50, 270);oRenderTransferPen.fillText('enqueueUpdate', 160, 270);oRenderTransferPen.fillText('ensureRootIsScheduled', 270, 270);oRenderTransferPen.fillText('root.tag === LegacyRoot', 146, 315);oRenderTransferPen.fillText('performSyncWorkOnRoot', 142, 385);oRenderTransferPen.fillText('performConcurrentWorkOnRoot', 380, 385);oRenderTransferPen.fillText('rederRootSync', 165, 425);oRenderTransferPen.fillText('renderRootConcurrent', 400, 425);oRenderTransferPen.fillText('workLoopSync', 170, 460);oRenderTransferPen.fillText('workLoopConcurrent', 430, 460);oRenderTransferPen.fillText('performUnitWork', 286, 492);oRenderTransferPen.fillText('beginWork', 198, 535);oRenderTransferPen.fillText('completeWork', 402, 535);oRenderTransferPen.fillText('.', 333, 555);oRenderTransferPen.fillText('.', 333, 558);oRenderTransferPen.fillText('.', 333, 561);oRenderTransferPen.fillText('.', 333, 564);oRenderTransferPen.fillText('.', 333, 567);oRenderTransferPen.fillText('.', 333, 570);oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(225, 20);oRenderTransferPen.lineTo(225, 35);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(221, 35);oRenderTransferPen.lineTo(229, 35);oRenderTransferPen.lineTo(225, 40);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(442, 20);oRenderTransferPen.lineTo(442, 35);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(438, 35);oRenderTransferPen.lineTo(446, 35);oRenderTransferPen.lineTo(442, 40);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(225, 55);oRenderTransferPen.lineTo(225, 80);oRenderTransferPen.lineTo(270, 80);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(270, 76);oRenderTransferPen.lineTo(270, 84);oRenderTransferPen.lineTo(275, 80);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(442, 55);oRenderTransferPen.lineTo(442, 80);oRenderTransferPen.lineTo(392, 80);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(392, 76);oRenderTransferPen.lineTo(392, 84);oRenderTransferPen.lineTo(387, 80);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(334, 86);oRenderTransferPen.lineTo(334, 93);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(331, 93);oRenderTransferPen.lineTo(337, 93);oRenderTransferPen.lineTo(334, 97);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(334, 108);oRenderTransferPen.lineTo(334, 115);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(331, 115);oRenderTransferPen.lineTo(337, 115);oRenderTransferPen.lineTo(334, 120);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(225, 80);oRenderTransferPen.lineTo(225, 156);oRenderTransferPen.lineTo(278, 156);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(278, 153);oRenderTransferPen.lineTo(278, 159);oRenderTransferPen.lineTo(281, 156);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(442, 80);oRenderTransferPen.lineTo(442, 156);oRenderTransferPen.lineTo(389, 156);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(389, 153);oRenderTransferPen.lineTo(389, 159);oRenderTransferPen.lineTo(386, 156);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(225, 156);oRenderTransferPen.lineTo(225, 217);oRenderTransferPen.lineTo(270, 217);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(270, 212);oRenderTransferPen.lineTo(270, 222);oRenderTransferPen.lineTo(275, 217);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(442, 156);oRenderTransferPen.lineTo(442, 178);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(438, 178);oRenderTransferPen.lineTo(446, 178);oRenderTransferPen.lineTo(442, 182);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(442, 192);oRenderTransferPen.lineTo(442, 217);oRenderTransferPen.lineTo(400, 217);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(400, 212);oRenderTransferPen.lineTo(400, 222);oRenderTransferPen.lineTo(395, 217);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(335, 222);oRenderTransferPen.lineTo(335, 240);oRenderTransferPen.lineTo(90, 240);oRenderTransferPen.lineTo(90, 253);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(87, 253);oRenderTransferPen.lineTo(93, 253);oRenderTransferPen.lineTo(90, 258);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(205, 240);oRenderTransferPen.lineTo(205, 253);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(202, 253);oRenderTransferPen.lineTo(208, 253);oRenderTransferPen.lineTo(205, 258);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(335, 240);oRenderTransferPen.lineTo(335, 253);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(332, 253);oRenderTransferPen.lineTo(338, 253);oRenderTransferPen.lineTo(335, 258);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(335, 272);oRenderTransferPen.lineTo(335, 290);oRenderTransferPen.lineTo(205, 290);oRenderTransferPen.lineTo(205, 300);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(202, 300);oRenderTransferPen.lineTo(208, 300);oRenderTransferPen.lineTo(205, 305);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(335, 290);oRenderTransferPen.lineTo(465, 290);oRenderTransferPen.lineTo(465, 370);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(462, 370);oRenderTransferPen.lineTo(468, 370);oRenderTransferPen.lineTo(465, 375);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(200, 320);oRenderTransferPen.lineTo(180, 340);oRenderTransferPen.stroke();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(210, 320);oRenderTransferPen.lineTo(230, 340);oRenderTransferPen.stroke();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(180, 355);oRenderTransferPen.lineTo(200, 372);oRenderTransferPen.stroke();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(230, 355);oRenderTransferPen.lineTo(210, 372);oRenderTransferPen.stroke();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(206, 388);oRenderTransferPen.lineTo(206, 408);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(203, 408);oRenderTransferPen.lineTo(209, 408);oRenderTransferPen.lineTo(206, 412);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(465, 388);oRenderTransferPen.lineTo(465, 408);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(462, 408);oRenderTransferPen.lineTo(468, 408);oRenderTransferPen.lineTo(465, 412);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(465, 398);oRenderTransferPen.lineTo(256, 421);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(256, 418);oRenderTransferPen.lineTo(258, 424);oRenderTransferPen.lineTo(250, 422);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(206, 428);oRenderTransferPen.lineTo(206, 448);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(203, 448);oRenderTransferPen.lineTo(209, 448);oRenderTransferPen.lineTo(206, 452);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(465, 428);oRenderTransferPen.lineTo(465, 448);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(462, 448);oRenderTransferPen.lineTo(468, 448);oRenderTransferPen.lineTo(465, 452);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(206, 463);oRenderTransferPen.lineTo(206, 488);oRenderTransferPen.lineTo(275, 488);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(275, 484);oRenderTransferPen.lineTo(275, 492);oRenderTransferPen.lineTo(279, 488);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(465, 463);oRenderTransferPen.lineTo(465, 488);oRenderTransferPen.lineTo(391, 488);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(391, 484);oRenderTransferPen.lineTo(391, 492);oRenderTransferPen.lineTo(387, 488);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(335, 494);oRenderTransferPen.lineTo(335, 510);oRenderTransferPen.lineTo(225, 510);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(335, 510);oRenderTransferPen.lineTo(442, 510);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(225, 510);oRenderTransferPen.lineTo(225, 520);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(221, 520);oRenderTransferPen.lineTo(229, 520);oRenderTransferPen.lineTo(225, 525);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(442, 510);oRenderTransferPen.lineTo(442, 520);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(438, 520);oRenderTransferPen.lineTo(446, 520);oRenderTransferPen.lineTo(442, 525);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.font = '8px sans-serif';oRenderTransferPen.fillText('传参不同', 235, 214);oRenderTransferPen.fillText('传参不同', 403, 214);oRenderTransferPen.fillText('createFiberRoot', 302, 106);oRenderTransferPen.fillText('createHostFoorFiber', 298, 126);oRenderTransferPen.fillText('listenToAllSupportedEvents', 283, 158);oRenderTransferPen.fillText('创建update对象', 57, 280);oRenderTransferPen.fillText('保存在updateQueue环状链表上', 145, 280);oRenderTransferPen.fillText('是', 180, 330);oRenderTransferPen.fillText('否', 223, 330);oRenderTransferPen.fillText('同步调用', 160, 350);oRenderTransferPen.fillText('异步调用', 220, 350);oRenderTransferPen.fillText('异步调用', 470, 350);oRenderTransferPen.fillText('是否使用了新功能', 470, 394);oRenderTransferPen.fillText('是', 470, 412);oRenderTransferPen.fillText('否', 420, 399);oRenderTransferPen.fillText('workOnProgress !== null', 110, 480);oRenderTransferPen.fillText('workOnProgress !== null && !shouldYield()', 470, 480);oRenderTransferPen.font = '14px sans-serif';oRenderTransferPen.fillStyle='red';oRenderTransferPen.fillText('createContainer', 278, 85);oRenderTransferPen.fillText('updateContainer', 281, 221);</script>


<pre><code>两种启动模式，我们一起回顾一下。高角度地来看就是createContainer和updateContainer。
1）刚开始是进行一些初始化的工作，createContainer创建fiberRoot和rootFiber（有时间仔细看一下这里），绑定上所有支持的函数，这一步两种模式是相同的，Legacy是调用暴露出的render函数，Concurrent是调用暴露出的createRoot函数。
2）下一步就是updateContainer，之后的render阶段以及commit阶段都是在其中调用或连接。我们先看render阶段，这时两种模式都调用了updateContainer，Legacy是之前render函数调用，Concurrent是再次调用createRoot函数返回的new ReactDOMRoot的原型上的render方法调用，二者传参不同。updateContainer首先调用createUpdate创建update对象，再调用enqueueUpdate将其保存在updateQueue环状链表上，最后调用ensureRootIsScheduled，ensureRootIsScheduled会根据之前Legacy和Concurrent传参的不同，有不同的处理。Legacy这边会判断root.tag是否等于LegacyRoot，如果相等则同步调用performSyncWorkOnRoot，否则异步调用performSyncWorkOnRoot，而Concurrent这边是直接异步调用performConcurrentWorkOnRoot。接下来performSyncWorkOnRoot会调用renderRootSync,而performConcurrentWorkOnRoot这时会判断，是否调用了新的功能特性，如果没有则会调用renderRootSync，走回Legacy的模式。如果使用了新的功能特性才会调用renderRootConcurrent。renderRootSync和renderRootConcurrent都回调用prepareFreshStack，这里很重要，prepareFreshStack会生成新的workInProgress的Fiber对象，然后renderRootSync会调用workLoopSync，renderRootConcurrent会调用workLoopConcurrent，workLoopSync和workLoopConcurrent二者都会Loop调用performUnitOfWork，只是调用的条件有一点不同，workLoopSync的停止条件只有workInProgress===null，而，workLoopConcurrent的停止条件是workInProgress === null或shouldYield()，也就是不仅workInProgress为null时会停下来，当浏览器没有足够的时间的时候也会停下来，这也是我们所说的异步可中断机制中的可中断实现。之后performUnitOfWork会调用beginWork和completeWork完成协调和调度的过程，然后将调度结果传给commitRoot函数，进入commit阶段。render阶段的从beginWork和completeWork到commitRoot的详细学习，放在下面。
</code></pre><h3 id="render阶段函数调用过程"><a href="#render阶段函数调用过程" class="headerlink" title="render阶段函数调用过程"></a>render阶段函数调用过程</h3><ul>
<li>workInProgress：新创建的workInProgress Fiber</li>
<li>performUnitOfWork：workInprogress 和 已经创建的Fiber连接形成fiber树，这个过程类似于深度优化遍历。</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  React.createElement(</span><br><span class="line">    &apos;div&apos;, </span><br><span class="line">    &#123;key: &apos;name&apos;&#125;, </span><br><span class="line">    [React.createElement(&apos;h1&apos;, &#123;key: &apos;num&apos;&#125;, 123), &apos;jyy&apos;]), </span><br><span class="line">  document.getElementById(&quot;root&quot;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
  <canvas id="performUnitOfWork" width="600" height="460"></canvas>

<script>
  const oPerformUnitOfWork = document.getElementById('performUnitOfWork');
  const oPerformUnitOfWorkPen = oPerformUnitOfWork.getContext('2d');
  oPerformUnitOfWorkPen.font = '14px sans-serif';oPerformUnitOfWorkPen.fillStyle='black';oPerformUnitOfWorkPen.strokeRect(150, 10, 100, 50);oPerformUnitOfWorkPen.strokeRect(150, 140, 100, 50);oPerformUnitOfWorkPen.strokeRect(150, 260, 100, 50);oPerformUnitOfWorkPen.strokeRect(150, 380, 100, 50);oPerformUnitOfWorkPen.strokeRect(460, 260, 100, 50);oPerformUnitOfWorkPen.beginPath();oPerformUnitOfWorkPen.lineTo(185, 60);oPerformUnitOfWorkPen.lineTo(185, 140);oPerformUnitOfWorkPen.lineTo(180, 135);oPerformUnitOfWorkPen.stroke();oPerformUnitOfWorkPen.beginPath();oPerformUnitOfWorkPen.lineTo(185, 140);oPerformUnitOfWorkPen.lineTo(190, 135);oPerformUnitOfWorkPen.stroke();oPerformUnitOfWorkPen.beginPath();oPerformUnitOfWorkPen.lineTo(185, 190);oPerformUnitOfWorkPen.lineTo(185, 260);oPerformUnitOfWorkPen.lineTo(180, 255);oPerformUnitOfWorkPen.stroke();oPerformUnitOfWorkPen.beginPath();oPerformUnitOfWorkPen.lineTo(185, 260);oPerformUnitOfWorkPen.lineTo(190, 255);oPerformUnitOfWorkPen.stroke();oPerformUnitOfWorkPen.beginPath();oPerformUnitOfWorkPen.lineTo(185, 310);oPerformUnitOfWorkPen.lineTo(185, 380);oPerformUnitOfWorkPen.lineTo(180, 375);oPerformUnitOfWorkPen.stroke();oPerformUnitOfWorkPen.beginPath();oPerformUnitOfWorkPen.lineTo(185, 380);oPerformUnitOfWorkPen.lineTo(190, 375);oPerformUnitOfWorkPen.stroke();oPerformUnitOfWorkPen.beginPath();oPerformUnitOfWorkPen.lineTo(215, 140);oPerformUnitOfWorkPen.lineTo(215, 60);oPerformUnitOfWorkPen.lineTo(210, 65);oPerformUnitOfWorkPen.stroke();oPerformUnitOfWorkPen.beginPath();oPerformUnitOfWorkPen.lineTo(215, 60);oPerformUnitOfWorkPen.lineTo(220, 65);oPerformUnitOfWorkPen.stroke();oPerformUnitOfWorkPen.beginPath();oPerformUnitOfWorkPen.lineTo(215, 260);oPerformUnitOfWorkPen.lineTo(215, 190);oPerformUnitOfWorkPen.lineTo(210, 195);oPerformUnitOfWorkPen.stroke();oPerformUnitOfWorkPen.beginPath();oPerformUnitOfWorkPen.lineTo(215, 190);oPerformUnitOfWorkPen.lineTo(220, 195);oPerformUnitOfWorkPen.stroke();oPerformUnitOfWorkPen.beginPath();oPerformUnitOfWorkPen.lineTo(215, 380);oPerformUnitOfWorkPen.lineTo(215, 310);oPerformUnitOfWorkPen.lineTo(210, 315);oPerformUnitOfWorkPen.stroke();oPerformUnitOfWorkPen.beginPath();oPerformUnitOfWorkPen.lineTo(215, 310);oPerformUnitOfWorkPen.lineTo(220, 315);oPerformUnitOfWorkPen.stroke();oPerformUnitOfWorkPen.beginPath();oPerformUnitOfWorkPen.lineTo(250, 295);oPerformUnitOfWorkPen.lineTo(460, 295);oPerformUnitOfWorkPen.lineTo(455, 290);oPerformUnitOfWorkPen.stroke();oPerformUnitOfWorkPen.beginPath();oPerformUnitOfWorkPen.lineTo(460, 295);oPerformUnitOfWorkPen.lineTo(455, 300);oPerformUnitOfWorkPen.stroke();oPerformUnitOfWorkPen.beginPath();oPerformUnitOfWorkPen.lineTo(510, 260);oPerformUnitOfWorkPen.lineTo(250, 175);oPerformUnitOfWorkPen.lineTo(257, 182);oPerformUnitOfWorkPen.stroke();oPerformUnitOfWorkPen.beginPath();oPerformUnitOfWorkPen.lineTo(250, 175);oPerformUnitOfWorkPen.lineTo(260, 176);oPerformUnitOfWorkPen.stroke();oPerformUnitOfWorkPen.fillText('rootFiber', 170, 40);oPerformUnitOfWorkPen.fillText('div.name', 168, 168);oPerformUnitOfWorkPen.fillText('h1.num', 178, 290);oPerformUnitOfWorkPen.fillText('123', 189, 408);oPerformUnitOfWorkPen.fillText('jyy', 503, 288);oPerformUnitOfWorkPen.fillText('child', 153, 105);oPerformUnitOfWorkPen.fillText('return ', 218, 105);oPerformUnitOfWorkPen.fillText('child', 153, 227);oPerformUnitOfWorkPen.fillText('return', 218, 227);oPerformUnitOfWorkPen.fillText('sibling', 280, 310);oPerformUnitOfWorkPen.fillText('return', 365, 210);oPerformUnitOfWorkPen.fillStyle='#F612E3';oPerformUnitOfWorkPen.fillText('1.beginWork', 60, 40);oPerformUnitOfWorkPen.fillText('2.beginWork', 60, 168);oPerformUnitOfWorkPen.fillText('3-1.beginWork', 50, 290);oPerformUnitOfWorkPen.fillText('4-1.beginWork', 360, 270);oPerformUnitOfWorkPen.fillStyle='#3CF612';oPerformUnitOfWorkPen.fillText('3-2.completeWork', 255, 290);oPerformUnitOfWorkPen.fillText('4-2.completeWork', 470, 240);oPerformUnitOfWorkPen.fillText('4-3.completeWork', 255, 168);oPerformUnitOfWorkPen.fillText('4-4.completeWork', 255, 40);
</script>


<ol>
<li><p><code>beginWork阶段</code> 从根节点rootFiber开始，遍历到叶子节点，每次遍历到的节点都会执行beginWork，并且传入当前Fiber节点，然后创建或复用它的子Fiber节点，并赋值给workInProgress.child。</p>
</li>
<li><p><code>completeWork阶段</code> 在捕获阶段遍历到子节点之后，会执行completeWork方法，执行完成之后会判断此节点的兄弟节点存不存在，如果存在就会为兄弟节点执行completeWork，当全部兄弟节点执行完之后，会向上‘冒泡’到父节点执行completeWork，直到rootFiber。</p>
</li>
</ol>
  <div class="post-warning">注意：当遍历到只有一个子文本节点的Fiber时，该Fiber节点的子节点不会执行beginWork和completeWork，如图中的‘count’文本节点。这是react的一种优化手段</div>

<ul>
<li>render阶段整体调用流程：</li>
</ul>
  <canvas id="render" width="700" height="530"></canvas>


  <script>var oRender = document.getElementById('render');var oRenderPen = oRender.getContext('2d');oRenderPen.font = '10px sans-serif';oRenderPen.strokeRect(159, 10, 130, 30);oRenderPen.fillText('performSyncWorkOnRoot', 165, 28);oRenderPen.beginPath();oRenderPen.lineTo(224, 40);oRenderPen.lineTo(224, 54);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(220, 54);oRenderPen.lineTo(228, 54);oRenderPen.lineTo(224, 59);oRenderPen.closePath();oRenderPen.fill();oRenderPen.strokeRect(320, 10, 158, 30);oRenderPen.fillText('performConcurrentWorkOnRoot', 325, 28);oRenderPen.beginPath();oRenderPen.lineTo(398, 40);oRenderPen.lineTo(398, 54);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(394, 54);oRenderPen.lineTo(402, 54);oRenderPen.lineTo(398, 59);oRenderPen.closePath();oRenderPen.fill();oRenderPen.strokeRect(185, 60, 80, 30);oRenderPen.fillText('workLoopSync', 192, 78);oRenderPen.beginPath();oRenderPen.lineTo(265, 75);oRenderPen.lineTo(285, 75);oRenderPen.lineTo(285, 104);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(281, 104);oRenderPen.lineTo(289, 104);oRenderPen.lineTo(285, 109);oRenderPen.closePath();oRenderPen.fill();oRenderPen.strokeRect(340, 60, 110, 30);oRenderPen.fillText('workLoopConcurrent', 347, 78);oRenderPen.beginPath();oRenderPen.lineTo(340, 75);oRenderPen.lineTo(320, 75);oRenderPen.lineTo(320, 104);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(316, 104);oRenderPen.lineTo(324, 104);oRenderPen.lineTo(320, 109);oRenderPen.closePath();oRenderPen.fill();oRenderPen.strokeRect(253, 110, 100, 30);oRenderPen.fillText('performUnitOfWork', 257, 128);oRenderPen.beginPath();oRenderPen.lineTo(253, 125);oRenderPen.lineTo(224, 125);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(224, 121);oRenderPen.lineTo(224, 129);oRenderPen.lineTo(219, 125);oRenderPen.closePath();oRenderPen.fill();oRenderPen.strokeRect(160, 110, 58, 30);oRenderPen.fillText('beginWork', 164, 128);oRenderPen.beginPath();oRenderPen.lineTo(189, 140);oRenderPen.lineTo(189, 155);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(185, 155);oRenderPen.lineTo(193, 155);oRenderPen.lineTo(189, 160);oRenderPen.closePath();oRenderPen.fill();oRenderPen.beginPath();oRenderPen.lineTo(189, 160);oRenderPen.lineTo(244, 185);oRenderPen.lineTo(189, 210);oRenderPen.lineTo(134, 185);oRenderPen.closePath();oRenderPen.fillText('current !== null', 152, 182);oRenderPen.fillText('update | mount', 154, 193);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(134, 185);oRenderPen.lineTo(70, 185);oRenderPen.lineTo(70, 220);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(66, 220);oRenderPen.lineTo(74, 220);oRenderPen.lineTo(70, 225);oRenderPen.closePath();oRenderPen.fill();oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(244, 185);oRenderPen.lineTo(342, 185);oRenderPen.lineTo(342, 250);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(338, 250);oRenderPen.lineTo(346, 250);oRenderPen.lineTo(342, 255);oRenderPen.closePath();oRenderPen.fill();oRenderPen.beginPath();oRenderPen.lineTo(70, 225);oRenderPen.lineTo(108, 240);oRenderPen.lineTo(70, 255);oRenderPen.lineTo(32, 240);oRenderPen.closePath();oRenderPen.stroke();oRenderPen.fillText('是否能复用', 44, 243);oRenderPen.beginPath();oRenderPen.lineTo(108, 240);oRenderPen.lineTo(262, 240);oRenderPen.lineTo(262, 250);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(258, 250);oRenderPen.lineTo(266, 250);oRenderPen.lineTo(262, 255);oRenderPen.closePath();oRenderPen.fill();oRenderPen.beginPath();oRenderPen.lineTo(70, 255);oRenderPen.lineTo(70, 275);oRenderPen.lineTo(70, 275);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(66, 275);oRenderPen.lineTo(74, 275);oRenderPen.lineTo(70, 280);oRenderPen.closePath();oRenderPen.fill();oRenderPen.strokeRect(1, 280, 144, 30);oRenderPen.fillText('bailoutOnAlreadyFinishedWork', 2, 298);oRenderPen.beginPath();oRenderPen.lineTo(70, 310);oRenderPen.lineTo(70, 340);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(66, 340);oRenderPen.lineTo(74, 340);oRenderPen.lineTo(70, 345);oRenderPen.closePath();oRenderPen.fill();oRenderPen.beginPath();oRenderPen.lineTo(70, 345);oRenderPen.lineTo(128, 360);oRenderPen.lineTo(70, 375);oRenderPen.lineTo(12, 360);oRenderPen.closePath();oRenderPen.stroke();oRenderPen.fillText('节点是否需要更新', 31, 364);oRenderPen.beginPath();oRenderPen.lineTo(70, 375);oRenderPen.lineTo(70, 395);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(66, 395);oRenderPen.lineTo(74, 395);oRenderPen.lineTo(70, 400);oRenderPen.closePath();oRenderPen.fill();oRenderPen.strokeRect(30, 400, 82, 30);oRenderPen.fillText('cloneChildFibers', 31, 418);oRenderPen.beginPath();oRenderPen.lineTo(128, 360);oRenderPen.lineTo(142, 360);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(142, 356);oRenderPen.lineTo(142, 364);oRenderPen.lineTo(147, 360);oRenderPen.closePath();oRenderPen.fill();oRenderPen.strokeRect(147, 344, 50, 30);oRenderPen.fillText('return null', 148, 362);oRenderPen.strokeRect(236, 255, 128, 30);oRenderPen.fillText('根据workInProgress.tag进入', 236, 268);oRenderPen.fillText('不同的Fiber创建函数', 254, 280);oRenderPen.beginPath();oRenderPen.lineTo(262, 285);oRenderPen.lineTo(262, 315);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(258, 315);oRenderPen.lineTo(266, 315);oRenderPen.lineTo(262, 320);oRenderPen.closePath();oRenderPen.fill();oRenderPen.beginPath();oRenderPen.lineTo(342, 285);oRenderPen.lineTo(342, 315);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(338, 315);oRenderPen.lineTo(346, 315);oRenderPen.lineTo(342, 320);oRenderPen.closePath();oRenderPen.fill();oRenderPen.strokeRect(202, 320, 96, 30);oRenderPen.fillText('reconcileChildFibers', 203, 338);oRenderPen.strokeRect(310, 320, 82, 30);oRenderPen.fillText('mountchildFibers', 312, 338);oRenderPen.beginPath();oRenderPen.lineTo(262, 350);oRenderPen.lineTo(262, 375);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(258, 375);oRenderPen.lineTo(266, 375);oRenderPen.lineTo(262, 380);oRenderPen.closePath();oRenderPen.fill();oRenderPen.beginPath();oRenderPen.lineTo(342, 350);oRenderPen.lineTo(342, 375);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(338, 375);oRenderPen.lineTo(346, 375);oRenderPen.lineTo(342, 380);oRenderPen.closePath();oRenderPen.fill();oRenderPen.strokeRect(258, 380, 90, 30);oRenderPen.fillText('childReconclier', 268, 398);oRenderPen.strokeRect(272, 430, 64, 30);oRenderPen.fillText('createFibers', 275, 448);oRenderPen.beginPath();oRenderPen.lineTo(302, 410);oRenderPen.lineTo(302, 425);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(298, 425);oRenderPen.lineTo(306, 425);oRenderPen.lineTo(302, 430);oRenderPen.closePath();oRenderPen.fill();oRenderPen.beginPath();oRenderPen.lineTo(353, 125);oRenderPen.lineTo(365, 125);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(365, 121);oRenderPen.lineTo(365, 129);oRenderPen.lineTo(370, 125);oRenderPen.closePath();oRenderPen.fill();oRenderPen.strokeRect(370, 110, 108, 30);oRenderPen.fillText('completeUnitOfWork', 374, 128);oRenderPen.beginPath();oRenderPen.lineTo(478, 125);oRenderPen.lineTo(505, 125);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(505, 121);oRenderPen.lineTo(505, 129);oRenderPen.lineTo(510, 125);oRenderPen.closePath();oRenderPen.fill();oRenderPen.strokeRect(510, 110, 76, 30);oRenderPen.fillText('completeWork', 514, 128);oRenderPen.beginPath();oRenderPen.lineTo(548, 140);oRenderPen.lineTo(548, 155);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(544, 155);oRenderPen.lineTo(552, 155);oRenderPen.lineTo(548, 160);oRenderPen.closePath();oRenderPen.fill();oRenderPen.strokeRect(482, 160, 142, 30);oRenderPen.fillText('根据workInProgress.tag的类型', 483, 172);oRenderPen.fillText('进入不同的函数', 516, 184);oRenderPen.beginPath();oRenderPen.lineTo(550, 190);oRenderPen.lineTo(550, 200);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(546, 200);oRenderPen.lineTo(554, 200);oRenderPen.lineTo(550, 205);oRenderPen.closePath();oRenderPen.fill();oRenderPen.beginPath();oRenderPen.lineTo(551, 205);oRenderPen.lineTo(599, 220);oRenderPen.lineTo(551, 235);oRenderPen.lineTo(503, 220);oRenderPen.closePath();oRenderPen.stroke();oRenderPen.fillText('update | mount', 516, 222);oRenderPen.beginPath();oRenderPen.lineTo(503, 220);oRenderPen.lineTo(458, 220);oRenderPen.lineTo(458, 265);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(454, 265);oRenderPen.lineTo(462, 265);oRenderPen.lineTo(458, 270);oRenderPen.closePath();oRenderPen.fill();oRenderPen.beginPath();oRenderPen.lineTo(599, 220);oRenderPen.lineTo(644, 220);oRenderPen.lineTo(644, 265);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(640, 265);oRenderPen.lineTo(648, 265);oRenderPen.lineTo(644, 270);oRenderPen.closePath();oRenderPen.fill();oRenderPen.strokeRect(404, 270, 120, 30);oRenderPen.fillText('updateHostComponent$1', 405, 288);oRenderPen.beginPath();oRenderPen.lineTo(460, 300);oRenderPen.lineTo(460, 435);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(456, 435);oRenderPen.lineTo(464, 435);oRenderPen.lineTo(460, 440);oRenderPen.closePath();oRenderPen.fill();oRenderPen.strokeRect(404, 440, 192, 30);oRenderPen.fillText('把带有effectTag的节点加入到effectList中', 405, 453);oRenderPen.fillText('返回下一个workInProgress节点', 430, 465);oRenderPen.beginPath();oRenderPen.lineTo(530, 470);oRenderPen.lineTo(530, 485);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(526, 485);oRenderPen.lineTo(534, 485);oRenderPen.lineTo(530, 490);oRenderPen.closePath();oRenderPen.fill();oRenderPen.strokeRect(610, 270, 70, 30);oRenderPen.fillText('createInstance', 611, 288);oRenderPen.beginPath();oRenderPen.lineTo(644, 300);oRenderPen.lineTo(644, 315);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(640, 315);oRenderPen.lineTo(648, 315);oRenderPen.lineTo(644, 320);oRenderPen.closePath();oRenderPen.fill();oRenderPen.strokeRect(603, 320, 86, 30);oRenderPen.fillText('appendAllChildren', 604, 338);oRenderPen.beginPath();oRenderPen.lineTo(644, 350);oRenderPen.lineTo(644, 365);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(640, 365);oRenderPen.lineTo(648, 365);oRenderPen.lineTo(644, 370);oRenderPen.closePath();oRenderPen.fill();oRenderPen.strokeRect(598, 370, 96, 30);oRenderPen.fillText('finalizeInitialchildren', 599, 388);oRenderPen.beginPath();oRenderPen.lineTo(644, 400);oRenderPen.lineTo(644, 455);oRenderPen.lineTo(601, 455);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(601, 451);oRenderPen.lineTo(601, 459);oRenderPen.lineTo(596, 455);oRenderPen.closePath();oRenderPen.fill();oRenderPen.strokeRect(496, 490, 70, 30);oRenderPen.fillText('commitRoot', 503, 508);oRenderPen.fillStyle='blue';oRenderPen.fillText('update', 92, 180);oRenderPen.fillText('mount', 260, 180);oRenderPen.fillText('否', 120, 236);oRenderPen.fillText('能', 74, 270);oRenderPen.fillText('否', 130, 357);oRenderPen.fillText('是', 74, 388);oRenderPen.fillText('clone子节点', 114, 418);oRenderPen.fillText('update',228, 305);oRenderPen.fillText('mount', 344, 305);oRenderPen.fillText('带上effectTag',190, 315);oRenderPen.fillText('不带上effectTag', 350, 315);oRenderPen.fillText('diff算法', 225, 370);oRenderPen.fillText('创建子节点', 214, 450);oRenderPen.fillText('假设进入了', 430, 175);oRenderPen.fillText('HostComponent', 402, 187);oRenderPen.fillText('update', 467, 216);oRenderPen.fillText('mount', 603, 216);oRenderPen.fillText('处理props将变化的部分赋值给', 462, 250);oRenderPen.fillText('workInprogress.updateQueue', 462, 262);oRenderPen.fillText('创建dom节点赋值', 529, 282);oRenderPen.fillText('给fiber.stateNode', 528, 294);oRenderPen.fillText('将后代节点插入当前节点', 492, 338);oRenderPen.fillText('初始化dom属性', 525, 387);</script>


<h3 id="beginWork"><a href="#beginWork" class="headerlink" title="beginWork"></a>beginWork</h3><p>  beginWork主要的工作是创建或复用子fiber节点。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params">current, workInProgress, renderLanes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> updateLanes = workInProgress.lanes;</span><br><span class="line">  <span class="comment">// 1.update时满足条件即可复用current fiber进入bailoutOnAlreadyFinishedWork函数</span></span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> oldProps = current.memoizedProps;</span><br><span class="line">    <span class="keyword">var</span> newProps = workInProgress.pendingProps;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldProps !== newProps || hasContextChanged() || (workInProgress.type !== current.type )) &#123;</span><br><span class="line">      didReceiveUpdate = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!includesSomeLane(renderLanes, updateLanes)) &#123;</span><br><span class="line">      didReceiveUpdate = <span class="literal">false</span>; </span><br><span class="line">      <span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">       <span class="comment">// ......</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((current.flags &amp; ForceUpdateForLegacySuspense) !== NoFlags) &#123;</span><br><span class="line">        didReceiveUpdate = <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  workInProgress.lanes = NoLanes;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.根据tag来创建不同的fiber 最后进入reconcileChildren函数</span></span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> IndeterminateComponent: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> LazyComponent: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> FunctionComponent: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> ClassComponent: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> HostRoot: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> HostComponent: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> HostText: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> SuspenseComponent: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> HostPortal: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> ForwardRef: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> Fragment: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> Mode: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> Profiler: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> ContextProvider: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> ContextConsumer: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> MemoComponent: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> SimpleMemoComponent: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> IncompleteClassComponent: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> SuspenseListComponent: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> FundamentalComponent: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> ScopeComponent: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> Block:   <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> OffscreenComponent: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> LegacyHiddenComponent: <span class="comment">// ......</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>( <span class="string">"Unknown unit of work tag ("</span> + workInProgress.tag + <span class="string">"). This error is likely caused by a bug in React. Please file an issue."</span> );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  从代码中可以看到参数中有current Fiber，也就是当前真实dom对应的Fiber树，在之前介绍Fiber双缓存机制中，我们知道在首次渲染时除了rootFiber外，current 等于 null，因为首次渲染dom还没构建出来，在update时current不等于 null，因为update时dom树已经存在了，所以beginWork函数中用current === null来判断是mount还是update进入不同的逻辑。</p>
<blockquote>
<p>mount：根据fiber.tag进入不同fiber的创建函数，最后都会调用到reconcileChildren创建子Fiber<br>update：在构建workInProgress的时候，当满足条件时，会复用current Fiber来进行优化，也就是进入bailoutOnAlreadyFinishedWork的逻辑，能复用didReceiveUpdate变量是false，复用的条件是<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">oldProps === newProps &amp;&amp; workInProgress.type === current.type 属性和fiber的type不变</span><br><span class="line">!includesSomeLane(renderLanes, updateLanes) 更新的优先级是否足够。</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="bailoutOnAlreadyFinishedWork"><a href="#bailoutOnAlreadyFinishedWork" class="headerlink" title="bailoutOnAlreadyFinishedWork"></a>bailoutOnAlreadyFinishedWork</h4>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bailoutOnAlreadyFinishedWork</span>(<span class="params">current, workInProgress, renderLanes</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 优先级足够则进入cloneChildFibers，否则返回null，不需要更新</span></span><br><span class="line">  <span class="keyword">if</span> (!includesSomeLane(renderLanes, workInProgress.childLanes)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cloneChildFibers(current, workInProgress);</span><br><span class="line">    <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="reconcileChildren-mountChildFibers"><a href="#reconcileChildren-mountChildFibers" class="headerlink" title="reconcileChildren/mountChildFibers"></a>reconcileChildren/mountChildFibers</h4><p>  创建子fiber的过程会进入reconcileChildren（可以看一下源码），该函数的作用是为workInProgress fiber节点生成它的child fiber即 workInProgress.child。<strong>然后继续深度优先遍历它的子节点执行相同的操作。</strong></p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildren</span>(<span class="params">current, workInProgress, nextChildren, renderLanes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">    workInProgress.child = mountChildFibers(workInProgress, <span class="literal">null</span>, nextChildren, renderLanes);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  reconcileChildren会区分mount和update两种情况，进入reconcileChildFibers或mountChildFibers，reconcileChildFibers和mountChildFibers最终其实都是调用ChildReconciler传递不同的参数返回的函数，这个参数（shouldTrackSideEffects）用来表示是否追踪副作用，在ChildReconciler中用shouldTrackSideEffects来判断是否为对应的节点打上effectTag。</p>
<p>  为Fiber打上effectTag之后在commit阶段会被执行对应dom的增删改，而且在reconcileChildren的时候，rootFiber是存在alternate的，即rootFiber存在对应的current Fiber，所以rootFiber会走reconcileChildFibers的逻辑，所以shouldTrackSideEffects等于true会追踪副作用，最后为rootFiber打上Placement的effectTag，然后将dom一次性插入，提高性能。</p>
<h3 id="completeWork"><a href="#completeWork" class="headerlink" title="completeWork"></a>completeWork</h3><p>  completeWork主要工作是处理fiber的props、创建dom、创建effectList。</p>
<p>  从函数调用来看，我们可以从performUnitOfWork来看，在WorkLoopSync或WorkLoopConcurrent中都会do…while调用performUnitOfWork，停止的条件是workInprogress等于null。</p>
<p>  performUnitOfWork首先会调用beginWork，创建或复用子fiber节点，如果子节点还有有子节点，则将其赋为新的workInprogress继续执行beginWork。如果没有子节点开始调用completeUnitOfWork。</p>
<p>  completeUnitOfWork会do…while调用completeWork，如果当前有兄弟节点siblingFiber，则对将siblingFiber赋值给workInProgress，再走beginWork。。。如果当前子节点有returnFiber则将returnFiber赋给workInProgress，继续执行completeWork。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeWork</span>(<span class="params">current, workInProgress, renderLanes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newProps = workInProgress.pendingProps; </span><br><span class="line"></span><br><span class="line">  popTreeContext(workInProgress);</span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> IndeterminateComponent:</span><br><span class="line">    <span class="keyword">case</span> LazyComponent:</span><br><span class="line">    <span class="keyword">case</span> SimpleMemoComponent:</span><br><span class="line">    <span class="keyword">case</span> FunctionComponent:</span><br><span class="line">    <span class="keyword">case</span> ForwardRef:</span><br><span class="line">    <span class="keyword">case</span> Fragment:</span><br><span class="line">    <span class="keyword">case</span> Mode:</span><br><span class="line">    <span class="keyword">case</span> Profiler:</span><br><span class="line">    <span class="keyword">case</span> ContextConsumer:</span><br><span class="line">    <span class="keyword">case</span> MemoComponent:</span><br><span class="line">      ...</span><br><span class="line">    <span class="keyword">case</span> ClassComponent:</span><br><span class="line">      ...</span><br><span class="line">    <span class="keyword">case</span> HostComponent:</span><br><span class="line">      &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (current !== <span class="literal">null</span> &amp;&amp; workInProgress.stateNode != <span class="literal">null</span>) &#123;</span><br><span class="line">          updateHostComponent(current, workInProgress, type, newProps, rootContainerInstance);</span><br><span class="line">          ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          ...</span><br><span class="line">          <span class="keyword">var</span> instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);</span><br><span class="line"></span><br><span class="line">          appendAllChildren(instance, workInProgress, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">          workInProgress.stateNode = instance;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) &#123;</span><br><span class="line">            markUpdate(workInProgress);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bubbleProperties(workInProgress);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>根据workInProgress.tag进入不同函数，我们以HostComponent举例</li>
<li>update时（除了判断current===null外还需要判断workInProgress.stateNode===null），调用updateHostComponent处理props（包括onClick、style、children …），并将处理好的props赋值给updatePayload,最后会保存在workInProgress.updateQueue上。<br>mount时 调用createInstance创建dom，将后代dom节点插入刚创建的dom中，调用finalizeInitialChildren处理props（和updateHostComponent处理的逻辑类似）</li>
<li>在beginWork的mount时，rootFiber存在对应的current，所以他会执行mountChildFibers打上Placement的effectTag，在冒泡阶段也就是执行completeWork时，我们将子孙节点通过appendAllChildren挂载到新创建的dom节点上，最后就可以一次性将内存中的节点用dom原生方法反应到真实dom中。</li>
<li>在beginWork 中我们知道有的节点被打上了effectTag的标记，有的没有，而在commit阶段时要遍历所有包含effectTag的Fiber来执行对应的增删改，那我们还需要从Fiber树中找到这些带effectTag的节点嘛，答案是不需要的，这里是以空间换时间，在执行completeWork的时候遇到了带effectTag的节点，会将这个节点加入一个叫effectList中,所以在commit阶段只要遍历effectList就可以了（rootFiber.firstEffect.nextEffect就可以访问带effectTag的Fiber了）</li>
</ol>
<p>  画个简单的示意图：</p>
  <canvas id="pic" width="400" height="200"></canvas>


<script>
  const oPic = document.getElementById('pic');
  const oPicPen = oPic.getContext('2d');oPicPen.beginPath();oPicPen.lineTo(200, 20);oPicPen.lineTo(200, 60);oPicPen.lineTo(140, 100);oPicPen.lineTo(100, 140);oPicPen.lineTo(75, 170);oPicPen.stroke();oPicPen.beginPath();oPicPen.lineTo(200, 60);oPicPen.lineTo(260, 100);oPicPen.lineTo(220, 140);oPicPen.stroke();oPicPen.beginPath();oPicPen.lineTo(140, 100);oPicPen.lineTo(180, 140);oPicPen.lineTo(155, 170);oPicPen.stroke();oPicPen.beginPath();oPicPen.lineTo(260, 100);oPicPen.lineTo(300, 140);oPicPen.stroke();oPicPen.beginPath();oPicPen.lineTo(100, 140);oPicPen.lineTo(125, 170);oPicPen.stroke();oPicPen.beginPath();oPicPen.lineTo(180, 140);oPicPen.lineTo(205, 170);oPicPen.stroke();oPicPen.strokeStyle='blue';oPicPen.beginPath();oPicPen.lineTo(180, 10);oPicPen.lineTo(180, 60);oPicPen.lineTo(120, 100);oPicPen.lineTo(80, 140);oPicPen.lineTo(55, 180);oPicPen.lineTo(138, 180);oPicPen.lineTo(110, 140);oPicPen.lineTo(170, 140);oPicPen.lineTo(143, 180);oPicPen.lineTo(225, 180);oPicPen.lineTo(160, 100);oPicPen.lineTo(250, 100);oPicPen.lineTo(205, 150);oPicPen.lineTo(320, 150);oPicPen.lineTo(280, 100);oPicPen.lineTo(220, 60);oPicPen.lineTo(220, 10);oPicPen.stroke();oPicPen.fillStyle='red';oPicPen.fillText('1.begin', 142, 20);oPicPen.fillText('2.begin', 140, 60);oPicPen.fillText('3.begin', 82, 100);oPicPen.fillText('4.begin', 42, 140);oPicPen.fillText('5.begin', 25, 170);oPicPen.fillText('6.begin', 100, 190);oPicPen.fillText('7.b', 157, 140);oPicPen.fillText('8.begin', 150, 179);oPicPen.fillText('9.begin', 226, 190);oPicPen.fillText('10.begin', 213, 98);oPicPen.fillText('11.begin', 210, 148);oPicPen.fillText('12.begin', 320, 158);oPicPen.fillStyle='green';oPicPen.fillText('5.complete', 2, 180);oPicPen.fillText('6.complete', 83, 179);oPicPen.fillText('6.c', 110, 140);oPicPen.fillText('8.complete', 150, 190);oPicPen.fillText('9.complete', 226, 179);oPicPen.fillText('9.c', 180, 140);oPicPen.fillText('9.complete', 150, 98);oPicPen.fillText('11.complete', 210, 158);oPicPen.fillText('12.complete', 320, 148);oPicPen.fillText('12.complete', 280, 100);oPicPen.fillText('12.complete', 225, 60);oPicPen.fillText('12.complete', 225, 20);
</script>

<h2 id="commit阶段"><a href="#commit阶段" class="headerlink" title="commit阶段"></a>commit阶段</h2><h2 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h2><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h2 id="状态更新流程"><a href="#状态更新流程" class="headerlink" title="状态更新流程"></a>状态更新流程</h2><h2 id="hooks"><a href="#hooks" class="headerlink" title="hooks"></a>hooks</h2><h2 id="scheduler-amp-Lane"><a href="#scheduler-amp-Lane" class="headerlink" title="scheduler&amp;Lane"></a>scheduler&amp;Lane</h2><h2 id="concurrent模式-1"><a href="#concurrent模式-1" class="headerlink" title="concurrent模式"></a>concurrent模式</h2><h2 id="context"><a href="#context" class="headerlink" title="context"></a>context</h2><h2 id="事件系统"><a href="#事件系统" class="headerlink" title="事件系统"></a>事件系统</h2><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  不止停留在理论，也不只停留在源码。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/13/interview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lemon">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/background22.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/13/interview/" itemprop="url">interview</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-07-13T11:21:46+08:00">
                2021-07-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/专题/" itemprop="url" rel="index">
                    <span itemprop="name">专题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>每天一道面试题</p>
<h1 id="html"><a href="#html" class="headerlink" title="html"></a>html</h1><h1 id="css"><a href="#css" class="headerlink" title="css"></a>css</h1><h1 id="js"><a href="#js" class="headerlink" title="js"></a>js</h1><h2 id="回调函数，Promise，async-await的区别及理解"><a href="#回调函数，Promise，async-await的区别及理解" class="headerlink" title="回调函数，Promise，async await的区别及理解"></a>回调函数，Promise，async await的区别及理解</h2><h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><h1 id="react"><a href="#react" class="headerlink" title="react"></a>react</h1><h1 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h1><h1 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h1><h1 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h1><h1 id="数据结构-amp-算法"><a href="#数据结构-amp-算法" class="headerlink" title="数据结构&amp;算法"></a>数据结构&amp;算法</h1><h1 id="专题"><a href="#专题" class="headerlink" title="专题"></a>专题</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/05/13/nodejs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lemon">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/background22.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/13/nodejs/" itemprop="url">nodejs</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-05-13T20:07:53+08:00">
                2021-05-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/框架/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h1><p>  Node.js 是一个开源与跨平台的 JavaScript 运行时环境。<br>  Node.js 在浏览器外运行 V8 JavaScript 引擎（Google Chrome 的内核）。</p>
<p>  Node.js 2009年诞生。</p>
<p>  常见的Node.js 框架和工具，比如：Express。</p>
<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><h2 id="V8-JavaScript-引擎"><a href="#V8-JavaScript-引擎" class="headerlink" title="V8 JavaScript 引擎"></a><font color="#ff99cc">V8 JavaScript 引擎</font></h2><p>  <a href="https://v8.dev/" target="_blank" rel="noopener">V8</a> 提供了执行 JavaScript 的运行时环境。 DOM 和其他 Web 平台 API 则由浏览器提供。</p>
<p>  JavaScript 引擎独立于托管它的浏览器。 这个关键的特性推动了 Node.js 的兴起。 V8 于 2009 年被选为为 Node.js 提供支持的引擎，并且随着 Node.js 的爆炸性发展，V8 成为了现在为大量的服务器端代码（使用 JavaScript 编写）提供支持的引擎。</p>
<p>  V8 使用 C++ 编写，并且不断地被改进。 它是可移植的，且可运行于 Mac、Windows、Linux 和其他一些系统。</p>
<h2 id="从命令行运行-Node-js-脚本"><a href="#从命令行运行-Node-js-脚本" class="headerlink" title="从命令行运行 Node.js 脚本"></a><font color="#ff99cc">从命令行运行 Node.js 脚本</font></h2>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node xxx.js</span><br></pre></td></tr></table></figure>
<h2 id="Node-js程序中退出"><a href="#Node-js程序中退出" class="headerlink" title="Node.js程序中退出"></a><font color="#ff99cc">Node.js程序中退出</font></h2><pre><code>命令行：Ctrl + c
程序：
1）process.exit()
  如：process.exit(1)  不写默认0。 [退出码](http://nodejs.cn/api/process.html#process_exit_codes)

  也可以设置 process.exitCode 属性：
  process.exitCode = 1
  当程序结束时，Node.js 会返回该退出码。

  当进程完成所有处理后，程序会正常地退出。
</code></pre>  <div class="post-warning">注意：process 不需要 “require”，它是自动可用的。</div>

<pre><code>2）信号
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">process.on(&apos;SIGTERM&apos;, () =&gt; &#123;</span><br><span class="line">  server.close(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;进程已终止&apos;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</code></pre>  <div class="post-warning">什么是信号？信号是一个 POSIX 内部通信系统：发送通知给进程，以告知其发生的事件。</div>

<pre><code>SIGKILL 是告诉进程要立即终止的信号，理想情况下，其行为类似于 process.exit()。

SIGTERM 是告诉进程要正常终止的信号。它是从进程管理者（如 upstart 或 supervisord）等发出的信号。

可以从程序内部另一个函数中发送此信号：
process.kill(process.pid, &apos;SIGTERM&apos;)
或从另一个正在运行的 Node.js 程序、或从系统中运行的其他任何的应用程序（能知道要终止的进程的 PID）。
</code></pre><h2 id="从-Node-js-读取环境变量"><a href="#从-Node-js-读取环境变量" class="headerlink" title="从 Node.js 读取环境变量"></a><font color="#ff99cc">从 Node.js 读取环境变量</font></h2><pre><code>Node.js 的 process 核心模块提供了 env 属性，该属性承载了在启动进程时设置的所有环境变量。
这是访问 NODE_ENV 环境变量的示例，该环境变量默认情况下被设置为 development。在脚本运行之前将其设置为 &quot;production&quot;，则可告诉 Node.js 这是生产环境。
可以用相同的方式访问设置的任何自定义的环境变量。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process.env.NODE_ENV // &quot;development&quot;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="使用-Node-js-REPL"><a href="#使用-Node-js-REPL" class="headerlink" title="使用 Node.js REPL"></a><font color="#ff99cc">使用 Node.js REPL</font></h2>  <div class="post-warning">REPL 也被称为运行评估打印循环，是一种编程语言环境（主要是控制台窗口），它使用单个表达式作为用户输入，并在执行后将结果返回到控制台。</div>

<ol>
<li><p>终端直接执行node<br>会等待js代码的输入，酷。<br>Ctrl+c 或者.exit退出程序。<br>使用 tab 键自动补全</p>
</li>
<li><p>点提示<br>尝试输入 JavaScript 类的名称，例如 Number，添加一个点号并按下 tab。REPL 会打印可以在该类上访问的所有属性和方法。<br>通过输入 global. 并按下 tab，可以检查可以访问的全局变量。</p>
</li>
<li><p>点命令<br>REPL 有一些特殊的命令，所有这些命令都以点号 . 开头。它们是：<br>.help: 显示点命令的帮助。<br>.editor: 启用编辑器模式，可以轻松地编写多行 JavaScript 代码。当处于此模式时，按下 ctrl-D 可以运行编写的代码。<br>.break: 当输入多行的表达式时，输入 .break 命令可以中止进一步的输入。相当于按下 ctrl-C。<br>.clear: 将 REPL 上下文重置为空对象，并清除当前正在输入的任何多行的表达式。<br>.load: 加载 JavaScript 文件（相对于当前工作目录）。<br>.save: 将在 REPL 会话中输入的所有内容保存到文件（需指定文件名）。<br>.exit: 退出 REPL（相当于按下两次 ctrl-C）。</p>
</li>
</ol>
<h2 id="Node-js-从命令行接收参数"><a href="#Node-js-从命令行接收参数" class="headerlink" title="Node.js 从命令行接收参数"></a><font color="#ff99cc">Node.js 从命令行接收参数</font></h2><pre><code>process 对象的argv属性。
</code></pre><h2 id="使用-Node-js-输出到命令行"><a href="#使用-Node-js-输出到命令行" class="headerlink" title="使用 Node.js 输出到命令行"></a><font color="#ff99cc">使用 Node.js 输出到命令行</font></h2><h3 id="使用控制台模块的基础输出"><a href="#使用控制台模块的基础输出" class="headerlink" title="使用控制台模块的基础输出"></a>使用控制台模块的基础输出</h3><p>   Node.js 提供了 console 模块，该模块提供了大量非常有用的与命令行交互的方法。它基本上与浏览器中的 console 对象相同。最基础、最常用的方法是 console.log()，该方法会打印传入到控制台的字符串。<br>   可以传入多个变量到 console.log，也可以通过传入变量和格式说明符来格式化用语。<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;我的%s已经%d岁&apos;, &apos;猫&apos;, 2); // 我的猫已经2岁</span><br></pre></td></tr></table></figure></p>
<pre><code>%s 会格式化变量为字符串
%d 会格式化变量为数字
%i 会格式化变量为其整数部分
%o 会格式化变量为对象
</code></pre><h3 id="清空控制台"><a href="#清空控制台" class="headerlink" title="清空控制台"></a>清空控制台</h3><pre><code>console.clear()
</code></pre><h3 id="元素计数"><a href="#元素计数" class="headerlink" title="元素计数"></a>元素计数</h3><pre><code>console.count()
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const oranges = [&apos;橙子&apos;, &apos;橙子&apos;]</span><br><span class="line">const apples = [&apos;苹果&apos;]</span><br><span class="line">oranges.forEach(fruit =&gt; &#123;</span><br><span class="line">  console.count(fruit)</span><br><span class="line">&#125;)</span><br><span class="line">apples.forEach(fruit =&gt; &#123;</span><br><span class="line">  console.count(fruit)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">橙子: 1</span><br><span class="line">橙子: 2</span><br><span class="line">苹果: 1</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="打印堆栈踪迹"><a href="#打印堆栈踪迹" class="headerlink" title="打印堆栈踪迹"></a>打印堆栈踪迹</h3><pre><code>在某些情况下，打印函数的调用堆栈踪迹很有用，console.trace()
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const function2 = () =&gt; console.trace()</span><br><span class="line">const function1 = () =&gt; function2()</span><br><span class="line">function1()</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="计算耗时"><a href="#计算耗时" class="headerlink" title="计算耗时"></a>计算耗时</h3>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const doSomething = () =&gt; console.log(&apos;测试&apos;)</span><br><span class="line">const measureDoingSomething = () =&gt; &#123;</span><br><span class="line">  console.time(&apos;开始&apos;)</span><br><span class="line">  //做点事，并测量所需的时间。</span><br><span class="line">  doSomething()</span><br><span class="line">  console.timeEnd(&apos;开始&apos;)</span><br><span class="line">&#125;</span><br><span class="line">measureDoingSomething()</span><br><span class="line"></span><br><span class="line">开始: 10401.35498046875 ms</span><br></pre></td></tr></table></figure>
<h3 id="stdout-和-stderr"><a href="#stdout-和-stderr" class="headerlink" title="stdout 和 stderr"></a>stdout 和 stderr</h3><pre><code>console.log 非常适合在控制台中打印消息。 这就是所谓的标准输出（或称为 stdout）。
console.error 会打印到 stderr 流。
它不会出现在控制台中，但是会出现在错误日志中。
</code></pre><h3 id="为输出着色"><a href="#为输出着色" class="headerlink" title="为输出着色"></a>为输出着色</h3><p>   1）可以使用转义序列在控制台中为文本的输出着色。 转义序列是一组标识颜色的字符。<br>    console.log(‘\033[30m%s\033[0m’, ‘你好’) // 黑色<br>    console.log(‘\033[31m%s\033[0m’, ‘你好’) // 红色<br>    console.log(‘\033[32m%s\033[0m’, ‘你好’) // 绿色<br>    console.log(‘\033[33m%s\033[0m’, ‘你好’) // 黄色<br>    console.log(‘\033[34m%s\033[0m’, ‘你好’) // 深蓝<br>    console.log(‘\033[35m%s\033[0m’, ‘你好’) // 深粉<br>    console.log(‘\033[36m%s\033[0m’, ‘你好’) // 浅蓝<br>    console.log(‘\033[37m%s\033[0m’, ‘你好’) // 白色<br>    console.log(‘\x1b[33m%s\x1b[0m’, ‘你好’)  // 黄色</p>
<p>  2） 为控制台输出着色的最简单方法是使用库。 Chalk 是一个这样的库，除了为其着色外，它还有助于其他样式的设置（例如使文本变为粗体、斜体或带下划线）。<br>      可以使用 npm install chalk 进行安装，然后就可以使用它：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const chalk = require(&apos;chalk&apos;)</span><br><span class="line">console.log(chalk.yellow(&apos;你好&apos;))</span><br></pre></td></tr></table></figure></p>
<h3 id="创建进度条"><a href="#创建进度条" class="headerlink" title="创建进度条"></a>创建进度条</h3><p>   Progress 是一个很棒的软件包，可在控制台中创建进度条。 使用 npm install progress 进行安装。</p>
<p>   以下代码段会创建一个 10 步的进度条，每 100 毫秒完成一步。 当进度条结束时，则清除定时器：<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const ProgressBar = require(&apos;progress&apos;)</span><br><span class="line"></span><br><span class="line">const bar = new ProgressBar(&apos;:bar&apos;, &#123; total: 10 &#125;)</span><br><span class="line">const timer = setInterval(() =&gt; &#123;</span><br><span class="line">  bar.tick()</span><br><span class="line">  if (bar.complete) &#123;</span><br><span class="line">    clearInterval(timer)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, 100)</span><br></pre></td></tr></table></figure></p>
<h2 id="在-Node-js-中从命令行接收输入"><a href="#在-Node-js-中从命令行接收输入" class="headerlink" title="在 Node.js 中从命令行接收输入"></a><font color="#ff99cc">在 Node.js 中从命令行接收输入</font></h2><p>  从版本 7 开始，Node.js 提供了 readline <a href="http://nodejs.cn/api/readline.html" target="_blank" rel="noopener">模块</a>来执行以下操作：每次一行地从可读流（例如 process.stdin 流，在 Node.js 程序执行期间该流就是终端输入）获取输入。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const readline = require(&apos;readline&apos;).createInterface(&#123;</span><br><span class="line">  input: process.stdin,</span><br><span class="line">  output: process.stdout</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">readline.question(`你叫什么名字?`, name =&gt; &#123;</span><br><span class="line">  console.log(`你好 $&#123;name&#125;!`)</span><br><span class="line">  readline.close()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const inquirer = require(&apos;inquirer&apos;)</span><br><span class="line"></span><br><span class="line">var questions = [</span><br><span class="line">  &#123;</span><br><span class="line">    type: &apos;input&apos;,</span><br><span class="line">    name: &apos;name&apos;,</span><br><span class="line">    message: &quot;你叫什么名字?&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">inquirer.prompt(questions).then(answers =&gt; &#123;</span><br><span class="line">  console.log(`你好 $&#123;answers[&apos;name&apos;]&#125;!`)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>  Inquirer.js 可以执行许多操作，例如询问多项选择、展示单选按钮、确认等。</p>
<h2 id="使用-exports-从-Node-js-文件中公开功能"><a href="#使用-exports-从-Node-js-文件中公开功能" class="headerlink" title="使用 exports 从 Node.js 文件中公开功能"></a><font color="#ff99cc">使用 exports 从 Node.js 文件中公开功能</font></h2><pre><code>Node.js 具有内置的模块系统。
1) 第一种方式是将对象赋值给 module.exports（这是模块系统提供的对象），这会使文件只导出该对象：
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const car = &#123;</span><br><span class="line">  brand: &apos;Ford&apos;,</span><br><span class="line">  model: &apos;Fiesta&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = car</span><br><span class="line"></span><br><span class="line">//在另一个文件中</span><br><span class="line"></span><br><span class="line">const car = require(&apos;./car&apos;)</span><br></pre></td></tr></table></figure>

2) 第二种方式是将要导出的对象添加为 exports 的属性。这种方式可以导出多个对象、函数或数据：
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const car = &#123;</span><br><span class="line">  brand: &apos;Ford&apos;,</span><br><span class="line">  model: &apos;Fiesta&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.car = car</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在另一个文件中，则通过引用导入的属性来使用它：</span><br><span class="line">const items = require(&apos;./items&apos;)</span><br><span class="line">items.car</span><br><span class="line">或</span><br><span class="line">const car = require(&apos;./items&apos;).car</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li>module.exports 和 exports 之间有什么区别？<br>  前者公开了它指向的对象。 后者公开了它指向的对象的属性。</li>
</ul>
<h2 id="npm-包管理器简介"><a href="#npm-包管理器简介" class="headerlink" title="npm 包管理器简介"></a><font color="#ff99cc">npm 包管理器简介</font></h2><p>  npm 是 Node.js 标准的软件包管理器。</p>
  <div class="post-warning">Yarn 是 npm 的一个替代选择。</div>

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">npm install  // 如果项目具有 package.json 文件，则通过运行此命令可安装全部依赖</span><br><span class="line">npm install xxx</span><br><span class="line"> npm install &lt;package-name&gt;@0.0.1</span><br><span class="line">npm i --save</span><br><span class="line">npm i --save-dev</span><br><span class="line">npm update</span><br><span class="line">npm update &lt;package-name&gt;</span><br><span class="line">npm run &lt;task-name&gt; // 运行script命令</span><br></pre></td></tr></table></figure>
<h2 id="npm-将软件包安装到哪里"><a href="#npm-将软件包安装到哪里" class="headerlink" title="npm 将软件包安装到哪里"></a><font color="#ff99cc">npm 将软件包安装到哪里</font></h2><ul>
<li><p>本地安装<br>软件包会被安装到当前文件树中的 node_modules 子文件夹下。</p>
</li>
<li><p>全局安装<br>在这种情况下，npm 不会将软件包安装到本地文件夹下，而是使用全局的位置。<br>npm root -g 命令会告知其在计算机上的确切位置。</p>
<p>在 macOS 或 Linux 上，此位置可能是 /usr/local/lib/node_modules。 在 Windows 上，可能是 C:\Users\YOU\AppData\Roaming\npm\node_modules。</p>
</li>
</ul>
<h2 id="如何使用或执行-npm-安装的软件包"><a href="#如何使用或执行-npm-安装的软件包" class="headerlink" title="如何使用或执行 npm 安装的软件包"></a><font color="#ff99cc">如何使用或执行 npm 安装的软件包</font></h2><h2 id="package-json-指南"><a href="#package-json-指南" class="headerlink" title="package.json 指南"></a><font color="#ff99cc">package.json 指南</font></h2><p>  package.json 文件是项目的清单。 它可以做很多完全互不相关的事情。 例如，它是用于工具的配置中心。 它也是 npm 和 yarn 存储所有已安装软件包的名称和版本的地方。</p>
<h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>  对于package.json 文件中的内容没有固定的要求，唯一的要求是必须遵守 JSON 格式。</p>
<h3 id="属性分类"><a href="#属性分类" class="headerlink" title="属性分类"></a>属性分类</h3><pre><code>- name
- author
- contributors
- bugs
- homepage
- version
- license
- keywords
- description
- repository
- main
- private
- scripts
- dependencies
- devDependencies
- engines
- browserslist
- 命令特有的属性
  package.json 文件还可以承载命令特有的配置，例如 Babel、ESLint 等。
  每个都有特有的属性，例如 eslintConfig、babel 等。 它们是命令特有的，可以在相应的命令/项目文档中找到如何使用它们。
</code></pre><h3 id="软件包版本"><a href="#软件包版本" class="headerlink" title="软件包版本"></a>软件包版本</h3><ul>
<li>在上面的描述中，已经看到类似以下的版本号：〜0.13.0 或 ^0.13.0。 它们是什么意思，还可以使用哪些其他的版本说明符？<br>该符号指定了软件包能从该依赖接受的更新。<br>如果写入的是 〜0.13.0，则只更新补丁版本：即 0.13.1 可以，但 0.14.0 不可以。<br>如果写入的是 ^0.13.0，则要更新补丁版本和次版本：即 0.13.1、0.14.0、依此类推。<br>如果写入的是 0.13.0，则始终使用确切的版本。</li>
</ul>
<h2 id="package-lock-json-文件"><a href="#package-lock-json-文件" class="headerlink" title="package-lock.json 文件"></a><font color="#ff99cc">package-lock.json 文件</font></h2><pre><code>package-lock.json 会固化当前安装的每个软件包的版本，当运行 npm install时，npm 会使用这些确切的版本。
package-lock.json 文件需要被提交到 Git 仓库，以便被其他人获取（如果项目是公开的或有合作者，或者将 Git 作为部署源）。
当运行 npm update 时，package-lock.json 文件中的依赖的版本会被更新。
&lt;div class=&apos;post-warning&apos;&gt;如果指定确切的版本，例如示例中的 0.13.0，则不会受到此问题的影响。如果指定确切的版本，例如示例中的 0.13.0，则不会受到此问题的影响。&lt;/div&gt;
</code></pre><h2 id="npm-包"><a href="#npm-包" class="headerlink" title="npm 包"></a><font color="#ff99cc">npm 包</font></h2><h3 id="查看-npm-包安装的版本"><a href="#查看-npm-包安装的版本" class="headerlink" title="查看 npm 包安装的版本"></a>查看 npm 包安装的版本</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm list  // 查看所有已安装的 npm 软件包（包括它们的依赖包），也可以打开 package-lock.json 文件，但这需要进行一些视觉扫描。</span><br><span class="line">npm list -g  // 也一样，但适用于全局安装的软件包。</span><br><span class="line">npm list --depth=0  // 仅获取顶层的软件包</span><br><span class="line">npm list &lt;package-name&gt; // 获取特定软件包的版本</span><br><span class="line">npm view [package_name] version // 查看软件包在 npm 仓库上最新的可用版本</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="安装-npm-包的旧版本"><a href="#安装-npm-包的旧版本" class="headerlink" title="安装 npm 包的旧版本"></a>安装 npm 包的旧版本</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install &lt;package&gt;@&lt;version&gt;  // 安装指定版本</span><br><span class="line">npm view &lt;package&gt; versions  // 查看包的所有版本</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="npm包更新"><a href="#npm包更新" class="headerlink" title="npm包更新"></a>npm包更新</h3><pre><code>npm update，则!或~已安装的版本会被更新，并且 package-lock.json 文件会被新版本填充。package.json 则保持不变。
主版本永远不会被这种方式更新，因为它们（根据定义）会引入重大的更改，npm 希望为你减少麻烦。
若要发觉软件包的新版本，则运行 npm outdated。
</code></pre><h3 id="npm的语义版本控制"><a href="#npm的语义版本控制" class="headerlink" title="npm的语义版本控制"></a>npm的语义版本控制</h3><pre><code>语义版本控制的概念很简单：所有的版本都有 3 个数字：x.y.z。
- 第一个数字是主版本。进行不兼容的 API 更改。
- 第二个数字是次版本。以向后兼容的方式添加功能。
- 第三个数字是补丁版本。进行向后兼容的缺陷修复。

规则：
  ^: 只会执行不更改最左边非零数字的更新。 如果写入的是 ^0.13.0，则当运行 npm update 时，可以更新到 0.13.1、0.13.2 等，但不能更新到 0.14.0 或更高版本。 如果写入的是 ^1.13.0，则当运行 npm update 时，可以更新到 1.13.1、1.14.0 等，但不能更新到 2.0.0 或更高版本。
  ~: 如果写入的是 〜0.13.0，则当运行 npm update 时，会更新到补丁版本：即 0.13.1 可以，但 0.14.0 不可以。
  &gt;: 接受高于指定版本的任何版本。
  &gt;=: 接受等于或高于指定版本的任何版本。
  &lt;=: 接受等于或低于指定版本的任何版本。
  &lt;: 接受低于指定版本的任何版本。
  =: 接受确切的版本。
  -: 接受一定范围的版本。例如：2.1.0 - 2.6.2。
  ||: 组合集合。例如 &lt; 2.1 || &gt; 2.6。
  可以合并其中的一些符号，例如 1.0.0 || &gt;=1.1.0 &lt;1.2.0，即使用 1.0.0 或从 1.1.0 开始但低于 1.2.0 的版本。

  还有其他的规则：
  无符号: 仅接受指定的特定版本（例如 1.2.1）。
  latest: 使用可用的最新版本。
</code></pre><h3 id="卸载-npm-软件包"><a href="#卸载-npm-软件包" class="headerlink" title="卸载 npm 软件包"></a>卸载 npm 软件包</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall &lt;package-name&gt;</span><br><span class="line"></span><br><span class="line">如果使用 -S 或 --save 标志，则此操作还会移除 package.json 文件中的引用:</span><br><span class="line">npm uninstall -S &lt;package-name&gt;</span><br><span class="line">npm uninstall -D &lt;package-name&gt;  // -D 或 --save-dev</span><br><span class="line"></span><br><span class="line">如果该软件包是全局安装的，则需要添加 -g 或 --global 标志：</span><br><span class="line">npm uninstall -g &lt;package-name&gt;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="Node-js-包运行器-npx"><a href="#Node-js-包运行器-npx" class="headerlink" title="Node.js 包运行器 npx"></a><font color="#ff99cc">Node.js 包运行器 npx</font></h2><pre><code>npx 是一个非常强大的命令，从 npm 的 5.2 版本（发布于 2017 年 7 月）开始可用。
</code></pre><h3 id="轻松地运行本地命令"><a href="#轻松地运行本地命令" class="headerlink" title="轻松地运行本地命令"></a>轻松地运行本地命令</h3><pre><code>运行 npx commandname 会自动地在项目的 node_modules 文件夹中找到命令的正确引用，而无需知道确切的路径，也不需要在全局和用户路径中安装软件包。
</code></pre><h3 id="无需安装的命令执行"><a href="#无需安装的命令执行" class="headerlink" title="无需安装的命令执行"></a>无需安装的命令执行</h3><pre><code>npx 的另一个重要的特性是，无需先安装命令即可运行命令。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npx 可以运行该 npm 命令，而无需在本地安装：</span><br><span class="line">npx cowsay &quot;你好&quot;</span><br></pre></td></tr></table></figure>

其他场景有：
  运行 vue CLI 工具以创建新的应用程序并运行它们：npx @vue/cli create my-vue-app。
  使用 create-react-app 创建新的 React 应用：npx create-react-app my-react-app。
  还有更多其他的场景。

  当被下载完，则下载的代码会被擦除。
</code></pre><h3 id="使用不同的-Node-js-版本运行代码"><a href="#使用不同的-Node-js-版本运行代码" class="headerlink" title="使用不同的 Node.js 版本运行代码"></a>使用不同的 Node.js 版本运行代码</h3><pre><code>使用 @ 指定版本，并将其与 node npm 软件包 结合使用,这有助于避免使用 nvm 之类的工具或其他 Node.js 版本管理工具。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npx node@10 -v #v10.18.1</span><br><span class="line">npx node@12 -v #v12.14.1</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="直接从-URL-运行任意代码片段"><a href="#直接从-URL-运行任意代码片段" class="headerlink" title="直接从 URL 运行任意代码片段"></a>直接从 URL 运行任意代码片段</h3><h2 id="Node-js-事件循环"><a href="#Node-js-事件循环" class="headerlink" title="Node.js 事件循环"></a><font color="#ff99cc">Node.js 事件循环</font></h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><pre><code>Node.js JavaScript 代码运行在单个线程上。 每次只处理一件事。
这个限制实际上非常有用，因为它大大简化了编程方式，而不必担心并发问题。
</code></pre><h3 id="阻塞事件循环"><a href="#阻塞事件循环" class="headerlink" title="阻塞事件循环"></a>阻塞事件循环</h3><h3 id="调用堆栈"><a href="#调用堆栈" class="headerlink" title="调用堆栈"></a>调用堆栈</h3><pre><code>调用堆栈是一个 LIFO 队列（后进先出）。
事件循环不断地检查调用堆栈，以查看是否需要运行任何函数。
</code></pre><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><pre><code>setTimeout(() =&gt; {}, 0) 的用例是调用一个函数，但是是在代码中的每个其他函数已被执行之后。
事件循环会赋予调用堆栈优先级，它首先处理在调用堆栈中找到的所有东西，一旦其中没有任何东西，便开始处理消息队列中的东西。
我们不必等待诸如 setTimeout、fetch、或其他的函数来完成它们自身的工作，因为它们是由浏览器提供的，并且位于它们自身的线程中。 例如，如果将 setTimeout 的超时设置为 2 秒，但不必等待 2 秒，等待发生在其他地方。
</code></pre><h3 id="作业队列"><a href="#作业队列" class="headerlink" title="作业队列"></a>作业队列</h3><pre><code>ECMAScript 2015 引入了作业队列的概念，Promise 使用了该队列（也在 ES6/ES2015 中引入）。 这种方式会尽快地执行异步函数的结果，而不是放在调用堆栈的末尾。

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const bar = () =&gt; console.log(&apos;bar&apos;)</span><br><span class="line">const baz = () =&gt; console.log(&apos;baz&apos;)</span><br><span class="line"></span><br><span class="line">const foo = () =&gt; &#123;</span><br><span class="line">  console.log(&apos;foo&apos;)</span><br><span class="line">  setTimeout(bar, 0)</span><br><span class="line">  new Promise((resolve, reject) =&gt;&#123;</span><br><span class="line">    console.log(&apos;🍉&apos;);</span><br><span class="line">    resolve(&apos;应该在 baz 之后、bar 之前&apos;);</span><br><span class="line">  &#125;).then(resolve =&gt; console.log(resolve))</span><br><span class="line">  baz()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

  foo
  🍉
  baz
  应该在 baz 之后、bar 之前
  bar

这是 Promise（以及基于 promise 构建的 async/await）与通过 setTimeout() 或其他平台 API 的普通的旧异步函数之间的巨大区别。
</code></pre><h2 id="了解-process-nextTick"><a href="#了解-process-nextTick" class="headerlink" title="了解 process.nextTick()"></a><font color="#ff99cc">了解 process.nextTick()</font></h2><p>  每当事件循环进行一次完整的行程时，我们都将其称为一个滴答。<br>  当将一个函数传给 process.nextTick() 时，则指示引擎在当前操作结束（在下一个事件循环滴答开始之前）时调用此函数：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick(() =&gt; &#123;</span><br><span class="line">  //做些事情</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>  当该操作结束时，JS 引擎会运行在该操作期间传给 nextTick 调用的所有函数。<br>  这是可以告诉 JS 引擎异步地（在当前函数之后）处理函数的方式，但是尽快执行而不是将其排入队列。<br>  调用 setTimeout(() =&gt; {}, 0) 会在下一个滴答结束时执行该函数，比使用 nextTick()（其会优先执行该调用并在下一个滴答开始之前执行该函数）晚得多。<br>  当要确保在下一个事件循环迭代中代码已被执行，则使用 nextTick()。</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const bar = () =&gt; console.log(&apos;bar&apos;)</span><br><span class="line">const baz = () =&gt; console.log(&apos;baz&apos;)</span><br><span class="line"></span><br><span class="line">const foo = () =&gt; &#123;</span><br><span class="line">  console.log(&apos;foo&apos;)</span><br><span class="line">  process.nextTick(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;滴答🐦&apos;)</span><br><span class="line">  &#125;)</span><br><span class="line">  setTimeout(bar, 0)</span><br><span class="line">  new Promise((resolve, reject) =&gt;&#123;</span><br><span class="line">    console.log(&apos;🍉&apos;);</span><br><span class="line">    resolve(&apos;应该在 baz 之后、bar 之前&apos;);</span><br><span class="line">  &#125;).then(resolve =&gt; console.log(resolve))</span><br><span class="line">  baz()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>
<pre><code>foo
🍉
baz
滴答🐦
应该在 baz 之后、bar 之前
bar
</code></pre><h2 id="了解-setImmediate"><a href="#了解-setImmediate" class="headerlink" title="了解 setImmediate()"></a><font color="#ff99cc">了解 setImmediate()</font></h2><pre><code>作为 setImmediate() 参数传入的任何函数都是在事件循环的下一个迭代中执行的回调。
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(() =&gt; &#123;</span><br><span class="line">  //运行一些东西</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

setImmediate() 与 setTimeout(() =&gt; {}, 0)（传入 0 毫秒的超时）、process.nextTick() 有何不同？
传给 process.nextTick() 的函数会在事件循环的当前迭代中（当前操作结束之后）被执行。 这意味着它会始终在 setTimeout 和 setImmediate 之前执行。
延迟 0 毫秒的 setTimeout() 回调与 setImmediate() 非常相似。 执行顺序取决于各种因素，但是它们都会在事件循环的下一个迭代中运行。
</code></pre><h2 id="探索-JavaScript-定时器"><a href="#探索-JavaScript-定时器" class="headerlink" title="探索 JavaScript 定时器"></a><font color="#ff99cc">探索 JavaScript 定时器</font></h2><h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout()"></a>setTimeout()</h3><pre><code>该语法定义了一个新的函数。 可以在其中调用所需的任何其他函数，也可以传入现有的函数名称和一组参数：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const myFunction = (firstParam, secondParam) =&gt; &#123;</span><br><span class="line">  // 做些事情</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2 秒之后运行</span><br><span class="line">const id = setTimeout(myFunction, 2000, firstParam, secondParam)</span><br><span class="line"></span><br><span class="line">clearTimeout(id)</span><br></pre></td></tr></table></figure>

setTimeout 会返回定时器的 id。 通常不使用它，但是可以保存此 id，并在要删除此安排的函数执行时清除它。

- 零延迟

&lt;div class=&apos;post-warning&apos;&gt;
  某些浏览器（IE 和 Edge）实现的 setImmediate() 方法具有相同的确切功能，但是不是标准的，并且在其他浏览器上不可用。但是在 Node.js 中它是标准的函数。
  Node.js 还提供 setImmediate()（相当于使用 setTimeout(() =&gt; {}, 0)），通常用于与 Node.js 事件循环配合使用。
&lt;/div&gt;
</code></pre><h3 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval()"></a>setInterval()</h3><pre><code>除非使用 clearInterval 告诉它停止（传入 setInterval 返回的间隔定时器 id），否则它会在指定的特定时间间隔（以毫秒为单位）一直地运行回调函数，而不是只运行一次：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const id = setInterval(() =&gt; &#123;</span><br><span class="line">  // 每 2 秒运行一次</span><br><span class="line">&#125;, 2000)</span><br><span class="line"></span><br><span class="line">clearInterval(id)</span><br></pre></td></tr></table></figure>

  通常在 setInterval 回调函数中调用 clearInterval，以使其自行判断是否应该再次运行或停止。 例如，此代码会运行某些事情，除非 App.somethingIWait 具有值 arrived：
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const interval = setInterval(() =&gt; &#123;</span><br><span class="line">  if (App.somethingIWait === &apos;arrived&apos;) &#123;</span><br><span class="line">    clearInterval(interval)</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  // 否则做些事情</span><br><span class="line">&#125;, 100)</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="JavaScript-异步编程与回调"><a href="#JavaScript-异步编程与回调" class="headerlink" title="JavaScript 异步编程与回调"></a><font color="#ff99cc">JavaScript 异步编程与回调</font></h2><pre><code>程序在内部会使用中断，一种被发送到处理器以获取系统关注的信号。
当程序正在等待来自网络的响应时，则它无法在请求完成之前停止处理器。

JS在默认情况下是同步的，并且是单线程的。这意味着代码无法创建新的线程并且不能并行运行。
</code></pre><h3 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h3><pre><code>JavaScript 诞生于浏览器内部，一开始的主要工作是响应用户的操作，例如 onClick、onMouseOver、onChange、onSubmit 等。
- 使用同步的编程模型该如何做到这一点？
  答案就在于它的环境。 浏览器通过提供一组可以处理这种功能的 API 来提供了一种实现方式。

  Node.js 引入了非阻塞的 I/O 环境，以将该概念扩展到文件访问、网络调用等。
</code></pre><h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><pre><code>回调是一个简单的函数，会作为值传给另一个函数，并且仅在事件发生时才被执行。之所以这样做，是因为JS具有顶级的函数，这些函数可以被分配给变量并传给其他函数（成为高阶函数）。

- 处理回调中的错误
  一种非常常见的策略是使用 Node.js 所采用的方式：任何回调函数中的第一个参数为错误对象（即错误优先的回调）。
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(&apos;/文件.json&apos;, (err, data) =&gt; &#123;</span><br><span class="line">  if (err !== null) &#123;</span><br><span class="line">    //处理错误</span><br><span class="line">    console.log(err)</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //没有错误，则处理数据。</span><br><span class="line">  console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

- 回调的问题
  回调适用于简单的场景！
  回调复杂时可能会是回调地狱。。。

- 回调的替代方法
  从 ES6 开始，JavaScript 引入了一些特性，可以帮助处理异步代码而不涉及使用回调：Promise（ES6）和 Async/Await（ES2017）。
</code></pre><h2 id="了解-JavaScript-Promise"><a href="#了解-JavaScript-Promise" class="headerlink" title="了解 JavaScript Promise"></a><font color="#ff99cc">了解 JavaScript Promise</font></h2><pre><code>Promise通常被定义为**最终会被变为可用值的代理**。  

当promise被调用后，它会以处理中状态开始。这意味着调用的函数会继续执行，而promise仍处于处理中直到解决未知，从而为调用的函数提供所请求的任何数据。

被创建的promise最终会以**被解决状态**或**被拒绝状态**结束，并在完成时调用相应的回调函数（then或catch）。
resolve -&gt; then
rejecte -&gt; catch
如果在执行路径中从未调用过这些函数之一，则 promise 会保持处理中(pending)状态。

一种被称为 Promisifying 的技术。 这项技术能够使用经典的 JavaScript 函数来接受回调并使其返回 promise：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">const getFile = (fileName) =&gt; &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    fs.readFile(fileName, (err, data) =&gt; &#123;</span><br><span class="line">      if (err) &#123;</span><br><span class="line">        reject(err)  // 调用 `reject` 会导致 promise 失败，无论是否传入错误作为参数，</span><br><span class="line">        return        // 且不再进行下去。</span><br><span class="line">      &#125;</span><br><span class="line">      resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getFile(&apos;/etc/passwd&apos;)</span><br><span class="line">.then(data =&gt; console.log(data))</span><br><span class="line">.catch(err =&gt; console.error(err))</span><br></pre></td></tr></table></figure>
</code></pre>  <div class="post-warning">在最新版本的 Node.js 中，无需为大多数 API 进行手动地转换。如果需要 promisifying 的函数具有正确的签名，则 util 模块中有一个 promisifying 函数可以完成此操作。</div>

<h3 id="链式-promise"><a href="#链式-promise" class="headerlink" title="链式 promise"></a>链式 promise</h3><p>  Promise 可以返回到另一个 promise，从而创建一个 promise 链。</p>
<p>  Fetch API 是基于 promise 的机制，调用 fetch() 相当于使用 new Promise() 来定义 promsie。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const status = response =&gt; &#123;</span><br><span class="line">  if (response.status &gt;= 200 &amp;&amp; response.status &lt; 300) &#123;</span><br><span class="line">    return Promise.resolve(response)</span><br><span class="line">  &#125;</span><br><span class="line">  return Promise.reject(new Error(response.statusText))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const json = response =&gt; response.json()</span><br><span class="line"></span><br><span class="line">fetch(&apos;/todos.json&apos;)</span><br><span class="line">  .then(status)    // 注意，`status` 函数实际上在这里被调用，并且同样返回 promise，</span><br><span class="line">  .then(json)      // 这里唯一的区别是的 `json` 函数会返回解决时传入 `data` 的 promise，</span><br><span class="line">  .then(data =&gt; &#123;  // 这是 `data` 会在此处作为匿名函数的第一个参数的原因。</span><br><span class="line">    console.log(&apos;请求成功获得 JSON 响应&apos;, data)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(error =&gt; &#123;</span><br><span class="line">    console.log(&apos;请求失败&apos;, error)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h3><p>  当 promise 链中的任何内容失败并引发错误或拒绝 promise 时，则控制权会转到链中最近的 catch() 语句。</p>
<p>  如果再catch内部发生错误，则可以附加第二个catch来处理，以此类推。</p>
<h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><p>  如果需要同步不同的 promise，则 Promise.all() 可以帮助定义 promise 列表，并在所有 promise 都被解决后执行一些操作。</p>
<p>  示例：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const f1 = fetch(&apos;/something.json&apos;)</span><br><span class="line">const f2 = fetch(&apos;/something2.json&apos;)</span><br><span class="line"></span><br><span class="line">Promise.all([f1, f2])</span><br><span class="line">  .then(res =&gt; &#123;</span><br><span class="line">    console.log(&apos;结果的数组&apos;, res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(err =&gt; &#123;</span><br><span class="line">    console.error(err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p>
<pre><code>ES2015 解构赋值语法也可以执行：
</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.all([f1, f2]).then(([res1, res2]) =&gt; &#123;</span><br><span class="line">  console.log(&apos;结果&apos;, res1, res2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<pre><code>当然，不限于使用 fetch，任何 promise 都可以以这种方式使用。
</code></pre><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><p>  当传给其的首个 promise 被解决时，则 Promise.race() 开始运行，并且只运行一次附加的回调（传入第一个被解决的 promise 的结果）。</p>
<p>  示例：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const first = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(resolve, 500, &apos;第一个&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">const second = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(resolve, 100, &apos;第二个&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Promise.race([first, second]).then(result =&gt; &#123;</span><br><span class="line">  console.log(result) // 第二个</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="常见的错误"><a href="#常见的错误" class="headerlink" title="常见的错误"></a>常见的错误</h3><pre><code>- Uncaught TypeError: undefined is not a promise
如果在控制台中收到 Uncaught TypeError: undefined is not a promise 错误，则请确保使用 new Promise() 而不是 Promise()。

- UnhandledPromiseRejectionWarning
这意味着调用的 promise 被拒绝，但是没有用于处理错误的 catch。 在 then 之后添加 catch 则可以正确地处理。
</code></pre><h2 id="具有-Async-和-Await-的现代异步-JavaScript"><a href="#具有-Async-和-Await-的现代异步-JavaScript" class="headerlink" title="具有 Async 和 Await 的现代异步 JavaScript"></a><font color="#ff99cc">具有 Async 和 Await 的现代异步 JavaScript</font></h2><pre><code>Promise 被引入了用于解决著名的回调地狱问题，但是它们自身引入了复杂性以及语法复杂性。
它们使代码看起来像是同步的，但它是异步的并且在后台无阻塞。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const doSomethingAsync = () =&gt; &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    console.log(&apos;+1&apos;);resolve(&apos;做些事情&apos;);console.log(&apos;+2&apos;);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const doSomething = async () =&gt; &#123;</span><br><span class="line">  console.log(&apos;+3&apos;);</span><br><span class="line">  console.log(await doSomethingAsync());</span><br><span class="line">  console.log(&apos;+4&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(&apos;之前&apos;);</span><br><span class="line">doSomething();</span><br><span class="line">console.log(&apos;之后&apos;);</span><br><span class="line"></span><br><span class="line">// 之前  +3   +1   +2   之后 做些事情 +4</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="Promise-所有事情"><a href="#Promise-所有事情" class="headerlink" title="Promise 所有事情"></a>Promise 所有事情</h3><pre><code>在任何函数之前加上 async 关键字意味着该函数会返回 promise。即使没有显式地这样做，它也会在内部使它返回 promise。
这就是为什么此代码有效的原因：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const aFunction = async () =&gt; &#123;</span><br><span class="line">  return &apos;测试&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">aFunction().then(alert) // 这会 alert &apos;测试&apos;</span><br></pre></td></tr></table></figure>

等同于：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const aFunction = () =&gt; &#123;</span><br><span class="line">  return Promise.resolve(&apos;测试&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">aFunction().then(alert) // 这会 alert &apos;测试&apos;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="代码更容易阅读"><a href="#代码更容易阅读" class="headerlink" title="代码更容易阅读"></a>代码更容易阅读</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const getFirstUserData = () =&gt; &#123;</span><br><span class="line">  return fetch(&apos;/users.json&apos;) // 获取用户列表</span><br><span class="line">    .then(response =&gt; response.json()) // 解析 JSON</span><br><span class="line">    .then(users =&gt; users[0]) // 选择第一个用户</span><br><span class="line">    .then(user =&gt; fetch(`/users/$&#123;user.name&#125;`)) // 获取用户数据</span><br><span class="line">    .then(userResponse =&gt; userResponse.json()) // 解析 JSON</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getFirstUserData()</span><br></pre></td></tr></table></figure>

这是使用 await/async 提供的相同功能：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const getFirstUserData = async () =&gt; &#123;</span><br><span class="line">  const response = await fetch(&apos;/users.json&apos;) // 获取用户列表</span><br><span class="line">  const users = await response.json() // 解析 JSON</span><br><span class="line">  const user = users[0] // 选择第一个用户</span><br><span class="line">  const userResponse = await fetch(`/users/$&#123;user.name&#125;`) // 获取用户数据</span><br><span class="line">  const userData = await userResponse.json() // 解析 JSON</span><br><span class="line">  return userData</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getFirstUserData()</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="多个异步函数串联"><a href="#多个异步函数串联" class="headerlink" title="多个异步函数串联"></a>多个异步函数串联</h3><pre><code>异步函数可以很容易地链接起来，并且语法比普通的 promise 更具可读性。例子略，有需要见官网。
</code></pre><h3 id="更容易调试"><a href="#更容易调试" class="headerlink" title="更容易调试"></a>更容易调试</h3><pre><code>调试 promise 很难，因为调试器不会跳过异步的代码。

Async/await 使这非常容易，因为对于编译器而言，它就像同步代码一样。
</code></pre><h2 id="Node-js-事件触发器"><a href="#Node-js-事件触发器" class="headerlink" title="Node.js 事件触发器"></a><font color="#ff99cc">Node.js 事件触发器</font></h2><pre><code>在后端，Node.js 也提供了使用 events 模块构建类似系统的选项。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const EventEmitter = require(&apos;events&apos;)</span><br><span class="line">const eventEmitter = new EventEmitter()</span><br></pre></td></tr></table></figure>

- 该对象公开了 on 和 emit 方法。
  emit 用于触发事件。
  on 用于添加回调函数（会在事件被触发时执行）。

可传参：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eventEmitter.on(&apos;start&apos;, (start, end) =&gt; &#123;</span><br><span class="line">  console.log(`从 $&#123;start&#125; 到 $&#123;end&#125;`)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">eventEmitter.emit(&apos;start&apos;, 1, 100);</span><br></pre></td></tr></table></figure>

- EventEmitter 对象还公开了其他几个与事件进行交互的方法，例如：
  once(): 添加单次监听器。
  removeListener() / off(): 从事件中移除事件监听器。
  removeAllListeners(): 移除事件的所有监听器。
  可以在[事件模块](http://nodejs.cn/api/events.html)的页面上阅读其所有详细信息。
</code></pre><h2 id="搭建-HTTP-服务器"><a href="#搭建-HTTP-服务器" class="headerlink" title="搭建 HTTP 服务器"></a><font color="#ff99cc">搭建 HTTP 服务器</font></h2><pre><code>这是一个简单的 HTTP web 服务器的示例：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http&apos;)</span><br><span class="line"></span><br><span class="line">const port = 3000</span><br><span class="line"></span><br><span class="line">const server = http.createServer((req, res) =&gt; &#123;</span><br><span class="line">  res.statusCode = 200</span><br><span class="line">  res.setHeader(&apos;Content-Type&apos;, &apos;text/plain&apos;)</span><br><span class="line">  res.end(&apos;你好世界\n&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(port, () =&gt; &#123;</span><br><span class="line">  console.log(`服务器运行在 http://$&#123;hostname&#125;:$&#123;port&#125;/`)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="使用-Node-js-发送-HTTP-请求"><a href="#使用-Node-js-发送-HTTP-请求" class="headerlink" title="使用 Node.js 发送 HTTP 请求"></a><font color="#ff99cc">使用 Node.js 发送 HTTP 请求</font></h2><pre><code>- 执行 GET 请求
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const https = require(&apos;https&apos;)</span><br><span class="line">const options = &#123;</span><br><span class="line">  hostname: &apos;nodejs.cn&apos;,</span><br><span class="line">  port: 443,</span><br><span class="line">  path: &apos;/todos&apos;,</span><br><span class="line">  method: &apos;GET&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const req = https.request(options, res =&gt; &#123;</span><br><span class="line">  console.log(`状态码: $&#123;res.statusCode&#125;`)</span><br><span class="line"></span><br><span class="line">  res.on(&apos;data&apos;, d =&gt; &#123;</span><br><span class="line">    process.stdout.write(d)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">req.on(&apos;error&apos;, error =&gt; &#123;</span><br><span class="line">  console.error(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">req.end()</span><br></pre></td></tr></table></figure>

- 执行 POST 请求
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">const https = require(&apos;https&apos;)</span><br><span class="line"></span><br><span class="line">const data = JSON.stringify(&#123;</span><br><span class="line">  todo: &apos;做点事情&apos;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const options = &#123;</span><br><span class="line">  hostname: &apos;nodejs.cn&apos;,</span><br><span class="line">  port: 443,</span><br><span class="line">  path: &apos;/todos&apos;,</span><br><span class="line">  method: &apos;POST&apos;,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    &apos;Content-Type&apos;: &apos;application/json&apos;,</span><br><span class="line">    &apos;Content-Length&apos;: data.length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const req = https.request(options, res =&gt; &#123;</span><br><span class="line">  console.log(`状态码: $&#123;res.statusCode&#125;`)</span><br><span class="line"></span><br><span class="line">  res.on(&apos;data&apos;, d =&gt; &#123;</span><br><span class="line">    process.stdout.write(d)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">req.on(&apos;error&apos;, error =&gt; &#123;</span><br><span class="line">  console.error(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">req.write(data)</span><br><span class="line">req.end()</span><br></pre></td></tr></table></figure>


- PUT 和 DELETE
  PUT 和 DELETE 请求使用相同的 POST 请求格式，只需更改 options.method 的值即可。
</code></pre><h2 id="使用-Node-js-发送-HTTP-POST-请求"><a href="#使用-Node-js-发送-HTTP-POST-请求" class="headerlink" title="使用 Node.js 发送 HTTP POST 请求"></a><font color="#ff99cc">使用 Node.js 发送 HTTP POST 请求</font></h2><pre><code>在 Node.js 中，有多种方式可以执行 HTTP POST 请求，具体取决于要使用的抽象级别。

使用 Node.js 执行 HTTP 请求的最简单的方式是使用 Axios 库：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const axios = require(&apos;axios&apos;)</span><br><span class="line"></span><br><span class="line">axios</span><br><span class="line">  .post(&apos;http://nodejs.cn/todos&apos;, &#123;</span><br><span class="line">    todo: &apos;做点事情&apos;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(res =&gt; &#123;</span><br><span class="line">    console.log(`状态码: $&#123;res.statusCode&#125;`)</span><br><span class="line">    console.log(res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(error =&gt; &#123;</span><br><span class="line">    console.error(error)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

Axios 需要使用第三方的库。
也可以只使用 Node.js 的标准模块来发送 POST 请求，尽管它比前面的选择冗长些：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">const https = require(&apos;https&apos;)</span><br><span class="line"></span><br><span class="line">const data = JSON.stringify(&#123;</span><br><span class="line">  todo: &apos;做点事情&apos;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const options = &#123;</span><br><span class="line">  hostname: &apos;nodejs.cn&apos;,</span><br><span class="line">  port: 443,</span><br><span class="line">  path: &apos;/todos&apos;,</span><br><span class="line">  method: &apos;POST&apos;,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    &apos;Content-Type&apos;: &apos;application/json&apos;,</span><br><span class="line">    &apos;Content-Length&apos;: data.length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const req = https.request(options, res =&gt; &#123;</span><br><span class="line">  console.log(`状态码: $&#123;res.statusCode&#125;`)</span><br><span class="line"></span><br><span class="line">  res.on(&apos;data&apos;, d =&gt; &#123;</span><br><span class="line">    process.stdout.write(d)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">req.on(&apos;error&apos;, error =&gt; &#123;</span><br><span class="line">  console.error(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">req.write(data)</span><br><span class="line">req.end()</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="使用-Node-js-获取-HTTP-请求的正文数据"><a href="#使用-Node-js-获取-HTTP-请求的正文数据" class="headerlink" title="使用 Node.js 获取 HTTP 请求的正文数据"></a><font color="#ff99cc">使用 Node.js 获取 HTTP 请求的正文数据</font></h2><pre><code>如果使用的是 Express，则非常简单：使用 body-parser Node.js 模块。

例如，获取此请求的正文：
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const axios = require(&apos;axios&apos;)</span><br><span class="line"></span><br><span class="line">axios.post(&apos;http://nodejs.cn/todos&apos;, &#123;</span><br><span class="line">  todo: &apos;做点事情&apos;</span><br><span class="line">&#125;)</span><br><span class="line">这是对应的服务器端代码：</span><br><span class="line"></span><br><span class="line">const express = require(&apos;express&apos;)</span><br><span class="line">const app = express()</span><br><span class="line"></span><br><span class="line">app.use(</span><br><span class="line">  express.urlencoded(&#123;</span><br><span class="line">    extended: true</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">app.use(express.json())</span><br><span class="line"></span><br><span class="line">app.post(&apos;/todos&apos;, (req, res) =&gt; &#123;</span><br><span class="line">  console.log(req.body.todo)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

  如果不使用 Express 并想在普通的 Node.js 中执行此操作，则需要做多一点的工作，因为 Express 抽象了很多工作。

  要理解的关键是，当使用 http.createServer() 初始化 HTTP 服务器时，服务器会在获得所有 HTTP 请求头（而不是请求正文时）时调用回调。

  在连接回调中传入的 request 对象是一个流。

  因此，必须监听要处理的主体内容，并且其是按数据块处理的。

  首先，通过监听流的 data 事件来获取数据，然后在数据结束时调用一次流的 end 事件：

  const server = http.createServer((req, res) =&gt; {
    // 可以访问 HTTP 请求头
    req.on(&apos;data&apos;, chunk =&gt; {
      console.log(`可用的数据块: ${chunk}`)
    })
    req.on(&apos;end&apos;, () =&gt; {
      //数据结束
    })
  })
  因此，若要访问数据（假设期望接收到字符串），则必须将其放入数组中：

  const server = http.createServer((req, res) =&gt; {
    let data = &apos;&apos;;
    req.on(&apos;data&apos;, chunk =&gt; {
      data += chunk;
    })
    req.on(&apos;end&apos;, () =&gt; {
      JSON.parse(data).todo // &apos;做点事情&apos;
    })
  })
</code></pre><h2 id="在-Node-js-中使用文件描述符"><a href="#在-Node-js-中使用文件描述符" class="headerlink" title="在 Node.js 中使用文件描述符"></a><font color="#ff99cc">在 Node.js 中使用文件描述符</font></h2><pre><code>文件描述符是使用 fs 模块提供的 open() 方法打开文件后返回的：
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">fs.open(&apos;/Users/joe/test.txt&apos;, &apos;r&apos;, (err, fd) =&gt; &#123;</span><br><span class="line">  //fd 是文件描述符。</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

注意，将 r 作为 fs.open() 调用的第二个参数。
该标志意味着打开文件用于读取。

其他常用的标志有：
r+ 打开文件用于读写。
w+ 打开文件用于读写，将流定位到文件的开头。如果文件不存在则创建文件。
a 打开文件用于写入，将流定位到文件的末尾。如果文件不存在则创建文件。
a+ 打开文件用于读写，将流定位到文件的末尾。如果文件不存在则创建文件。

也可以使用 fs.openSync 方法打开文件，该方法会返回文件描述符（而不是在回调中提供）：
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  const fd = fs.openSync(&apos;/Users/joe/test.txt&apos;, &apos;r&apos;)</span><br><span class="line">&#125; catch (err) &#123;</span><br><span class="line">  console.error(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

一旦获得文件描述符，就可以以任何方式执行所有需要它的操作，例如调用 fs.open() 以及许多与文件系统交互的其他操作。
</code></pre><h2 id="Node-js-文件属性"><a href="#Node-js-文件属性" class="headerlink" title="Node.js 文件属性"></a><font color="#ff99cc">Node.js 文件属性</font></h2><pre><code>每个文件都带有一组详细信息，可以使用 Node.js 进行检查。具体地说，使用 fs 模块提供的 stat() 方法。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line">fs.stat(&apos;/Users/joe/test.txt&apos;, (err, stats) =&gt; &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    console.error(err)</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stats.isFile() //true</span><br><span class="line">  stats.isDirectory() //false</span><br><span class="line">  stats.isSymbolicLink() //false</span><br><span class="line">  stats.size //1024000 //= 1MB</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

Node.js 也提供了同步的方法，该方法会阻塞线程，直到文件属性准备就绪为止：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line">try &#123;</span><br><span class="line">  const stats = fs.statSync(&apos;/Users/joe/test.txt&apos;)</span><br><span class="line">&#125; catch (err) &#123;</span><br><span class="line">  console.error(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="Node-js-文件路径"><a href="#Node-js-文件路径" class="headerlink" title="Node.js 文件路径"></a><font color="#ff99cc">Node.js 文件路径</font></h2><pre><code>- 从路径中获取信息
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const notes = &apos;/users/joe/notes.txt&apos;</span><br><span class="line"></span><br><span class="line">path.dirname(notes) // /users/joe   获取文件的父文件夹。</span><br><span class="line">path.basename(notes) // notes.txt   获取文件名部分。</span><br><span class="line">path.extname(notes) // .txt         获取文件的扩展名。</span><br><span class="line">path.basename(notes, path.extname(notes)) //notes  可以通过为 basename 指定第二个参数来获取不带扩展名的文件名：</span><br></pre></td></tr></table></figure>

- 使用路径
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">连接路径:</span><br><span class="line">const name = &apos;joe&apos;</span><br><span class="line">path.join(&apos;/&apos;, &apos;users&apos;, name, &apos;notes.txt&apos;) // &apos;/users/joe/notes.txt&apos;</span><br><span class="line"></span><br><span class="line">path.resolve() 获得相对路径的绝对路径:</span><br><span class="line">path.resolve(&apos;joe.txt&apos;) // &apos;/Users/joe/joe.txt&apos; 如果从主文件夹运行。</span><br><span class="line">path.resolve(&apos;tmp&apos;, &apos;joe.txt&apos;) // &apos;/Users/joe/tmp/joe.txt&apos;    如果从主文件夹运行。</span><br><span class="line">path.resolve(&apos;/etc&apos;, &apos;joe.txt&apos;) // &apos;/etc/joe.txt&apos;   如果第一个参数以斜杠开头，则表示它是绝对路径</span><br><span class="line"></span><br><span class="line">path.normalize() 是另一个有用的函数，当包含诸如 .、.. 或双斜杠之类的相对说明符时，其会尝试计算实际的路径：</span><br><span class="line">path.normalize(&apos;/users/joe/..//test.txt&apos;) // &apos;/users/test.txt&apos;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="使用-Node-js-读取文件"><a href="#使用-Node-js-读取文件" class="headerlink" title="使用 Node.js 读取文件"></a><font color="#ff99cc">使用 Node.js 读取文件</font></h2><pre><code>在 Node.js 中读取文件最简单的方式是使用 fs.readFile() 方法，向其传入文件路径、编码、以及会带上文件数据（以及错误）进行调用的回调函数：
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">fs.readFile(&apos;/Users/joe/test.txt&apos;, &apos;utf8&apos; , (err, data) =&gt; &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    console.error(err)</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


另外，也可以使用同步的版本 fs.readFileSync()：
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  const data = fs.readFileSync(&apos;/Users/joe/test.txt&apos;, &apos;utf8&apos;)</span><br><span class="line">  console.log(data)</span><br><span class="line">&#125; catch (err) &#123;</span><br><span class="line">  console.error(err)</span><br><span class="line">&#125;</span><br><span class="line">fs.readFile() 和 fs.readFileSync() 都会在返回数据之前将文件的全部内容读取到内存中。</span><br></pre></td></tr></table></figure>

这意味着大文件会对内存的消耗和程序执行的速度产生重大的影响。

在这种情况下，更好的选择是使用流来读取文件的内容。
</code></pre><h2 id="使用-Node-js-写入文件"><a href="#使用-Node-js-写入文件" class="headerlink" title="使用 Node.js 写入文件"></a><font color="#ff99cc">使用 Node.js 写入文件</font></h2>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line">const content = &apos;一些内容&apos;</span><br><span class="line"></span><br><span class="line">fs.writeFile(&apos;/Users/joe/test.txt&apos;, content, err =&gt; &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    console.error(err)</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  //文件写入成功。</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<pre><code>另外，也可以使用同步的版本 fs.writeFileSync()：
</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">const content = &apos;一些内容&apos;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  const data = fs.writeFileSync(&apos;/Users/joe/test.txt&apos;, content)</span><br><span class="line">  //文件写入成功。</span><br><span class="line">&#125; catch (err) &#123;</span><br><span class="line">  console.error(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>默认情况下，此 API 会替换文件的内容（如果文件已经存在）。可以通过指定标志来修改默认的行为：
</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.writeFile(&apos;/Users/joe/test.txt&apos;, content, &#123; flag: &apos;a+&apos; &#125;, err =&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure>
<pre><code>可能会使用的标志有：
r+ 打开文件用于读写。
w+ 打开文件用于读写，将流定位到文件的开头。如果文件不存在则创建文件。
a 打开文件用于写入，将流定位到文件的末尾。如果文件不存在则创建文件。
a+ 打开文件用于读写，将流定位到文件的末尾。如果文件不存在则创建文件。
(可以在 http://nodejs.cn/api/fs.html#fs_file_system_flags 中查看更多标志)
</code></pre><ul>
<li><p>追加到文件<br>将内容追加到文件末尾的便捷方法是 fs.appendFile()（及其对应的 fs.appendFileSync()）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const content = &apos;一些内容&apos;</span><br><span class="line"></span><br><span class="line">fs.appendFile(&apos;file.log&apos;, content, err =&gt; &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    console.error(err)</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  //完成！</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用流<br>所有这些方法都是在将全部内容写入文件之后才会将控制权返回给程序（在异步的版本中，这意味着执行回调）。</p>
<p>在这种情况下，更好的选择是使用流写入文件的内容。</p>
<h2 id="Node-js-文件系统模块"><a href="#Node-js-文件系统模块" class="headerlink" title="Node.js 文件系统模块"></a><font color="#ff99cc">Node.js 文件系统模块</font></h2><p>fs 模块提供了许多非常实用的函数来访问文件系统并与文件系统进行交互。<br>无需安装。 作为 Node.js 核心的组成部分，可以通过简单地引用来使用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;)</span><br></pre></td></tr></table></figure>
<p>其所有的方法，包括：<br>fs.access(): 检查文件是否存在，以及 Node.js 是否有权限访问。<br>fs.appendFile(): 追加数据到文件。如果文件不存在，则创建文件。<br>fs.chmod(): 更改文件（通过传入的文件名指定）的权限。相关方法：fs.lchmod()、fs.fchmod()。<br>fs.chown(): 更改文件（通过传入的文件名指定）的所有者和群组。相关方法：fs.fchown()、fs.lchown()。<br>fs.close(): 关闭文件描述符。<br>fs.copyFile(): 拷贝文件。<br>fs.createReadStream(): 创建可读的文件流。<br>fs.createWriteStream(): 创建可写的文件流。<br>fs.link(): 新建指向文件的硬链接。<br>fs.mkdir(): 新建文件夹。<br>fs.mkdtemp(): 创建临时目录。<br>fs.open(): 设置文件模式。<br>fs.readdir(): 读取目录的内容。<br>fs.readFile(): 读取文件的内容。相关方法：fs.read()。<br>fs.readlink(): 读取符号链接的值。<br>fs.realpath(): 将相对的文件路径指针（.、..）解析为完整的路径。<br>fs.rename(): 重命名文件或文件夹。<br>fs.rmdir(): 删除文件夹。<br>fs.stat(): 返回文件（通过传入的文件名指定）的状态。相关方法：fs.fstat()、fs.lstat()。<br>fs.symlink(): 新建文件的符号链接。<br>fs.truncate(): 将传递的文件名标识的文件截断为指定的长度。相关方法：fs.ftruncate()。<br>fs.unlink(): 删除文件或符号链接。<br>fs.unwatchFile(): 停止监视文件上的更改。<br>fs.utimes(): 更改文件（通过传入的文件名指定）的时间戳。相关方法：fs.futimes()。<br>fs.watchFile(): 开始监视文件上的更改。相关方法：fs.watch()。<br>fs.writeFile(): 将数据写入文件。相关方法：fs.write()。</p>
<p>关于 fs 模块的特殊之处是，所有的方法默认情况下都是异步的，但是通过在前面加上 Sync 也可以同步地工作。<br>例如：</p>
<pre><code>fs.rename()
fs.renameSync()
fs.write()
fs.writeSync()
</code></pre><p>这在应用程序流程中会产生巨大的差异。</p>
</li>
</ul>
<h2 id="Node-js-路径模块"><a href="#Node-js-路径模块" class="headerlink" title="Node.js 路径模块"></a><font color="#ff99cc">Node.js 路径模块</font></h2><p>  path 模块提供了许多非常实用的函数来访问文件系统并与文件系统进行交互。<br>  无需安装。 作为 Node.js 核心的组成部分，可以通过简单地引用来使用它：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;)</span><br></pre></td></tr></table></figure></p>
<p>  该模块提供了 path.sep（作为路径段分隔符，在 Windows 上是 \，在 Linux/macOS 上是 /）和 path.delimiter（作为路径定界符，在 Windows 上是 ;，在 Linux/macOS 上是 :）。</p>
<p>  还有这些 path 方法：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">path.basename()  返回路径的最后一部分。 第二个参数可以过滤掉文件的扩展名：</span><br><span class="line">  require(&apos;path&apos;).basename(&apos;/test/something&apos;) //something</span><br><span class="line">  require(&apos;path&apos;).basename(&apos;/test/something.txt&apos;) //something.txt</span><br><span class="line">  require(&apos;path&apos;).basename(&apos;/test/something.txt&apos;, &apos;.txt&apos;) //something</span><br><span class="line"></span><br><span class="line">path.dirname()  返回路径的目录部分：</span><br><span class="line">  require(&apos;path&apos;).dirname(&apos;/test/something&apos;) // /test</span><br><span class="line">  require(&apos;path&apos;).dirname(&apos;/test/something/file.txt&apos;) // /test/something</span><br><span class="line"></span><br><span class="line">path.extname()  返回路径的扩展名部分。</span><br><span class="line">  require(&apos;path&apos;).extname(&apos;/test/something&apos;) // &apos;&apos;</span><br><span class="line">  require(&apos;path&apos;).extname(&apos;/test/something/file.txt&apos;) // &apos;.txt&apos;</span><br><span class="line"></span><br><span class="line">path.isAbsolute()  如果是绝对路径，则返回 true。</span><br><span class="line">  require(&apos;path&apos;).isAbsolute(&apos;/test/something&apos;) // true</span><br><span class="line">  require(&apos;path&apos;).isAbsolute(&apos;./test/something&apos;) // false</span><br><span class="line"></span><br><span class="line">path.join()  连接路径的两个或多个部分：</span><br><span class="line">  const name = &apos;joe&apos;</span><br><span class="line">  require(&apos;path&apos;).join(&apos;/&apos;, &apos;users&apos;, name, &apos;notes.txt&apos;) //&apos;/users/joe/notes.txt&apos;</span><br><span class="line"></span><br><span class="line">path.normalize()  当包含类似 .、.. 或双斜杠等相对的说明符时，则尝试计算实际的路径：</span><br><span class="line">  require(&apos;path&apos;).normalize(&apos;/users/joe/..//test.txt&apos;) //&apos;/users/test.txt&apos;</span><br><span class="line"></span><br><span class="line">path.parse()</span><br><span class="line">  解析对象的路径为组成其的片段：</span><br><span class="line">    root: 根路径。</span><br><span class="line">    dir: 从根路径开始的文件夹路径。</span><br><span class="line">    base: 文件名 + 扩展名</span><br><span class="line">    name: 文件名</span><br><span class="line">    ext: 文件扩展名</span><br><span class="line">  </span><br><span class="line">  require(&apos;path&apos;).parse(&apos;/users/test.txt&apos;)</span><br><span class="line">    结果是：</span><br><span class="line">    &#123;</span><br><span class="line">      root: &apos;/&apos;,</span><br><span class="line">      dir: &apos;/users&apos;,</span><br><span class="line">      base: &apos;test.txt&apos;,</span><br><span class="line">      ext: &apos;.txt&apos;,</span><br><span class="line">      name: &apos;test&apos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">path.relative() 接受 2 个路径作为参数。 基于当前工作目录，返回从第一个路径到第二个路径的相对路径。</span><br><span class="line">  require(&apos;path&apos;).relative(&apos;/Users/joe&apos;, &apos;/Users/joe/test.txt&apos;) //&apos;test.txt&apos;</span><br><span class="line">  require(&apos;path&apos;).relative(&apos;/Users/joe&apos;, &apos;/Users/joe/something/test.txt&apos;) //&apos;something/test.txt&apos;</span><br><span class="line"></span><br><span class="line">path.resolve() 可以使用 path.resolve() 获得相对路径的绝对路径计算：</span><br><span class="line">  path.resolve(&apos;joe.txt&apos;) //&apos;/Users/joe/joe.txt&apos; 如果从主文件夹运行</span><br><span class="line"> </span><br><span class="line">  通过指定第二个参数，resolve 会使用第一个参数作为第二个参数的基准：</span><br><span class="line">  path.resolve(&apos;tmp&apos;, &apos;joe.txt&apos;) //&apos;/Users/joe/tmp/joe.txt&apos; 如果从主文件夹运行</span><br><span class="line">   </span><br><span class="line">  如果第一个参数以斜杠开头，则表示它是绝对路径：</span><br><span class="line">  path.resolve(&apos;/etc&apos;, &apos;joe.txt&apos;) //&apos;/etc/joe.txt&apos;</span><br></pre></td></tr></table></figure></p>
<h2 id="Node-js-操作系统模块"><a href="#Node-js-操作系统模块" class="headerlink" title="Node.js 操作系统模块"></a><font color="#ff99cc">Node.js 操作系统模块</font></h2><pre><code>该模块提供了许多函数，可用于从底层的操作系统和程序运行所在的计算机上检索信息并与其进行交互。
  os.arch()
  os.cpus()
  os.endianness()
  os.freemem()
  os.homedir()
  os.hostname()
  os.loadavg()
  os.networkInterfaces()
  os.platform()
  os.release()
  os.tmpdir()
  os.totalmem()
  os.type()
  os.uptime()
  os.userInfo()
</code></pre><h2 id="Node-js-事件模块"><a href="#Node-js-事件模块" class="headerlink" title="Node.js 事件模块"></a><font color="#ff99cc">Node.js 事件模块</font></h2><pre><code>events 模块为提供了 EventEmitter 类，这是在 Node.js 中处理事件的关键。
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const EventEmitter = require(&apos;events&apos;)</span><br><span class="line">const emitter = new EventEmitter()</span><br></pre></td></tr></table></figure>

  emitter.addListener()
  emitter.emit()
  emitter.eventNames()
  emitter.getMaxListeners()
  emitter.listenerCount()
  emitter.listeners()
  emitter.off()
  emitter.on()
  emitter.once()
  emitter.prependListener()
  emitter.prependOnceListener()
  emitter.removeAllListeners()
  emitter.removeListener()
  emitter.setMaxListeners()
</code></pre><h2 id="Node-js-http-模块"><a href="#Node-js-http-模块" class="headerlink" title="Node.js http 模块"></a><font color="#ff99cc">Node.js http 模块</font></h2><pre><code>HTTP 核心模块是 Node.js 网络的关键模块。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http&apos;)</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="Node-js-Buffer"><a href="#Node-js-Buffer" class="headerlink" title="Node.js Buffer"></a><font color="#ff99cc">Node.js Buffer</font></h2><pre><code>Buffer 是内存区域，由 Node.js Buffer 类实现。 它表示在 V8 JavaScript 引擎外部分配的固定大小的内存块（无法调整大小）。

Buffer 与流紧密相连。 当流处理器接收数据的速度快于其消化的速度时，则会将数据放入 buffer 中。

- 创建buffer：
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Buffer.from()、Buffer.alloc() 和 Buffer.allocUnsafe() 方法可以创建 buffer。</span><br><span class="line">  const buf = Buffer.from(&apos;Hey!&apos;)</span><br><span class="line">  Buffer.from(array)</span><br><span class="line">  Buffer.from(arrayBuffer[, byteOffset[, length]])</span><br><span class="line">  Buffer.from(buffer)</span><br><span class="line">  Buffer.from(string[, encoding])</span><br><span class="line">  </span><br><span class="line">也可以只初始化 buffer（传入大小）。 以下会创建一个 1KB 的 buffer：</span><br><span class="line">  const buf = Buffer.alloc(1024)</span><br><span class="line">  //或</span><br><span class="line">  const buf = Buffer.allocUnsafe(1024) </span><br><span class="line"></span><br><span class="line">（allocUnsafe 不安全的原因，在使用它时必须格外小心。）</span><br></pre></td></tr></table></figure>

  &lt;div class=&apos;post-warning&apos;&gt;注意，如果使用数字（设置其大小）初始化 buffer，则可以访问到包含随机数据的已预初始化的内存（而不是空的 buffer）&lt;/div&gt;

- 使用 buffer
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Buffer（字节数组）可以像数组一样被访问：</span><br><span class="line">  const buf = Buffer.from(&apos;Hey!&apos;)</span><br><span class="line">  buf[0] //72   Unicode 码</span><br><span class="line">  buf[1] //101  Unicode 码</span><br><span class="line">  buf[2] //121  Unicode 码</span><br><span class="line">  buf.toString()  // Hey!</span><br><span class="line"></span><br><span class="line">获取 buffer 的长度：buf.length // 4</span><br><span class="line"></span><br><span class="line">遍历 buffer 的内容：</span><br><span class="line">  for (const item of buf) &#123;</span><br><span class="line">    console.log(item) //72 101 121 33</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">更改 buffer 的内容：</span><br><span class="line">  const buf = Buffer.alloc(4)</span><br><span class="line">  buf.write(&apos;Hey!&apos;)</span><br><span class="line">  或</span><br><span class="line">  buf[1] = 111 //o</span><br><span class="line">  console.log(buf.toString()) //Hoy</span><br><span class="line"></span><br><span class="line">复制 buffer：</span><br><span class="line">  const buf = Buffer.from(&apos;Hey!&apos;)</span><br><span class="line">  let bufcopy = Buffer.alloc(4) //分配 4 个字节。</span><br><span class="line">  buf.copy(bufcopy)</span><br><span class="line">  bufcopy.toString()  // &apos;Hey!&apos;</span><br><span class="line"></span><br><span class="line">  默认情况下，会复制整个 buffer。 另外的 3 个参数可以定义开始位置、结束位置、以及新的 buffer 长度：</span><br><span class="line">  const buf = Buffer.from(&apos;Hey!&apos;)</span><br><span class="line">  let bufcopy = Buffer.alloc(2) //分配 2 个字节。</span><br><span class="line">  buf.copy(bufcopy, 0, 0, 2)</span><br><span class="line">  bufcopy.toString() //&apos;He&apos;</span><br><span class="line"></span><br><span class="line">切片 buffer</span><br><span class="line">  如果要创建 buffer 的局部视图，则可以创建切片。 切片不是副本：原始 buffer 仍然是真正的来源。 如果那改变了，则切片也会改变。</span><br><span class="line">  使用 slice() 方法创建它。 第一个参数是起始位置，可以指定第二个参数作为结束位置：</span><br><span class="line"></span><br><span class="line">  const buf = Buffer.from(&apos;Hey!&apos;)</span><br><span class="line">  buf.slice(0).toString() //Hey!</span><br><span class="line">  const slice = buf.slice(0, 2)</span><br><span class="line">  console.log(slice.toString()) //He</span><br><span class="line">  buf[1] = 111 //o</span><br><span class="line">  console.log(slice.toString()) //Ho</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="Node-js-流"><a href="#Node-js-流" class="headerlink" title="Node.js 流"></a><font color="#ff99cc">Node.js 流</font></h2><h3 id="什么是流"><a href="#什么是流" class="headerlink" title="什么是流"></a>什么是流</h3><pre><code>流是为Node.js应用程序提供动力的基本概念之一。它们是一种以高效的方式处理读/写文件，网络通信，或任何类型的端到端的信息交换。
流不是Nodejs特有的概念。它们是几十年前在Unix操作系统中引入的，程序可以通过管道运算符（|）对流进行相互交互。

例如，在传统的方式中，当告诉程序读取文件时，这会将文件从头到尾读入内存，然后进行处理。使用流，则可以逐个片段地读取。

Node.js的 Stream 模块 提供了构建所有流 API 的基础。所有的流都是 EventEmitter 的实例。

相对于其他的数据处理方式，流具有两大优点：
1）内存效率：无需加载大量的数据到内存就可以进行处理。
2）时间效率：当获得数据之后即可立即开始处理数据，这样所需的时间更是，而不必等到整个数据的有效负载可用才开始。
</code></pre><h3 id="流的示例"><a href="#流的示例" class="headerlink" title="流的示例"></a>流的示例</h3><pre><code>一个典型的例子是从磁盘读取文件。

- 使用 Node.js 的 fs 模块，可以读取文件，并在与 HTTP 服务器建立新连接时通过 HTTP 提供文件：
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http&apos;)</span><br><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">const server = http.createServer(function(req, res) &#123;</span><br><span class="line">  fs.readFile(__dirname + &apos;/data.txt&apos;, (err, data) =&gt; &#123;</span><br><span class="line">    res.end(data)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(3000)</span><br></pre></td></tr></table></figure>

  readFile() 读取文件的全部内容，并在完成时调用回调函数。回调中的 res.end(data) 会返回文件的内容给 HTTP 客户端。

- 如果文件很大，则该操作会花费较多的时间。 以下是使用流编写的相同内容：
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http&apos;)</span><br><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">const server = http.createServer((req, res) =&gt; &#123;</span><br><span class="line">  const stream = fs.createReadStream(__dirname + &apos;/data.txt&apos;)</span><br><span class="line">  stream.pipe(res)</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(3000)</span><br></pre></td></tr></table></figure>

  当要发送的数据块已获得时就立即开始将其流式传输到 HTTP 客户端，而不是等待直到文件被完全读取。
</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code>- pipe()
  它是获取来源流，并将其通过管道传输到目标流。

  在来源流上调用pipe()，在上面的示例中，文件流通过管道传输到HTTP响应。
  pipe()返回的是目标流，可以链式调用：
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">src.pipe(dest1).pipe(dest2)</span><br><span class="line">此构造相对于：</span><br><span class="line"></span><br><span class="line">src.pipe(dest1)</span><br><span class="line">dest1.pipe(dest2)</span><br></pre></td></tr></table></figure>

- 流驱动的 Node.js API
  由于它们的优点，许多 Node.js 核心模块提供了原生的流处理功能，最值得注意的有：
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">process.stdin 返回连接到 stdin 的流。</span><br><span class="line">process.stdout 返回连接到 stdout 的流。</span><br><span class="line">process.stderr 返回连接到 stderr 的流。</span><br><span class="line">fs.createReadStream() 创建文件的可读流。</span><br><span class="line">fs.createWriteStream() 创建到文件的可写流。</span><br><span class="line">net.connect() 启动基于流的连接。</span><br><span class="line">http.request() 返回 http.ClientRequest 类的实例，该实例是可写流。</span><br><span class="line">zlib.createGzip() 使用 gzip（压缩算法）将数据压缩到流中。</span><br><span class="line">zlib.createGunzip() 解压缩 gzip 流。</span><br><span class="line">zlib.createDeflate() 使用 deflate（压缩算法）将数据压缩到流中。</span><br><span class="line">zlib.createInflate() 解压缩 deflate 流。</span><br></pre></td></tr></table></figure>

- 流分为四类：
  Readable: 可以通过管道读取、但不能通过管道写入的流（可以接收数据，但不能向其发送数据）。 当推送数据到可读流中时，会对其进行缓冲，直到使用者开始读取数据为止。
  Writable: 可以通过管道写入、但不能通过管道读取的流（可以发送数据，但不能从中接收数据）。
  Duplex: 可以通过管道写入和读取的流，基本上相对于是可读流和可写流的组合。
  Transform: 类似于双工流、但其输出是其输入的转换的转换流。

- 创建可读流：
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const Stream = require(&apos;stream&apos;)</span><br><span class="line">const readableStream = new Stream.Readable()</span><br><span class="line"></span><br><span class="line">readableStream._read = () =&gt; &#123;&#125;</span><br><span class="line">或</span><br><span class="line">const readableStream = new Stream.Readable(&#123;</span><br><span class="line">  read() &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">现在，流已初始化，可以向其发送数据了：</span><br><span class="line">readableStream.push(&apos;hi!&apos;)</span><br><span class="line">readableStream.push(&apos;ho!&apos;)</span><br></pre></td></tr></table></figure>

- 创建可写流
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const Stream = require(&apos;stream&apos;)</span><br><span class="line">const writableStream = new Stream.Writable()</span><br><span class="line"></span><br><span class="line">writableStream._write = (chunk, encoding, next) =&gt; &#123;</span><br><span class="line">  console.log(chunk.toString())</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">现在，可以通过以下方式传输可读流：</span><br><span class="line">process.stdin.pipe(writableStream)</span><br></pre></td></tr></table></figure>

- 从可读流中获取数据
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const Stream = require(&apos;stream&apos;)</span><br><span class="line">const readableStream = new Stream.Readable(&#123;</span><br><span class="line">  read() &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line">const writableStream = new Stream.Writable()</span><br><span class="line"></span><br><span class="line">writableStream._write = (chunk, encoding, next) =&gt; &#123;</span><br><span class="line">  console.log(chunk.toString())</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">readableStream.pipe(writableStream)</span><br><span class="line"></span><br><span class="line">readableStream.push(&apos;hi!&apos;)</span><br><span class="line">readableStream.push(&apos;ho!&apos;)</span><br><span class="line">也可以使用 readable 事件直接地消费可读流：</span><br><span class="line"></span><br><span class="line">readableStream.on(&apos;readable&apos;, () =&gt; &#123;</span><br><span class="line">  console.log(readableStream.read())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

- 发送数据到可写流
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writableStream.write(&apos;hey!\n&apos;)</span><br></pre></td></tr></table></figure>

- 使用信号通知已结束写入的可写流
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const Stream = require(&apos;stream&apos;)</span><br><span class="line"></span><br><span class="line">const readableStream = new Stream.Readable(&#123;</span><br><span class="line">  read() &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line">const writableStream = new Stream.Writable()</span><br><span class="line"></span><br><span class="line">writableStream._write = (chunk, encoding, next) =&gt; &#123;</span><br><span class="line">  console.log(chunk.toString())</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">readableStream.pipe(writableStream)</span><br><span class="line"></span><br><span class="line">readableStream.push(&apos;hi!&apos;)</span><br><span class="line">readableStream.push(&apos;ho!&apos;)</span><br><span class="line"></span><br><span class="line">writableStream.end()</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="Node-js-开发环境与生产环境的区别"><a href="#Node-js-开发环境与生产环境的区别" class="headerlink" title="Node.js 开发环境与生产环境的区别"></a><font color="#ff99cc">Node.js 开发环境与生产环境的区别</font></h2><pre><code>此环境变量是一个约定，在外部库中也广泛使用。

设置环境为 production 通常可以确保：
- 日志记录保持在最低水平。
- 更高的缓存级别以优化性能。

最好将其放在的 shell 配置文件中（例如，使用 Bash shell 的 .bash_profile），否则当系统重启时，该设置不会被保留。
也可以通过将环境变量放在应用程序的初始化命令之前来应用它：NODE_ENV=production node app.js

可以使用条件语句在不同的环境中执行代码：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (process.env.NODE_ENV === &quot;development&quot;) &#123;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br><span class="line">if (process.env.NODE_ENV === &quot;production&quot;) &#123;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br><span class="line">if([&apos;production&apos;, &apos;staging&apos;].indexOf(process.env.NODE_ENV) &gt;= 0) &#123;</span><br><span class="line">  //...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


例如，在 Express 应用中，可以使用此工具为每个环境设置不同的错误处理程序：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (process.env.NODE_ENV === &quot;development&quot;) &#123;</span><br><span class="line">  app.use(express.errorHandler(&#123; dumpExceptions: true, showStack: true &#125;))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">if (process.env.NODE_ENV === &quot;production&quot;) &#123;</span><br><span class="line">  app.use(express.errorHandler())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="Node-js-中的错误处理"><a href="#Node-js-中的错误处理" class="headerlink" title="Node.js 中的错误处理"></a><font color="#ff99cc">Node.js 中的错误处理</font></h2><h3 id="创建异常"><a href="#创建异常" class="headerlink" title="创建异常"></a>创建异常</h3><pre><code>使用 throw 关键字创建异常：throw value
一旦 JavaScript 执行到此行，则常规的程序流会被停止，且控制会被交给最近的异常处理程序。

通常，在客户端代码中，value 可以是任何 JavaScript 值（包括字符串、数字、或对象）。
在 Node.js 中，我们不抛出字符串，而仅抛出 Error 对象。
</code></pre><h3 id="错误对象"><a href="#错误对象" class="headerlink" title="错误对象"></a>错误对象</h3><pre><code>错误对象是 Error 对象的实例、或者继承自 Error 类（由 Error 核心模块提供）：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">throw new Error(&apos;错误信息&apos;)</span><br><span class="line">或：</span><br><span class="line"></span><br><span class="line">class NotEnoughCoffeeError extends Error &#123;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br><span class="line">throw new NotEnoughCoffeeError()</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h3><pre><code>异常处理程序是 try/catch 语句。
</code></pre><h3 id="捕获未捕获的异常"><a href="#捕获未捕获的异常" class="headerlink" title="捕获未捕获的异常"></a>捕获未捕获的异常</h3><pre><code>如果在程序执行过程中引发了未捕获的异常，则程序会崩溃。

若要解决此问题，则监听 process 对象上的 uncaughtException 事件：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">process.on(&apos;uncaughtException&apos;, err =&gt; &#123;</span><br><span class="line">  console.error(&apos;有一个未捕获的错误&apos;, err)</span><br><span class="line">  process.exit(1) //强制性的（根据 Node.js 文档）</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

无需为此导入 process 核心模块，因为它是自动注入的。
</code></pre><h3 id="Promise-的异常"><a href="#Promise-的异常" class="headerlink" title="Promise 的异常"></a>Promise 的异常</h3><ul>
<li>使用 promise 可以链接不同的操作，并在最后处理错误：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">doSomething1()</span><br><span class="line">  .then(doSomething2)</span><br><span class="line">  .then(doSomething3)</span><br><span class="line">  .catch(err =&gt; console.error(err))</span><br><span class="line">你怎么知道错误发生在哪里？ 你并不知道，但是你可以处理所调用的每个函数（doSomethingX）中的错误，并且在错误处理程序内部抛出新的错误，这就会调用外部的 catch 处理程序：</span><br><span class="line"></span><br><span class="line">const doSomething1 = () =&gt; &#123;</span><br><span class="line">  //...</span><br><span class="line">  try &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    //... 在本地处理</span><br><span class="line">    throw new Error(err.message)</span><br><span class="line">  &#125;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>- 为了能够在本地（而不是在调用的函数中）处理错误，则可以断开链条，在每个 then() 函数中创建函数并处理异常：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">doSomething1()</span><br><span class="line">  .then(() =&gt; &#123;</span><br><span class="line">    return doSomething2().catch(err =&gt; &#123;</span><br><span class="line">      //处理错误</span><br><span class="line">      throw err //打断链条</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(() =&gt; &#123;</span><br><span class="line">    return doSomething2().catch(err =&gt; &#123;</span><br><span class="line">      //处理错误</span><br><span class="line">      throw err //打断链条</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(err =&gt; console.error(err))</span><br></pre></td></tr></table></figure>

### async/await 的错误处理
  使用 async/await 时，仍然需要捕获错误，可以通过以下方式进行操作：

  async function someFunction() {
    try {
      await someOtherFunction()
    } catch (err) {
      console.error(err.message)
    }
  }
</code></pre><h2 id="在-Node-js-中如何记录对象"><a href="#在-Node-js-中如何记录对象" class="headerlink" title="在 Node.js 中如何记录对象"></a><font color="#ff99cc">在 Node.js 中如何记录对象</font></h2><pre><code>在达到一定嵌套级别之前一切都很好。 在经过两个级别的嵌套后，Node.js 会放弃并打印 [Object] 作为占位符：
如何打印整个对象？

最好的方法（同时保留漂亮的打印效果）是使用：
console.log(JSON.stringify(obj, null, 2))
其中 2 是用于缩进的空格数。

另一种选择是使用：
require(&apos;util&apos;).inspect.defaultOptions.depth = null
console.log(obj)
但是有个问题，第 2 级之后的嵌套对象会被展平，这可能是复杂对象的问题。
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/04/22/workReward/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lemon">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/background22.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/22/workReward/" itemprop="url">workReward</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-22T17:39:33+08:00">
                2021-04-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/专题/" itemprop="url" rel="index">
                    <span itemprop="name">专题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="js"><a href="#js" class="headerlink" title="js"></a>js</h1><h2 id="ES5-map循环：循环遍历竟然出现逗号！"><a href="#ES5-map循环：循环遍历竟然出现逗号！" class="headerlink" title="ES5 map循环：循环遍历竟然出现逗号！"></a>ES5 map循环：循环遍历竟然出现逗号！</h2>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = document.getElementById(&apos;root&apos;);</span><br><span class="line">var b = [1,2,3,4,5,6].map( item =&gt; item);</span><br><span class="line">a.innerText = b;   //  1,2,3,4,5,6</span><br></pre></td></tr></table></figure>
<p>  原来:利用map插入到DOM时 map最终返回的数组因为拼接+=调用了toString方法. 数组结构[1, 2, 3] 里面居然是这个逗号, 转换的时候把它带上了！<br>  我们知道了原因之后就非常方便解决了。我们可以巧妙地利用join方法：join()可以切开一个数组, 指定要使用的分隔符。如果省略该参数，则使用逗号作为分隔符。</p>
<h2 id="模板字符串中-n失效问题"><a href="#模板字符串中-n失效问题" class="headerlink" title="模板字符串中\n失效问题"></a>模板字符串中\n失效问题</h2><pre><code>white-space: pre-line;
</code></pre><h2 id="forEach不遍历内部为空的数组，函数内的代码也不执行。"><a href="#forEach不遍历内部为空的数组，函数内的代码也不执行。" class="headerlink" title="forEach不遍历内部为空的数组，函数内的代码也不执行。"></a>forEach不遍历内部为空的数组，函数内的代码也不执行。</h2><pre><code>为空是指Empty，不是null或undefined。可以改写成for循环。
</code></pre><h2 id="判断用户输入数据是否是JSON格式："><a href="#判断用户输入数据是否是JSON格式：" class="headerlink" title="判断用户输入数据是否是JSON格式："></a>判断用户输入数据是否是JSON格式：</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const checkJson = (d: string) =&gt; &#123;</span><br><span class="line">  if (typeof d !== &apos;string&apos;) &#123;</span><br><span class="line">    message.warning(&apos;非 JSON 格式&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  try &#123;</span><br><span class="line">    const obj = JSON.parse(d);</span><br><span class="line">    if (typeof obj === &apos;object&apos; &amp;&amp; obj) &#123;</span><br><span class="line">      message.warning(&apos;是 JSON 格式&apos;);</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    message.warning(&apos;非 JSON 格式&apos;);</span><br><span class="line">    return false;</span><br><span class="line">  &#125; catch (info) &#123;</span><br><span class="line">    message.warning(&apos;非 JSON 格式&apos;);</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="JSON-stringify-…"><a href="#JSON-stringify-…" class="headerlink" title="JSON.stringify(…)"></a>JSON.stringify(…)</h2><pre><code>JSON.stringify(…)用于将对象转换成字符串，但是注意JSON.stringify(…)也会转译引号。
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(&#123;&#125;)  === “&#123;&#125;”                       <span class="literal">true</span></span><br><span class="line">JSON.stringify(‘123<span class="string">')  === 123                     false</span></span><br><span class="line"><span class="string">JSON.stringify(‘123'</span>)  === <span class="string">"\"123\””               true</span></span><br><span class="line"><span class="string">JSON.stringify(&#123;a: 1&#125;)  === "</span>&#123;\<span class="string">"a\":1&#125;”            true</span></span><br><span class="line"><span class="string">JSON.stringify(&#123;a: '123’&#125;) === "</span>&#123;\<span class="string">"a\":\"123\"&#125;”   true</span></span><br></pre></td></tr></table></figure>
</code></pre><h2 id="switch…case和else…if"><a href="#switch…case和else…if" class="headerlink" title="switch…case和else…if"></a>switch…case和else…if</h2><pre><code>switch…case和else…if的根本区别在于，switch…case会生成一个和索引和switch变量相等的跳转表来指向实际的case分支地址，而else…if需要一条一条地遍历。如此看来， switch…case的效率会更高。
switch…case只能判断byte,short,int或是char类型，if的条件会更灵活

详解：switch...case会生成一份大小（表项数）为最大case常量＋1的跳表，程序首先判断switch变量是否大于最大case 常量，若大于，则跳到default分支处理；否则取得索引号为switch变量大小的跳表项的地址（即跳表的起始地址＋表项大小＊索引号），程序接着跳到此地址执行，到此完成了分支的跳转。
</code></pre><p>  ## </p>
<h1 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h1><h2 id="微信小程序扫码跳转指定页面"><a href="#微信小程序扫码跳转指定页面" class="headerlink" title="微信小程序扫码跳转指定页面"></a>微信小程序扫码跳转指定页面</h2><p>  微信公众平台 - 开发 - 开发管理 - 开发设置 - 扫普通链接二维码打开小程序 - 添加</p>
<p>  填写规则信息 - 将校验文件放在服务器对应目录下 - 选择测试范围（非线上版本最多可添加5个测试链接，规则发布后将不受限制）</p>
<h2 id="小程序登录"><a href="#小程序登录" class="headerlink" title="小程序登录"></a>小程序登录</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wx.login(code)                                    -&gt;  </span><br><span class="line">                                                  -&gt; 后端接口（session_key,openId  storage） -&gt;  后端接口（用户信息）</span><br><span class="line">Button(getPhoneNumber - iv,encryptedData storage) -&gt;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="微信小程序登录问题–第一次登录失败，第二次登录成功问题"><a href="#微信小程序登录问题–第一次登录失败，第二次登录成功问题" class="headerlink" title="微信小程序登录问题–第一次登录失败，第二次登录成功问题"></a>微信小程序登录问题–第一次登录失败，第二次登录成功问题</h2><p>  出现这样的问题都是先获取用户信息（getPhoneNumber）encryptedData与iv，再进行登录wx.login（）获取code。是因为每次获取code会产生一个新的session_key，这时的session_key会与encryptedData解密出来的session_key不同，所以就失败了。正确的做法是先获取code再获取encryptedData。也就是实线wx.login（），这样在getPhoneNumber的时候就没问题了。</p>
<h1 id="周边"><a href="#周边" class="headerlink" title="周边"></a>周边</h1><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><p>  别名，甚至是你想改本地的npm包的代码，奈何生效的只是压缩后的代码，未压缩代码修改后不生效。<br>  此时，alias小可爱就可以帮你解决这个问题，nice。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      &apos;tblh-validate-upload&apos;: path.resolve(process.cwd(), &apos;node_modules&apos;, &apos;tblh-validate-upload/src/index.tsx&apos;),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin https://github.com/LemonQueenx/summer.git</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>
<h3 id="pull-request"><a href="#pull-request" class="headerlink" title="pull request"></a>pull request</h3><p>  我们有需求想改别人的github仓库代码的bug时，需要提pull request。流程是我们fork一下对方的仓库到我们账号下，clone到本地，新建个分支，造作后提交到远程，然后提pull request给对方。对方如果看到，并且愿意采纳你的修改，就会merge，合并到他的项目中。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fork -&gt; </span><br><span class="line">git clone xxx</span><br><span class="line">cd xxx/</span><br><span class="line">git checkout -b fix_jyy</span><br><span class="line">git add .</span><br><span class="line">git commit -m &apos;yyy&apos;</span><br><span class="line">git push --set-upstream origin fix_jyy</span><br></pre></td></tr></table></figure></p>
<p>  完成修改之后，回到 test-pr 分支，点击旁边绿色的 Compare &amp; pull request 按钮</p>
<h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>  npm get registry<br>  npm config set registry xxx<br>  npm adduser –registry xxx<br>  npm profile set password –registry xxx</p>
<p>  npm publish<br>  发布📢：</p>
<ul>
<li>发布之前记得build编译，小包使用rollup打包很简单</li>
<li><p>发布在公司内源的话，需要改变项目的npm源。.npmrc registry=’xxx’</p>
<p>npm view npm包 versions</p>
</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="excel-csv文件的校验并上传"><a href="#excel-csv文件的校验并上传" class="headerlink" title="excel\csv文件的校验并上传"></a>excel\csv文件的校验并上传</h2><p>  基于antd-upload + exceljs二次封装</p>
<ul>
<li>browser引入与使用：<br>（1）npm install exceljs –save<br>（2）import * as ExcelJS from ‘exceljs/dist/exceljs.bare’<br>（3）declare module ‘exceljs/dist/exceljs.bare’</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &apos;react&apos;;</span><br><span class="line">import &#123; Upload, Modal, Button &#125; from &apos;antd&apos;;</span><br><span class="line">const ExcelJS = require(&apos;exceljs/dist/exceljs.bare&apos;);</span><br><span class="line">const Papa = require(&apos;papaparse&apos;);</span><br><span class="line">const jschardet = require(&apos;jschardet&apos;);</span><br><span class="line">const atob = require(&apos;atob&apos;);</span><br><span class="line"></span><br><span class="line">const &#123; Dragger &#125; = Upload as any;</span><br><span class="line">/**类型定义 */</span><br><span class="line">interface IProps &#123;</span><br><span class="line">  sheetProps?: ISheetProps;</span><br><span class="line">  handleMoreValidate?: (rows: any, worksheet?: any) =&gt; string,</span><br><span class="line">  dragProps?: object,</span><br><span class="line">  style?: object,</span><br><span class="line">  children?: React.ReactNode | string,</span><br><span class="line">  uploadToolTip?: React.ReactNode | string,</span><br><span class="line">  resultTitle?: string,</span><br><span class="line">  type?: &apos;excel&apos; | &apos;csv&apos;, // 默认excel</span><br><span class="line">&#125;;</span><br><span class="line">type IType = &apos;list&apos; | &apos;number&apos; | &apos;text&apos; | &apos;custome&apos;; </span><br><span class="line">interface ISheetProps &#123;</span><br><span class="line">  [key: string]: &#123;</span><br><span class="line">    colTitle: string;</span><br><span class="line">    type: IType,</span><br><span class="line">    allowBlank: boolean;</span><br><span class="line">    valueErrorMessage?: string;</span><br><span class="line">    formulae?: any;</span><br><span class="line">    isUnique?: boolean;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">interface ICellErrorInfo &#123;</span><br><span class="line">    cellIndex: string;</span><br><span class="line">    errorMessage: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 工具函数</span><br><span class="line">* @returns </span><br><span class="line">*/</span><br><span class="line">function getEN() &#123;</span><br><span class="line">    var arr = [null] as any;</span><br><span class="line">    for(var i = 65; i &lt; 91; i++)&#123;</span><br><span class="line">        arr.push(String.fromCharCode(i));</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function isInteger(value: number) &#123;</span><br><span class="line">    return value % 1 === 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function dataValidation(value: any, validation: any) &#123;</span><br><span class="line">    if (!validation) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!validation.allowBlank &amp;&amp; !String(value)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //  默认规则</span><br><span class="line">    if (value &amp;&amp; validation.type === &apos;list&apos; &amp;&amp; !validation.formulae.includes(String(value))) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (value &amp;&amp; validation.type === &apos;number&apos; &amp;&amp; !isInteger(Number(value))) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (value &amp;&amp; validation.type === &apos;custom&apos; &amp;&amp; !validation.formulae.test(value)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (value &amp;&amp; validation.type === &apos;text&apos; &amp;&amp; validation.formulae &amp;&amp; value.length &gt; validation.formulae) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const A2Zarray = getEN();</span><br><span class="line"></span><br><span class="line">function checkEncoding(base64Str: any) &#123;</span><br><span class="line">    // 这种方式得到的是一种二进制串</span><br><span class="line">    let str = atob(base64Str.split(&apos;;base64,&apos;)[1]);</span><br><span class="line">    // console.log(str);</span><br><span class="line">    // 要用二进制格式</span><br><span class="line">    let encoding = jschardet.detect(str);</span><br><span class="line">    encoding = encoding.encoding;</span><br><span class="line">    // console.log( encoding );</span><br><span class="line">    if (encoding === &apos;windows-1252&apos;) &#123;</span><br><span class="line">      // 有时会识别错误（如UTF8的中文二字）</span><br><span class="line">      encoding = &apos;ANSI&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    return encoding;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function getFileReaderResult(file: any) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        const fileReader = new FileReader()</span><br><span class="line">        fileReader.readAsDataURL(file);</span><br><span class="line">        fileReader.onload = (e: any) =&gt; &#123;</span><br><span class="line">            const result = e.target.result;</span><br><span class="line">            const encoding = checkEncoding(result);</span><br><span class="line">            resolve(&#123;</span><br><span class="line">                file,</span><br><span class="line">                encoding,</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function getJsonFromCsv(file: any) &#123;</span><br><span class="line">    const data = await getFileReaderResult(file) as any;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        Papa.parse(data.file, &#123;</span><br><span class="line">            encoding: data.encoding,</span><br><span class="line">            complete: function(results: any) &#123;</span><br><span class="line">                resolve(results.data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 组件</span><br><span class="line">* @param props </span><br><span class="line">* @returns </span><br><span class="line">*/</span><br><span class="line">const Demo = (props: IProps) =&gt; &#123;</span><br><span class="line">    const &#123; sheetProps, type=&apos;excel&apos; &#125; = props;</span><br><span class="line">    const [modal, setModal] = React.useState(&#123;</span><br><span class="line">        visible: false,</span><br><span class="line">        resultContent: &apos;&apos;,</span><br><span class="line">    &#125;);</span><br><span class="line">    const dragProps = &#123;</span><br><span class="line">        name: &apos;file&apos;,</span><br><span class="line">        multiple: true,</span><br><span class="line">        accept: &apos;.csv,.xlsx&apos;,</span><br><span class="line">        action: &apos;https://www.mocky.io/v2/5cc8019d300000980a055e76&apos;,</span><br><span class="line">        beforeUpload: async (file: any) =&gt; &#123;</span><br><span class="line">            if (!sheetProps) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            return new Promise(async (resolve, reject) =&gt; &#123;</span><br><span class="line">                if (type === &apos;csv&apos;) &#123;</span><br><span class="line">                    const json = await getJsonFromCsv(file) as any;</span><br><span class="line">                    const csvInfo = &#123;</span><br><span class="line">                        bodyErrorInfo: [],</span><br><span class="line">                        titleError: [],</span><br><span class="line">                        isEmptyCsv: false,</span><br><span class="line">                        extraErrorInfo: &apos;&apos;,</span><br><span class="line">                    &#125; as any;</span><br><span class="line">                    // isEmpty</span><br><span class="line">                    if (!json.length) &#123;</span><br><span class="line">                        csvInfo.isEmptyCsv = true;</span><br><span class="line">                        // setModal(&#123;</span><br><span class="line">                        //     visible: true,</span><br><span class="line">                        //     resultContent: `$&#123;modal.resultContent&#125;\n上传为空表，请检查`,</span><br><span class="line">                        // &#125;);</span><br><span class="line">                        // reject(false);</span><br><span class="line">                    &#125;</span><br><span class="line">                    // isErrorTitle</span><br><span class="line">                    Object.values(sheetProps).forEach((item: any, index: number) =&gt; &#123;</span><br><span class="line">                        if (item.colTitle !== json[0][index]) &#123;</span><br><span class="line">                            csvInfo.titleError = (csvInfo.titleError || []).concat(index);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    // isErrorbody</span><br><span class="line">                    json.forEach((item: any, index: number) =&gt; &#123;</span><br><span class="line">                        if (index) &#123;</span><br><span class="line">                            item.forEach((value: any, i: number) =&gt; &#123;</span><br><span class="line">                                if (!dataValidation(value, sheetProps[A2Zarray[i + 1]])) &#123;</span><br><span class="line">                                    csvInfo.bodyErrorInfo.push(&#123;</span><br><span class="line">                                        cellIndex: `$&#123;index + 1&#125;行 $&#123;A2Zarray[i + 1]&#125;列`,</span><br><span class="line">                                        errorMessage: sheetProps[A2Zarray[i + 1]].valueErrorMessage || &apos;值为空或类型错误，请检查&apos;,</span><br><span class="line">                                    &#125;);</span><br><span class="line">                                &#125;;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    // extraInfo</span><br><span class="line">                    if (props.handleMoreValidate) &#123;</span><br><span class="line">                        csvInfo.extraErrorInfo = props.handleMoreValidate(json);</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 来吧，展示</span><br><span class="line">                    let errorInfo = &apos;&apos;;</span><br><span class="line">                    if (csvInfo.isEmptyCsv) &#123;</span><br><span class="line">                        errorInfo += &apos;上传为空表，请检查&apos;;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (csvInfo.titleError.length) &#123;</span><br><span class="line">                        errorInfo += `\n列标题错误，请检查$&#123;csvInfo.titleError&#125;`;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (csvInfo.bodyErrorInfo.length) &#123;</span><br><span class="line">                        errorInfo += `\n内容错误，错误信息如下：\n$&#123;csvInfo.bodyErrorInfo.map((i: any) =&gt; (`$&#123;i.cellIndex&#125;:$&#123;i.errorMessage&#125;\n`)).join(&apos;&apos;)&#125;`;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (csvInfo.extraErrorInfo) &#123;</span><br><span class="line">                        errorInfo += `\n$&#123;csvInfo.extraErrorInfo&#125;`;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (errorInfo) &#123;</span><br><span class="line">                        setModal(&#123;</span><br><span class="line">                            visible: true,</span><br><span class="line">                            resultContent: errorInfo,</span><br><span class="line">                        &#125;);</span><br><span class="line">                        reject(false);</span><br><span class="line">                    &#125;</span><br><span class="line">                    resolve(true);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                // 以下是对excel的处理</span><br><span class="line">                const buffer = file.arrayBuffer();</span><br><span class="line">                const workbook = new ExcelJS.Workbook();</span><br><span class="line">                await workbook.xlsx.load(buffer);</span><br><span class="line">                let sheetInfo = &#123;&#125; as any;</span><br><span class="line">                workbook.eachSheet(async function(worksheet: any, sheetId: any) &#123;</span><br><span class="line">                    // 先获取当前sheet中的有效数据</span><br><span class="line">                    // 校验列标题和列号是不是正确的</span><br><span class="line">                    // 遍历body每一行数据，校验每个cell</span><br><span class="line">                    sheetInfo[sheetId] = &#123;</span><br><span class="line">                        name: worksheet.name,</span><br><span class="line">                    &#125;;</span><br><span class="line">                    // let breakRowNumber = null as any;</span><br><span class="line">                    let errorTitleIndex = [] as any;</span><br><span class="line">                    let isEmptySheet = false;</span><br><span class="line">                    // 检查主规则</span><br><span class="line">                    let bodyErrorInfo: ICellErrorInfo[] = [];</span><br><span class="line">                    worksheet.eachRow(&#123; includeEmpty: true &#125;, function(row: any, rowNumber: any) &#123;</span><br><span class="line">                        // 检查头部</span><br><span class="line">                        if (rowNumber === 1) &#123;</span><br><span class="line">                            row.values.forEach((title: string, index: number) =&gt; &#123;</span><br><span class="line">                                if (index &amp;&amp; sheetProps[A2Zarray[index]] &amp;&amp; sheetProps[A2Zarray[index]].colTitle !== title) &#123;</span><br><span class="line">                                    errorTitleIndex.push(A2Zarray[index]);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 检查是否是空表</span><br><span class="line">                        if (rowNumber === 1 &amp;&amp; !row.values.length) &#123;</span><br><span class="line">                            isEmptySheet = true;</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 截取有效数据部分</span><br><span class="line">                        if (rowNumber &gt; 1) &#123;</span><br><span class="line">                            row.values.forEach((value: any, index: number) =&gt; &#123;</span><br><span class="line">                                const colIndex = A2Zarray[index];</span><br><span class="line">                                const cellIndex = `$&#123;rowNumber&#125;行 $&#123;colIndex&#125;列`;</span><br><span class="line">                                if (!dataValidation(value, sheetProps[colIndex])) &#123;</span><br><span class="line">                                    bodyErrorInfo.push(&#123;</span><br><span class="line">                                        cellIndex,</span><br><span class="line">                                        errorMessage: sheetProps[colIndex].valueErrorMessage || &apos;值为空或类型错误，请检查&apos;,</span><br><span class="line">                                    &#125;);</span><br><span class="line">                                &#125;;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    // 检查唯一性</span><br><span class="line">                    /////////////// ......</span><br><span class="line">                    // 检查额外逻辑的处理</span><br><span class="line">                    let extraErrorInfo: string = &apos;&apos;;</span><br><span class="line">                    if (props.handleMoreValidate) &#123;</span><br><span class="line">                        const rows = worksheet._rows.map((e: any) =&gt; Array.isArray(e.values) &amp;&amp; e.values.slice(1));</span><br><span class="line">                        extraErrorInfo = props.handleMoreValidate(rows, worksheet);</span><br><span class="line">                    &#125;</span><br><span class="line">                    sheetInfo[sheetId] = &#123;</span><br><span class="line">                        ...sheetInfo[sheetId],</span><br><span class="line">                        isEmptySheet,</span><br><span class="line">                        // breakRowNumber,</span><br><span class="line">                        errorTitleIndex,</span><br><span class="line">                        bodyErrorInfo,</span><br><span class="line">                        extraErrorInfo,</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;);</span><br><span class="line">                let errorInfo = &apos;&apos;;</span><br><span class="line">                // 对结果进行提示</span><br><span class="line">                Object.keys(sheetInfo).forEach((key: string | number) =&gt; &#123;</span><br><span class="line">                    if (sheetInfo[key].isEmptySheet) &#123;</span><br><span class="line">                        errorInfo +=  `$&#123;sheetInfo[key].name&#125;为空表`;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (sheetInfo[key].errorTitleIndex.length) &#123;</span><br><span class="line">                        errorInfo +=  `\n$&#123;sheetInfo[key].name&#125;表标题错误，请检查，列如下：\n$&#123;sheetInfo[key].errorTitleIndex&#125;`;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (sheetInfo[key].bodyErrorInfo.length) &#123;</span><br><span class="line">                        errorInfo +=  `\n$&#123;sheetInfo[key].name&#125;表内容错误，请检查，单元格如下：\n$&#123;sheetInfo[key].bodyErrorInfo.map((i: any) =&gt; (`$&#123;i.cellIndex&#125;:$&#123;i.errorMessage&#125;\n`)).join(&apos;&apos;)&#125;`;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (sheetInfo[key].extraErrorInfo) &#123;</span><br><span class="line">                        errorInfo +=  `\n$&#123;sheetInfo[key].extraErrorInfo&#125;`;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                if (errorInfo) &#123;</span><br><span class="line">                    setModal(&#123;</span><br><span class="line">                        visible: true,</span><br><span class="line">                        resultContent: errorInfo,</span><br><span class="line">                    &#125;);</span><br><span class="line">                    reject(false);</span><br><span class="line">                &#125;</span><br><span class="line">                resolve(true);</span><br><span class="line">                return;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        onChange(info: any) &#123;</span><br><span class="line">          const &#123; status &#125; = info.file;</span><br><span class="line">          if (status !== &apos;uploading&apos;) &#123;</span><br><span class="line">            // console.log(info.file, info.fileList);</span><br><span class="line">          &#125;</span><br><span class="line">          if (status === &apos;done&apos;) &#123;</span><br><span class="line">            // message.success(`$&#123;info.file.name&#125; file uploaded successfully.`);</span><br><span class="line">          &#125; else if (status === &apos;error&apos;) &#123;</span><br><span class="line">            // message.error(`$&#123;info.file.name&#125; file upload failed.`);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        ...props.dragProps || &#123;&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    const handleCancelModal = () =&gt; &#123;</span><br><span class="line">        setModal(&#123;</span><br><span class="line">            visible: false,</span><br><span class="line">            resultContent: &apos;&apos;,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return (</span><br><span class="line">        &lt;div style=&#123;props.style || &#123;&#125;&#125;&gt;</span><br><span class="line">            &#123; props.children || null &#125;</span><br><span class="line">            &lt;Modal</span><br><span class="line">              style=&#123;&#123; whiteSpace: &apos;pre-line&apos; &#125;&#125;</span><br><span class="line">              visible=&#123;modal.visible&#125; title=&#123;props.resultTitle || &apos;校验结果&apos;&#125;</span><br><span class="line">              footer = &#123; &lt;Button  type = &quot;primary&quot; onClick = &#123; handleCancelModal &#125;&gt;确定&lt;/Button&gt; &#125;</span><br><span class="line">            &gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    modal.resultContent</span><br><span class="line">                &#125;</span><br><span class="line">            &lt;/Modal&gt;</span><br><span class="line">            &lt;Dragger &#123;...dragProps&#125;&gt;</span><br><span class="line">                &lt;p&gt;</span><br><span class="line">                    &#123; props.uploadToolTip || &apos;Support CSV and EXCEL file for analysis&apos; &#125;</span><br><span class="line">                &lt;/p&gt;</span><br><span class="line">            &lt;/Dragger&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Demo;</span><br></pre></td></tr></table></figure>
<h2 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h2><pre><code>a标签的download属性，想必大家都知道它的意义是改变文件下载的名称。但是当跨域下载远程文件的时候，这个属性会存在失效问题。我们今天就来看看，在不用服务器协调的情况下，前端如何自行处理这个问题。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">const handleDownLoad = () =&gt; &#123;</span><br><span class="line">const template = &apos;https://festatic-1254389369.cos.ap-guangzhou.myqcloud.com/science/otms/importTemplatestationCreate.csv&apos;;</span><br><span class="line">const download = &apos;模板.csv&apos;;</span><br><span class="line"></span><br><span class="line">const x = new XMLHttpRequest();</span><br><span class="line">x.open(&apos;GET&apos;, template, true);</span><br><span class="line">x.responseType = &apos;blob&apos;;</span><br><span class="line">x.onload = () =&gt; &#123;</span><br><span class="line">  const url = window.URL.createObjectURL(x.response);</span><br><span class="line">  const a = document.createElement(&apos;a&apos;);</span><br><span class="line">  a.href = url;</span><br><span class="line">  a.download = download;</span><br><span class="line">  a.click();</span><br><span class="line">&#125;;</span><br><span class="line">x.send();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const handleDownLoad = async () =&gt; &#123;</span><br><span class="line">const template = &apos;https://festatic-1254389369.cos.ap-guangzhou.myqcloud.com/science/otms/importTemplatestationCreate.csv&apos;;</span><br><span class="line">const download = &apos;模板.csv&apos;;</span><br><span class="line"></span><br><span class="line">const response = await fetch(template);</span><br><span class="line">const blob = await response.blob();</span><br><span class="line">const objectUrl = window.URL.createObjectURL(blob);</span><br><span class="line">const a = document.createElement(&apos;a&apos;);</span><br><span class="line">a.href = objectUrl;</span><br><span class="line">a.download = download;</span><br><span class="line">document.body.appendChild(a);</span><br><span class="line">a.click();</span><br><span class="line">setTimeout(() =&gt; document.body.removeChild(a), 1000);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

&lt;div class=&apos;post-warning&apos;&gt;注意：代码中对创建的&lt;a\&gt; 进行的 appendChild 和 remove 操作主要是为了兼容 FireFox 浏览器，在 FireFox 浏览器下调用该方法如果不将创建的&lt;a\&gt;标签添加到 body 里，点击链接不会有任何反应，无法触发下载，而在 Chrome 浏览器中则不受此影响。&lt;/div&gt;
</code></pre><h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><p>  书签栏-复制cookies：<br>  1）在chrome中打开下面的的html，之后把页面中的‘复制cookies’拉到书签栏即可。<br>  2）书签栏空白处邮件-添加网页-将javascript部分粘贴到地址部分即可。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;a href=&quot;javascript:void(function() &#123;</span><br><span class="line">        var cookies = document.cookie;</span><br><span class="line">        var cookieArr = cookies.split(&apos;;&apos;);</span><br><span class="line">            cookieArr = cookieArr.map((item,index) =&gt; &#123;</span><br><span class="line">              var cookiePair = item.split(&apos;=&apos;);</span><br><span class="line">              cookiePair = cookiePair.map(member=&gt;member.trim());</span><br><span class="line">              return &#123;</span><br><span class="line">                domain:&apos;localhost&apos;,</span><br><span class="line">                expirationDate: 2629505262.602054,</span><br><span class="line">                hostOnly: true,</span><br><span class="line">                httpOnly: false,</span><br><span class="line">                name: cookiePair[0],</span><br><span class="line">                path: &apos;/&apos;,</span><br><span class="line">                sameSite: &apos;unspecified&apos;,</span><br><span class="line">                secure: false,</span><br><span class="line">                session: false,</span><br><span class="line">                storeId: &apos;0&apos;,</span><br><span class="line">                value: cookiePair[1],</span><br><span class="line">                id: index</span><br><span class="line">              &#125;;</span><br><span class="line">            &#125;);</span><br><span class="line">        var tag = document.createElement(&apos;input&apos;);</span><br><span class="line">        tag.style.opacity = &apos;0&apos;;</span><br><span class="line">        tag.setAttribute(&apos;id&apos;, &apos;cp_hgz_input&apos;);</span><br><span class="line">        tag.value = JSON.stringify(cookieArr);</span><br><span class="line">        document.getElementsByTagName(&apos;body&apos;)[0].appendChild(tag);</span><br><span class="line">        document.getElementById(&apos;cp_hgz_input&apos;).select();</span><br><span class="line">        document.execCommand(&apos;copy&apos;);</span><br><span class="line">        document.getElementById(&apos;cp_hgz_input&apos;).remove();</span><br><span class="line">      &#125;)()&quot;&gt;复制cookies&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/04/06/qiankun/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lemon">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/background22.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/06/qiankun/" itemprop="url">qiankun</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-06T17:52:30+08:00">
                2021-04-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/专题/" itemprop="url" rel="index">
                    <span itemprop="name">专题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>  微前端是现在前端很火的一个概念，主要是为了解决企业级中后台系统过大所带来的性能问题的解决方案。目前，稍成熟的方案主要有single-spa和qiankun，qiankun是基于single-spa，我们选择qiankun + react，Let’s  start ~</p>
  <canvas id="qiankun" width="500" height="500"></canvas>

<h1 id="一、快速上手"><a href="#一、快速上手" class="headerlink" title="一、快速上手"></a>一、快速上手</h1><p>  主应用</p>
<ol>
<li><p>安装 qiankun<br>$ yarn add qiankun # 或者 npm i qiankun -S</p>
</li>
<li><p>在主应用中注册微应用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import &#123; registerMicroApps, start &#125; from &apos;qiankun&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// qiankun 注册微应用</span><br><span class="line">registerMicroApps([</span><br><span class="line">  &#123;</span><br><span class="line">    name: &apos;service_activity_app&apos;, // app name registered</span><br><span class="line">    entry: process.env.NODE_ENV === &apos;production&apos; ? &apos;&apos; : &apos;http://localhost:8080&apos;,</span><br><span class="line">    container: &apos;#subContainer&apos;,</span><br><span class="line">    activeRule: (location) =&gt; location.href.includes(&apos;/microApp/serviceActivityApp&apos;),</span><br><span class="line">  &#125;,</span><br><span class="line">]);</span><br><span class="line">start();</span><br><span class="line"></span><br><span class="line">&lt;div id=&apos;subContainer&apos;&gt;微前端&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>name：必选，微应用的名称，与微应用package.json中name属性值一致，微应用之间必须确保唯一；<br>entry：必选，微应用的入口访问地址，需要区分本地调试环境还是线上环境；<br>container：必选，微应用的容器节点的选择器或者 Element 实例，一般是主应用提供的用于承载微应用的容器节点。</p>
<pre><code>如&apos;#subContainer&apos; 或 document.querySelector(&apos;#subContainer&apos;)。
</code></pre><p>activeRule：string | (location: Location) =&gt; boolean | Array<string | (location: location)> boolean - 必选，微应用的激活规则。<br>支持直接配置字符串或字符串数组，如 _activeRule: ‘/app1’ _或 activeRule: activeRule: [‘/app1’, ‘/app2’]当配置为字符串时会直接跟 url 中的路径部分做前缀匹配，匹配成功表明当前应用会被激活<br>支持配置一个 active function 函数或一组 active function。函数会传入当前 location 作为参数，函数返回 true 时表明当前微应用会被激活。如 location =&gt; location.pathname.startsWith(‘/app1’)</string></p>
<p>很重要的一点是，主应用记得配置微应用的代理。</p>
</li>
</ol>
<ol start="3">
<li><p>子应用中的配置</p>
<ol>
<li><p>导出相应的生命周期钩子<br>微应用需要在自己的入口 js (通常就是你配置的 webpack 的 entry js) 导出 bootstrap、mount、unmount 三个生命周期钩子，以供主应用在适当的时机调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">* bootstrap 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。</span><br><span class="line">* 通常我们可以在这里做一些全局变量的初始化，比如不会在 unmount 阶段被销毁的应用级别的缓存等。</span><br><span class="line">export async function bootstrap() &#123;</span><br><span class="line">  console.log(&apos;react app bootstraped&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">* 应用每次进入都会调用 mount 方法，通常我们在这里触发应用的渲染方法</span><br><span class="line">export async function mount(props) &#123;</span><br><span class="line">  ReactDOM.render(&lt;App /&gt;, props.container ? props.container.querySelector(&apos;#root&apos;) : document.getElementById(&apos;root&apos;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">* 应用每次 切出/卸载 会调用的方法，通常在这里我们会卸载微应用的应用实例</span><br><span class="line">export async function unmount(props) &#123;</span><br><span class="line">  ReactDOM.unmountComponentAtNode(</span><br><span class="line">    props.container ? props.container.querySelector(&apos;#root&apos;) : document.getElementById(&apos;root&apos;),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">* 可选生命周期钩子，仅使用 loadMicroApp 方式加载微应用时生效</span><br><span class="line">export async function update(props) &#123;</span><br><span class="line">  console.log(&apos;update props&apos;, props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>qiankun 基于 single-spa，所以你可以在<a href="https://single-spa.js.org/docs/building-applications/#registered-application-lifecycle" target="_blank" rel="noopener">这里</a>找到更多关于微应用生命周期相关的文档说明。</p>
</li>
</ol>
</li>
</ol>
<pre><code>2. 配置微应用的打包工具
  除了代码中暴露出相应的生命周期钩子之外，为了让主应用能正确识别微应用暴露出来的一些信息，微应用的打包工具需要增加如下配置：

  webpack:
  const packageName = require(&apos;./package.json&apos;).name;

  module.exports = {
    output: {
      ...
      publicPath: &apos;http://localhost:8080/&apos;
      library: `${packageName}-[name]`,
      libraryTarget: &apos;umd&apos;,
      jsonpFunction: `webpackJsonp_${packageName}`,
    },
  };

3. package.json
  name 保持一致且唯一
</code></pre><h1 id="二、父子应用通信"><a href="#二、父子应用通信" class="headerlink" title="二、父子应用通信"></a>二、父子应用通信</h1><h2 id="qiankun-Actions"><a href="#qiankun-Actions" class="headerlink" title="qiankun - Actions"></a>qiankun - Actions</h2><pre><code>qiankun官方提供了父子应用通信的方法，使用简单，适用于业务划分清晰，父子应用通信少的场景。
initGlobalState方法：初始化globalState的值。
setGlobalState方法：设置globalState的值，内部进行浅检查，如果检查到globalState发生改变时，通知所有的观察者函数。
onGlobalStateChange事件：观察者函数。在globalState发生改变时触发该函数。
offGlobalStateChange：取消观察者函数。
</code></pre>  <canvas id="pic" width="500" height="400"></canvas>

<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">主应用：</span><br><span class="line">const actions: MicroAppStateActions = initGlobalState(&#123;&#125;);</span><br><span class="line">actions.setGlobalState(&#123;</span><br><span class="line">  publicInfo: &#123;</span><br><span class="line">    name: &apos;origin&apos;,</span><br><span class="line">    authCode: [999],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">actions.onGlobalStateChange((state: any) =&gt; &#123;</span><br><span class="line">  console.log(&apos;主应用&apos;, state);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">子应用：</span><br><span class="line">export async function mount(props) &#123;</span><br><span class="line">  props.setGlobalState(&#123; publicInfo: &apos;123&apos; &#125;);</span><br><span class="line">  props.onGlobalStateChange((state, pre) =&gt; &#123;</span><br><span class="line">    console.log(&apos;子应用-onGlobalStateChange&apos;, state, pre);</span><br><span class="line">  &#125;);</span><br><span class="line">  ······</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="redux-Shared"><a href="#redux-Shared" class="headerlink" title="redux - Shared"></a>redux - Shared</h2><h1 id="三、公共资源引入"><a href="#三、公共资源引入" class="headerlink" title="三、公共资源引入"></a>三、公共资源引入</h1><p>  微前端可以让子应用拥有自己的独立的依赖，互不打扰。乾坤官方也有提到：</p>
<p>  <div class="post-warning">不要共享运行时，即便所有团队都是用同一框架</div><br>  虽然共享依赖并不建议，但如果你真的有这个需求，你可以在微应用中将公共依赖配置成 external，然后在主应用中导入这些公共依赖。</p>
<h2 id="公共依赖"><a href="#公共依赖" class="headerlink" title="公共依赖"></a>公共依赖</h2><p>  如果不同的项目有用到相同的包的相同版本，重复加载就会存在浪费内存和降低性能的问题，所以我们考虑复用公共依赖。</p>
<p>  我们对于公共依赖的复用，有两点期望：一是集合时，主应用可以加载，子应用不再重复加载，二是子应用独立运行时可以正常加载运行。</p>
<h3 id="1）集合时，主应用加载公共依赖，子用主"><a href="#1）集合时，主应用加载公共依赖，子用主" class="headerlink" title="1）集合时，主应用加载公共依赖，子用主"></a>1）集合时，主应用加载公共依赖，子用主</h3><p>  子项目原本需要加载的公共部分，全部由主项目调度，配合webpack的externals功能通过外链的方式按需加载，一旦有一个子项目加载过，下一个子项目就不需要再加载，这样一来每个子项目的dist文件里就只有子项目自己的业务代码；</p>
<p>  主子项目的index.html 中公共依赖的 script 和 link 标签加上 ignore 属性，有了这个属性，qiankun 便不会再去加载这个 js/css。子项目独立运行时，加载自己的公共依赖的 script 和 link资源即可。</p>
  <canvas id="dependencies" width="600" height="300"></canvas>

<p>  为了实现主应用加载公共资源，我们可以维护一个子应用所需公共依赖的集合，在全局微应用的beforeUpload中，通过插入script标签的方式，加载对于子应用所需的js资源。具体实现如下：</p>
<p>  主应用：primary-app<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  1. 定义子应用的公共依赖</span></span><br><span class="line"><span class="keyword">const</span> dependencies: any = &#123;</span><br><span class="line">  summer: [<span class="string">'react'</span>, <span class="string">'react-dom'</span>], <span class="comment">// 子应用summer，这里以react和react-dom两个基础依赖为例</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> getDependencies = <span class="function">(<span class="params">appName: string</span>) =&gt;</span> dependencies[appName];</span><br><span class="line"><span class="comment">// 构建script标签</span></span><br><span class="line"><span class="keyword">const</span> loadScript = <span class="function">(<span class="params">url: string</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">  script.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">  script.src = url;</span><br><span class="line">  script.setAttribute(<span class="string">'ignore'</span>, <span class="string">'true'</span>); <span class="comment">// 避免重复加载</span></span><br><span class="line">  script.onerror = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`加载失败<span class="subst">$&#123;url&#125;</span>，请刷新重试`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2：注册子应用</span></span><br><span class="line">registerMicroApps([</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'summer'</span>, <span class="comment">// app name registered</span></span><br><span class="line">    entry: process.env.NODE_ENV === <span class="string">'production'</span> ? <span class="string">''</span> : <span class="string">'http://localhost:8083/'</span>,</span><br><span class="line">    container: <span class="string">'#router-view'</span>,</span><br><span class="line">    activeRule: [<span class="string">'/systemManage'</span>, <span class="string">'/orderManage'</span>],</span><br><span class="line">  &#125;], &#123;</span><br><span class="line">  beforeLoad: [</span><br><span class="line">    app =&gt; <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolved: any</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'[LifeCycle] before load %c%s'</span>, <span class="string">'color: green;'</span>, app.name);</span><br><span class="line">      getDependencies(app.name).forEach(<span class="function">(<span class="params">dependency: string</span>) =&gt;</span> &#123;</span><br><span class="line">        loadScript(<span class="string">`<span class="subst">$&#123;<span class="built_in">window</span>.location.origin&#125;</span>/<span class="subst">$&#123;dependency&#125;</span>.js`</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">      resolved(<span class="literal">true</span>);</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br><span class="line">);</span><br><span class="line">start();</span><br></pre></td></tr></table></figure></p>
<p>  这里还要注意通过 webpack 来生产好相应的依赖资源，我们使用的是 copy-webpack-plugin 插件将 node_modules 下的 release 资源转换成包成可以通过独立 URL 访问的资源。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackExternalsPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-externals-plugin'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackExternalsPlugin(&#123;</span><br><span class="line">      externals: [&#123;</span><br><span class="line">        <span class="built_in">module</span>: <span class="string">'react'</span>,</span><br><span class="line">        entry: &#123;</span><br><span class="line">          path: <span class="string">'umd/react.development.js'</span>,</span><br><span class="line">          attributes: &#123; <span class="attr">ignore</span>: <span class="string">'true'</span> &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        global: <span class="string">'React'</span>,</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        <span class="built_in">module</span>: <span class="string">'react-dom'</span>,</span><br><span class="line">        entry: &#123;</span><br><span class="line">          path: <span class="string">'umd/react-dom.development.js'</span>,</span><br><span class="line">          attributes: &#123; <span class="attr">ignore</span>: <span class="string">'true'</span> &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        global: <span class="string">'ReactDOM'</span>,</span><br><span class="line">      &#125;],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2）子应用在独立运行时又可加载正常运行"><a href="#2）子应用在独立运行时又可加载正常运行" class="headerlink" title="2）子应用在独立运行时又可加载正常运行"></a>2）子应用在独立运行时又可加载正常运行</h3><p>  子应用将主应用已经定义的公共依赖通过 html-webpack-externals-plugin 这个插件使用 external 的方式独立出来，不打包到 Webpack bundle 中，同时通过插件的配置，给 &lt; script &gt; 标签加上 ignore 属性，那么在 qiankun 加载这个子应用时使用，qiankun 依赖的 import-html-entry 插件分析到 &lt; script &gt; 标签时，会忽略加载有 ignore 属性的 &lt; script &gt; 标签，而独立访问时子应用本身可以正常加载这个 Javascript 资源。<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackExternalsPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-externals-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">   plugins: [</span><br><span class="line">     ...</span><br><span class="line">     <span class="keyword">new</span> HtmlWebpackExternalsPlugin(&#123;</span><br><span class="line">       externals: [&#123;</span><br><span class="line">         <span class="built_in">module</span>: <span class="string">'react'</span>,</span><br><span class="line">         entry: &#123;</span><br><span class="line">           path: <span class="string">'umd/react.development.js'</span>,</span><br><span class="line">           attributes: &#123; <span class="attr">ignore</span>: <span class="string">'true'</span> &#125;,</span><br><span class="line">         &#125;,</span><br><span class="line">         global: <span class="string">'React'</span>,</span><br><span class="line">       &#125;, &#123;</span><br><span class="line">         <span class="built_in">module</span>: <span class="string">'react-dom'</span>,</span><br><span class="line">         entry: &#123;</span><br><span class="line">           path: <span class="string">'umd/react-dom.development.js'</span>,</span><br><span class="line">           attributes: &#123; <span class="attr">ignore</span>: <span class="string">'true'</span> &#125;,</span><br><span class="line">         &#125;,</span><br><span class="line">         global: <span class="string">'ReactDOM'</span>,</span><br><span class="line">       &#125;],</span><br><span class="line">     &#125;),</span><br><span class="line">   ],</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></p>
<p>  <strong>踩坑记录</strong>：<br>  1）安装copy-webpack-plugin时，可能会遇到版本兼容问题，这时候安装合适的版本可以解决。<br>  2）安装html-webpack-externals-plugin时，遇到了：Super expression must either be null or a function, not undefined报错。<br>     解决：试了切换版本后还是不行，有说是React.Component的大小写写错了，但是我并没有用到React.Component。最后发现是HtmlWebpackExternalsPlugin.externals配置项的module和global配置出现问题。大家遇到了一些奇怪的问题也可以检查此配置项。</p>
<p>  copy-webpack-plugin 在构建过程中复制源树中已经存在的文件。<br>  HtmlWebpackExternalsPlugin : 基础库不打包，直接URL（CDN）引入。</p>
<p>  这里需要注意的是，<a href="https://github.com/mmiller42/html-webpack-externals-plugin" target="_blank" rel="noopener">HtmlWebpackExternalsPlugin</a>插件目前已经被弃用，不再维护：<br>  <div class="post-warning">Sorry, this module is no longer maintained, and its functionality is baked into wonderful plugins by jharris4, html-webpack-tags-plugin and html-webpack-deploy-plugin.</div><br>  但是很遗憾 <a href="https://github.com/jharris4/html-webpack-deploy-plugin" target="_blank" rel="noopener">html-webpack-tags-plugin</a>和<a href="https://github.com/jharris4/html-webpack-deploy-plugin" target="_blank" rel="noopener">html-webpack-deploy-plugin</a>的3.x版本都要求使用webpack5.0或更高版本。我们的基座应用primary-app的webpack版本是4.x版本，且被二次封装过，暂无法体验这两个插件。</p>
<p>  不过这个插件不再维护，且我们用目前的版本遇到无法解决的问题的话，我们拆开来配也行：<br>  这个插件非常简单，只是封装了另外两个 Webpack 插件来完成繁重的工作。它：<br>    在运行时修改您的 Webpack 配置以将您的供应商模块添加到externals属性中。<br>    运行copy-webpack-plugin将您的供应商模块资产复制到输出路径中。<br>    运行html-webpack-include-assets-plugin将您的供应商模块包添加到 HTML 输出。</p>
<p>  ModuleFederationPlugin</p>
<h2 id="公共组件"><a href="#公共组件" class="headerlink" title="公共组件"></a>公共组件</h2><pre><code>1) npm包的方式
  NPM 或者 Git Tag、Git Submodule 来管理

2）父子项目间的组件共享
</code></pre><h1 id="四、常见问题"><a href="#四、常见问题" class="headerlink" title="四、常见问题"></a>四、常见问题</h1><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>  问题： Access to fetch at ‘<a href="http://localhost:8083/&#39;" target="_blank" rel="noopener">http://localhost:8083/&#39;</a> from origin ‘<a href="http://localhost:3032&#39;" target="_blank" rel="noopener">http://localhost:3032&#39;</a> has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource. If an opaque response serves your needs, set the request’s mode to ‘no-cors’ to fetch the resource with CORS disabled.</p>
<p>  解决：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.all(&apos;*&apos;, (_req, res, next) =&gt; &#123;</span><br><span class="line">  res.header(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="主应用和子应用冲突"><a href="#主应用和子应用冲突" class="headerlink" title="主应用和子应用冲突"></a>主应用和子应用冲突</h2><p>  问题： cjs 和 esm 等兼容性问题<br>        You are loading the CommonJS build of React Router on a page that is already running the ES modules build, so things won’t work right. </p>
<p>  解决：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  mainFields: [&apos;browser&apos;, &apos;jsnext:main&apos;, &apos;main&apos;],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<h2 id="加载子应用失败"><a href="#加载子应用失败" class="headerlink" title="加载子应用失败"></a>加载子应用失败</h2><p>  问题：Application died in status LOADING_SOURCE_CODE: You need to export the functional lifecycles in xxx entry<br>  解决： <a href="https://qiankun.umijs.org/zh/faq" target="_blank" rel="noopener">常见问题</a></p>
<h2 id="子应用渲染问题"><a href="#子应用渲染问题" class="headerlink" title="子应用渲染问题"></a>子应用渲染问题</h2><p>  问题：子应用首次渲染，切换回主应用或其他子应用后再切回来，就只加载到子应用根节点，根节点里面的内容就不插入到根节点中了？？？<br>  解决：在生命周期的mount函数中挂在时，也要判断是否有container，有的话挂在在container节点上。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const &#123; container &#125; = props;</span><br><span class="line">if (container) &#123;</span><br><span class="line">  Render(container.querySelector(&apos;#root&apos;));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  Render(document.getElementById(&apos;root&apos;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="父子应用切换"><a href="#父子应用切换" class="headerlink" title="父子应用切换"></a>父子应用切换</h2><p>  问题：如果一个应用在父应用中有两个路由页面。从子应用的页面1，通过父应用菜单切换到父应用，再通过父应用菜单切换到子应用的页面2，此时页面加载的是子应用的页面1。<br>  解决：在菜单Menu的click方法中，加上key<br>       <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useHistory &#125; from &apos;react-router-dom&apos;;</span><br><span class="line"></span><br><span class="line">const CustomMenu = memo((props: InjectedIntlProps) =&gt; &#123;</span><br><span class="line">  const history = useHistory();</span><br><span class="line"></span><br><span class="line">  const onClick = (menuItem: any) =&gt; &#123;</span><br><span class="line">    ···</span><br><span class="line">    history.push(key, &#123;&#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return (&lt;Menu onClick=&#123;onClick&#125;&gt; ··· &lt;/Menu&gt;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default CustomMenu;</span><br></pre></td></tr></table></figure></p>
<h2 id="output-jsonpFunctionn"><a href="#output-jsonpFunctionn" class="headerlink" title="output.jsonpFunctionn"></a>output.jsonpFunctionn</h2><p>  webpack5删除了该属性，替换为output.chunkLoadingGlobal。</p>
<p>  资料：<br>  <a href="https://www.zhihu.com/column/c_1250900868893462528" target="_blank" rel="noopener">微前端-知乎</a></p>
  <script>
    const oCanvas = document.getElementById("pic");
    const oPen = oCanvas.getContext('2d');
    oPen.textAlign = "left";
    oPen.textBaseLine = "hanging";
    oPen.fillStyle = "deeppink";
    oPen.font = '18px sans-serif';
    oPen.fillText("主应用", 30,50);
    oPen.fillText("···", 160,50);
    oPen.fillText("子应用1", 240,50);
    oPen.fillText("子应用2", 390,50);
    oPen.fillStyle = "green";
    oPen.fillText("父子应用更新globalState", 160,200);
    oPen.fillStyle = "blue";
    oPen.fillText("父应用初始化globalState", 160,320);
    oPen.fillStyle = "deeppink";
    oPen.font = '12px sans-serif';
    oPen.fillText("onGlobalStateChange", 0, 65);
    oPen.fillText("onGlobalStateChange", 210,65);
    oPen.fillText("onGlobalStateChange", 360,65);
    oPen.fillStyle = "green";
    oPen.fillText("setGlobalState", 220,215);
    oPen.fillText("↑", 260,160);
    oPen.fillText("更新", 280,160);
    oPen.fillStyle = "blue";
    oPen.fillText("initGlobalState", 220,335);
    oPen.fillText("↑", 260,295);
    oPen.fillText("初始化", 280,295);
    oPen.closePath();


    // oPen.fillText("Hello World!" , 70 ,50);
    // oPen.strokeText("Hello World!" , 320 ,50);

    const oQiankun = document.getElementById("qiankun");
    const oContext = oQiankun.getContext('2d');
    oContext.textAlign = "left";
    oContext.textBaseLine = "hanging";
    oContext.fillStyle = "orange";
    oContext.font = '30px sans-serif';
    oContext.fillText("微前端", 200, 230);
    oContext.fillStyle = "black";
    oContext.font = '20px sans-serif';
    oContext.fillText("js沙箱", 218, 40);
    oContext.fillText("样式隔离", 360, 100);
    oContext.fillText("HTML Entry", 380, 200);
    oContext.fillText("Config Entry", 350, 300);
    oContext.fillText("按需加载", 340, 390);
    oContext.fillText("公共依赖加载", 190, 450);
    oContext.fillText("预加载", 100, 390);
    oContext.fillText("父子应用通讯", 30, 300);
    oContext.fillText("子应用嵌套", 10, 200);
    oContext.fillText("子应用并行", 40, 100);


    const oDependencies = document.getElementById("dependencies");
    const oPen1 = oDependencies.getContext('2d');
    oPen1.textAlign = "left";
    oPen1.textBaseLine = "hanging";
    oContext.fillStyle = "orange";
    oPen1.font = '16px sans-serif';
    oPen1.fillText("主项目", 80, 20);
    oPen1.fillText("node_modules", 50, 45);
    oPen1.fillText("↓", 100, 100);
    oPen1.fillText("js", 130, 100);
    oPen1.fillText("主项目", 200, 20);
    oPen1.fillText("<script src='xxx.js' ignore>", 10, 150);
    oPen1.fillText("子项目", 380, 20);
    oPen1.fillText("node_modules", 350, 45);
    oPen1.fillText("↓", 400, 100);
    oPen1.fillText("js", 430, 100);
    oPen1.fillText("<script src='xxx.js' ignore>", 310, 150);
    oPen1.fillText("↘", 120, 200);
    oPen1.fillText("↙", 380, 200);
    oPen1.fillText("主 子共同运行时，取主。子独立运行时，取子。", 100, 250);
  </script>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/30/summer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lemon">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/background22.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/30/summer/" itemprop="url">summer</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-30T17:05:30+08:00">
                2021-03-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/框架/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、-搭建过程"><a href="#一、-搭建过程" class="headerlink" title="一、 搭建过程"></a>一、 搭建过程</h1><h2 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h2><ul>
<li><p>package.json<br>npm init初始化或者手动创建一个package.json。<br>因为暂时github总是无法访问，所以暂时不git init或者创建远程git仓库了。也不配置.gitignore文件了</p>
</li>
<li><p>README.md<br>touch 初始化或者手动创建一个README.md。</p>
</li>
<li><p>建立文件目录</p>
</li>
<li><p>配置webpack<br>webpack-cli init初始化或者手动创建webpack配置文件。<br>webpack –config ‘webpack配置文件’。<br><br></p>
</li>
</ul>
<h2 id="2-启动-server"><a href="#2-启动-server" class="headerlink" title="2. 启动 server"></a>2. 启动 server</h2><p>  可以直接使用内置的webpack-dev-server命令，也可以通过express搭建服务器。</p>
<h3 id="express"><a href="#express" class="headerlink" title="express"></a>express</h3><pre><code>npm install express --save-dev

start.js
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&quot;express&quot;);</span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">app.get(&apos;/&apos;, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(&apos;nodeJS服务器搭建成功！&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(8083, () =&gt; &#123;</span><br><span class="line">  console.log(&apos;Server is running at http://localhost:8083&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

执行node start.js，即可启动服务器。页面显示：&apos;nodeJS服务器搭建成功！&apos;。
</code></pre><h3 id="express-html模板-热重载热更新"><a href="#express-html模板-热重载热更新" class="headerlink" title="express+html模板+热重载热更新"></a>express+html模板+热重载热更新</h3><pre><code>npm install --save webpack
npm install --save-dev webpack-dev-middleware webpack-hot-middleware
npm install --save html-webpack-plugin

- webpack-dev-middleware 插件，该插件对更改的文件进行监控，编译。
- 一般和 webpack-hot-middleware[https://github.com/webpack-contrib/webpack-hot-middleware] 配合使用，实现热加载功能
- HtmlWebpackPlugin
HtmlWebpackPlugin 简化了 HTML 文件的创建，以便为你的 webpack 包提供服务。这对于那些文件名中包含哈希值，并且哈希值会随着每次编译而改变的 webpack 包特别有用。你可以让该插件为你生成一个 HTML 文件，使用 lodash 模板提供模板，或者使用你自己的 loader。


webpack配置：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const webpack = require(&apos;webpack&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: [&apos;webpack-hot-middleware/client?path=/__webpack_hmr&amp;timeout=20000&apos;, path.resolve(__dirname, &apos;../src/index.js&apos;)],</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;bundle.js&apos;,</span><br><span class="line">    path: path.resolve(__dirname, &apos;../dist&apos;),</span><br><span class="line">    publicPath: &apos;/&apos;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mode: &apos;development&apos;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      inject: true,</span><br><span class="line">      filename: &apos;index.html&apos;,</span><br><span class="line">      template: path.resolve(process.cwd(), &apos;public&apos;, &apos;index.html&apos;),</span><br><span class="line">    &#125;),</span><br><span class="line">    new webpack.HotModuleReplacementPlugin(),</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

start.js 配置
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&quot;express&quot;);</span><br><span class="line">const path = require(&quot;path&quot;);</span><br><span class="line">const webpack = require(&quot;webpack&quot;);</span><br><span class="line">const webpackConfig = require(&quot;../config/webpack.base.config&quot;);</span><br><span class="line">const webpackHotMiddleware = require(&quot;webpack-hot-middleware&quot;);</span><br><span class="line">const webpackDevMiddleware = require(&quot;webpack-dev-middleware&quot;);</span><br><span class="line"></span><br><span class="line">const compiler = webpack(webpackConfig);</span><br><span class="line">const middleware = webpackDevMiddleware(compiler, &#123;</span><br><span class="line">  //绑定中间件的公共路径,与webpack配置的路径相同</span><br><span class="line">  publicPath: webpackConfig.output.publicPath,</span><br><span class="line">&#125;);</span><br><span class="line">const app = express();</span><br><span class="line">const fs = middleware.context.outputFileSystem;</span><br><span class="line"></span><br><span class="line">app.use(middleware);</span><br><span class="line">app.use(webpackHotMiddleware(compiler));</span><br><span class="line">app.get(&apos;*&apos;, (req, res) =&gt; &#123;</span><br><span class="line">  fs.readFile(path.join(compiler.outputPath, &apos;index.html&apos;), (err, file) =&gt; &#123;</span><br><span class="line">    if (err) &#123;</span><br><span class="line">      res.sendStatus(404);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      res.send(file.toString());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(8083, () =&gt; &#123;</span><br><span class="line">  console.log(&apos;Server is running at http://localhost:8083&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

index.js
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import a from &apos;./containers/Demo/index.js&apos;;</span><br><span class="line"></span><br><span class="line">const handleTest = () =&gt; &#123;</span><br><span class="line">  console.log(&apos;a:&apos;, a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 开发模式下热加载</span><br><span class="line">if (module.hot) &#123;</span><br><span class="line">  module.hot.accept([&apos;./containers/Demo/index.js&apos;], function () &#123; </span><br><span class="line">    handleTest();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleTest();</span><br></pre></td></tr></table></figure>

node start.js或在package.json中配置script脚步命令（&quot;start&quot;: &quot;node scripts/start.js &quot;）。
</code></pre><p>  <br></p>
<h2 id="3-react-ts-antd"><a href="#3-react-ts-antd" class="headerlink" title="3.react + ts + antd"></a>3.react + ts + antd</h2><p>  npm install  -S  babel-loader thread-loader cache-loader<br>                  ts-loader css-loader style-loader url-loader<br>                  less less-loader typescript<br>                  @babel/preset-react  @babel/core</p>
<h3 id="react"><a href="#react" class="headerlink" title="react"></a>react</h3><h4 id="配置webpack"><a href="#配置webpack" class="headerlink" title="配置webpack"></a>配置webpack</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: /\.js$/,</span><br><span class="line">      exclude: /node_moduåles/,</span><br><span class="line">      use: [</span><br><span class="line">        &apos;cache-loader&apos;,</span><br><span class="line">        &apos;thread-loader&apos;,</span><br><span class="line">        &#123;</span><br><span class="line">          loader: &apos;babel-loader&apos;,</span><br><span class="line">          options: &#123;</span><br><span class="line">            cacheDirectory: true</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: /\.(ts|tsx)$/,</span><br><span class="line">      exclude: /node_modules/,</span><br><span class="line">      use: [</span><br><span class="line">        &apos;cache-loader&apos;,</span><br><span class="line">        &apos;thread-loader&apos;,</span><br><span class="line">        &#123;</span><br><span class="line">          loader: &apos;ts-loader&apos;,</span><br><span class="line">          options: &#123; transpileOnly: true, happyPackMode: true &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: /\.less$/,</span><br><span class="line">      exclude: /node_modules/,</span><br><span class="line">      use: [</span><br><span class="line">        &apos;style-loader&apos;,</span><br><span class="line">        &apos;css-loader&apos;,</span><br><span class="line">        &#123;</span><br><span class="line">          loader: &apos;less-loader&apos;,</span><br><span class="line">          options: &#123;</span><br><span class="line">            lessOptions: &#123;</span><br><span class="line">              javascriptEnabled: true,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: /\.css$/,</span><br><span class="line">      exclude: /node_modules/,</span><br><span class="line">      use: [</span><br><span class="line">        &apos;style-loader&apos;,</span><br><span class="line">        &apos;css-loader&apos;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: /\.(jpg|jpeg|png|gif|webp)$/,</span><br><span class="line">      exclude: /node_modules/,</span><br><span class="line">      use: [</span><br><span class="line">        &#123;</span><br><span class="line">          loader: &apos;url-loader&apos;,</span><br><span class="line">          options: &#123;</span><br><span class="line">            // Inline files smaller than 10 kB</span><br><span class="line">            limit: 10 * 1024,</span><br><span class="line">            name: &apos;static/assets/[name].[ext]&apos;,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="引入react"><a href="#引入react" class="headerlink" title="引入react"></a>引入react</h4><pre><code>index.js
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &apos;react&apos;;</span><br><span class="line">import * as ReactDOM from &apos;react-dom&apos;;</span><br><span class="line"></span><br><span class="line">import Main from &apos;./containers/Main&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const Render = ()  =&gt; &#123;</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    &lt;Main /&gt;,</span><br><span class="line">    document.getElementById(&apos;root&apos;),</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 开发模式下热加载</span><br><span class="line">if (module.hot) &#123;</span><br><span class="line">  module.hot.accept([&apos;./containers/Main&apos;], function () &#123; </span><br><span class="line">    Render();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Render();</span><br></pre></td></tr></table></figure>

src/containers/Main/index.js
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">const Main = () =&gt; &#123;</span><br><span class="line">  return (&lt;div&gt;Main&lt;/div&gt;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Main;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="typescript"><a href="#typescript" class="headerlink" title="typescript"></a>typescript</h3><p>  以上，我们已经引入了react，可以使用jsx语法。现在我们来尝试引入ts。</p>
<h4 id="1-webapck配置"><a href="#1-webapck配置" class="headerlink" title="1. webapck配置"></a>1. webapck配置</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: /\.(ts|tsx)$/,</span><br><span class="line">    exclude: /node_modules/,</span><br><span class="line">    use: [</span><br><span class="line">      &apos;cache-loader&apos;,</span><br><span class="line">      &apos;thread-loader&apos;,</span><br><span class="line">      &#123;</span><br><span class="line">        loader: &quot;ts-loader&quot;,</span><br><span class="line">        options: &#123; transpileOnly: true, happyPackMode: true &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

问题1：Could not find a declaration file for module &apos;react&apos;。
      Could not find a declaration file for module &apos;react-dom&apos;.
解决：npm install @types/react @types/react-dom --save-dev

问题2：Field &apos;browser&apos; doesn&apos;t contain a valid alias configuration。
webapck配置:尝试按顺序解析这些后缀名。如果有多个文件有相同的名字，但后缀名不同，webpack 会解析列在数组首位的后缀的文件 并跳过其余的后缀。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  extensions: [&quot;.tsx&quot;, &quot;.js&quot;, &quot;.jsx&quot;, &quot;.react.js&quot;, &quot;.ts&quot;, &quot;.json&quot;],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="2-tsconfig-json"><a href="#2-tsconfig-json" class="headerlink" title="2. tsconfig.json"></a>2. tsconfig.json</h4><pre><code>首先我们得装一个typescript，这就跟我们在用babel前需要先装一个babel-core是一个道理。
npx tsc --init生成tsconfig.json或手动创建。

报错：Cannot use JSX unless the &apos;--jsx&apos; flag is prodided.提示不能使用jsx的语法
解决：去tsconfig配置一下即可。
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;:&#123;</span><br><span class="line">    &quot;jsx&quot;: &quot;react&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

jsx这个配置项有三个值可选择，分别是&quot;preserve&quot;,&quot;react-native&quot;和&quot;react&quot;。在preserve和react-native模式下生成代码中会保留JSX以供后续的转换操作使用（比如：Babel）。另外，preserve输出文件会带有.jsx扩展名，而react-native是.js拓展名。react模式会生成React.createElement，在使用前不需要再进行转换操作了，输出文件的扩展名为.js。
</code></pre><table>
<thead>
<tr>
<th>模式</th>
<th>输入</th>
<th>输出</th>
<th>输出文件扩展名</th>
</tr>
</thead>
<tbody>
<tr>
<td>preserve</td>
<td>&lt; div /&gt;</td>
<td>&lt; div /&gt;</td>
<td>.jsx</td>
</tr>
<tr>
<td>react</td>
<td>&lt; div /&gt;</td>
<td>React.createElement(“div”)</td>
<td>.js</td>
</tr>
<tr>
<td>react-native</td>
<td>&lt; div /&gt;</td>
<td>&lt; div /&gt;</td>
<td>.js</td>
</tr>
</tbody>
</table>
<h3 id="antd-style-componets-样式管理"><a href="#antd-style-componets-样式管理" class="headerlink" title="antd + style-componets 样式管理"></a>antd + style-componets 样式管理</h3><h4 id="antd"><a href="#antd" class="headerlink" title="antd"></a>antd</h4><p>   npm install antd –save</p>
<p>   之后要引入antd的样式<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &apos;antd/dist/antd.css&apos;; // or &apos;antd/dist/antd.less&apos;</span><br><span class="line"></span><br><span class="line">此时遇到报错：</span><br><span class="line">引入的是css时: ERROR in ./node_modules/antd/dist/antd.css 13:6</span><br><span class="line">              Module parse failed: Unexpected token (13:6)</span><br><span class="line">引入的是less时: ERROR in ./node_modules/antd/dist/antd.less 1:0</span><br><span class="line">              Module parse failed: Unexpected character &apos;@&apos; (1:0)</span><br><span class="line"></span><br><span class="line">解决办法：在webpack中的css或less配置一个 include: /node_modules/即可。</span><br></pre></td></tr></table></figure></p>
<h4 id="style-componets"><a href="#style-componets" class="headerlink" title="style-componets"></a>style-componets</h4><p>   npm install -S styled-components</p>
<p><br></p>
<h2 id="4-状态管理"><a href="#4-状态管理" class="headerlink" title="4. 状态管理"></a>4. 状态管理</h2><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p>  redux-toolkit  + redux-saga<br>  Redux &amp; Mobx =&gt; Redux; 但是由于使用Redux样板代码过多，因此最终选用的是redux-toolkit，redux-toolkit只是对redux以及部分中间件进行进一步封装，并不是中间件也不是新的解决方案；</p>
<p>  npm i -S react-redux @reduxjs/toolkit redux-saga redux-injectors<br>  npm i -S whatwg-fetch qs</p>
<h3 id="公共状态"><a href="#公共状态" class="headerlink" title="公共状态"></a>公共状态</h3><pre><code>1. 公共状态指整个应用所共用的，一般有以下数据：
2. 全局状态标识：loading, Error, 初始化等状态；
3. 公共Layout状态；
4. 登录用户信息：基础信息等；
5. 路由数据；
6. 通用基础数据；
</code></pre><h3 id="数据取用"><a href="#数据取用" class="headerlink" title="数据取用"></a>数据取用</h3><p>  取数据使用的是<strong>reselect</strong>，数据的所有复合、计算也是在这一层进行，这使得我们能够在store中存储最原子、最简洁的数据，且reselect会进行数据缓存，如若关联数据没有变化不会再行计算。</p>
<p>  redux-toolkit也集成了reselect，鸡贼的直接导出了reselect的createSelector；</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// selectors.ts</span></span><br><span class="line"><span class="keyword">import</span> selectorsFactory <span class="keyword">from</span> <span class="string">'utils/selectorsFactory'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createSelector &#125; <span class="keyword">from</span> <span class="string">'@reduxjs/toolkit'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; NAMESPACE &#125; <span class="keyword">from</span> <span class="string">'./constants'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; initialState &#125; <span class="keyword">from</span> <span class="string">'./slice'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; IPageState &#125; <span class="keyword">from</span> <span class="string">'./types'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动生成一级数据的selector，使用selectors.name调用，如需要更进一步的计算再自行添加selector</span></span><br><span class="line"><span class="keyword">const</span> selectors = selectorsFactory&lt;IPageState&gt;(NAMESPACE, initialState);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如，需要单独Select modal的data，或者更进一步的计算某些数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> selectModalData = createSelector(</span><br><span class="line">  selectors.mainModal,</span><br><span class="line">  mainModal =&gt; mainModal.data,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> selectors;</span><br></pre></td></tr></table></figure>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Modal.tsx</span></span><br><span class="line"><span class="keyword">import</span> &#123; useDispatch, useSelector &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> selectors <span class="keyword">from</span> <span class="string">'../selectors'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MainModal</span>(<span class="params">props: InjectedIntlProps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dispatch = useDispatch();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> modalData = useSelector(selectors.mainModal);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  从示例代码中可以看到，为了减少样板代码，我们开发了selectorsFactory方法，用以自动生成一级selector，可以通过selectors.mainModal实现数据的取用，其实这也表示，我们期待更扁平的Store结构设计，并不提倡嵌套层次过多；</p>
<h2 id="5-路由-菜单-面包屑"><a href="#5-路由-菜单-面包屑" class="headerlink" title="5. 路由+菜单+面包屑"></a>5. 路由+菜单+面包屑</h2><p>  通过路由配置，自动寻找对应文件，动态加载。并且完成路由、菜单和面包屑三项的同步。</p>
<p>  我们的页面文件结构选择的是平铺的方式，这完全有利于上述方案的实施。嵌套的文件结构不利于扩展和更改，灵活性不够，所以推荐平铺。<br>  也就是页面间的父子、兄弟关系仅靠路由配置维护，而在文件层级上均为兄弟关系。</p>
<h3 id="路由-Loading-NotFoundPage"><a href="#路由-Loading-NotFoundPage" class="headerlink" title="路由 + Loading + NotFoundPage"></a>路由 + Loading + NotFoundPage</h3><p>  connected-react-router是一个绑定react-router到redux的组件，来实现双向绑定router的数据到redux store中，这么做的好处就是让应用更Redux化，可以在action中实现对路由的操作。</p>
<p>  npm i -S react-router react-router-dom  react-redux connected-react-router history react-router-cache-route</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &apos;react&apos;;</span><br><span class="line">import &#123; Router &#125; from &apos;react-router&apos;;</span><br><span class="line">import &#123; CacheRoute, CacheSwitch &#125; from &apos;react-router-cache-route&apos;;</span><br><span class="line">import &#123; createBrowserHistory &#125; from &apos;history&apos;;</span><br><span class="line"></span><br><span class="line">import menuData from &apos;configs/router.conf&apos;;    </span><br><span class="line"> </span><br><span class="line">const history = createBrowserHistory();</span><br><span class="line"></span><br><span class="line">function traversMenu(arr: IMenuDataItem[], keyPath: string[] = []) &#123;</span><br><span class="line">  let leafsArray: IMenuItem[] = [];</span><br><span class="line"></span><br><span class="line">  arr.forEach(item =&gt; &#123;</span><br><span class="line">    const newKeyPath = keyPath.concat([item.path]);</span><br><span class="line">    if (item.children) &#123;</span><br><span class="line">      if (item.exist) &#123;</span><br><span class="line">        leafsArray.push(&#123;</span><br><span class="line">          path: item.route,</span><br><span class="line">          componentName: item.componentName || `$&#123;item.path.substring(0, 1).toUpperCase()&#125;$&#123;item.path.substring(1)&#125;`,</span><br><span class="line">          isDetail: !!item.isDetail,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      leafsArray = leafsArray.concat(traversMenu(item.children, [...newKeyPath]));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      leafsArray.push(&#123;</span><br><span class="line">        path: item.route,</span><br><span class="line">        componentName: item.componentName || `$&#123;item.path.substring(0, 1).toUpperCase()&#125;$&#123;item.path.substring(1)&#125;`,</span><br><span class="line">        isDetail: !!item.isDetail,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  return leafsArray;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">function getLazyComponent(item: IMenuItem) &#123;</span><br><span class="line">  const comp = React.lazy(() =&gt; import(`../../containers/$&#123;item.componentName&#125;/index.tsx`).catch(err =&gt; &#123;</span><br><span class="line">    // 如果路径不存在，则降级为首页；</span><br><span class="line">    return import(&apos;../../containers/HomePage/index&apos;);</span><br><span class="line">  &#125;));</span><br><span class="line">  return comp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const pathToComponentArr = traversMenu(menuData, []);</span><br><span class="line">&lt;Router history=&#123;history&#125;&gt;</span><br><span class="line">  &lt;React.Suspense fallback=&#123;&lt;LoadingIndicator /&gt;&#125;&gt;</span><br><span class="line">    &lt;CacheSwitch&gt;</span><br><span class="line">      &lt;CacheRoute</span><br><span class="line">        exact</span><br><span class="line">        path=&quot;/&quot;</span><br><span class="line">        key=&quot;default&quot;</span><br><span class="line">        component=&#123;getLazyComponent(&#123;</span><br><span class="line">          path: &apos;../../containers/HomePage/index&apos;,</span><br><span class="line">          componentName: &apos;HomePage&apos;</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        pathToComponentArr.map((item: IMenuItem) =&gt; (</span><br><span class="line">          &lt;CacheRoute</span><br><span class="line">            exact</span><br><span class="line">            cacheKey=&#123;() =&gt; item.isDetail ? window.location.pathname + window.location.search : item.path&#125;</span><br><span class="line">            multiple=&#123;item.isDetail&#125;</span><br><span class="line">            key=&#123;item.path&#125;</span><br><span class="line">            className=&apos;main-content-wrap&apos;</span><br><span class="line">            path=&#123;item.isDetail ? `$&#123;item.path&#125;/:id` : item.path&#125;</span><br><span class="line">            component=&#123;getLazyComponent(item)&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        ))</span><br><span class="line">      &#125;</span><br><span class="line">      &lt;CacheRoute path=&quot;*&quot; component=&#123;NotFoundPage&#125; /&gt;</span><br><span class="line">    &lt;/CacheSwitch&gt;</span><br><span class="line">  &lt;/React.Suspense&gt;</span><br><span class="line">&lt;/Router&gt;</span><br></pre></td></tr></table></figure>
<h3 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h3><h3 id="面包屑"><a href="#面包屑" class="headerlink" title="面包屑"></a>面包屑</h3><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><h3 id="tabs"><a href="#tabs" class="headerlink" title="tabs"></a>tabs</h3><h3 id="ErrorBoundary"><a href="#ErrorBoundary" class="headerlink" title="ErrorBoundary"></a>ErrorBoundary</h3><h3 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a>eslint</h3><p>  <a href="https://eslint.org/docs/user-guide/getting-started" target="_blank" rel="noopener">eslint</a><br>  npm install eslint –save-dev<br>  npm eslint –init</p>
<p>  airbnb<br>  eslint-plugin-jsx-a11y<br>  eslint-plugin-import</p>
<h3 id="骨架屏"><a href="#骨架屏" class="headerlink" title="骨架屏"></a>骨架屏</h3><h3 id="react-dev-inspector"><a href="#react-dev-inspector" class="headerlink" title="react-dev-inspector"></a>react-dev-inspector</h3><h2 id="打包部署"><a href="#打包部署" class="headerlink" title="打包部署"></a>打包部署</h2><p>  1） 执行webpack命令<br>  2） webpack –config ‘webpack配置文件’。<br>  3） 配置script命令（”start”: “webpack –config ./config/webpack.base.config.js”），后执行</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/17/fq/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lemon">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/background22.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/17/fq/" itemprop="url">翻墙</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-17T20:19:55+08:00">
                2021-03-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/专题/" itemprop="url" rel="index">
                    <span itemprop="name">专题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ShadowscoksX + banwagong Server 翻墙：</p>
<ol>
<li>Shadowscoks可以在github中搜到，windows下载-win版，mac下载-X版。<br>（<a href="https://github.com/yangfeicheung/Shadowsocks-X/releases/）" target="_blank" rel="noopener">https://github.com/yangfeicheung/Shadowsocks-X/releases/）</a></li>
<li>购买服务器：可以在搬瓦工上购买<a href="https://bwh88.net/，根据需求购买。" target="_blank" rel="noopener">https://bwh88.net/，根据需求购买。</a></li>
<li>购买成功之后，查看Services-&gt;Login to KiwiVM Control Oanel -&gt;Root password modification获取密码。之后进行Shadowsocks配置即可。</li>
<li>114.34.187.46 29309 PeD593bsZMSM</li>
<li>144.34.191.186 28890 WPQbfuTpny5X</li>
<li>由于搬瓦工后台的shadowsocks的服务器配置被墙了，所以只能通过软件进行配置了，下载putty，（<a href="https://www.ttrar.com/mac/soft/1295.html）" target="_blank" rel="noopener">https://www.ttrar.com/mac/soft/1295.html）</a></li>
</ol>
<p>下载putty：<a href="http://pan.baidu.com/s/1jI0T5Fw或者直接在百度搜putty下载解压运行putty.exe，" target="_blank" rel="noopener">http://pan.baidu.com/s/1jI0T5Fw或者直接在百度搜putty下载解压运行putty.exe，</a></p>
<ol start="7">
<li><p>填入刚才查到的主机地址和端口号，前面图中有介绍。<br>如果这里有对话框弹出，选择是，然后在全黑的屏幕上输入 root ，回车。等五秒，按提示输入root的密码，密码就是前面刚刚重置的root密码。<br>copy你的密码，粘贴至putty（粘贴方式为单击鼠标右键，只需要右键单击一次，这里不会显示任何内容，其实是已经输入了），回车。<br>SSR脚本安装正式开始，等到出现root@host~字样，复制下面脚本第1条命令，回车：<br>脚本命令1：wget –no-check-certificate -O shadowsocks-all.sh <a href="https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh" target="_blank" rel="noopener">https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh</a><br>（备注：国外服务器运行脚本时容易出错，如出现错误提示 bash: wget: command not found，可以请先执行 yum -y install wget 命令。成功后，再执行上面的命令。如果没提示错误，请略过）</p>
</li>
<li><p>等出现了上图显示后，输入第2条脚本命令，回车：<br>脚本命令2：chmod +x shadowsocks-all.sh</p>
</li>
<li><p>等出现了上图显示后，输入第3条脚本命令，回车：<br>脚本命令3：./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log</p>
<p>出现以上画面，根据需要选择，不懂的话直接选1，或者默认回车</p>
</li>
<li><p>下面会提示你输入你的SS SERVER的密码，和端口。不输入就是默认。跑完命令后会出来你的SS客户端的信息。</p>
<p>输入后，回车！</p>
<p>特别注意，由于iphone端的的wingy目前只支持到cfb，所以我们选择aes-256-cfb，即7 ，回车</p>
<p>这一步按回车继续，然后需要几分钟的安装过程，请耐心等待出现下面的画面！</p>
</li>
<li><p>请立即copy下来加以保存。上面的命令全部回车执行后，如果没有报错，即为执行成功，出现确认提示的时候，输入 y 后，回车即可。安装完成后，脚本提示如下：<br>Congratulations, Shadowsocks-Python server install completed!<br>Your Server IP : IP地址<br>Your Server Port : 端口<br>Your Password : 密码<br>Your Encryption Method: aes-256-gcm<br>Your QR Code: (For Shadowsocks Windows, OSX, Android and iOS clients)<br>ss://YWVzLTsadsa206YnVkZHkyMDA4QDEwNC4yMjQuMTM1Ldfghdfgk=<br>Your QR Code has been saved as a PNG file path:<br>/root/shadowsocks_python_qr.png<br>Welcome to visit: <a href="https://teddysun.com/486.html" target="_blank" rel="noopener">https://teddysun.com/486.html</a><br>Enjoy it!</p>
<p>Starting Shadowsocks success</p>
<p>记录保存好你的上述信息：Server IP、Server Port、Password、Encryption Method<br>这时你的专属ss已经搭好了，开始使用吧。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/03/webpack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lemon">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/background22.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/03/webpack/" itemprop="url">webpack</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-03T16:12:35+08:00">
                2021-03-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/基础/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="文档学习"><a href="#文档学习" class="headerlink" title="文档学习"></a><font color="#b300b2">文档学习</font></h1><p>打包工具。当 webpack 处理应用程序时，会在内部构建一个依赖图，此依赖图对应映射到项目所需的每个模块，并生成一个或多个bundle。<br>核心概念：entry、output、loader、plugin、mode、浏览器兼容性(browser compatibility)、environment。</p>
<h2 id="入口起点（entry-points）"><a href="#入口起点（entry-points）" class="headerlink" title="入口起点（entry points）"></a>入口起点（entry points）</h2><p>  入口是配置webpack构建内部依赖图的起点模块。</p>
<p>  用法：entry: string | [string] | 对象语法</p>
<p>  动态加载的模块 不是 入口起点。<br>  简单规则：每个 HTML 页面都有一个入口起点。单页应用(SPA)：一个入口起点，多页应用(MPA)：多个入口起点。</p>
<p>  <strong>Naming</strong><br>  如果传入一个字符串或字符串数组，chunk 会被命名为 main。如果传入一个对象，则每个属性的键(key)会是 chunk 的名称，该属性的值描述了 chunk 的入口点。</p>
<h2 id="输出（output）"><a href="#输出（output）" class="headerlink" title="输出（output）"></a>输出（output）</h2><p>  output属性是配置webpack打包后的文件名称及存放位置。</p>
<h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>  webpack本身只能解析js和json文件。<br>  loader可以让webpack能够解析其他类型的文件，并将它们转换为有效的模块，以供程序员使用，并将其添加到依赖图中。<br>  test定义识别哪种类型的文件，use定义使用哪些loader去解析这种类型的文件。</p>
<p>  <strong>三种使用 loader 的方式：</strong><br>  配置方式（推荐）：在 webpack.config.js 文件中指定 loader。<br>  内联方式：在每个 import 语句中显式指定 loader。<br>  CLI 方式：在 shell 命令中指定它们。</p>
<p>  <strong>loader 特性：</strong><br>  loader 支持链式调用。链中的每个 loader 会将转换应用在已处理过的资源上。一组链式的 loader 将按照相反的顺序执行。链中的第一个 loader 将其结果（也就是应用过转换后的资源）传递给下一个 loader，依此类推。最后，链中的最后一个 loader，返回 webpack 所期望的 JavaScript。<br>  loader 可以是同步的，也可以是异步的。<br>  loader 运行在 Node.js 中，并且能够执行任何操作。<br>  loader 可以通过 options 对象配置（仍然支持使用 query 参数来设置选项，但是这种方式已被废弃）。<br>  除了常见的通过 package.json 的 main 来将一个 npm 模块导出为 loader，还可以在 module.rules 中使用 loader 字段直接引用一个模块。<br>  插件(plugin)可以为 loader 带来更多特性。<br>  loader 能够产生额外的任意文件。</p>
<h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h2><p>  loader用于转换某种类型的文件，plugin则用来执行更广泛的任务，如：注入环境变量、资源管理、打包优化等。</p>
<p>  插件目的在于解决 loader 无法实现的其他事。</p>
<p>  用法：</p>
<ul>
<li>配置方式（webpack.config.js）</li>
<li>Node API 方式</li>
</ul>
<h2 id="配置（Configuration）"><a href="#配置（Configuration）" class="headerlink" title="配置（Configuration）"></a>配置（Configuration）</h2><h2 id="模块（Modules）"><a href="#模块（Modules）" class="headerlink" title="模块（Modules）"></a>模块（Modules）</h2><p>  webpack 提供了可定制，强大且丰富的 API，允许在 任何技术栈 中使用，同时支持在开发、测试和生产环境的工作流中做到 无侵入性。</p>
<p>  与 Node.js 模块相比，webpack _模块_能以各种方式表达它们的依赖关系。下面是一些示例：</p>
<ul>
<li>ES2015 import 语句</li>
<li>CommonJS require() 语句</li>
<li>AMD define 和 require 语句</li>
<li>css/sass/less 文件中的 @import 语句。</li>
<li>stylesheet url(…) 或者 HTML &lt; img src=…&gt; 文件中的图片链接。</li>
</ul>
<p>  webpack 天生支持如下模块类型：</p>
<ul>
<li>ECMAScript 模块</li>
<li>CommonJS 模块</li>
<li>AMD 模块</li>
<li>Assets</li>
<li>WebAssembly 模块</li>
</ul>
<p>  通过 loader 可以使 webpack 支持多种语言和预处理器语法编写的模块。loader 向 webpack 描述了如何处理非原生模块，并将相关依赖引入到你的 bundles中。 webpack 社区已经为各种流行的语言和预处理器创建了 loader，其中包括：</p>
<ul>
<li>CoffeeScript</li>
<li>TypeScript</li>
<li>ESNext (Babel)</li>
<li>Sass</li>
<li>Less</li>
<li>Stylus</li>
<li>Elm</li>
</ul>
<h2 id="模块解析（Module-Resolution）"><a href="#模块解析（Module-Resolution）" class="headerlink" title="模块解析（Module Resolution）"></a>模块解析（Module Resolution）</h2><p>  resolver 是一个帮助寻找模块绝对路径的库。</p>
<p>  使用 enhanced-resolve，webpack 能解析三种文件路径：</p>
<ul>
<li>绝对路径 </li>
<li>相对路径 </li>
<li><p>模块路径<br>在 resolve.modules 中指定的所有目录检索模块。<br>在 resolve.alias 置别名</p>
<p>一旦根据上述规则解析路径后，resolver 将会检查路径是指向文件还是文件夹。<br>如果路径指向文件：</p>
<ul>
<li>如果文件具有扩展名，则直接将文件打包。</li>
<li>否则，将使用 resolve.extensions 选项作为文件扩展名来解析，此选项会告诉解析器在解析中能够接受哪些扩展名（例如 .js，.jsx）。</li>
</ul>
<p>如果路径指向一个文件夹，则进行如下步骤寻找具有正确扩展名的文件：</p>
<ul>
<li>如果文件夹中包含 package.json 文件，则会根据 resolve.mainFields 配置中的字段顺序查找，并根据 package.json 中的符合配置要求的第一个字段来确定文件路径。<br>如果不存在 package.json 文件或 resolve.mainFields 没有返回有效路径，则会根据 resolve.mainFiles 配置选项中指定的文件名顺序查找，看是否能在 import/require 的目录下匹配到一个存在的文件名。<br>然后使用 resolve.extensions 选项，以类似的方式解析文件扩展名。</li>
</ul>
</li>
</ul>
<h2 id="Module-Federation"><a href="#Module-Federation" class="headerlink" title="Module Federation"></a>Module Federation</h2><h2 id="依赖图-dependency-graph"><a href="#依赖图-dependency-graph" class="headerlink" title="依赖图(dependency graph)"></a>依赖图(dependency graph)</h2><h2 id="target"><a href="#target" class="headerlink" title="target"></a>target</h2><h2 id="manifest"><a href="#manifest" class="headerlink" title="manifest"></a>manifest</h2><h2 id="模块热替换（Module-Hot-Replacement）"><a href="#模块热替换（Module-Hot-Replacement）" class="headerlink" title="模块热替换（Module Hot Replacement）"></a>模块热替换（Module Hot Replacement）</h2><h2 id="为什么选择webpack"><a href="#为什么选择webpack" class="headerlink" title="为什么选择webpack"></a>为什么选择webpack</h2><p>  想要理解为什么要使用 webpack，我们先回顾下历史，在打包工具出现之前，我们是如何在 web 中使用 JavaScript 的。<br>  在浏览器中运行 JavaScript 有两种方法。第一种方式，引用一些脚本来存放每个功能；此解决方案很难扩展，因为加载太多脚本会导致网络瓶颈。第二种方式，使用一个包含所有项目代码的大型 .js 文件，但是这会导致作用域、文件大小、可读性和可维护性方面的问题。</p>
<p>  <font color="#ff4d4d"><strong>立即调用函数表达式(IIFE) - Immediately invoked function expressions</strong></font><br>  IIFE 解决大型项目的作用域问题；当脚本文件被封装在 IIFE 内部时，你可以安全地拼接或安全地组合所有文件，而不必担心作用域冲突。<br>  IIFE 使用方式产生出 Make, Gulp, Grunt, Broccoli 或 Brunch 等工具。这些工具称为任务执行器，它们将所有项目文件拼接在一起。<br>  但是，修改一个文件意味着必须重新构建整个文件。拼接可以做到很容易地跨文件重用脚本，但是却使构建结果的优化变得更加困难。如何判断代码是否实际被使用？<br>  即使你只用到 lodash 中的某个函数，也必须在构建结果中加入整个库，然后将它们压缩在一起。如何 treeshake 代码依赖？难以大规模地实现延迟加载代码块，这需要开发人员手动地进行大量工作。</p>
<p>  <font color="#ff4d4d"><strong>感谢 Node.js，JavaScript 模块诞生了</strong></font><br>  Node.js 是一个 JavaScript 运行时，可以在浏览器环境之外的计算机和服务器中使用。webpack 运行在 Node.js 中。<br>  当 Node.js 发布时，一个新的时代开始了，它带来了新的挑战。既然不是在浏览器中运行 JavaScript，现在已经没有了可以添加到浏览器中的 html 文件和 script 标签。那么 Node.js 应用程序要如何加载新的代码 chunk 呢？<br>  CommonJS 问世并引入了 require 机制，它允许你在当前文件中加载和使用某个模块。导入需要的每个模块，这一开箱即用的功能，帮助我们解决了作用域问题。</p>
<p>  <font color="#ff4d4d"><strong>npm + Node.js + modules - 大规模分发模块 </strong></font><br>  JavaScript 已经成为一种语言、一个平台和一种快速开发和创建快速应用程序的方式，接管了整个 JavaScript 世界。<br>  但 CommonJS 没有浏览器支持。没有 live binding(实时绑定)。循环引用存在问题。同步执行的模块解析加载器速度很慢。虽然 CommonJS 是 Node.js 项目的绝佳解决方案，但浏览器不支持模块，因而产生了 Browserify, RequireJS 和 SystemJS 等打包工具，允许我们编写能够在浏览器中运行的 CommonJS 模块。</p>
<p>  <font color="#ff4d4d"><strong>ESM - ECMAScript 模块</strong></font><br>  来自 Web 项目的好消息是，模块正在成为 ECMAScript 标准的官方功能。然而，浏览器支持不完整，版本迭代速度也不够快，目前还是推荐上面那些早期模块实现。</p>
<p>  <font color="#ff4d4d"><strong>依赖自动收</strong></font><br>  传统的任务构建工具基于 Google 的 Closure 编译器都要求你手动在顶部声明所有的依赖。然而像 webpack 一类的打包工具自动构建并基于你所引用或导出的内容推断出依赖的图谱。这个特性与其它的如插件 and 加载器一道让开发者的体验更好。</p>
<p>  <font color="#ff4d4d"><strong>看起来都不是很好……</strong> </font><br>  是否可以有一种方式，不仅可以让我们编写模块，而且还支持任何模块格式（至少在我们到达 ESM 之前），并且可以同时处理资源和资产？</p>
<p>  这就是 webpack 存在的原因。它是一个工具，可以打包你的 JavaScript 应用程序（支持 ESM 和 CommonJS），可以扩展为支持许多不同的资产，例如：images, fonts 和 stylesheets。</p>
<p>  webpack 关心性能和加载时间；它始终在改进或添加新功能，例如：异步地加载 chunk 和预取，以便为你的项目和用户提供最佳体验。</p>
<h2 id="揭示内部原理"><a href="#揭示内部原理" class="headerlink" title="揭示内部原理"></a>揭示内部原理</h2><p>  打包，是指处理某些文件并将其输出为某些文件的能力。<br>  但是在输入和输出之间，还存在着模块、入口起点、chunk、chunk组和许多其他中间部分。</p>
<p>  <strong>主要部分</strong><br>  项目中使用的每个文件都是一个模块。</p>
<p>  通过相互引用，这些模块会形成一个图（ModuleGraph）数据结构。<br>  在打包的过程中，文件会被合并成chunk。chunk合并成chunk组，并形成一个通过模块连接的图（ModuleGraph）。</p>
<h1 id="API"><a href="#API" class="headerlink" title="API"></a><font color="#b300b2">API</font></h1><h2 id="命令行接口（CLI）"><a href="#命令行接口（CLI）" class="headerlink" title="命令行接口（CLI）"></a>命令行接口（CLI）</h2><p>   CLI中传入的任何参数会在配置文件中映射为对应的参数。</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a><font color="#b300b2">配置</font></h1><h2 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h2><p>  development    会将 DefinePlugin 中 process.env.NODE_ENV 的值设置为 development。<br>  production    会将 DefinePlugin 中 process.env.NODE_ENV 的值设置为 production。<br>  none    不使用任何默认优化选项</p>
<h1 id="question"><a href="#question" class="headerlink" title="question"></a><font color="#b300b2">question</font></h1><h2 id="loader和plugin的区别"><a href="#loader和plugin的区别" class="headerlink" title="loader和plugin的区别"></a>loader和plugin的区别</h2><pre><code>loader 模块转换器 （less-&gt;css）
plugin 是扩展插件，如HtmlWebpackPlugin

常见的loader和plugin有哪些？
Loader:
babel-loader：把 ES6 转换成 ES5
css-loader：加载 CSS，支持模块化、压缩、文件导入等特性
style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。
file-loader (png|jpg|jpeg|gif) 开发
url-loader, 生产
vue-loader

Plugin:
IgnorePlugin 避免引入无用模块
HotModuleReplacementPlugin 热更新
define-plugin：定义环境变量
commons-chunk-plugin：提取公共代码
uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/background22.jpg" alt="Lemon">
            
              <p class="site-author-name" itemprop="name">Lemon</p>
              <p class="site-description motion-element" itemprop="description">乘风破浪</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lemon</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
