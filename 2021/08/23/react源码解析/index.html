<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="React,">










<meta name="description" content="一、前言我们每天都在使用react，但是对于react的实现原理却不一定知其所以然。  于是我们打开react包（17.0.2），发现，咦，为什么只有3000多行代码❓  很快，我们就会意识到，原来是分包了（2015-10），还有react-dom（17.0.2），一打开，26000多行，哦哦，对的。  因为react不止针对web了，还有移动端（react-native），所以就分包了。reac">
<meta name="keywords" content="React">
<meta property="og:type" content="article">
<meta property="og:title" content="react源码解析">
<meta property="og:url" content="http://yoursite.com/2021/08/23/react源码解析/index.html">
<meta property="og:site_name" content="小寒">
<meta property="og:description" content="一、前言我们每天都在使用react，但是对于react的实现原理却不一定知其所以然。  于是我们打开react包（17.0.2），发现，咦，为什么只有3000多行代码❓  很快，我们就会意识到，原来是分包了（2015-10），还有react-dom（17.0.2），一打开，26000多行，哦哦，对的。  因为react不止针对web了，还有移动端（react-native），所以就分包了。reac">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/f81d27cf172e1ea3718b9d54cdf8e307.png">
<meta property="og:updated_time" content="2021-12-09T11:54:43.928Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="react源码解析">
<meta name="twitter:description" content="一、前言我们每天都在使用react，但是对于react的实现原理却不一定知其所以然。  于是我们打开react包（17.0.2），发现，咦，为什么只有3000多行代码❓  很快，我们就会意识到，原来是分包了（2015-10），还有react-dom（17.0.2），一打开，26000多行，哦哦，对的。  因为react不止针对web了，还有移动端（react-native），所以就分包了。reac">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/img_convert/f81d27cf172e1ea3718b9d54cdf8e307.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/08/23/react源码解析/">





  <title>react源码解析 | 小寒</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小寒</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-窝">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            窝
          </a>
        </li>
      
        
        <li class="menu-item menu-item-类">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-档">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-于">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/23/react源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lemon">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/background22.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">react源码解析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-23T15:00:59+08:00">
                2021-08-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/框架/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><pre><code>我们每天都在使用react，但是对于react的实现原理却不一定知其所以然。

于是我们打开react包（17.0.2），发现，咦，为什么只有3000多行代码❓

很快，我们就会意识到，原来是分包了（2015-10），还有react-dom（17.0.2），一打开，26000多行，哦哦，对的。

因为react不止针对web了，还有移动端（react-native），所以就分包了。react实现主干逻辑，react-dom针对 dom 的平台实现，主要用于在 web 端进行渲染。

3000+26000多行代码，令人头大，不管了，🔥 热情来了，说干就干。就从最眼熟的开始（ReactDOM.render）下手，杀熟 😎。就问你这 🍉 保熟吗？。
</code></pre><h2 id="直接看源码"><a href="#直接看源码" class="headerlink" title="直接看源码"></a>直接看源码</h2><h3 id="ReactDOM-render"><a href="#ReactDOM-render" class="headerlink" title="ReactDOM.render"></a>ReactDOM.render</h3><pre><code>尽量乱中有序。
我们一点一点看，首先，整体来看ReactDOM，最外层是一个立即执行函数iife，写源码或者写jquery的时候，一般都是用iife的模块化方式。（当时的想法）
</code></pre><p>  <code>(function (a, b) {……}(c, d))</code></p>
<pre><code>借着细看，这个立即函数有两个参数，一个对象，一个函数。立即函数的内容是判断多种条件下，给参数函数传参后执行。
</code></pre>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">global, factory</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">typeof</span> exports === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span> !== <span class="string">'undefined'</span> ? factory(exports, <span class="built_in">require</span>(<span class="string">'react'</span>)) :</span><br><span class="line">  <span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd ? define([<span class="string">'exports'</span>, <span class="string">'react'</span>], factory) :</span><br><span class="line">  (global = global || self, factory(global.ReactDOM = &#123;&#125;, global.React));</span><br><span class="line">&#125;(<span class="keyword">this</span>, (<span class="function"><span class="keyword">function</span> (<span class="params">exports, React</span>) </span>&#123; </span><br><span class="line">  ...</span><br><span class="line">  exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;</span><br><span class="line">  exports.createPortal = createPortal$<span class="number">1</span>;</span><br><span class="line">  exports.findDOMNode = findDOMNode;</span><br><span class="line">  exports.flushSync = flushSync;</span><br><span class="line">  exports.hydrate = hydrate;</span><br><span class="line">  exports.render = render;</span><br><span class="line">  exports.unmountComponentAtNode = unmountComponentAtNode;</span><br><span class="line">  exports.unstable_batchedUpdates = batchedUpdates$<span class="number">1</span>;</span><br><span class="line">  exports.unstable_createPortal = unstable_createPortal;</span><br><span class="line">  exports.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;</span><br><span class="line">  exports.version = ReactVersion;</span><br><span class="line">&#125;)));</span><br></pre></td></tr></table></figure>
<pre><code>看到这段代码，我们好像知道点啥，但是又说不清。不管可，先关心主要问题，看看 ReactDOM.render 到底做了什么。于是梳理了两遍，写了3页笔记。。。

只是大抵看了调用关系，但是并没有搞清楚每一行代码，因为真的是太多了（看我的3页笔记），真要靠光看源码去看懂框架，真的是需要投入大量的时间。甚至仅通过查看代码的方法很难真正理解react。

不过也不要太灰心，看了一遍，多多少少还是有点收获的，先记录一下这点可怜的收获：
</code></pre><h4 id="1、ReactDOM-render"><a href="#1、ReactDOM-render" class="headerlink" title="1、ReactDOM.render"></a>1、ReactDOM.render</h4><pre><code>整体来看，先返回了一个FiberRootNode，FiberRootNode上绑定了所有支持的事件，之后执行了updateContainer。

updateContainer里，我们还能看到createUpdate创建更新，enqueueUpdate排序标记更新优先级，scheduleUpdateOnFiber调度更新到Fiber上，以及commit阶段提交优先级，这里还能看到一些时间（expirationTime）的计算。

具体来看：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM = &#123;</span><br><span class="line">  render(</span><br><span class="line">    element: React$Element&lt;any&gt;,</span><br><span class="line">    container: DOMContainer,</span><br><span class="line">    callback: ?Function,</span><br><span class="line">  ) &#123;</span><br><span class="line">    return legacyRenderSubtreeIntoContainer(</span><br><span class="line">      null,</span><br><span class="line">      element,</span><br><span class="line">      container,</span><br><span class="line">      false,</span><br><span class="line">      callback,</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 首先会创建ReactRoot对象，然后调用他的render方法</span><br><span class="line"># 创建ReactRoot的时候会调用DOMRenderer.createContainer创建FiberRoot，在后期调度更新的过程中这个节点非常重要</span><br><span class="line"></span><br><span class="line">function legacyRenderSubtreeIntoContainer(</span><br><span class="line">  parentComponent: ?React$Component&lt;any, any&gt;,</span><br><span class="line">  children: ReactNodeList,</span><br><span class="line">  container: DOMContainer,</span><br><span class="line">  forceHydrate: boolean,</span><br><span class="line">  callback: ?Function,</span><br><span class="line">) &#123;</span><br><span class="line">  var root = container._reactRootContainer;</span><br><span class="line">  var fiberRoot;</span><br><span class="line"></span><br><span class="line">  if (!root) &#123;</span><br><span class="line">    // Initial mount</span><br><span class="line">    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate);</span><br><span class="line">    fiberRoot = root._internalRoot;</span><br><span class="line"></span><br><span class="line">    if (typeof callback === &apos;function&apos;) &#123;</span><br><span class="line">      var originalCallback = callback;</span><br><span class="line"></span><br><span class="line">      callback = function () &#123;</span><br><span class="line">        var instance = getPublicRootInstance(fiberRoot);</span><br><span class="line">        originalCallback.call(instance);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125; // Initial mount should not be batched.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    unbatchedUpdates(function () &#123;</span><br><span class="line">      updateContainer(children, fiberRoot, parentComponent, callback);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    fiberRoot = root._internalRoot;</span><br><span class="line"></span><br><span class="line">    if (typeof callback === &apos;function&apos;) &#123;</span><br><span class="line">      var _originalCallback = callback;</span><br><span class="line"></span><br><span class="line">      callback = function () &#123;</span><br><span class="line">        var instance = getPublicRootInstance(fiberRoot);</span><br><span class="line"></span><br><span class="line">        _originalCallback.call(instance);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125; // Update</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    updateContainer(children, fiberRoot, parentComponent, callback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return getPublicRootInstance(fiberRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function legacyCreateRootFromDOMContainer(</span><br><span class="line">  container: DOMContainer,</span><br><span class="line">  forceHydrate: boolean,</span><br><span class="line">): Root &#123;</span><br><span class="line">  var shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container); // First clear any existing content.</span><br><span class="line"></span><br><span class="line">  if (!shouldHydrate) &#123;</span><br><span class="line">    var warned = false;</span><br><span class="line">    var rootSibling;</span><br><span class="line"></span><br><span class="line">    while (rootSibling = container.lastChild) &#123;</span><br><span class="line">      &#123;</span><br><span class="line">        if (!warned &amp;&amp; rootSibling.nodeType === ELEMENT_NODE &amp;&amp; rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) &#123;</span><br><span class="line">          warned = true;</span><br><span class="line"></span><br><span class="line">          error(&apos;render(): Target node has markup rendered by React, but there &apos; + &apos;are unrelated nodes as well. This is most commonly caused by &apos; + &apos;white-space inserted around server-rendered markup.&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      container.removeChild(rootSibling);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    if (shouldHydrate &amp;&amp; !forceHydrate &amp;&amp; !warnedAboutHydrateAPI) &#123;</span><br><span class="line">      warnedAboutHydrateAPI = true;</span><br><span class="line"></span><br><span class="line">      warn(&apos;render(): Calling ReactDOM.render() to hydrate server-rendered markup &apos; + &apos;will stop working in React v18. Replace the ReactDOM.render() call &apos; + &apos;with ReactDOM.hydrate() if you want React to attach to the server HTML.&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return new ReactDOMBlockingRoot(container, LegacyRoot, options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ReactDOMBlockingRoot(container, tag, options) &#123;</span><br><span class="line">  this._internalRoot = createRootImpl(container, tag, options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOMRoot.prototype.render = ReactDOMBlockingRoot.prototype.render = function (children) &#123;</span><br><span class="line">  var root = this._internalRoot;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    if (typeof arguments[1] === &apos;function&apos;) &#123;</span><br><span class="line">      error(&apos;render(...): does not support the second callback argument. &apos; + &apos;To execute a side effect after rendering, declare it in a component body with useEffect().&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var container = root.containerInfo;</span><br><span class="line"></span><br><span class="line">    if (container.nodeType !== COMMENT_NODE) &#123;</span><br><span class="line">      var hostInstance = findHostInstanceWithNoPortals(root.current);</span><br><span class="line"></span><br><span class="line">      if (hostInstance) &#123;</span><br><span class="line">        if (hostInstance.parentNode !== container) &#123;</span><br><span class="line">          error(&apos;render(...): It looks like the React-rendered content of the &apos; + &apos;root container was removed without using React. This is not &apos; + &apos;supported and will cause errors. Instead, call &apos; + &quot;root.unmount() to empty a root&apos;s container.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  updateContainer(children, root, null, null);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ReactDOMRoot.prototype.unmount = ReactDOMBlockingRoot.prototype.unmount = function () &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    if (typeof arguments[0] === &apos;function&apos;) &#123;</span><br><span class="line">      error(&apos;unmount(...): does not support a callback argument. &apos; + &apos;To execute a side effect after rendering, declare it in a component body with useEffect().&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var root = this._internalRoot;</span><br><span class="line">  var container = root.containerInfo;</span><br><span class="line">  updateContainer(null, root, null, function () &#123;</span><br><span class="line">    unmarkContainerAsRoot(container);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function createRootImpl(container, tag, options) &#123;</span><br><span class="line">  // Tag is either LegacyRoot or Concurrent Root</span><br><span class="line">  var hydrate = options != null &amp;&amp; options.hydrate === true;</span><br><span class="line">  var hydrationCallbacks = options != null &amp;&amp; options.hydrationOptions || null;</span><br><span class="line">  var mutableSources = options != null &amp;&amp; options.hydrationOptions != null &amp;&amp; options.hydrationOptions.mutableSources || null;</span><br><span class="line">  var root = createContainer(container, tag, hydrate);</span><br><span class="line">  markContainerAsRoot(root.current, container);</span><br><span class="line">  var containerNodeType = container.nodeType;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;</span><br><span class="line">    listenToAllSupportedEvents(rootContainerElement);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (mutableSources) &#123;</span><br><span class="line">    for (var i = 0; i &lt; mutableSources.length; i++) &#123;</span><br><span class="line">      var mutableSource = mutableSources[i];</span><br><span class="line">      registerMutableSourceForHydration(root, mutableSource);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createContainer(containerInfo, tag, hydrate, hydrationCallbacks) &#123;</span><br><span class="line">  return createFiberRoot(containerInfo, tag, hydrate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks) &#123;</span><br><span class="line">  var root = new FiberRootNode(containerInfo, tag, hydrate);</span><br><span class="line">  // stateNode is any.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  var uninitializedFiber = createHostRootFiber(tag);</span><br><span class="line">  root.current = uninitializedFiber;</span><br><span class="line">  uninitializedFiber.stateNode = root;</span><br><span class="line">  initializeUpdateQueue(uninitializedFiber);</span><br><span class="line">  return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function FiberRootNode(containerInfo, tag, hydrate) &#123;</span><br><span class="line">  this.tag = tag;</span><br><span class="line">  this.containerInfo = containerInfo;</span><br><span class="line">  this.pendingChildren = null;</span><br><span class="line">  this.current = null;</span><br><span class="line">  this.pingCache = null;</span><br><span class="line">  this.finishedWork = null;</span><br><span class="line">  this.timeoutHandle = noTimeout;</span><br><span class="line">  this.context = null;</span><br><span class="line">  this.pendingContext = null;</span><br><span class="line">  this.hydrate = hydrate;</span><br><span class="line">  this.callbackNode = null;</span><br><span class="line">  this.callbackPriority = NoLanePriority;</span><br><span class="line">  this.eventTimes = createLaneMap(NoLanes);</span><br><span class="line">  this.expirationTimes = createLaneMap(NoTimestamp);</span><br><span class="line">  this.pendingLanes = NoLanes;</span><br><span class="line">  this.suspendedLanes = NoLanes;</span><br><span class="line">  this.pingedLanes = NoLanes;</span><br><span class="line">  this.expiredLanes = NoLanes;</span><br><span class="line">  this.mutableReadLanes = NoLanes;</span><br><span class="line">  this.finishedLanes = NoLanes;</span><br><span class="line">  this.entangledLanes = NoLanes;</span><br><span class="line">  this.entanglements = createLaneMap(NoLanes);</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    this.mutableSourceEagerHydrationData = null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    this.interactionThreadID = unstable_getThreadID();</span><br><span class="line">    this.memoizedInteractions = new Set();</span><br><span class="line">    this.pendingInteractionMap = new Map();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    switch (tag) &#123;</span><br><span class="line">      case BlockingRoot:</span><br><span class="line">        this._debugRootType = &apos;createBlockingRoot()&apos;;</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">      case ConcurrentRoot:</span><br><span class="line">        this._debugRootType = &apos;createRoot()&apos;;</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">      case LegacyRoot:</span><br><span class="line">        this._debugRootType = &apos;createLegacyRoot()&apos;;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function listenToAllSupportedEvents(rootContainerElement) &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    if (rootContainerElement[listeningMarker]) &#123;</span><br><span class="line">      // Performance optimization: don&apos;t iterate through events</span><br><span class="line">      // for the same portal container or root node more than once.</span><br><span class="line">      // TODO: once we remove the flag, we may be able to also</span><br><span class="line">      // remove some of the bookkeeping maps used for laziness.</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rootContainerElement[listeningMarker] = true;</span><br><span class="line">    allNativeEvents.forEach(function (domEventName) &#123;</span><br><span class="line">      if (!nonDelegatedEvents.has(domEventName)) &#123;</span><br><span class="line">        listenToNativeEvent(domEventName, false, rootContainerElement, null);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      listenToNativeEvent(domEventName, true, rootContainerElement, null);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 其中DOMRenderer是react-reconciler/src/ReactFiberReconciler，他的updateContainer如下在这里计算了一个时间，这个时间叫做expirationTime，顾名思义就是这次更新的 超时时间。</span><br><span class="line"></span><br><span class="line"># 然后调用了updateContainerAtExpirationTime，在这个方法里调用了scheduleRootUpdate就非常重要了</span><br><span class="line"></span><br><span class="line">export function updateContainer(</span><br><span class="line">  element: ReactNodeList,</span><br><span class="line">  container: OpaqueRoot,</span><br><span class="line">  parentComponent: ?React$Component&lt;any, any&gt;,</span><br><span class="line">  callback: ?Function,</span><br><span class="line">): ExpirationTime &#123;</span><br><span class="line">  const current = container.current</span><br><span class="line">  const currentTime = requestCurrentTime()</span><br><span class="line">  const expirationTime = computeExpirationForFiber(currentTime, current)</span><br><span class="line">  return updateContainerAtExpirationTime(</span><br><span class="line">    element,</span><br><span class="line">    container,</span><br><span class="line">    parentComponent,</span><br><span class="line">    expirationTime,</span><br><span class="line">    callback,</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function updateContainerAtExpirationTime(</span><br><span class="line">  element: ReactNodeList,</span><br><span class="line">  container: OpaqueRoot,</span><br><span class="line">  parentComponent: ?React$Component&lt;any, any&gt;,</span><br><span class="line">  expirationTime: ExpirationTime,</span><br><span class="line">  callback: ?Function,</span><br><span class="line">) &#123;</span><br><span class="line">  // TODO: If this is a nested container, this won&apos;t be the root.</span><br><span class="line">  const current = container.current</span><br><span class="line">  const context = getContextForSubtree(parentComponent)</span><br><span class="line">  if (container.context === null) &#123;</span><br><span class="line">    container.context = context</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    container.pendingContext = context</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return scheduleRootUpdate(current, element, expirationTime, callback)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 开始调度</span><br><span class="line"># 首先要生成一个update，不管你是setState还是ReactDOM.render造成的 React 更新，都会生成一个叫update的对象，并且会赋值给Fiber.updateQueue</span><br><span class="line"># 然后就是调用scheduleWork。注意到这里之前setState和ReactDOM.render是不一样，但进入schedulerWork之后，就是任务调度的事情了，跟之前你是怎么调用的没有任何关系</span><br><span class="line"></span><br><span class="line">function scheduleRootUpdate(</span><br><span class="line">  current: Fiber,</span><br><span class="line">  element: ReactNodeList,</span><br><span class="line">  expirationTime: ExpirationTime,</span><br><span class="line">  callback: ?Function,</span><br><span class="line">) &#123;</span><br><span class="line">  const update = createUpdate(expirationTime)</span><br><span class="line"></span><br><span class="line">  update.payload = &#123; element &#125;</span><br><span class="line"></span><br><span class="line">  callback = callback === undefined ? null : callback</span><br><span class="line">  if (callback !== null) &#123;</span><br><span class="line">    warningWithoutStack(</span><br><span class="line">      typeof callback === &apos;function&apos;,</span><br><span class="line">      &apos;render(...): Expected the last optional `callback` argument to be a &apos; +</span><br><span class="line">        &apos;function. Instead received: %s.&apos;,</span><br><span class="line">      callback,</span><br><span class="line">    )</span><br><span class="line">    update.callback = callback</span><br><span class="line">  &#125;</span><br><span class="line">  enqueueUpdate(current, update)</span><br><span class="line"></span><br><span class="line">  scheduleWork(current, expirationTime)</span><br><span class="line">  return expirationTime</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="2、cjs、amd、umd和esm"><a href="#2、cjs、amd、umd和esm" class="headerlink" title="2、cjs、amd、umd和esm"></a>2、cjs、amd、umd和esm</h4><pre><code>JavaScript最初仅用于交互式浏览器。与Node一起，可在非浏览器上下文中使用。由于这个因素和其他因素，模块的格式不兼容。CJS、AMD、UMD 和 ESM都是给 Javascript 添加模块化的方法，还有其他方法，但这些是比较通用的。
</code></pre><p>  <strong>CJS</strong> ，CommonJS，是同步导入模块，描述了 exports 对象的使用。 NodeJS是CommonJS格式的最流行实现。不允许在交互式浏览器中加载CommonJS模块，它必须经过转换和打包。<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入：都可以起作用,当 CJS 导入时，它会给你一个导入对象的副本。</span></span><br><span class="line"><span class="keyword">const</span> doSomething = <span class="built_in">require</span>(<span class="string">'./doSomething.js'</span>); 或 <span class="keyword">const</span> React = <span class="built_in">require</span>(<span class="string">'react'</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出：</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;...&#125;;</span><br></pre></td></tr></table></figure></p>
<pre><code>每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。
CommonJS规范加载模块是同步的，由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用
</code></pre><blockquote>
<p>主要特点：<br>所有代码都运行在模块作用域，不会污染全局作用域<br>模块可以多次加载，但是只会在第一次加载的时候执行，然后会缓存一份，后面再引用返回的都是缓存<br>模块加载的顺序是按照出现的位置来定<br>因为被输出的是拷贝值，则如果在外部对模块代码就行修改则不会生效<br>一般用于服务端的规范</p>
</blockquote>
<p>  <strong>AMD</strong>，Asynchronously  Module Definition，异步模块定义，描述了如何在假定将JavaScript模块加载到交互式浏览器中的情况下捆绑JavaScript模块。</p>
<p>  跟CJS并称量大通用模块规范，主要用于客户端，因为客户端在加载的时候主要看中加载速度，如果像是CJS那样同步执行的话，在加载一个很大的组件的情况下会相当的耽误时间，所以催生了AMD客户端的异步规范。<br>  第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">'lodash'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">lh</span>) </span>&#123;</span><br><span class="line">  lo.isArray([]);</span><br><span class="line">  <span class="comment">// Define the module value by returning a value.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>  <strong>UMD</strong>，Universal Module Definition，通用模块定义，是一种尝试制作可被使用的模块的模式。为了同时支持CJS和AMD的规范，判断谁的规范支持就使用谁的规范，他的最外层是一个iife。<br>    在前端和后端都适用（“通用”因此得名）<br>    与 CJS 或 AMD 不同，UMD 更像是一种配置多个模块系统的模式。这里可以找到更多的模式<br>    当使用 Rollup/Webpack 之类的打包器时，UMD 通常用作备用模块<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">root, factory</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">"function"</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">    define([<span class="string">"jquery"</span>, <span class="string">"underscore"</span>], factory);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> exports === <span class="string">"object"</span>) &#123;</span><br><span class="line">    <span class="built_in">module</span>.exports = factory(<span class="built_in">require</span>(<span class="string">"jquery"</span>), <span class="built_in">require</span>(<span class="string">"underscore"</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    root.Requester = factory(root.$, root._);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params">$, _</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// this is where I defined my module implementation</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> Requester = &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Requester;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure></p>
<pre><code>恍然，因为我打开的是umd/react-dom.development.js，所以上面那么写，其实叫umd规范写法。哈哈哈。
</code></pre><p>  <strong>ESM</strong>，ECMAScript Module，2015定义了 export 和 import 语法（不同于上述所有内容）以支持模块。<br>    它兼具两方面的优点：具有 CJS 的简单语法和 AMD 的异步<br>    得益于 ES6 的静态模块结构，可以进行 Tree Shaking<br>    ESM 允许像 Rollup 这样的打包器，删除不必要的代码，减少代码包可以获得更快的加载<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;foo, bar&#125; <span class="keyword">from</span> <span class="string">'./myLib'</span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// your Function</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> function1() &#123;...&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> function2() &#123;...&#125;;</span><br></pre></td></tr></table></figure></p>
<p>  ESM由于具有简单的语法，异步加载的特性，以及Tree-shakeable的特性，因此被广泛使用。<br>  UMD可以在任何环境下使用，并且在ESM不能使用的情况下选择UMD。<br>  CJS是同步的，适用于后端环境。<br>  AMD是异步的，适用于前端环境。</p>
<p>  到这里，我们再看直接看源码的第一步，为什么会这样写，这就是umd规范吖。因为我打开的是umd/react-dom.development.js，虽然之前也不是十分了解umd到底是什么，但是就是觉得应该看umd的。哈哈哈。<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">global, factory</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">typeof</span> exports === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span> !== <span class="string">'undefined'</span> ? factory(exports, <span class="built_in">require</span>(<span class="string">'react'</span>)) :</span><br><span class="line">  <span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd ? define([<span class="string">'exports'</span>, <span class="string">'react'</span>], factory) :</span><br><span class="line">  (global = global || self, factory(global.ReactDOM = &#123;&#125;, global.React));</span><br><span class="line">&#125;(<span class="keyword">this</span>, (<span class="function"><span class="keyword">function</span> (<span class="params">exports, React</span>) </span>&#123; </span><br><span class="line">  ...</span><br><span class="line">  exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;</span><br><span class="line">  exports.createPortal = createPortal$<span class="number">1</span>;</span><br><span class="line">  exports.findDOMNode = findDOMNode;</span><br><span class="line">  exports.flushSync = flushSync;</span><br><span class="line">  exports.hydrate = hydrate;</span><br><span class="line">  exports.render = render;</span><br><span class="line">  exports.unmountComponentAtNode = unmountComponentAtNode;</span><br><span class="line">  exports.unstable_batchedUpdates = batchedUpdates$<span class="number">1</span>;</span><br><span class="line">  exports.unstable_createPortal = unstable_createPortal;</span><br><span class="line">  exports.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;</span><br><span class="line">  exports.version = ReactVersion;</span><br><span class="line">&#125;)));</span><br></pre></td></tr></table></figure></p>
<p>  其实对于这个模块化话题，还可以探索地更深，但是我们的主题是react源码，就先到这了。</p>
<h4 id="3、其他小点"><a href="#3、其他小点" class="headerlink" title="3、其他小点"></a>3、其他小点</h4><p>  <code>节点类型 nodeType</code></p>
<table>
<thead>
<tr>
<th>节点类型</th>
<th>描述</th>
<th>子节点</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 Element</td>
<td>代表元素</td>
<td>Element, Text, Comment, ProcessingInstruction, CDATASection, EntityReference</td>
</tr>
<tr>
<td>2 Attr</td>
<td>代表属性</td>
<td>Text, EntityReference</td>
</tr>
<tr>
<td>3 Text</td>
<td>代表元素或属性中的文本内容。</td>
<td>None</td>
</tr>
<tr>
<td>4 CDATASection</td>
<td>代表文档中的 CDATA 部分（不会由解析器解析的文本）。</td>
<td>None</td>
</tr>
<tr>
<td>5 EntityReference</td>
<td>代表实体引用。</td>
<td>Element, ProcessingInstruction, Comment, Text, CDATASection, EntityReference</td>
</tr>
<tr>
<td>6 Entity</td>
<td>代表实体。</td>
<td>Element, ProcessingInstruction, Comment, Text, CDATASection, EntityReference</td>
</tr>
<tr>
<td>7 ProcessingInstruction</td>
<td>代表处理指令。</td>
<td>None</td>
</tr>
<tr>
<td>8 Comment</td>
<td>代表注释。</td>
<td>None</td>
</tr>
<tr>
<td>9 Document</td>
<td>代表整个文档（DOM 树的根节点）。</td>
<td>Element, ProcessingInstruction, Comment, DocumentType</td>
</tr>
<tr>
<td>10 DocumentType</td>
<td>向为文档定义的实体提供接口</td>
<td>None</td>
</tr>
<tr>
<td>11 DocumentFragment</td>
<td>代表轻量级的 Document 对象，能够容纳文档的某个部分</td>
<td>Element, ProcessingInstruction, Comment, Text, CDATASection, EntityReference</td>
</tr>
<tr>
<td>12 Notation</td>
<td>代表 DTD 中声明的符号。</td>
<td>None</td>
</tr>
</tbody>
</table>
<p>  <code>{ } 封闭作用域</code><br>  <code>!! 真假</code><br>  <code>‘’ + ‘’ 拼接长字符串</code><br>  <code>‘xxx’ + Math.random.toString(36).slice(2) 打标识</code></p>
<p>  开啃之后就会发现，小丑 🤡 果然还是自己，直接上口真是吃不消，还是要有方法去看这种大框架源码。<br>  不是一朝一夕的事情，要有足够的耐心和时间才行。</p>
<h2 id="怎么学react源码"><a href="#怎么学react源码" class="headerlink" title="怎么学react源码"></a>怎么学react源码</h2><pre><code>直接看源码，就像是盲人摸象，不，应该是盲蚂蚁 🐜 摸象 🐘， 这不是一朝一夕就能完成的事情。
痛定思痛：一定要先找出我们的大方向，循序渐进。
边看成熟的结论，边看源码实现，相辅相成，反复验证。
</code></pre>  <!-- - 前人的肩膀推荐：
    [React 源码解析](https://react.jokcy.me/) ，从API的角度解析react。
    [全栈潇晨-react源码解析](https://xiaochen1024.com/courseware/60b1b2f6cf10a4003b634718/60b1b311cf10a4003b634719)，从API和抽象角度解析react。
    [React官方-实现说明](https://zh-hans.reactjs.org/docs/implementation-notes.html)
  - 源码可以直接 download react 源码，也可以直接看包中的umd的development.js。 -->
<p>  看我们带着什么样的目的去看react源码</p>
<p><br><br><br><br><br><br><br></p>
<h1 id="二、react源码框架总览"><a href="#二、react源码框架总览" class="headerlink" title="二、react源码框架总览"></a>二、react源码框架总览</h1><p>  我们一步一步深入了解，然后制定出相对满意的长期学习计划。从上帝视角，俯冲向下，直至一个个平民。<br>  <div class="post-desc">react的核心可以用ui = fn(state)来表示，更详细可以用：<br>    const state = reconcile (update);<br>    const UI = commit (state);<br>  </div></p>
<p>  状态更新视图，调度器，协调器，渲染器。<br>  <canvas id="react-zong" width="500" height="390"></canvas></p>
  <script>const oReactZong = document.getElementById('react-zong');const oReactZongPen = oReactZong.getContext('2d');oReactZongPen.fillText('jsx', 28, 220);oReactZongPen.fillText('task2', 155, 133);oReactZongPen.fillText('中优先级', 150, 146);oReactZongPen.fillText('task3', 155, 165);oReactZongPen.fillText('低优先级', 150, 175);oReactZongPen.fillText('task1', 268, 133);oReactZongPen.fillText('高优先级', 260, 146);oReactZongPen.fillStyle='blue';oReactZongPen.fillText('mount/update', 2, 190);oReactZongPen.fillText('render阶段', 250, 100);oReactZongPen.fillText('在内存中进行', 180, 350);oReactZongPen.fillText('commit阶段', 410, 100);oReactZongPen.font = '14px sans-serif';oReactZongPen.fillText('Scheduler', 135, 210);oReactZongPen.fillText('（调度器）', 130, 225);oReactZongPen.fillText('Reconciler', 245, 210);oReactZongPen.fillText('（协调器）', 239, 225);oReactZongPen.fillText('Renderer', 409, 210);oReactZongPen.fillText('（渲染器）', 405, 225);oReactZongPen.lineWidth = 0.5;oReactZongPen.strokeStyle = 'black';oReactZongPen.beginPath();oReactZongPen.setLineDash([2]);oReactZongPen.strokeRect( 5 , 203 , 60, 30 );oReactZongPen.stroke();oReactZongPen.beginPath();oReactZongPen.arc(305, 90, 20, -Math.PI/2 , Math.PI, true);oReactZongPen.arc(265, 90, 20, 0, -Math.PI/2, true);oReactZongPen.font = '10px sans-serif';oReactZongPen.fillStyle='black';oReactZongPen.fillText('根据update计算state', 240, 40);oReactZongPen.fillText('diff算法', 270, 52);oReactZongPen.fillText('给Fiber打上Flags', 250, 64);oReactZongPen.lineTo(233, 70);oReactZongPen.lineTo(233, 25);oReactZongPen.lineTo(343, 25);oReactZongPen.lineTo(343, 70);oReactZongPen.closePath();oReactZongPen.stroke();oReactZongPen.beginPath();oReactZongPen.arc(460, 90, 20, -Math.PI/2 , Math.PI, true);oReactZongPen.arc(420, 90, 20, 0, -Math.PI/2, true);oReactZongPen.fillText('react-dom', 415, 28);oReactZongPen.fillText('react-art', 415, 40);oReactZongPen.fillText('......', 420, 52);oReactZongPen.fillText('操作DOM', 415, 64);oReactZongPen.lineTo(400, 70);oReactZongPen.lineTo(400, 15);oReactZongPen.lineTo(480, 15);oReactZongPen.lineTo(480, 70);oReactZongPen.closePath();oReactZongPen.stroke();oReactZongPen.beginPath();oReactZongPen.arc(150, 90, 20, -Math.PI/2 , Math.PI, true);oReactZongPen.arc(110, 90, 20, 0, -Math.PI/2, true);oReactZongPen.font = '10px sans-serif';oReactZongPen.fillStyle='black';oReactZongPen.fillText('如果低优先级task被打断，', 75, 40);oReactZongPen.fillText('也只是发生在内存中，', 85, 52);oReactZongPen.fillText('不影响真实节点', 95, 64);oReactZongPen.lineTo(64, 70);oReactZongPen.lineTo(64, 25);oReactZongPen.lineTo(200, 25);oReactZongPen.lineTo(200, 70);oReactZongPen.closePath();oReactZongPen.stroke();oReactZongPen.beginPath();oReactZongPen.strokeRect( 98 , 85 , 260 , 280 );oReactZongPen.stroke();oReactZongPen.beginPath();oReactZongPen.setLineDash([]);oReactZongPen.lineTo(65, 220);oReactZongPen.lineTo(123, 220);oReactZongPen.fillStyle='black';oReactZongPen.fillText('→' , 119, 223);oReactZongPen.stroke();oReactZongPen.beginPath();oReactZongPen.strokeRect( 130 , 120 , 80 , 200 );oReactZongPen.setLineDash([2]);oReactZongPen.lineTo(130, 150);oReactZongPen.lineTo(210, 150);oReactZongPen.stroke();oReactZongPen.beginPath();oReactZongPen.lineTo(130, 180);oReactZongPen.lineTo(210, 180);oReactZongPen.stroke();oReactZongPen.beginPath();oReactZongPen.setLineDash([]);oReactZongPen.strokeRect( 240 , 120 , 80 , 200 );oReactZongPen.setLineDash([2]);oReactZongPen.lineTo(240, 150);oReactZongPen.lineTo(320, 150);oReactZongPen.stroke();oReactZongPen.beginPath();oReactZongPen.setLineDash([]);oReactZongPen.strokeRect( 400 , 120 , 80 , 200 );</script>


<p>  <img src="https://img-blog.csdnimg.cn/img_convert/f81d27cf172e1ea3718b9d54cdf8e307.png" alt="tusods"></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">创建更新</span><br><span class="line">    ReactDOM.render</span><br><span class="line">    setState &amp; forceUpdate</span><br><span class="line">    expirationTime 计算</span><br><span class="line">任务调度</span><br><span class="line">    全局变量</span><br><span class="line">    scheduleWork</span><br><span class="line">    react-scheduler</span><br><span class="line">    performWork</span><br><span class="line">    performUnitOfWork</span><br><span class="line">    renderRoot</span><br><span class="line">    beginWork</span><br><span class="line">    reconcileChildren</span><br><span class="line">commit 阶段</span><br><span class="line">    commitRoot</span><br><span class="line">    invokeGuardedCallback</span><br><span class="line">    commitBeforeMutationLifecycles</span><br><span class="line">    commitAllHostEffects</span><br><span class="line">    commitPlacement</span><br><span class="line">功能</span><br><span class="line">    context</span><br><span class="line">    hydrate</span><br><span class="line">    ref</span><br><span class="line">    事件系统初始化</span><br><span class="line">    事件绑定</span><br><span class="line">    事件触发</span><br><span class="line">    事件对象生成</span><br><span class="line">    Suspense</span><br><span class="line">    挂起任务的含义</span><br><span class="line">    lazy 组件</span><br></pre></td></tr></table></figure>
<p>  fiberRoot是整个项目的根节点，只存在一个，rootFiber是应用的根节点，可能存在多个，例如多个ReactDOM.render(&lt; App /&gt;, document.getElementById(“root”));创建多个应用节点</p>
<h2 id="jsx"><a href="#jsx" class="headerlink" title="jsx"></a>jsx</h2><p>  <code>jsx</code> 声明式地编写我们想要的UI效果，本质上是React.createElement的语法糖。语法糖的意思就是二者本质是等价的，只是裹了一层糖衣（写起来更甜更简单直接）。这层糖衣就是babel来做的，react通过babel词法解析，将jsx转换成React.createElement。</p>
<p>  React.createElement方法返回virtual dom对象（内存中用来描述dom阶段的对象）。</p>
<h2 id="Fiber双缓存"><a href="#Fiber双缓存" class="headerlink" title="Fiber双缓存"></a>Fiber双缓存</h2><pre><code>Fiber对象映射节点信息。Fiber对象（FiberRootNode、FiberNode）上保存了这个节点的属性、类型、dom（child、sibling）等，Fiber通过child、sibling、return（指向父节点）来形成Fiber树。还保存了更新状态时用于计算state的updateQueue，updateQueue是一种链表结构，上面可能存在多个未计算的update，update也是一种数据结构，上面包含了更新的数据、优先级等，除了这些之外，上面还有和副作用有关的信息。

双缓存是指有两棵Fiber树，current Fiber树描述了当前已经呈现的dom树，workInProgress Fiber树是正在更新的Fiber树。当workInProgress Fiber树构建完成后，会将其作为current Fiber树更新到真实Dom树上。

在mount（装载，首次渲染）时，会根据jsx对象（class component的render函数或者Function Component的返回值）生成workInProgress Fiber树，把workInProgress Fiber切换成current Fiber，Current Fiber树应用到真实的dom上。在update（状态更新，如setState）时，会根据状态更新后的jsx对象和Current fiber树作对比逐渐形成新的workInProgress Fiber树，workInProgress Fiber构建完成后会替换成Current Fiber，更新到真实的dom上。而这一切都是在内存中进行的，减少真实dom渲染耗性能。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line">  return (</span><br><span class="line">    &lt;h1</span><br><span class="line">      onClick=&#123;() =&gt; &#123;</span><br><span class="line">        setCount(() =&gt; count + 1);</span><br><span class="line">      &#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">        &lt;p title=&#123;count&#125;&gt;&#123;count&#125;&lt;/p&gt; jyy</span><br><span class="line">    &lt;/h1&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById(&quot;root&quot;));</span><br></pre></td></tr></table></figure>
</code></pre>  <canvas id="react-fiber" width="600" height="500"></canvas>

  <script>const oReactFiber = document.getElementById('react-fiber');const oReactFiberPen = oReactFiber.getContext('2d');oReactFiberPen.font = '14px sans-serif';oReactFiberPen.fillStyle='black';oReactFiberPen.strokeRect(245, 10, 110, 40);oReactFiberPen.strokeRect(160, 120, 90, 40);oReactFiberPen.strokeRect(160, 210, 90, 40);oReactFiberPen.strokeRect(160, 300, 90, 40);oReactFiberPen.strokeRect(160, 390, 90, 40);oReactFiberPen.strokeRect(30, 391, 50, 38);oReactFiberPen.strokeRect(348, 120, 90, 40);oReactFiberPen.strokeRect(348, 210, 90, 40);oReactFiberPen.strokeRect(348, 300, 90, 40);oReactFiberPen.strokeRect(348, 390, 90, 40);oReactFiberPen.strokeRect(520, 391, 50, 38);oReactFiberPen.beginPath();oReactFiberPen.lineTo(245, 50);oReactFiberPen.lineTo(180, 120);oReactFiberPen.lineTo(181, 111);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(180, 120);oReactFiberPen.lineTo(190, 117);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(220, 120);oReactFiberPen.lineTo(285, 50);oReactFiberPen.lineTo(284, 59);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(285, 50);oReactFiberPen.lineTo(275, 54);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(200, 160);oReactFiberPen.lineTo(200, 210);oReactFiberPen.lineTo(196, 206);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(200, 210);oReactFiberPen.lineTo(204, 206);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(200, 250);oReactFiberPen.lineTo(200, 300);oReactFiberPen.lineTo(196, 296);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(200, 300);oReactFiberPen.lineTo(204, 296);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(200, 340);oReactFiberPen.lineTo(200, 391);oReactFiberPen.lineTo(196, 387);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(200, 391);oReactFiberPen.lineTo(204, 387);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(220, 210);oReactFiberPen.lineTo(220, 160);oReactFiberPen.lineTo(216, 164);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(220, 160);oReactFiberPen.lineTo(224, 164);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(220, 300);oReactFiberPen.lineTo(220, 250);oReactFiberPen.lineTo(216, 254);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(220, 250);oReactFiberPen.lineTo(224, 254);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(220, 391);oReactFiberPen.lineTo(220, 340);oReactFiberPen.lineTo(216, 344);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(220, 340);oReactFiberPen.lineTo(224, 344);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(388, 160);oReactFiberPen.lineTo(388, 210);oReactFiberPen.lineTo(384, 206);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(388, 210);oReactFiberPen.lineTo(392, 206);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(388, 250);oReactFiberPen.lineTo(388, 300);oReactFiberPen.lineTo(384, 296);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(388, 300);oReactFiberPen.lineTo(392, 296);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(388, 340);oReactFiberPen.lineTo(388, 391);oReactFiberPen.lineTo(384, 387);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(388, 391);oReactFiberPen.lineTo(392, 387);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(408, 210);oReactFiberPen.lineTo(408, 160);oReactFiberPen.lineTo(404, 164);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(408, 160);oReactFiberPen.lineTo(412, 164);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(408, 300);oReactFiberPen.lineTo(408, 250);oReactFiberPen.lineTo(404, 254);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(408, 250);oReactFiberPen.lineTo(412, 254);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(408, 391);oReactFiberPen.lineTo(408, 340);oReactFiberPen.lineTo(404, 344);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(408, 340);oReactFiberPen.lineTo(412, 344);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(160, 410);oReactFiberPen.lineTo(80, 410);oReactFiberPen.lineTo(85, 406);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(80, 410);oReactFiberPen.lineTo(85, 414);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(60, 391);oReactFiberPen.lineTo(160, 320);oReactFiberPen.lineTo(150, 324);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(160, 320);oReactFiberPen.lineTo(153, 329);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(438, 410);oReactFiberPen.lineTo(520, 410);oReactFiberPen.lineTo(515, 406);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(520, 410);oReactFiberPen.lineTo(515, 414);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(540, 391);oReactFiberPen.lineTo(438, 320);oReactFiberPen.lineTo(443, 328);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(438, 320);oReactFiberPen.lineTo(448, 322);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(250, 140);oReactFiberPen.lineTo(348, 140);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(250, 230);oReactFiberPen.lineTo(348, 230);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(250, 320);oReactFiberPen.lineTo(348, 320);oReactFiberPen.stroke();oReactFiberPen.beginPath();oReactFiberPen.lineTo(250, 410);oReactFiberPen.lineTo(348, 410);oReactFiberPen.stroke();oReactFiberPen.setLineDash([2]);oReactFiberPen.strokeRect(20, 76, 250, 400);oReactFiberPen.strokeRect(330, 76, 250, 400);oReactFiberPen.fillStyle='#4F2F64';oReactFiberPen.fillText('fiberRootNode', 253, 35);oReactFiberPen.fillText('rootFiber', 175, 144);oReactFiberPen.fillText('App', 192, 234);oReactFiberPen.fillText('h1', 198, 325);oReactFiberPen.fillText('p', 202, 414);oReactFiberPen.fillText('jyy', 45, 415);oReactFiberPen.fillText('rootFiber', 365, 144);oReactFiberPen.fillText('App', 378, 234);oReactFiberPen.fillText('h1', 384, 325);oReactFiberPen.fillText('p', 390, 414);oReactFiberPen.fillText('jyy', 536, 415);oReactFiberPen.fillStyle='#E22312';oReactFiberPen.fillText('Current Fiber', 60, 58);oReactFiberPen.fillText('WorkInProgress Fiber', 400, 58);oReactFiberPen.fillStyle='#21AFF2';oReactFiberPen.fillText('current', 150, 100);oReactFiberPen.fillText('stateNode', 249, 100);oReactFiberPen.fillText('child', 166, 190);oReactFiberPen.fillText('return ', 225, 190);oReactFiberPen.fillText('child', 166, 281);oReactFiberPen.fillText('return', 225, 281);oReactFiberPen.fillText('child', 166, 368);oReactFiberPen.fillText('return', 225, 368);oReactFiberPen.fillText('sibling', 104, 405);oReactFiberPen.fillText('return', 63, 355);oReactFiberPen.fillText('child', 353, 190);oReactFiberPen.fillText('return ', 412, 190);oReactFiberPen.fillText('child', 353, 281);oReactFiberPen.fillText('return', 412, 281);oReactFiberPen.fillText('child', 353, 368);oReactFiberPen.fillText('return', 412, 368);oReactFiberPen.fillText('sibling', 462, 405);oReactFiberPen.fillText('return', 495, 355);oReactFiberPen.fillText('alternate', 272, 136);oReactFiberPen.fillText('alternate', 272, 226);oReactFiberPen.fillText('alternate', 272, 316);oReactFiberPen.fillText('alternate', 272, 406);</script>


<h2 id="scheduler"><a href="#scheduler" class="headerlink" title="scheduler"></a>scheduler</h2><pre><code>Scheduler的作用是调度任务，react15没有Scheduler这部分，所以所有任务没有优先级，也不能中断，只能同步执行。

我们知道了要实现异步可中断的更新，需要浏览器指定一个时间，如果没有时间剩余了就需要暂停任务，requestIdleCallback貌似是个不错的选择，但是它存在兼容和触发不稳定的原因，react17中采用MessageChannel来实现。

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoopConcurrent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Perform work until Scheduler asks us to yield</span></span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span> &amp;&amp; !shouldYield()) &#123;</span><br><span class="line">    performUnitOfWork(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

在Scheduler中的每的每个任务的优先级使用过期时间表示的，如果一个任务的过期时间离现在很近，说明它马上就要过期了，优先级很高，如果过期时间很长，那它的优先级就低，没有过期的任务存放在timerQueue中，过期的任务存放在taskQueue中，timerQueue和timerQueue都是小顶堆，所以peek取出来的都是离现在时间最近也就是优先级最高的那个任务，然后优先执行它。
</code></pre>  <!-- ## Lane模型 -->
<h2 id="reconciler（render-阶段）"><a href="#reconciler（render-阶段）" class="headerlink" title="reconciler（render 阶段）"></a>reconciler（render 阶段）</h2><pre><code>协调器是在render阶段工作的，简单一句话概括就是Reconciler会创建或者更新Fiber节点。在mount的时候会根据jsx生成Fiber对象，在update的时候会根据最新的state形成的jsx对象和current Fiber树对比构建workInProgress Fiber树，这个对比的过程就是diff算法。

diff算法发生在render阶段的reconcileChildFibers函数中，diff算法分为单节点的diff和多节点的diff（例如一个节点中包含多个子节点就属于多节点的diff），单节点会根据节点的key和type，props等来判断节点是复用还是直接新创建节点，多节点diff会涉及节点的增删和节点位置的变化。

reconcile时会在这些Fiber上打上Flags标签，这些标签代表节点的增删改，在commit阶段把这些标签应用到真实dom上。

render阶段遍历Fiber树类似dfs的过程，‘捕获’阶段发生在beginWork函数中，该函数做的主要工作是创建Fiber节点，计算state和diff算法，‘冒泡’阶段发生在completeWork中，该函数主要是做一些收尾工作，例如处理节点的props、和形成一条effectList的链表，该链表是被标记了更新的节点形成的链表。（可以看上面 Fiber双缓存 那张图，自上而下的是beginWork，自下而上是completeWork）
</code></pre><h2 id="renderer（commit-阶段）"><a href="#renderer（commit-阶段）" class="headerlink" title="renderer（commit 阶段）"></a>renderer（commit 阶段）</h2><pre><code>Renderer是在commit阶段工作的，commit阶段会遍历render阶段形成的effectList，并执行真实dom节点的操作和一些生命周期，不同平台对应的Renderer不同，例如浏览器对应的就是react-dom。

commit阶段发生在commitRoot函数中，该函数主要遍历effectList，分别用三个函数来处理effectList上的节点，这三个函数是commitBeforeMutationEffects、commitMutationEffects、commitLayoutEffects，他们主要做的事情如下，后面会详细研究，现在在大脑里有一个结构就行。
</code></pre><h2 id="concurrent"><a href="#concurrent" class="headerlink" title="concurrent"></a>concurrent</h2><pre><code>它是一类功能的合集（如fiber、schduler、lane、suspense），其目的是为了提高应用的响应速度，使应用cpu密集型的更新不再那么卡顿，其核心是实现了一套异步可中断、带优先级的更新。

一般浏览器的fps是60Hz，也就是每16.6ms会刷新一次，而js执行线程和GUI（也就是浏览器的绘制）是互斥的，因为js可以操作dom，影响最后呈现的结果，所以如果js执行的时间过长，会导致浏览器没时间绘制dom，造成卡顿。react17会在每一帧分配一个时间（时间片）给js执行，如果在这个时间内js还没执行完，那就要暂停它的执行，等下一帧继续执行，把执行权交回给浏览器去绘制。
</code></pre>  <div class="post-warning">FPS （Frames Per Second, 每秒传输帧数）， FPS是图像领域中的定义，是指画面每秒传输帧数，通俗来讲就是指动画或视频的画面数。FPS是测量用于保存、显示动态视频的信息数量。每秒钟帧数越多，所显示的动作就会越流畅。60Hz的刷新率刷也就是指屏幕一秒内只扫描60次，即60帧/秒。而当刷新率太低时我们肉眼都能感觉到屏幕的闪烁，不连贯，对图像显示效果和视觉感观产生不好的影响。</div>

  <canvas id="concurrent-browser" width="600" height="300"></canvas>

  <script>const oConcurrent = document.getElementById('concurrent-browser');const oConcurrentPen = oConcurrent.getContext('2d');oConcurrentPen.font = '14px sans-serif';oConcurrentPen.fillStyle='black';oConcurrentPen.fillText('js执行', 16, 245);oConcurrentPen.fillText('重排', 70, 245);oConcurrentPen.fillText('重绘', 122, 245);oConcurrentPen.fillText('js执行', 68, 125);oConcurrentPen.fillText('js执行', 218, 125);oConcurrentPen.fillText('重排', 422, 125);oConcurrentPen.fillText('重绘', 471, 125);oConcurrentPen.fillText('16.6ms', 65, 93);oConcurrentPen.fillText('16.6ms', 218, 93);oConcurrentPen.fillText('16.6ms', 65, 213);oConcurrentPen.font = '10px sans-serif';oConcurrentPen.fillText('......很长一段时间', 320, 93);oConcurrentPen.fillText('没时间执行', 435, 93);oConcurrentPen.strokeRect(10, 220, 50, 40);oConcurrentPen.strokeRect(60, 220, 50, 40);oConcurrentPen.strokeRect(110, 220, 50, 40);oConcurrentPen.strokeRect(10, 100, 150, 40);oConcurrentPen.strokeRect(160, 100, 150, 40);oConcurrentPen.strokeRect(410, 100, 50, 40);oConcurrentPen.strokeRect(460, 100, 50, 40);oConcurrentPen.beginPath();oConcurrentPen.lineTo(10, 82);oConcurrentPen.lineTo(10, 94);oConcurrentPen.stroke();oConcurrentPen.beginPath();oConcurrentPen.lineTo(160, 82);oConcurrentPen.lineTo(160, 94);oConcurrentPen.stroke();oConcurrentPen.beginPath();oConcurrentPen.lineTo(10, 88);oConcurrentPen.lineTo(55, 88);oConcurrentPen.stroke();oConcurrentPen.beginPath();oConcurrentPen.lineTo(115, 88);oConcurrentPen.lineTo(160, 88);oConcurrentPen.stroke();oConcurrentPen.beginPath();oConcurrentPen.lineTo(310, 82);oConcurrentPen.lineTo(310, 94);oConcurrentPen.stroke();oConcurrentPen.beginPath();oConcurrentPen.lineTo(160, 88);oConcurrentPen.lineTo(205, 88);oConcurrentPen.stroke();oConcurrentPen.beginPath();oConcurrentPen.lineTo(265, 88);oConcurrentPen.lineTo(310, 88);oConcurrentPen.stroke();oConcurrentPen.beginPath();oConcurrentPen.lineTo(410, 82);oConcurrentPen.lineTo(410, 94);oConcurrentPen.stroke();oConcurrentPen.beginPath();oConcurrentPen.lineTo(510, 82);oConcurrentPen.lineTo(510, 94);oConcurrentPen.stroke();oConcurrentPen.beginPath();oConcurrentPen.lineTo(410, 88);oConcurrentPen.lineTo(430, 88);oConcurrentPen.stroke();oConcurrentPen.beginPath();oConcurrentPen.lineTo(490, 88);oConcurrentPen.lineTo(510, 88);oConcurrentPen.stroke();oConcurrentPen.beginPath();oConcurrentPen.lineTo(10, 202);oConcurrentPen.lineTo(10, 214);oConcurrentPen.stroke();oConcurrentPen.beginPath();oConcurrentPen.lineTo(160, 202);oConcurrentPen.lineTo(160, 214);oConcurrentPen.stroke();oConcurrentPen.beginPath();oConcurrentPen.lineTo(10, 208);oConcurrentPen.lineTo(55, 208);oConcurrentPen.stroke();oConcurrentPen.beginPath();oConcurrentPen.lineTo(115, 208);oConcurrentPen.lineTo(160, 208);oConcurrentPen.stroke();</script>


<h1 id="三、react源码深入解析"><a href="#三、react源码深入解析" class="headerlink" title="三、react源码深入解析"></a>三、react源码深入解析</h1><p>  直接看react源码，就像是一个人站在你面前，他就在你面前，面面相觑，你不了解他。<br>  接下来，这一part我们听别人去讲他，我们去理解，再亲自去验证，深入理解他。</p>
<h2 id="源码目录结构和调试"><a href="#源码目录结构和调试" class="headerlink" title="源码目录结构和调试"></a>源码目录结构和调试</h2><ol>
<li>源码中主要包括如下部分<br> fixtures：为代码贡献者提供的测试React<br> packages：主要部分，包含Scheduler，reconciler等<br> scripts：react构建相关</li>
<li>packages主要包含的模块</li>
</ol>
<pre><code>- react：核心Api，如：React.createElement、React.Component都在这

- 和平台相关render相关的文件夹： 
  react-art：如canvas svg的渲染 
  react-dom：浏览器环境 
  react-native-renderer：原生相关 react-noop-renderer：调试或者fiber用

- 试验性的包
  react-server: ssr相关
  react-fetch: 请求相关
  react-interactions: 和事件如点击事件相关
  react-reconciler: 构建节点

- shared：包含公共方法和变量

- 辅助包：
  react-is : 判断类型
  react-client: 流相关
  react-fetch: 数据请求相关
  react-refresh: 热加载相关
  scheduler：调度器相关
  React-reconciler：在render阶段用它来构建fiber节点
</code></pre><ul>
<li>调试方法</li>
</ul>
<p>  方法一：这种方法我没走通，直接走的野路子方法二。</p>
<ol>
<li>clone源码：git clone <a href="https://github.com/facebook/react.git" target="_blank" rel="noopener">https://github.com/facebook/react.git</a></li>
<li>依赖安装：npm install or yarn</li>
<li>build源码：npm run build react/index,react/jsx,react-dom/index,scheduler –type=NODE<br>为源码建立软链：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build/node_modules/react</span><br><span class="line">npm link</span><br><span class="line"><span class="built_in">cd</span> build/node_modules/react-dom</span><br><span class="line">npm link</span><br><span class="line">create-react-app创建项目</span><br><span class="line"></span><br><span class="line">npx create-react-app demo</span><br><span class="line">npm link react react-dom</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>方法二：野路子，直捣黄龙</p>
<ol>
<li>npm i react react-dom</li>
<li><p>同目录创建html文件，script方式使用react和react-dom</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">'./node_modules/react/umd/react.development.js'</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">'./node_modules/react-dom/umd/react-dom.development.js'</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;div id=<span class="string">'root'</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">    <span class="string">'app'</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> a = <span class="string">'abc'</span>;</span><br><span class="line">  <span class="comment">// ReactDOM.render(null, document.getElementById('root'));</span></span><br><span class="line">  ReactDOM.render(React.createElement(<span class="string">'h1'</span>, &#123;<span class="attr">className</span>: <span class="string">'name'</span>, <span class="attr">onClick</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">'点我干嘛'</span>);&#125;&#125;, [<span class="string">'abc'</span>, React.createElement(<span class="string">'div'</span>, &#123;<span class="attr">key</span>: <span class="string">'num'</span>&#125;, <span class="string">'123456'</span>)]), <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>直接些jsx不可以，没有探索babel有没有cdn的使用方式，直接React.createElememt粗暴代替。</p>
</li>
</ol>
<h2 id="jsx-1"><a href="#jsx-1" class="headerlink" title="jsx"></a>jsx</h2><h3 id="virtual-Dom-是什么"><a href="#virtual-Dom-是什么" class="headerlink" title="virtual Dom 是什么"></a>virtual Dom 是什么</h3><p>  virtual Dom是一个js对象，描述了dom信息。更新就是渲染更新后的js对象到真实dom，这个对象是React.createElement()返回的结果。</p>
<h3 id="为什么用virtual-Dom"><a href="#为什么用virtual-Dom" class="headerlink" title="为什么用virtual Dom"></a>为什么用virtual Dom</h3><p>  真实DOM更新渲染，很小的更新就可能引起页面的重绘重排，耗时耗性能。<br>  js对象是在内存中处理的，很快，并通过diff算法比较virtual dom的变化，能做到批量，异步，最小化的dom变更，有效提升性能。</p>
<h3 id="jsx-amp-createElement"><a href="#jsx-amp-createElement" class="headerlink" title="jsx&amp;createElement"></a>jsx&amp;createElement</h3><p>  jsx是Class component的render函数的返回值或Function component的返回值，用来表示组件，声明式地描述视图。经过babel转义成React.createElement。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jsx结构:</span><br><span class="line">&lt;h1 class=&quot;name&quot; onClick=&#123;() =&gt; &#123;console.log(&apos;点我干嘛&apos;)&#125;&#125;&gt;</span><br><span class="line">  abc</span><br><span class="line">  &lt;div&gt;123456&lt;/div&gt;</span><br><span class="line">&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">经过babel转移成React.createElement</span><br><span class="line">React.createElement(</span><br><span class="line">  &apos;h1&apos;, &#123;className: &apos;name&apos;, onClick: () =&gt; &#123;console.log(&apos;点我干嘛&apos;);&#125;&#125;, </span><br><span class="line">    [&apos;abc&apos;, React.createElement(&apos;div&apos;, &#123;key: &apos;num&apos;&#125;, &apos;123456&apos;)])</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>  PS：这就是为什么jsx文件要声明import React from ‘react’的原因（现在我还不知道为什么react17之后不用导入？）</p>
<p>  React.createElement(810):</p>
<ul>
<li>处理config，把除了保留属性外的其他config赋值给props</li>
<li>把children处理后赋值给props.children</li>
<li>处理defaultProps</li>
<li>调用ReactElement(724)返回一个jsx对象(virtual-dom)</li>
</ul>
<p>  我们来看一下jsx对象：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  $$typeof: Symbol(react.element),</span><br><span class="line">  key: null,</span><br><span class="line">  props: &#123;</span><br><span class="line">    children: [</span><br><span class="line">      &quot;abc&quot;,</span><br><span class="line">      &#123;</span><br><span class="line">        $$typeof: Symbol(react.element),</span><br><span class="line">        key: &quot;num&quot;,</span><br><span class="line">        props: &#123;</span><br><span class="line">          children: &quot;123456&quot;,</span><br><span class="line">          key: undefined,</span><br><span class="line">          get key: ƒ (),</span><br><span class="line">          ref: null,</span><br><span class="line">          type: &quot;div&quot;,</span><br><span class="line">          _owner: null,</span><br><span class="line">          _store: &#123;validated: false&#125;,</span><br><span class="line">          _self: null,</span><br><span class="line">          _source: null,</span><br><span class="line">        &#125;  </span><br><span class="line">      &#125;,</span><br><span class="line">      length: 2,</span><br><span class="line">    ],</span><br><span class="line">    className: &quot;name&quot;,</span><br><span class="line">    onClick: () =&gt; &#123;console.log(&apos;点我干嘛&apos;);&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  ref: null,</span><br><span class="line">  type: &quot;h1&quot;,</span><br><span class="line">  _owner: null,</span><br><span class="line">  _store: &#123;validated: false&#125;,</span><br><span class="line">  _self: null,</span><br><span class="line">  _source: null,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  $$typeof表示的是组件的类型，例如在源码中有一个检查是否是合法Element的函数(isValidElement902)，就是根object.$$typeof === REACT_ELEMENT_TYPE来判断的</p>
<p>  看到这里，对jsx豁然开朗，至于babel是怎么转译的，以后有机会再做学习。<br>  <code>jsx -&gt; Virtual Dom(jsx对象，Fiber) -&gt; Dom</code><br>  还有个疑问，jsx对象和Fiber对象的关系？接着来大致看一下Fiber</p>
<blockquote>
<p>jsx对象上没有优先级、状态、effectTag等标记，这些标记在Fiber对象上，在mount时Fiber根据jsx对象来构建，在update时根据最新状态的jsx和current Fiber对比，形成新的workInProgress Fiber，最后workInProgress Fiber切换成current Fiber。</p>
</blockquote>
<p>  小结：jsx是React.createElement的语法糖，jsx通过babel转化成React.createElement函数，React.createElement执行之后返回jsx对象，也叫virtual-dom，Fiber会根据jsx对象和current Fiber进行对比形成workInProgress Fiber<br>  <!-- ## legacy和concurrent模式入口函数 --></p>
<h2 id="Fiber架构"><a href="#Fiber架构" class="headerlink" title="Fiber架构"></a>Fiber架构</h2><p>  react 15 在render阶段的reconcile过程是同步不可中断的，当进行大量节点的reconcile时就可能产生卡顿等，因为js执行是单线程的，一直在执行js，不放出执行权，浏览器要等到js执行完成后才能进行绘制和重排，这样的用户体验一定是不好的。</p>
<p>  react 16 增加了scheduler对时间片进行管理，分割task，给每个task（工作单元）一定的时间执行，时间到了没执行完也要交出执行权给到浏览器进行重绘重排。这种异步可中断的数据结构就是Fiber。</p>
<p>  Fiber：</p>
<ul>
<li><strong>工作单元 任务分解</strong>：这是Fiber最重要的工作，保存节点对应的信息，以指针的形式形成Fiber树。</li>
<li><strong>增量渲染</strong>：通过jsx对象和Current Fiber进行对比，生成最小的差异补丁，应用到真实节点上。</li>
<li><strong>保存状态</strong>：因为Fiber能保存状态和更新的信息，所以就能实现函数组件的状态更新，也就是hooks</li>
<li><strong>根据优先级暂停、继续、排列优先级</strong>：Fiber节点上保存了优先级，能通过不同节点优先级的对比达到此目的，也为上层批量更新、Suspense提供了基础。</li>
</ul>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FiberNode</span>(<span class="params">tag, pendingProps, key, mode</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 作为静态的数据结构 保存节点的信息 </span></span><br><span class="line">  <span class="keyword">this</span>.tag = tag; <span class="comment">// 对应组件的类型</span></span><br><span class="line">  <span class="keyword">this</span>.key = key;</span><br><span class="line">  <span class="keyword">this</span>.elementType = <span class="literal">null</span>; <span class="comment">// 元素类型</span></span><br><span class="line">  <span class="keyword">this</span>.type = <span class="literal">null</span>; <span class="comment">// class或Function</span></span><br><span class="line">  <span class="keyword">this</span>.stateNode = <span class="literal">null</span>; <span class="comment">// Fiber，真实DOM节点</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 作为fiber树架构 连接成fiber树</span></span><br><span class="line">  <span class="keyword">this</span>.return = <span class="literal">null</span>; <span class="comment">// 指向父节点</span></span><br><span class="line">  <span class="keyword">this</span>.child = <span class="literal">null</span>; <span class="comment">// 指向孩子</span></span><br><span class="line">  <span class="keyword">this</span>.sibling = <span class="literal">null</span>; <span class="comment">// 指向兄弟节点</span></span><br><span class="line">  <span class="keyword">this</span>.index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.ref = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 作为工作单元 来计算state</span></span><br><span class="line">  <span class="keyword">this</span>.pendingProps = pendingProps;</span><br><span class="line">  <span class="keyword">this</span>.memoizedProps = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.updateQueue = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.memoizedState = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.dependencies = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.mode = mode; <span class="comment">// Effects</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// effect相关</span></span><br><span class="line">  <span class="keyword">this</span>.flags = NoFlags;</span><br><span class="line">  <span class="keyword">this</span>.nextEffect = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.firstEffect = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.lastEffect = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 优先级相关</span></span><br><span class="line">  <span class="keyword">this</span>.lanes = NoLanes;</span><br><span class="line">  <span class="keyword">this</span>.childLanes = NoLanes;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// current和workInProgress的指针</span></span><br><span class="line">  <span class="keyword">this</span>.alternate = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>  <canvas id="fiber" width="600" height="460"></canvas>

<script>const oFiber = document.getElementById('fiber');const oFiberPen = oFiber.getContext('2d');oFiberPen.font = '14px sans-serif';oFiberPen.fillStyle='black';oFiberPen.strokeRect(150, 10, 100, 50);oFiberPen.strokeRect(150, 140, 100, 50);oFiberPen.strokeRect(150, 260, 100, 50);oFiberPen.strokeRect(150, 380, 100, 50);oFiberPen.strokeRect(460, 380, 100, 50);oFiberPen.beginPath();oFiberPen.lineTo(185, 60);oFiberPen.lineTo(185, 140);oFiberPen.lineTo(180, 135);oFiberPen.stroke();oFiberPen.beginPath();oFiberPen.lineTo(185, 140);oFiberPen.lineTo(190, 135);oFiberPen.stroke();oFiberPen.beginPath();oFiberPen.lineTo(185, 190);oFiberPen.lineTo(185, 260);oFiberPen.lineTo(180, 255);oFiberPen.stroke();oFiberPen.beginPath();oFiberPen.lineTo(185, 260);oFiberPen.lineTo(190, 255);oFiberPen.stroke();oFiberPen.beginPath();oFiberPen.lineTo(185, 310);oFiberPen.lineTo(185, 380);oFiberPen.lineTo(180, 375);oFiberPen.stroke();oFiberPen.beginPath();oFiberPen.lineTo(185, 380);oFiberPen.lineTo(190, 375);oFiberPen.stroke();oFiberPen.beginPath();oFiberPen.lineTo(215, 140);oFiberPen.lineTo(215, 60);oFiberPen.lineTo(210, 65);oFiberPen.stroke();oFiberPen.beginPath();oFiberPen.lineTo(215, 60);oFiberPen.lineTo(220, 65);oFiberPen.stroke();oFiberPen.beginPath();oFiberPen.lineTo(215, 260);oFiberPen.lineTo(215, 190);oFiberPen.lineTo(210, 195);oFiberPen.stroke();oFiberPen.beginPath();oFiberPen.lineTo(215, 190);oFiberPen.lineTo(220, 195);oFiberPen.stroke();oFiberPen.beginPath();oFiberPen.lineTo(215, 380);oFiberPen.lineTo(215, 310);oFiberPen.lineTo(210, 315);oFiberPen.stroke();oFiberPen.beginPath();oFiberPen.lineTo(215, 310);oFiberPen.lineTo(220, 315);oFiberPen.stroke();oFiberPen.beginPath();oFiberPen.lineTo(250, 405);oFiberPen.lineTo(460, 405);oFiberPen.lineTo(455, 400);oFiberPen.stroke();oFiberPen.beginPath();oFiberPen.lineTo(460, 405);oFiberPen.lineTo(455, 410);oFiberPen.stroke();oFiberPen.beginPath();oFiberPen.lineTo(510, 380);oFiberPen.lineTo(250, 295);oFiberPen.lineTo(257, 302);oFiberPen.stroke();oFiberPen.beginPath();oFiberPen.lineTo(250, 295);oFiberPen.lineTo(260, 296);oFiberPen.stroke();oFiberPen.fillText('rootFiber', 170, 40);oFiberPen.fillText('App', 188, 168);oFiberPen.fillText('h1', 193, 290);oFiberPen.fillText('p', 198, 408);oFiberPen.fillText('jyy', 503, 408);oFiberPen.fillText('child', 153, 105);oFiberPen.fillText('return ', 218, 105);oFiberPen.fillText('child', 153, 227);oFiberPen.fillText('return', 218, 227);oFiberPen.fillText('child', 153, 348);oFiberPen.fillText('return', 218, 348);oFiberPen.fillText('sibling', 340, 399);oFiberPen.fillText('return', 365, 330);</script>

<blockquote>
<p>在mount时：创建fiberRoot和rootFiber，然后根据jsx创建workInProgress Fiber，把workInProgress Fiber切换成current Fiber。</p>
</blockquote>
<blockquote>
<p>在update时：会根据新的状态形成的jsx（ClassComponent的render或者FuncComponent的返回值）和current Fiber对比形（diff算法）成一棵workInProgress Fiber树，然后将fiberRoot的current指向workInProgress树，此时workInProgress就变成了current Fiber。</p>
</blockquote>
<pre><code>fiberRoot：指整个应用的根节点，只存在一个

rootFiber：ReactDOM.render或者ReactDOM.unstable_createRoot创建出来的应用的节点，可以存在多个。
</code></pre><h2 id="render阶段"><a href="#render阶段" class="headerlink" title="render阶段"></a>render阶段</h2><pre><code>render阶段的主要工作是构建Fiber树和生成effectList链表。
</code></pre><h3 id="react启动模式"><a href="#react启动模式" class="headerlink" title="react启动模式"></a>react启动模式</h3><pre><code>几个月之前，刚开始看react源码的时候，最新版本还是17.0.2，现在（2021-11-04）React 18版本就已经发布了 Alpha 版本。

React 18 带来了什么，我们可以参看官网的[发布计划](https://zh-hans.reactjs.org/blog/2021/06/08/the-plan-for-react-18.html)。

这里对18比较感兴趣的是并发渲染（concurrent rendering）机制，只有由新特性触发的更新会启用并发渲染。如果没用到新属性，即使用了ReactDOM.createRoot(rootNode).render(...)，也会走原路。

试着用了一下react 18版本，reactDom.render会报Warning：ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it&apos;s running React 17。

这就是react新的启动模式：
1）legacy 模式： ReactDOM.render(&lt;App /&gt;, rootNode)。在react18中使用这种模式与react17完全相同，但是会有一条警告，表明它已被弃用并切换到新的 Root API。
2）concurrent 模式： ReactDOM.createRoot(rootNode).render(&lt;App /&gt;)。并发模式，这个模式开启了所有的新功能。




还发现一个hydrateRoot，不知道是做什么的，但是看起来和createRoot很像，也可以这样用，渲染页面：
ReactDOM.hydrateRoot(rootNode).render(&lt;App /&gt;);暂留
</code></pre><h4 id="两种模式函数主要执行过程"><a href="#两种模式函数主要执行过程" class="headerlink" title="两种模式函数主要执行过程"></a>两种模式函数主要执行过程</h4>  <canvas id="primary-progress" width="500" height="400"></canvas>

  <script>
    const oMain = document.getElementById('primary-progress');
    const oMainPen = oMain.getContext('2d');oMainPen.font = '14px sans-serif';oMainPen.strokeRect(92, 10, 320, 30);oMainPen.strokeRect(30, 80, 450, 30);oMainPen.strokeRect(93, 150, 316, 30);oMainPen.strokeRect(10, 220, 480, 30);oMainPen.strokeRect(160, 290, 180, 30);oMainPen.fillText('createContainer（创建fiberRootNode、rootFiber）', 96, 30);oMainPen.fillText('updateContainer（创建update对象，保存在updateQueue环状链表中）', 34, 100);oMainPen.fillText('scheduleUpdateOnFiber（在Fiber上调度update）', 95, 163);oMainPen.fillText('ensureRootIsScheduled（调度根节点）', 125, 177);oMainPen.fillText('commitRoot（commit阶段）', 164, 310);oMainPen.fillStyle='blue';oMainPen.fillText('performSyncWorkOnRoot | performConcurrentWorkOnRoot（render阶段）', 12, 240);oMainPen.fillStyle='black';oMainPen.beginPath();oMainPen.lineTo(252, 40);oMainPen.lineTo(252, 75);oMainPen.stroke();oMainPen.beginPath();oMainPen.lineTo(248, 75);oMainPen.lineTo(256, 75);oMainPen.lineTo(252, 80);oMainPen.closePath();oMainPen.fill();oMainPen.beginPath();oMainPen.lineTo(252, 110);oMainPen.lineTo(252, 145);oMainPen.stroke();oMainPen.beginPath();oMainPen.lineTo(248, 145);oMainPen.lineTo(256, 145);oMainPen.lineTo(252, 150);oMainPen.closePath();oMainPen.fill();oMainPen.beginPath();oMainPen.lineTo(252, 180);oMainPen.lineTo(252, 215);oMainPen.stroke();oMainPen.beginPath();oMainPen.lineTo(248, 215);oMainPen.lineTo(256, 215);oMainPen.lineTo(252, 220);oMainPen.closePath();oMainPen.fill();oMainPen.beginPath();oMainPen.lineTo(252, 250);oMainPen.lineTo(252, 285);oMainPen.stroke();oMainPen.beginPath();oMainPen.lineTo(248, 285);oMainPen.lineTo(256, 285);oMainPen.lineTo(252, 290);oMainPen.closePath();oMainPen.fill();
  </script>

<h4 id="legacy模式"><a href="#legacy模式" class="headerlink" title="legacy模式"></a>legacy模式</h4><p>  render调用legacyRenderSubtreeIntoContainer，createContainer调用createFiberRoot创建fiberRootNode，调用createHostRootFiber创建rootFiber。其中fiberRootNode是整个项目的根节点，rootFiber是当前应用挂载的节点，也就是ReactDom.render调用后的根节点。<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最上层的节点是整个项目的根节点fiberRootNode</span></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById("root")); // rootFiber</span><br><span class="line"></span><br><span class="line">fiberRootNode.current = rootFiber;</span><br><span class="line">rootFiber.stateNode = fiberRootNode;</span><br></pre></td></tr></table></figure></p>
<p>  创建完fiber节点后，legacyRenderSubtreeIntoContainer调用updateContainer创建Update对象挂载到updateQueue环状链表上，然后执行scheduleUpdateOnFiber调用performSyncWorkOnRoot进入render阶段和commit阶段。</p>
<h4 id="concurrent模式"><a href="#concurrent模式" class="headerlink" title="concurrent模式"></a>concurrent模式</h4><p>  createRoot调用createContainer创建fiberRootNode和rootFiber。创建完fiber节点后，return new ReactDOMRoot(root); 调用ReactDOMRoot.propertype.render执行updateContainer，然后异步调度scheduleUpdateOnFiber，performConcurrentWorkOnRoot进入render阶段和commit阶段。</p>
<h4 id="两种模式的不同点"><a href="#两种模式的不同点" class="headerlink" title="两种模式的不同点"></a>两种模式的不同点</h4><p>  1）createContainer中传入的第二个参数tag不一样 一个是LegacyRoot 0，一个是ConcurrentRoot 1。<br>  2）requestUpdateLane中获取的lane的优先级不同。<br>  3) 在函数scheduleUpdateOnFiber中根据不同优先级进入不同分支，legacy模式进入performSyncWorkOnRoot，concurrent模式 <strong>异步调度</strong> performConcurrentWorkOnRoot。</p>
<h3 id="两种模式的函数调用过程"><a href="#两种模式的函数调用过程" class="headerlink" title="两种模式的函数调用过程"></a>两种模式的函数调用过程</h3>  <canvas id="renderTransfer" width="650" height="600"></canvas>

  <script>const oRenderTransfer = document.getElementById('renderTransfer');const oRenderTransferPen = oRenderTransfer.getContext('2d');oRenderTransferPen.font = '12px sans-serif';oRenderTransferPen.fillStyle='black';oRenderTransferPen.fillText('Lagacy', 205, 15);oRenderTransferPen.fillText('Concurrent', 412, 15);oRenderTransferPen.fillText('render', 210, 50);oRenderTransferPen.fillText('createRoot', 408, 50);oRenderTransferPen.fillText('ReactDOMRoot.prototype.render', 360, 191);oRenderTransferPen.fillText('createUpdate', 50, 270);oRenderTransferPen.fillText('enqueueUpdate', 160, 270);oRenderTransferPen.fillText('ensureRootIsScheduled', 270, 270);oRenderTransferPen.fillText('root.tag === LegacyRoot', 146, 315);oRenderTransferPen.fillText('performSyncWorkOnRoot', 142, 385);oRenderTransferPen.fillText('performConcurrentWorkOnRoot', 380, 385);oRenderTransferPen.fillText('rederRootSync', 165, 425);oRenderTransferPen.fillText('renderRootConcurrent', 400, 425);oRenderTransferPen.fillText('workLoopSync', 170, 460);oRenderTransferPen.fillText('workLoopConcurrent', 430, 460);oRenderTransferPen.fillText('performUnitWork', 286, 492);oRenderTransferPen.fillText('beginWork', 198, 535);oRenderTransferPen.fillText('completeWork', 402, 535);oRenderTransferPen.fillText('.', 333, 555);oRenderTransferPen.fillText('.', 333, 558);oRenderTransferPen.fillText('.', 333, 561);oRenderTransferPen.fillText('.', 333, 564);oRenderTransferPen.fillText('.', 333, 567);oRenderTransferPen.fillText('.', 333, 570);oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(225, 20);oRenderTransferPen.lineTo(225, 35);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(221, 35);oRenderTransferPen.lineTo(229, 35);oRenderTransferPen.lineTo(225, 40);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(442, 20);oRenderTransferPen.lineTo(442, 35);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(438, 35);oRenderTransferPen.lineTo(446, 35);oRenderTransferPen.lineTo(442, 40);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(225, 55);oRenderTransferPen.lineTo(225, 80);oRenderTransferPen.lineTo(270, 80);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(270, 76);oRenderTransferPen.lineTo(270, 84);oRenderTransferPen.lineTo(275, 80);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(442, 55);oRenderTransferPen.lineTo(442, 80);oRenderTransferPen.lineTo(392, 80);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(392, 76);oRenderTransferPen.lineTo(392, 84);oRenderTransferPen.lineTo(387, 80);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(334, 86);oRenderTransferPen.lineTo(334, 93);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(331, 93);oRenderTransferPen.lineTo(337, 93);oRenderTransferPen.lineTo(334, 97);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(334, 108);oRenderTransferPen.lineTo(334, 115);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(331, 115);oRenderTransferPen.lineTo(337, 115);oRenderTransferPen.lineTo(334, 120);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(225, 80);oRenderTransferPen.lineTo(225, 156);oRenderTransferPen.lineTo(278, 156);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(278, 153);oRenderTransferPen.lineTo(278, 159);oRenderTransferPen.lineTo(281, 156);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(442, 80);oRenderTransferPen.lineTo(442, 156);oRenderTransferPen.lineTo(389, 156);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(389, 153);oRenderTransferPen.lineTo(389, 159);oRenderTransferPen.lineTo(386, 156);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(225, 156);oRenderTransferPen.lineTo(225, 217);oRenderTransferPen.lineTo(270, 217);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(270, 212);oRenderTransferPen.lineTo(270, 222);oRenderTransferPen.lineTo(275, 217);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(442, 156);oRenderTransferPen.lineTo(442, 178);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(438, 178);oRenderTransferPen.lineTo(446, 178);oRenderTransferPen.lineTo(442, 182);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(442, 192);oRenderTransferPen.lineTo(442, 217);oRenderTransferPen.lineTo(400, 217);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(400, 212);oRenderTransferPen.lineTo(400, 222);oRenderTransferPen.lineTo(395, 217);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(335, 222);oRenderTransferPen.lineTo(335, 240);oRenderTransferPen.lineTo(90, 240);oRenderTransferPen.lineTo(90, 253);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(87, 253);oRenderTransferPen.lineTo(93, 253);oRenderTransferPen.lineTo(90, 258);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(205, 240);oRenderTransferPen.lineTo(205, 253);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(202, 253);oRenderTransferPen.lineTo(208, 253);oRenderTransferPen.lineTo(205, 258);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(335, 240);oRenderTransferPen.lineTo(335, 253);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(332, 253);oRenderTransferPen.lineTo(338, 253);oRenderTransferPen.lineTo(335, 258);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(335, 272);oRenderTransferPen.lineTo(335, 290);oRenderTransferPen.lineTo(205, 290);oRenderTransferPen.lineTo(205, 300);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(202, 300);oRenderTransferPen.lineTo(208, 300);oRenderTransferPen.lineTo(205, 305);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(335, 290);oRenderTransferPen.lineTo(465, 290);oRenderTransferPen.lineTo(465, 370);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(462, 370);oRenderTransferPen.lineTo(468, 370);oRenderTransferPen.lineTo(465, 375);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(200, 320);oRenderTransferPen.lineTo(180, 340);oRenderTransferPen.stroke();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(210, 320);oRenderTransferPen.lineTo(230, 340);oRenderTransferPen.stroke();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(180, 355);oRenderTransferPen.lineTo(200, 372);oRenderTransferPen.stroke();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(230, 355);oRenderTransferPen.lineTo(210, 372);oRenderTransferPen.stroke();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(206, 388);oRenderTransferPen.lineTo(206, 408);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(203, 408);oRenderTransferPen.lineTo(209, 408);oRenderTransferPen.lineTo(206, 412);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(465, 388);oRenderTransferPen.lineTo(465, 408);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(462, 408);oRenderTransferPen.lineTo(468, 408);oRenderTransferPen.lineTo(465, 412);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(465, 398);oRenderTransferPen.lineTo(256, 421);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(256, 418);oRenderTransferPen.lineTo(258, 424);oRenderTransferPen.lineTo(250, 422);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(206, 428);oRenderTransferPen.lineTo(206, 448);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(203, 448);oRenderTransferPen.lineTo(209, 448);oRenderTransferPen.lineTo(206, 452);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(465, 428);oRenderTransferPen.lineTo(465, 448);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(462, 448);oRenderTransferPen.lineTo(468, 448);oRenderTransferPen.lineTo(465, 452);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(206, 463);oRenderTransferPen.lineTo(206, 488);oRenderTransferPen.lineTo(275, 488);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(275, 484);oRenderTransferPen.lineTo(275, 492);oRenderTransferPen.lineTo(279, 488);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(465, 463);oRenderTransferPen.lineTo(465, 488);oRenderTransferPen.lineTo(391, 488);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(391, 484);oRenderTransferPen.lineTo(391, 492);oRenderTransferPen.lineTo(387, 488);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(335, 494);oRenderTransferPen.lineTo(335, 510);oRenderTransferPen.lineTo(225, 510);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(335, 510);oRenderTransferPen.lineTo(442, 510);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(225, 510);oRenderTransferPen.lineTo(225, 520);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(221, 520);oRenderTransferPen.lineTo(229, 520);oRenderTransferPen.lineTo(225, 525);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(442, 510);oRenderTransferPen.lineTo(442, 520);oRenderTransferPen.stroke();oRenderTransferPen.beginPath();oRenderTransferPen.lineTo(438, 520);oRenderTransferPen.lineTo(446, 520);oRenderTransferPen.lineTo(442, 525);oRenderTransferPen.closePath();oRenderTransferPen.fill();oRenderTransferPen.font = '8px sans-serif';oRenderTransferPen.fillText('传参不同', 235, 214);oRenderTransferPen.fillText('传参不同', 403, 214);oRenderTransferPen.fillText('createFiberRoot', 302, 106);oRenderTransferPen.fillText('createHostFoorFiber', 298, 126);oRenderTransferPen.fillText('listenToAllSupportedEvents', 283, 158);oRenderTransferPen.fillText('创建update对象', 57, 280);oRenderTransferPen.fillText('保存在updateQueue环状链表上', 145, 280);oRenderTransferPen.fillText('是', 180, 330);oRenderTransferPen.fillText('否', 223, 330);oRenderTransferPen.fillText('同步调用', 160, 350);oRenderTransferPen.fillText('异步调用', 220, 350);oRenderTransferPen.fillText('异步调用', 470, 350);oRenderTransferPen.fillText('是否使用了新功能', 470, 394);oRenderTransferPen.fillText('是', 470, 412);oRenderTransferPen.fillText('否', 420, 399);oRenderTransferPen.fillText('workOnProgress !== null', 110, 480);oRenderTransferPen.fillText('workOnProgress !== null && !shouldYield()', 470, 480);oRenderTransferPen.font = '14px sans-serif';oRenderTransferPen.fillStyle='red';oRenderTransferPen.fillText('createContainer', 278, 85);oRenderTransferPen.fillText('updateContainer', 281, 221);</script>


<pre><code>两种启动模式，我们一起回顾一下。高角度地来看就是createContainer和updateContainer。
1）刚开始是进行一些初始化的工作，createContainer创建fiberRoot和rootFiber（有时间仔细看一下这里），绑定上所有支持的函数，这一步两种模式是相同的，Legacy是调用暴露出的render函数，Concurrent是调用暴露出的createRoot函数。
2）下一步就是updateContainer，之后的render阶段以及commit阶段都是在其中调用或连接。我们先看render阶段，这时两种模式都调用了updateContainer，Legacy是之前render函数调用，Concurrent是再次调用createRoot函数返回的new ReactDOMRoot的原型上的render方法调用，二者传参不同。updateContainer首先调用createUpdate创建update对象，再调用enqueueUpdate将其保存在updateQueue环状链表上，最后调用ensureRootIsScheduled，ensureRootIsScheduled会根据之前Legacy和Concurrent传参的不同，有不同的处理。Legacy这边会判断root.tag是否等于LegacyRoot，如果相等则同步调用performSyncWorkOnRoot，否则异步调用performSyncWorkOnRoot，而Concurrent这边是直接异步调用performConcurrentWorkOnRoot。接下来performSyncWorkOnRoot会调用renderRootSync,而performConcurrentWorkOnRoot这时会判断，是否调用了新的功能特性，如果没有则会调用renderRootSync，走回Legacy的模式。如果使用了新的功能特性才会调用renderRootConcurrent。renderRootSync和renderRootConcurrent都回调用prepareFreshStack，这里很重要，prepareFreshStack会生成新的workInProgress的Fiber对象，然后renderRootSync会调用workLoopSync，renderRootConcurrent会调用workLoopConcurrent，workLoopSync和workLoopConcurrent二者都会Loop调用performUnitOfWork，只是调用的条件有一点不同，workLoopSync的停止条件只有workInProgress===null，而，workLoopConcurrent的停止条件是workInProgress === null或shouldYield()，也就是不仅workInProgress为null时会停下来，当浏览器没有足够的时间的时候也会停下来，这也是我们所说的异步可中断机制中的可中断实现。之后performUnitOfWork会调用beginWork和completeWork完成协调和调度的过程，然后将调度结果传给commitRoot函数，进入commit阶段。render阶段的从beginWork和completeWork到commitRoot的详细学习，放在下面。
</code></pre><h3 id="render阶段函数调用过程"><a href="#render阶段函数调用过程" class="headerlink" title="render阶段函数调用过程"></a>render阶段函数调用过程</h3><ul>
<li>workInProgress：新创建的workInProgress Fiber</li>
<li>performUnitOfWork：workInprogress 和 已经创建的Fiber连接形成fiber树，这个过程类似于深度优化遍历。</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  React.createElement(</span><br><span class="line">    &apos;div&apos;, </span><br><span class="line">    &#123;key: &apos;name&apos;&#125;, </span><br><span class="line">    [React.createElement(&apos;h1&apos;, &#123;key: &apos;num&apos;&#125;, 123), &apos;jyy&apos;]), </span><br><span class="line">  document.getElementById(&quot;root&quot;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
  <canvas id="performUnitOfWork" width="600" height="460"></canvas>

<script>
  const oPerformUnitOfWork = document.getElementById('performUnitOfWork');
  const oPerformUnitOfWorkPen = oPerformUnitOfWork.getContext('2d');
  oPerformUnitOfWorkPen.font = '14px sans-serif';oPerformUnitOfWorkPen.fillStyle='black';oPerformUnitOfWorkPen.strokeRect(150, 10, 100, 50);oPerformUnitOfWorkPen.strokeRect(150, 140, 100, 50);oPerformUnitOfWorkPen.strokeRect(150, 260, 100, 50);oPerformUnitOfWorkPen.strokeRect(150, 380, 100, 50);oPerformUnitOfWorkPen.strokeRect(460, 260, 100, 50);oPerformUnitOfWorkPen.beginPath();oPerformUnitOfWorkPen.lineTo(185, 60);oPerformUnitOfWorkPen.lineTo(185, 140);oPerformUnitOfWorkPen.lineTo(180, 135);oPerformUnitOfWorkPen.stroke();oPerformUnitOfWorkPen.beginPath();oPerformUnitOfWorkPen.lineTo(185, 140);oPerformUnitOfWorkPen.lineTo(190, 135);oPerformUnitOfWorkPen.stroke();oPerformUnitOfWorkPen.beginPath();oPerformUnitOfWorkPen.lineTo(185, 190);oPerformUnitOfWorkPen.lineTo(185, 260);oPerformUnitOfWorkPen.lineTo(180, 255);oPerformUnitOfWorkPen.stroke();oPerformUnitOfWorkPen.beginPath();oPerformUnitOfWorkPen.lineTo(185, 260);oPerformUnitOfWorkPen.lineTo(190, 255);oPerformUnitOfWorkPen.stroke();oPerformUnitOfWorkPen.beginPath();oPerformUnitOfWorkPen.lineTo(185, 310);oPerformUnitOfWorkPen.lineTo(185, 380);oPerformUnitOfWorkPen.lineTo(180, 375);oPerformUnitOfWorkPen.stroke();oPerformUnitOfWorkPen.beginPath();oPerformUnitOfWorkPen.lineTo(185, 380);oPerformUnitOfWorkPen.lineTo(190, 375);oPerformUnitOfWorkPen.stroke();oPerformUnitOfWorkPen.beginPath();oPerformUnitOfWorkPen.lineTo(215, 140);oPerformUnitOfWorkPen.lineTo(215, 60);oPerformUnitOfWorkPen.lineTo(210, 65);oPerformUnitOfWorkPen.stroke();oPerformUnitOfWorkPen.beginPath();oPerformUnitOfWorkPen.lineTo(215, 60);oPerformUnitOfWorkPen.lineTo(220, 65);oPerformUnitOfWorkPen.stroke();oPerformUnitOfWorkPen.beginPath();oPerformUnitOfWorkPen.lineTo(215, 260);oPerformUnitOfWorkPen.lineTo(215, 190);oPerformUnitOfWorkPen.lineTo(210, 195);oPerformUnitOfWorkPen.stroke();oPerformUnitOfWorkPen.beginPath();oPerformUnitOfWorkPen.lineTo(215, 190);oPerformUnitOfWorkPen.lineTo(220, 195);oPerformUnitOfWorkPen.stroke();oPerformUnitOfWorkPen.beginPath();oPerformUnitOfWorkPen.lineTo(215, 380);oPerformUnitOfWorkPen.lineTo(215, 310);oPerformUnitOfWorkPen.lineTo(210, 315);oPerformUnitOfWorkPen.stroke();oPerformUnitOfWorkPen.beginPath();oPerformUnitOfWorkPen.lineTo(215, 310);oPerformUnitOfWorkPen.lineTo(220, 315);oPerformUnitOfWorkPen.stroke();oPerformUnitOfWorkPen.beginPath();oPerformUnitOfWorkPen.lineTo(250, 295);oPerformUnitOfWorkPen.lineTo(460, 295);oPerformUnitOfWorkPen.lineTo(455, 290);oPerformUnitOfWorkPen.stroke();oPerformUnitOfWorkPen.beginPath();oPerformUnitOfWorkPen.lineTo(460, 295);oPerformUnitOfWorkPen.lineTo(455, 300);oPerformUnitOfWorkPen.stroke();oPerformUnitOfWorkPen.beginPath();oPerformUnitOfWorkPen.lineTo(510, 260);oPerformUnitOfWorkPen.lineTo(250, 175);oPerformUnitOfWorkPen.lineTo(257, 182);oPerformUnitOfWorkPen.stroke();oPerformUnitOfWorkPen.beginPath();oPerformUnitOfWorkPen.lineTo(250, 175);oPerformUnitOfWorkPen.lineTo(260, 176);oPerformUnitOfWorkPen.stroke();oPerformUnitOfWorkPen.fillText('rootFiber', 170, 40);oPerformUnitOfWorkPen.fillText('div.name', 168, 168);oPerformUnitOfWorkPen.fillText('h1.num', 178, 290);oPerformUnitOfWorkPen.fillText('123', 189, 408);oPerformUnitOfWorkPen.fillText('jyy', 503, 288);oPerformUnitOfWorkPen.fillText('child', 153, 105);oPerformUnitOfWorkPen.fillText('return ', 218, 105);oPerformUnitOfWorkPen.fillText('child', 153, 227);oPerformUnitOfWorkPen.fillText('return', 218, 227);oPerformUnitOfWorkPen.fillText('sibling', 280, 310);oPerformUnitOfWorkPen.fillText('return', 365, 210);oPerformUnitOfWorkPen.fillStyle='#F612E3';oPerformUnitOfWorkPen.fillText('1.beginWork', 60, 40);oPerformUnitOfWorkPen.fillText('2.beginWork', 60, 168);oPerformUnitOfWorkPen.fillText('3-1.beginWork', 50, 290);oPerformUnitOfWorkPen.fillText('4-1.beginWork', 360, 270);oPerformUnitOfWorkPen.fillStyle='#3CF612';oPerformUnitOfWorkPen.fillText('3-2.completeWork', 255, 290);oPerformUnitOfWorkPen.fillText('4-2.completeWork', 470, 240);oPerformUnitOfWorkPen.fillText('4-3.completeWork', 255, 168);oPerformUnitOfWorkPen.fillText('4-4.completeWork', 255, 40);
</script>


<ol>
<li><p><code>beginWork阶段</code> 从根节点rootFiber开始，遍历到叶子节点，每次遍历到的节点都会执行beginWork，并且传入当前Fiber节点，然后创建或复用它的子Fiber节点，并赋值给workInProgress.child。</p>
</li>
<li><p><code>completeWork阶段</code> 在捕获阶段遍历到子节点之后，会执行completeWork方法，执行完成之后会判断此节点的兄弟节点存不存在，如果存在就会为兄弟节点执行completeWork，当全部兄弟节点执行完之后，会向上‘冒泡’到父节点执行completeWork，直到rootFiber。</p>
</li>
</ol>
  <div class="post-warning">注意：当遍历到只有一个子文本节点的Fiber时，该Fiber节点的子节点不会执行beginWork和completeWork，如图中的‘count’文本节点。这是react的一种优化手段</div>

<ul>
<li>render阶段整体调用流程：</li>
</ul>
  <canvas id="render" width="700" height="530"></canvas>


  <script>var oRender = document.getElementById('render');var oRenderPen = oRender.getContext('2d');oRenderPen.font = '10px sans-serif';oRenderPen.strokeRect(159, 10, 130, 30);oRenderPen.fillText('performSyncWorkOnRoot', 165, 28);oRenderPen.beginPath();oRenderPen.lineTo(224, 40);oRenderPen.lineTo(224, 54);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(220, 54);oRenderPen.lineTo(228, 54);oRenderPen.lineTo(224, 59);oRenderPen.closePath();oRenderPen.fill();oRenderPen.strokeRect(320, 10, 158, 30);oRenderPen.fillText('performConcurrentWorkOnRoot', 325, 28);oRenderPen.beginPath();oRenderPen.lineTo(398, 40);oRenderPen.lineTo(398, 54);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(394, 54);oRenderPen.lineTo(402, 54);oRenderPen.lineTo(398, 59);oRenderPen.closePath();oRenderPen.fill();oRenderPen.strokeRect(185, 60, 80, 30);oRenderPen.fillText('workLoopSync', 192, 78);oRenderPen.beginPath();oRenderPen.lineTo(265, 75);oRenderPen.lineTo(285, 75);oRenderPen.lineTo(285, 104);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(281, 104);oRenderPen.lineTo(289, 104);oRenderPen.lineTo(285, 109);oRenderPen.closePath();oRenderPen.fill();oRenderPen.strokeRect(340, 60, 110, 30);oRenderPen.fillText('workLoopConcurrent', 347, 78);oRenderPen.beginPath();oRenderPen.lineTo(340, 75);oRenderPen.lineTo(320, 75);oRenderPen.lineTo(320, 104);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(316, 104);oRenderPen.lineTo(324, 104);oRenderPen.lineTo(320, 109);oRenderPen.closePath();oRenderPen.fill();oRenderPen.strokeRect(253, 110, 100, 30);oRenderPen.fillText('performUnitOfWork', 257, 128);oRenderPen.beginPath();oRenderPen.lineTo(253, 125);oRenderPen.lineTo(224, 125);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(224, 121);oRenderPen.lineTo(224, 129);oRenderPen.lineTo(219, 125);oRenderPen.closePath();oRenderPen.fill();oRenderPen.strokeRect(160, 110, 58, 30);oRenderPen.fillText('beginWork', 164, 128);oRenderPen.beginPath();oRenderPen.lineTo(189, 140);oRenderPen.lineTo(189, 155);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(185, 155);oRenderPen.lineTo(193, 155);oRenderPen.lineTo(189, 160);oRenderPen.closePath();oRenderPen.fill();oRenderPen.beginPath();oRenderPen.lineTo(189, 160);oRenderPen.lineTo(244, 185);oRenderPen.lineTo(189, 210);oRenderPen.lineTo(134, 185);oRenderPen.closePath();oRenderPen.fillText('current !== null', 152, 182);oRenderPen.fillText('update | mount', 154, 193);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(134, 185);oRenderPen.lineTo(70, 185);oRenderPen.lineTo(70, 220);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(66, 220);oRenderPen.lineTo(74, 220);oRenderPen.lineTo(70, 225);oRenderPen.closePath();oRenderPen.fill();oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(244, 185);oRenderPen.lineTo(342, 185);oRenderPen.lineTo(342, 250);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(338, 250);oRenderPen.lineTo(346, 250);oRenderPen.lineTo(342, 255);oRenderPen.closePath();oRenderPen.fill();oRenderPen.beginPath();oRenderPen.lineTo(70, 225);oRenderPen.lineTo(108, 240);oRenderPen.lineTo(70, 255);oRenderPen.lineTo(32, 240);oRenderPen.closePath();oRenderPen.stroke();oRenderPen.fillText('是否能复用', 44, 243);oRenderPen.beginPath();oRenderPen.lineTo(108, 240);oRenderPen.lineTo(262, 240);oRenderPen.lineTo(262, 250);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(258, 250);oRenderPen.lineTo(266, 250);oRenderPen.lineTo(262, 255);oRenderPen.closePath();oRenderPen.fill();oRenderPen.beginPath();oRenderPen.lineTo(70, 255);oRenderPen.lineTo(70, 275);oRenderPen.lineTo(70, 275);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(66, 275);oRenderPen.lineTo(74, 275);oRenderPen.lineTo(70, 280);oRenderPen.closePath();oRenderPen.fill();oRenderPen.strokeRect(1, 280, 144, 30);oRenderPen.fillText('bailoutOnAlreadyFinishedWork', 2, 298);oRenderPen.beginPath();oRenderPen.lineTo(70, 310);oRenderPen.lineTo(70, 340);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(66, 340);oRenderPen.lineTo(74, 340);oRenderPen.lineTo(70, 345);oRenderPen.closePath();oRenderPen.fill();oRenderPen.beginPath();oRenderPen.lineTo(70, 345);oRenderPen.lineTo(128, 360);oRenderPen.lineTo(70, 375);oRenderPen.lineTo(12, 360);oRenderPen.closePath();oRenderPen.stroke();oRenderPen.fillText('节点是否需要更新', 31, 364);oRenderPen.beginPath();oRenderPen.lineTo(70, 375);oRenderPen.lineTo(70, 395);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(66, 395);oRenderPen.lineTo(74, 395);oRenderPen.lineTo(70, 400);oRenderPen.closePath();oRenderPen.fill();oRenderPen.strokeRect(30, 400, 82, 30);oRenderPen.fillText('cloneChildFibers', 31, 418);oRenderPen.beginPath();oRenderPen.lineTo(128, 360);oRenderPen.lineTo(142, 360);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(142, 356);oRenderPen.lineTo(142, 364);oRenderPen.lineTo(147, 360);oRenderPen.closePath();oRenderPen.fill();oRenderPen.strokeRect(147, 344, 50, 30);oRenderPen.fillText('return null', 148, 362);oRenderPen.strokeRect(236, 255, 128, 30);oRenderPen.fillText('根据workInProgress.tag进入', 236, 268);oRenderPen.fillText('不同的Fiber创建函数', 254, 280);oRenderPen.beginPath();oRenderPen.lineTo(262, 285);oRenderPen.lineTo(262, 315);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(258, 315);oRenderPen.lineTo(266, 315);oRenderPen.lineTo(262, 320);oRenderPen.closePath();oRenderPen.fill();oRenderPen.beginPath();oRenderPen.lineTo(342, 285);oRenderPen.lineTo(342, 315);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(338, 315);oRenderPen.lineTo(346, 315);oRenderPen.lineTo(342, 320);oRenderPen.closePath();oRenderPen.fill();oRenderPen.strokeRect(202, 320, 96, 30);oRenderPen.fillText('reconcileChildFibers', 203, 338);oRenderPen.strokeRect(310, 320, 82, 30);oRenderPen.fillText('mountchildFibers', 312, 338);oRenderPen.beginPath();oRenderPen.lineTo(262, 350);oRenderPen.lineTo(262, 375);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(258, 375);oRenderPen.lineTo(266, 375);oRenderPen.lineTo(262, 380);oRenderPen.closePath();oRenderPen.fill();oRenderPen.beginPath();oRenderPen.lineTo(342, 350);oRenderPen.lineTo(342, 375);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(338, 375);oRenderPen.lineTo(346, 375);oRenderPen.lineTo(342, 380);oRenderPen.closePath();oRenderPen.fill();oRenderPen.strokeRect(258, 380, 90, 30);oRenderPen.fillText('childReconclier', 268, 398);oRenderPen.strokeRect(272, 430, 64, 30);oRenderPen.fillText('createFibers', 275, 448);oRenderPen.beginPath();oRenderPen.lineTo(302, 410);oRenderPen.lineTo(302, 425);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(298, 425);oRenderPen.lineTo(306, 425);oRenderPen.lineTo(302, 430);oRenderPen.closePath();oRenderPen.fill();oRenderPen.beginPath();oRenderPen.lineTo(353, 125);oRenderPen.lineTo(365, 125);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(365, 121);oRenderPen.lineTo(365, 129);oRenderPen.lineTo(370, 125);oRenderPen.closePath();oRenderPen.fill();oRenderPen.strokeRect(370, 110, 108, 30);oRenderPen.fillText('completeUnitOfWork', 374, 128);oRenderPen.beginPath();oRenderPen.lineTo(478, 125);oRenderPen.lineTo(505, 125);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(505, 121);oRenderPen.lineTo(505, 129);oRenderPen.lineTo(510, 125);oRenderPen.closePath();oRenderPen.fill();oRenderPen.strokeRect(510, 110, 76, 30);oRenderPen.fillText('completeWork', 514, 128);oRenderPen.beginPath();oRenderPen.lineTo(548, 140);oRenderPen.lineTo(548, 155);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(544, 155);oRenderPen.lineTo(552, 155);oRenderPen.lineTo(548, 160);oRenderPen.closePath();oRenderPen.fill();oRenderPen.strokeRect(482, 160, 142, 30);oRenderPen.fillText('根据workInProgress.tag的类型', 483, 172);oRenderPen.fillText('进入不同的函数', 516, 184);oRenderPen.beginPath();oRenderPen.lineTo(550, 190);oRenderPen.lineTo(550, 200);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(546, 200);oRenderPen.lineTo(554, 200);oRenderPen.lineTo(550, 205);oRenderPen.closePath();oRenderPen.fill();oRenderPen.beginPath();oRenderPen.lineTo(551, 205);oRenderPen.lineTo(599, 220);oRenderPen.lineTo(551, 235);oRenderPen.lineTo(503, 220);oRenderPen.closePath();oRenderPen.stroke();oRenderPen.fillText('update | mount', 516, 222);oRenderPen.beginPath();oRenderPen.lineTo(503, 220);oRenderPen.lineTo(458, 220);oRenderPen.lineTo(458, 265);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(454, 265);oRenderPen.lineTo(462, 265);oRenderPen.lineTo(458, 270);oRenderPen.closePath();oRenderPen.fill();oRenderPen.beginPath();oRenderPen.lineTo(599, 220);oRenderPen.lineTo(644, 220);oRenderPen.lineTo(644, 265);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(640, 265);oRenderPen.lineTo(648, 265);oRenderPen.lineTo(644, 270);oRenderPen.closePath();oRenderPen.fill();oRenderPen.strokeRect(404, 270, 120, 30);oRenderPen.fillText('updateHostComponent$1', 405, 288);oRenderPen.beginPath();oRenderPen.lineTo(460, 300);oRenderPen.lineTo(460, 435);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(456, 435);oRenderPen.lineTo(464, 435);oRenderPen.lineTo(460, 440);oRenderPen.closePath();oRenderPen.fill();oRenderPen.strokeRect(404, 440, 192, 30);oRenderPen.fillText('把带有effectTag的节点加入到effectList中', 405, 453);oRenderPen.fillText('返回下一个workInProgress节点', 430, 465);oRenderPen.beginPath();oRenderPen.lineTo(530, 470);oRenderPen.lineTo(530, 485);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(526, 485);oRenderPen.lineTo(534, 485);oRenderPen.lineTo(530, 490);oRenderPen.closePath();oRenderPen.fill();oRenderPen.strokeRect(610, 270, 70, 30);oRenderPen.fillText('createInstance', 611, 288);oRenderPen.beginPath();oRenderPen.lineTo(644, 300);oRenderPen.lineTo(644, 315);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(640, 315);oRenderPen.lineTo(648, 315);oRenderPen.lineTo(644, 320);oRenderPen.closePath();oRenderPen.fill();oRenderPen.strokeRect(603, 320, 86, 30);oRenderPen.fillText('appendAllChildren', 604, 338);oRenderPen.beginPath();oRenderPen.lineTo(644, 350);oRenderPen.lineTo(644, 365);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(640, 365);oRenderPen.lineTo(648, 365);oRenderPen.lineTo(644, 370);oRenderPen.closePath();oRenderPen.fill();oRenderPen.strokeRect(598, 370, 96, 30);oRenderPen.fillText('finalizeInitialchildren', 599, 388);oRenderPen.beginPath();oRenderPen.lineTo(644, 400);oRenderPen.lineTo(644, 455);oRenderPen.lineTo(601, 455);oRenderPen.stroke();oRenderPen.beginPath();oRenderPen.lineTo(601, 451);oRenderPen.lineTo(601, 459);oRenderPen.lineTo(596, 455);oRenderPen.closePath();oRenderPen.fill();oRenderPen.strokeRect(496, 490, 70, 30);oRenderPen.fillText('commitRoot', 503, 508);oRenderPen.fillStyle='blue';oRenderPen.fillText('update', 92, 180);oRenderPen.fillText('mount', 260, 180);oRenderPen.fillText('否', 120, 236);oRenderPen.fillText('能', 74, 270);oRenderPen.fillText('否', 130, 357);oRenderPen.fillText('是', 74, 388);oRenderPen.fillText('clone子节点', 114, 418);oRenderPen.fillText('update',228, 305);oRenderPen.fillText('mount', 344, 305);oRenderPen.fillText('带上effectTag',190, 315);oRenderPen.fillText('不带上effectTag', 350, 315);oRenderPen.fillText('diff算法', 225, 370);oRenderPen.fillText('创建子节点', 214, 450);oRenderPen.fillText('假设进入了', 430, 175);oRenderPen.fillText('HostComponent', 402, 187);oRenderPen.fillText('update', 467, 216);oRenderPen.fillText('mount', 603, 216);oRenderPen.fillText('处理props将变化的部分赋值给', 462, 250);oRenderPen.fillText('workInprogress.updateQueue', 462, 262);oRenderPen.fillText('创建dom节点赋值', 529, 282);oRenderPen.fillText('给fiber.stateNode', 528, 294);oRenderPen.fillText('将后代节点插入当前节点', 492, 338);oRenderPen.fillText('初始化dom属性', 525, 387);</script>


<h3 id="beginWork"><a href="#beginWork" class="headerlink" title="beginWork"></a>beginWork</h3><p>  beginWork主要的工作是创建或复用子fiber节点。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params">current, workInProgress, renderLanes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> updateLanes = workInProgress.lanes;</span><br><span class="line">  <span class="comment">// 1.update时满足条件即可复用current fiber进入bailoutOnAlreadyFinishedWork函数</span></span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> oldProps = current.memoizedProps;</span><br><span class="line">    <span class="keyword">var</span> newProps = workInProgress.pendingProps;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldProps !== newProps || hasContextChanged() || (workInProgress.type !== current.type )) &#123;</span><br><span class="line">      didReceiveUpdate = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!includesSomeLane(renderLanes, updateLanes)) &#123;</span><br><span class="line">      didReceiveUpdate = <span class="literal">false</span>; </span><br><span class="line">      <span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">       <span class="comment">// ......</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((current.flags &amp; ForceUpdateForLegacySuspense) !== NoFlags) &#123;</span><br><span class="line">        didReceiveUpdate = <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  workInProgress.lanes = NoLanes;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.根据tag来创建不同的fiber 最后进入reconcileChildren函数</span></span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> IndeterminateComponent: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> LazyComponent: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> FunctionComponent: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> ClassComponent: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> HostRoot: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> HostComponent: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> HostText: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> SuspenseComponent: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> HostPortal: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> ForwardRef: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> Fragment: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> Mode: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> Profiler: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> ContextProvider: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> ContextConsumer: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> MemoComponent: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> SimpleMemoComponent: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> IncompleteClassComponent: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> SuspenseListComponent: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> FundamentalComponent: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> ScopeComponent: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> Block:   <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> OffscreenComponent: <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> LegacyHiddenComponent: <span class="comment">// ......</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>( <span class="string">"Unknown unit of work tag ("</span> + workInProgress.tag + <span class="string">"). This error is likely caused by a bug in React. Please file an issue."</span> );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  从代码中可以看到参数中有current Fiber，也就是当前真实dom对应的Fiber树，在之前介绍Fiber双缓存机制中，我们知道在首次渲染时除了rootFiber外，current 等于 null，因为首次渲染dom还没构建出来，在update时current不等于 null，因为update时dom树已经存在了，所以beginWork函数中用current === null来判断是mount还是update进入不同的逻辑。</p>
<blockquote>
<p>mount：根据fiber.tag进入不同fiber的创建函数，最后都会调用到reconcileChildren创建子Fiber<br>update：在构建workInProgress的时候，当满足条件时，会复用current Fiber来进行优化，也就是进入bailoutOnAlreadyFinishedWork的逻辑，能复用didReceiveUpdate变量是false，复用的条件是<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">oldProps === newProps &amp;&amp; workInProgress.type === current.type 属性和fiber的type不变</span><br><span class="line">!includesSomeLane(renderLanes, updateLanes) 更新的优先级是否足够。</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="bailoutOnAlreadyFinishedWork"><a href="#bailoutOnAlreadyFinishedWork" class="headerlink" title="bailoutOnAlreadyFinishedWork"></a>bailoutOnAlreadyFinishedWork</h4>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bailoutOnAlreadyFinishedWork</span>(<span class="params">current, workInProgress, renderLanes</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 优先级足够则进入cloneChildFibers，否则返回null，不需要更新</span></span><br><span class="line">  <span class="keyword">if</span> (!includesSomeLane(renderLanes, workInProgress.childLanes)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cloneChildFibers(current, workInProgress);</span><br><span class="line">    <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="reconcileChildren-mountChildFibers"><a href="#reconcileChildren-mountChildFibers" class="headerlink" title="reconcileChildren/mountChildFibers"></a>reconcileChildren/mountChildFibers</h4><p>  创建子fiber的过程会进入reconcileChildren（可以看一下源码），该函数的作用是为workInProgress fiber节点生成它的child fiber即 workInProgress.child。<strong>然后继续深度优先遍历它的子节点执行相同的操作。</strong></p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildren</span>(<span class="params">current, workInProgress, nextChildren, renderLanes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">    workInProgress.child = mountChildFibers(workInProgress, <span class="literal">null</span>, nextChildren, renderLanes);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  reconcileChildren会区分mount和update两种情况，进入reconcileChildFibers或mountChildFibers，reconcileChildFibers和mountChildFibers最终其实都是调用ChildReconciler传递不同的参数返回的函数，这个参数（shouldTrackSideEffects）用来表示是否追踪副作用，在ChildReconciler中用shouldTrackSideEffects来判断是否为对应的节点打上effectTag。</p>
<p>  为Fiber打上effectTag之后在commit阶段会被执行对应dom的增删改，而且在reconcileChildren的时候，rootFiber是存在alternate的，即rootFiber存在对应的current Fiber，所以rootFiber会走reconcileChildFibers的逻辑，所以shouldTrackSideEffects等于true会追踪副作用，最后为rootFiber打上Placement的effectTag，然后将dom一次性插入，提高性能。</p>
<h3 id="completeWork"><a href="#completeWork" class="headerlink" title="completeWork"></a>completeWork</h3><p>  completeWork主要工作是处理fiber的props、创建dom、创建effectList。</p>
<p>  从函数调用来看，我们可以从performUnitOfWork来看，在WorkLoopSync或WorkLoopConcurrent中都会do…while调用performUnitOfWork，停止的条件是workInprogress等于null。</p>
<p>  performUnitOfWork首先会调用beginWork，创建或复用子fiber节点，如果子节点还有有子节点，则将其赋为新的workInprogress继续执行beginWork。如果没有子节点开始调用completeUnitOfWork。</p>
<p>  completeUnitOfWork会do…while调用completeWork，如果当前有兄弟节点siblingFiber，则对将siblingFiber赋值给workInProgress，再走beginWork。。。如果当前子节点有returnFiber则将returnFiber赋给workInProgress，继续执行completeWork。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeWork</span>(<span class="params">current, workInProgress, renderLanes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newProps = workInProgress.pendingProps; </span><br><span class="line"></span><br><span class="line">  popTreeContext(workInProgress);</span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> IndeterminateComponent:</span><br><span class="line">    <span class="keyword">case</span> LazyComponent:</span><br><span class="line">    <span class="keyword">case</span> SimpleMemoComponent:</span><br><span class="line">    <span class="keyword">case</span> FunctionComponent:</span><br><span class="line">    <span class="keyword">case</span> ForwardRef:</span><br><span class="line">    <span class="keyword">case</span> Fragment:</span><br><span class="line">    <span class="keyword">case</span> Mode:</span><br><span class="line">    <span class="keyword">case</span> Profiler:</span><br><span class="line">    <span class="keyword">case</span> ContextConsumer:</span><br><span class="line">    <span class="keyword">case</span> MemoComponent:</span><br><span class="line">      ...</span><br><span class="line">    <span class="keyword">case</span> ClassComponent:</span><br><span class="line">      ...</span><br><span class="line">    <span class="keyword">case</span> HostComponent:</span><br><span class="line">      &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (current !== <span class="literal">null</span> &amp;&amp; workInProgress.stateNode != <span class="literal">null</span>) &#123;</span><br><span class="line">          updateHostComponent(current, workInProgress, type, newProps, rootContainerInstance);</span><br><span class="line">          ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          ...</span><br><span class="line">          <span class="keyword">var</span> instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);</span><br><span class="line"></span><br><span class="line">          appendAllChildren(instance, workInProgress, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">          workInProgress.stateNode = instance;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) &#123;</span><br><span class="line">            markUpdate(workInProgress);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bubbleProperties(workInProgress);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>根据workInProgress.tag进入不同函数，我们以HostComponent举例</li>
<li>update时（除了判断current===null外还需要判断workInProgress.stateNode===null），调用updateHostComponent处理props（包括onClick、style、children …），并将处理好的props赋值给updatePayload,最后会保存在workInProgress.updateQueue上。<br>mount时 调用createInstance创建dom，将后代dom节点插入刚创建的dom中，调用finalizeInitialChildren处理props（和updateHostComponent处理的逻辑类似）</li>
<li>在beginWork的mount时，rootFiber存在对应的current，所以他会执行mountChildFibers打上Placement的effectTag，在冒泡阶段也就是执行completeWork时，我们将子孙节点通过appendAllChildren挂载到新创建的dom节点上，最后就可以一次性将内存中的节点用dom原生方法反应到真实dom中。</li>
<li>在beginWork 中我们知道有的节点被打上了effectTag的标记，有的没有，而在commit阶段时要遍历所有包含effectTag的Fiber来执行对应的增删改，那我们还需要从Fiber树中找到这些带effectTag的节点嘛，答案是不需要的，这里是以空间换时间，在执行completeWork的时候遇到了带effectTag的节点，会将这个节点加入一个叫effectList中,所以在commit阶段只要遍历effectList就可以了（rootFiber.firstEffect.nextEffect就可以访问带effectTag的Fiber了）</li>
</ol>
<p>  画个简单的示意图：</p>
  <canvas id="pic" width="400" height="200"></canvas>


<script>
  const oPic = document.getElementById('pic');
  const oPicPen = oPic.getContext('2d');oPicPen.beginPath();oPicPen.lineTo(200, 20);oPicPen.lineTo(200, 60);oPicPen.lineTo(140, 100);oPicPen.lineTo(100, 140);oPicPen.lineTo(75, 170);oPicPen.stroke();oPicPen.beginPath();oPicPen.lineTo(200, 60);oPicPen.lineTo(260, 100);oPicPen.lineTo(220, 140);oPicPen.stroke();oPicPen.beginPath();oPicPen.lineTo(140, 100);oPicPen.lineTo(180, 140);oPicPen.lineTo(155, 170);oPicPen.stroke();oPicPen.beginPath();oPicPen.lineTo(260, 100);oPicPen.lineTo(300, 140);oPicPen.stroke();oPicPen.beginPath();oPicPen.lineTo(100, 140);oPicPen.lineTo(125, 170);oPicPen.stroke();oPicPen.beginPath();oPicPen.lineTo(180, 140);oPicPen.lineTo(205, 170);oPicPen.stroke();oPicPen.strokeStyle='blue';oPicPen.beginPath();oPicPen.lineTo(180, 10);oPicPen.lineTo(180, 60);oPicPen.lineTo(120, 100);oPicPen.lineTo(80, 140);oPicPen.lineTo(55, 180);oPicPen.lineTo(138, 180);oPicPen.lineTo(110, 140);oPicPen.lineTo(170, 140);oPicPen.lineTo(143, 180);oPicPen.lineTo(225, 180);oPicPen.lineTo(160, 100);oPicPen.lineTo(250, 100);oPicPen.lineTo(205, 150);oPicPen.lineTo(320, 150);oPicPen.lineTo(280, 100);oPicPen.lineTo(220, 60);oPicPen.lineTo(220, 10);oPicPen.stroke();oPicPen.fillStyle='red';oPicPen.fillText('1.begin', 142, 20);oPicPen.fillText('2.begin', 140, 60);oPicPen.fillText('3.begin', 82, 100);oPicPen.fillText('4.begin', 42, 140);oPicPen.fillText('5.begin', 25, 170);oPicPen.fillText('6.begin', 100, 190);oPicPen.fillText('7.b', 157, 140);oPicPen.fillText('8.begin', 150, 179);oPicPen.fillText('9.begin', 226, 190);oPicPen.fillText('10.begin', 213, 98);oPicPen.fillText('11.begin', 210, 148);oPicPen.fillText('12.begin', 320, 158);oPicPen.fillStyle='green';oPicPen.fillText('5.complete', 2, 180);oPicPen.fillText('6.complete', 83, 179);oPicPen.fillText('6.c', 110, 140);oPicPen.fillText('8.complete', 150, 190);oPicPen.fillText('9.complete', 226, 179);oPicPen.fillText('9.c', 180, 140);oPicPen.fillText('9.complete', 150, 98);oPicPen.fillText('11.complete', 210, 158);oPicPen.fillText('12.complete', 320, 148);oPicPen.fillText('12.complete', 280, 100);oPicPen.fillText('12.complete', 225, 60);oPicPen.fillText('12.complete', 225, 20);
</script>

<h2 id="commit阶段"><a href="#commit阶段" class="headerlink" title="commit阶段"></a>commit阶段</h2><h2 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h2><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h2 id="状态更新流程"><a href="#状态更新流程" class="headerlink" title="状态更新流程"></a>状态更新流程</h2><h2 id="hooks"><a href="#hooks" class="headerlink" title="hooks"></a>hooks</h2><h2 id="scheduler-amp-Lane"><a href="#scheduler-amp-Lane" class="headerlink" title="scheduler&amp;Lane"></a>scheduler&amp;Lane</h2><h2 id="concurrent模式-1"><a href="#concurrent模式-1" class="headerlink" title="concurrent模式"></a>concurrent模式</h2><h2 id="context"><a href="#context" class="headerlink" title="context"></a>context</h2><h2 id="事件系统"><a href="#事件系统" class="headerlink" title="事件系统"></a>事件系统</h2><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  不止停留在理论，也不只停留在源码。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/React/" rel="tag"># React</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/07/13/interview/" rel="next" title="interview">
                <i class="fa fa-chevron-left"></i> interview
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/10/28/npm/" rel="prev" title="npm">
                npm <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/background22.jpg" alt="Lemon">
            
              <p class="site-author-name" itemprop="name">Lemon</p>
              <p class="site-description motion-element" itemprop="description">乘风破浪</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#一、前言"><span class="nav-number">1.</span> <span class="nav-text">一、前言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#直接看源码"><span class="nav-number">1.1.</span> <span class="nav-text">直接看源码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ReactDOM-render"><span class="nav-number">1.1.1.</span> <span class="nav-text">ReactDOM.render</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、ReactDOM-render"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">1、ReactDOM.render</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、cjs、amd、umd和esm"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">2、cjs、amd、umd和esm</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、其他小点"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">3、其他小点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#怎么学react源码"><span class="nav-number">1.2.</span> <span class="nav-text">怎么学react源码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二、react源码框架总览"><span class="nav-number">2.</span> <span class="nav-text">二、react源码框架总览</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#jsx"><span class="nav-number">2.1.</span> <span class="nav-text">jsx</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fiber双缓存"><span class="nav-number">2.2.</span> <span class="nav-text">Fiber双缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#scheduler"><span class="nav-number">2.3.</span> <span class="nav-text">scheduler</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#reconciler（render-阶段）"><span class="nav-number">2.4.</span> <span class="nav-text">reconciler（render 阶段）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#renderer（commit-阶段）"><span class="nav-number">2.5.</span> <span class="nav-text">renderer（commit 阶段）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#concurrent"><span class="nav-number">2.6.</span> <span class="nav-text">concurrent</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三、react源码深入解析"><span class="nav-number">3.</span> <span class="nav-text">三、react源码深入解析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#源码目录结构和调试"><span class="nav-number">3.1.</span> <span class="nav-text">源码目录结构和调试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jsx-1"><span class="nav-number">3.2.</span> <span class="nav-text">jsx</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#virtual-Dom-是什么"><span class="nav-number">3.2.1.</span> <span class="nav-text">virtual Dom 是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么用virtual-Dom"><span class="nav-number">3.2.2.</span> <span class="nav-text">为什么用virtual Dom</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jsx-amp-createElement"><span class="nav-number">3.2.3.</span> <span class="nav-text">jsx&amp;createElement</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fiber架构"><span class="nav-number">3.3.</span> <span class="nav-text">Fiber架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#render阶段"><span class="nav-number">3.4.</span> <span class="nav-text">render阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#react启动模式"><span class="nav-number">3.4.1.</span> <span class="nav-text">react启动模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#两种模式函数主要执行过程"><span class="nav-number">3.4.1.1.</span> <span class="nav-text">两种模式函数主要执行过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#legacy模式"><span class="nav-number">3.4.1.2.</span> <span class="nav-text">legacy模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#concurrent模式"><span class="nav-number">3.4.1.3.</span> <span class="nav-text">concurrent模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#两种模式的不同点"><span class="nav-number">3.4.1.4.</span> <span class="nav-text">两种模式的不同点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两种模式的函数调用过程"><span class="nav-number">3.4.2.</span> <span class="nav-text">两种模式的函数调用过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#render阶段函数调用过程"><span class="nav-number">3.4.3.</span> <span class="nav-text">render阶段函数调用过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#beginWork"><span class="nav-number">3.4.4.</span> <span class="nav-text">beginWork</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#bailoutOnAlreadyFinishedWork"><span class="nav-number">3.4.4.1.</span> <span class="nav-text">bailoutOnAlreadyFinishedWork</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reconcileChildren-mountChildFibers"><span class="nav-number">3.4.4.2.</span> <span class="nav-text">reconcileChildren/mountChildFibers</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#completeWork"><span class="nav-number">3.4.5.</span> <span class="nav-text">completeWork</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#commit阶段"><span class="nav-number">3.5.</span> <span class="nav-text">commit阶段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#diff算法"><span class="nav-number">3.6.</span> <span class="nav-text">diff算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#生命周期"><span class="nav-number">3.7.</span> <span class="nav-text">生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#状态更新流程"><span class="nav-number">3.8.</span> <span class="nav-text">状态更新流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hooks"><span class="nav-number">3.9.</span> <span class="nav-text">hooks</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#scheduler-amp-Lane"><span class="nav-number">3.10.</span> <span class="nav-text">scheduler&amp;Lane</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#concurrent模式-1"><span class="nav-number">3.11.</span> <span class="nav-text">concurrent模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#context"><span class="nav-number">3.12.</span> <span class="nav-text">context</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件系统"><span class="nav-number">3.13.</span> <span class="nav-text">事件系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实践"><span class="nav-number">3.14.</span> <span class="nav-text">实践</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">3.15.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lemon</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
