<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="算法&面试题," />










<meta name="description" content="一、 HTML相关1、 常⻅见标签类型以及用法以及 meta 中常⻅见属性的含义【https://www.runoob.com/tags/html-reference.html】 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596">
<meta name="keywords" content="算法&amp;面试题">
<meta property="og:type" content="article">
<meta property="og:title" content="前端试题集锦（基础）">
<meta property="og:url" content="http://yoursite.com/2020/03/22/前端试题集锦（基础）/index.html">
<meta property="og:site_name" content="立夏">
<meta property="og:description" content="一、 HTML相关1、 常⻅见标签类型以及用法以及 meta 中常⻅见属性的含义【https://www.runoob.com/tags/html-reference.html】 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-05-28T09:38:20.189Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="前端试题集锦（基础）">
<meta name="twitter:description" content="一、 HTML相关1、 常⻅见标签类型以及用法以及 meta 中常⻅见属性的含义【https://www.runoob.com/tags/html-reference.html】 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/03/22/前端试题集锦（基础）/"/>





  <title>前端试题集锦（基础） | 立夏</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">立夏</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-窝">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            窝
          </a>
        </li>
      
        
        <li class="menu-item menu-item-签">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-类">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-档">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-于">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/22/前端试题集锦（基础）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lemon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/background10.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="立夏">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">前端试题集锦（基础）</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-22T10:04:00+08:00">
                2020-03-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/积累/" itemprop="url" rel="index">
                    <span itemprop="name">积累</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="一、-HTML相关"><a href="#一、-HTML相关" class="headerlink" title="一、 HTML相关"></a>一、 HTML相关</h2><h3 id="1、-常⻅见标签类型以及用法以及-meta-中常⻅见属性的含义"><a href="#1、-常⻅见标签类型以及用法以及-meta-中常⻅见属性的含义" class="headerlink" title="1、 常⻅见标签类型以及用法以及 meta 中常⻅见属性的含义"></a>1、 常⻅见标签类型以及用法以及 meta 中常⻅见属性的含义</h3><p>【<a href="https://www.runoob.com/tags/html-reference.html】" target="_blank" rel="noopener">https://www.runoob.com/tags/html-reference.html】</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--...--&gt;   	定义注释</span><br><span class="line">&lt;!DOCTYPE&gt;   	定义文档类型</span><br><span class="line">&lt;a&gt;	          定义超文本链接</span><br><span class="line">&lt;abbr&gt;   	    定义缩写</span><br><span class="line">&lt;acronym&gt;	    定义只取首字母的缩写，不支持HTML5</span><br><span class="line">&lt;address&gt;	    定义文档作者或拥有者的联系信息</span><br><span class="line">&lt;applet&gt;	    HTML5中不赞成使用。定义嵌入的 applet。</span><br><span class="line">&lt;area&gt;	      定义图像映射内部的区域</span><br><span class="line">&lt;article&gt;     定义一个文章区域 <span class="comment">#New	</span></span><br><span class="line">&lt;aside&gt;       定义页面的侧边栏内容 <span class="comment">#New	</span></span><br><span class="line">&lt;audio&gt;New   	定义音频内容</span><br><span class="line">&lt;b&gt;	          定义文本粗体</span><br><span class="line">&lt;base&gt;   	    定义页面中所有链接的默认地址或默认目标。</span><br><span class="line">&lt;basefont&gt;  	HTML5不支持，不赞成使用。定义页面中文本的默认字体、颜色或尺寸。</span><br><span class="line">&lt;bdi&gt;         允许您设置一段文本，使其脱离其父元素的文本方向设置。 <span class="comment">#New	</span></span><br><span class="line">&lt;bdo&gt;	        定义文字方向</span><br><span class="line">&lt;big&gt;	        定义大号文本，HTML5不支持</span><br><span class="line">&lt;blockquote&gt;	定义长的引用</span><br><span class="line">&lt;body&gt;	      定义文档的主体</span><br><span class="line">&lt;br&gt;	        定义换行</span><br><span class="line">&lt;button&gt;	    定义一个点击按钮</span><br><span class="line">&lt;canvas&gt;      定义图形，比如图表和其他图像,标签只是图形容器，您必须使用脚本来绘制图形 <span class="comment">#New	</span></span><br><span class="line">&lt;caption&gt;    	定义表格标题</span><br><span class="line">&lt;center&gt;	    HTML5不支持，不赞成使用。定义居中文本。</span><br><span class="line">&lt;cite&gt;	      定义引用(citation)</span><br><span class="line">&lt;code&gt;	      定义计算机代码文本</span><br><span class="line">&lt;col&gt;	        定义表格中一个或多个列的属性值</span><br><span class="line">&lt;colgroup&gt;   	定义表格中供格式化的列组</span><br><span class="line">&lt;<span class="built_in">command</span>&gt;     定义命令按钮，比如单选按钮、复选框或按钮 <span class="comment">#New	</span></span><br><span class="line">&lt;datalist&gt;    定义选项列表。请与 input 元素配合使用该元素，来定义 input 可能的值。 <span class="comment">#New	</span></span><br><span class="line">&lt;dd&gt;	        定义列表中项目的描述</span><br><span class="line">&lt;del&gt;	        定义被删除文本</span><br><span class="line">&lt;details&gt;     用于描述文档或文档某个部分的细节 <span class="comment">#New	</span></span><br><span class="line">&lt;dfn&gt;	        定义项目</span><br><span class="line">&lt;dialog&gt;      定义对话框，比如提示框 <span class="comment">#New	</span></span><br><span class="line">&lt;dir&gt;       	HTML5不支持，不赞成使用。定义目录列表。</span><br><span class="line">&lt;div&gt;       	定义文档中的节</span><br><span class="line">&lt;dl&gt;	        定义列表详情</span><br><span class="line">&lt;dt&gt;	        定义列表中的项目</span><br><span class="line">&lt;em&gt;	        定义强调文本</span><br><span class="line">&lt;embed&gt;       定义嵌入的内容，比如插件。 <span class="comment">#New	</span></span><br><span class="line">&lt;fieldset&gt;   	定义围绕表单中元素的边框</span><br><span class="line">&lt;figcaption&gt;  定义&lt;figure&gt; 元素的标题 <span class="comment">#New	</span></span><br><span class="line">&lt;figure&gt;      规定独立的流内容（图像、图表、照片、代码等等）。 <span class="comment">#New	</span></span><br><span class="line">&lt;font&gt;      	HTML5不支持，不赞成使用。定义文字的字体、尺寸和颜色。</span><br><span class="line">&lt;footer&gt;      定义 section 或 document 的页脚。 <span class="comment">#New	</span></span><br><span class="line">&lt;form&gt;	      定义了HTML文档的表单</span><br><span class="line">&lt;frame&gt;     	定义框架集的窗口或框架</span><br><span class="line">&lt;frameset&gt;	  定义框架集</span><br><span class="line">&lt;h1&gt; to &lt;h6&gt;	定义 HTML 标题</span><br><span class="line">&lt;head&gt;      	定义关于文档的信息</span><br><span class="line">&lt;header&gt;      定义了文档的头部区域 <span class="comment">#New	</span></span><br><span class="line">&lt;hr&gt;        	定义水平线</span><br><span class="line">&lt;html&gt;      	定义 HTML 文档</span><br><span class="line">&lt;i&gt;	          定义斜体字</span><br><span class="line">&lt;iframe&gt;	    定义内联框架</span><br><span class="line">&lt;img&gt;	        定义图像</span><br><span class="line">&lt;input&gt;	      定义输入控件</span><br><span class="line">&lt;ins&gt;	        定义被插入文本</span><br><span class="line">&lt;kbd&gt;	        定义键盘文本</span><br><span class="line">&lt;keygen&gt;      规定用于表单的密钥对生成器字段。 <span class="comment">#New	</span></span><br><span class="line">&lt;label&gt;	      定义 input 元素的标注</span><br><span class="line">&lt;legend&gt;	    定义 fieldset 元素的标题。</span><br><span class="line">&lt;li&gt;	        定义列表的项目</span><br><span class="line">&lt;link&gt;	      定义文档与外部资源的关系</span><br><span class="line">&lt;map&gt;	        定义图像映射</span><br><span class="line">&lt;mark&gt;        定义带有记号的文本。请在需要突出显示文本时使用 &lt;m&gt; 标签。 <span class="comment">#New	</span></span><br><span class="line">&lt;menu&gt;	      不赞成使用。定义菜单列表。</span><br><span class="line">&lt;meta&gt;	      定义关于 HTML 文档的元信息。</span><br><span class="line">&lt;meter&gt;       定义度量衡。仅用于已知最大和最小值的度量。 <span class="comment">#New	</span></span><br><span class="line">&lt;nav&gt;         定义导航链接的部分 <span class="comment">#New	</span></span><br><span class="line">&lt;noframes&gt;	  定义针对不支持框架的用户的替代内容。HTML5不支持</span><br><span class="line">&lt;noscript&gt;    定义针对不支持客户端脚本的用户的替代内容。</span><br><span class="line">&lt;object&gt;	    定义内嵌对象</span><br><span class="line">&lt;ol&gt;	        定义有序列表。</span><br><span class="line">&lt;optgroup&gt;	  定义选择列表中相关选项的组合。</span><br><span class="line">&lt;option&gt;	    定义选择列表中的选项。</span><br><span class="line">&lt;output&gt;      定义不同类型的输出，比如脚本的输出。 <span class="comment">#New	</span></span><br><span class="line">&lt;p&gt;	          定义段落。</span><br><span class="line">&lt;param&gt;	      定义对象的参数。</span><br><span class="line">&lt;pre&gt;	        定义预格式文本。</span><br><span class="line">&lt;progress&gt;    定义运行中的进度（进程）。 <span class="comment">#New	</span></span><br><span class="line">&lt;q&gt;	          定义短的引用。</span><br><span class="line">&lt;rp&gt;&lt;rp&gt;      标签在 ruby 注释中使用，以定义不支持 ruby 元素的浏览器所显示的内容。 <span class="comment">#New	</span></span><br><span class="line">&lt;rt&gt;&lt;rt&gt;      标签定义字符（中文注音或字符）的解释或发音。 <span class="comment">#New	</span></span><br><span class="line">&lt;ruby&gt;&lt;ruby&gt;  标签定义 ruby 注释（中文注音或字符）。 <span class="comment">#New	</span></span><br><span class="line">&lt;s&gt;	          不赞成使用。定义加删除线的文本。</span><br><span class="line">&lt;samp&gt;	      定义计算机代码样本。</span><br><span class="line">&lt;script&gt;	    定义客户端脚本。</span><br><span class="line">&lt;section&gt;&lt;section&gt; 标签定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。 <span class="comment">#New	</span></span><br><span class="line">&lt;select&gt;	     定义选择列表（下拉列表）。</span><br><span class="line">&lt;small&gt;	       定义小号文本。</span><br><span class="line">&lt;<span class="built_in">source</span>&gt;&lt;<span class="built_in">source</span>&gt; 标签为媒介元素（比如 &lt;video&gt; 和 &lt;audio&gt;）定义媒介资源。 <span class="comment">#New	</span></span><br><span class="line">&lt;span&gt;	       定义文档中的节。</span><br><span class="line">&lt;strike&gt;	     HTML5不支持，不赞成使用。定义加删除线文本。</span><br><span class="line">&lt;strong&gt;	     定义强调文本。</span><br><span class="line">&lt;style&gt;	       定义文档的样式信息。</span><br><span class="line">&lt;sub&gt;	         定义下标文本。</span><br><span class="line">&lt;summary&gt;&lt;summary&gt; 标签包含 details 元素的标题，<span class="string">"details"</span> 元素用于描述有关文档或文档片段的详细信息。 <span class="comment">#New	</span></span><br><span class="line">&lt;sup&gt;	         定义上标文本。</span><br><span class="line">&lt;table&gt;        定义表格。</span><br><span class="line">&lt;tbody&gt;	       定义表格中的主体内容。</span><br><span class="line">&lt;td&gt;	         定义表格中的单元。</span><br><span class="line">&lt;textarea&gt;	   定义多行的文本输入控件。</span><br><span class="line">&lt;tfoot&gt;	       定义表格中的表注内容（脚注）。</span><br><span class="line">&lt;th&gt;	         定义表格中的表头单元格。</span><br><span class="line">&lt;thead&gt;	       定义表格中的表头内容。</span><br><span class="line">&lt;time&gt;         定义日期或时间，或者两者。 <span class="comment">#New	</span></span><br><span class="line">&lt;title&gt;	       定义文档的标题。</span><br><span class="line">&lt;tr&gt;	         定义表格中的行。</span><br><span class="line">&lt;track&gt;&lt;track&gt; 标签为诸如 video 元素之类的媒介规定外部文本轨道。 <span class="comment">#New	</span></span><br><span class="line">&lt;tt&gt;	         定义打字机文本。</span><br><span class="line">&lt;u&gt;	           不赞成使用。定义下划线文本。</span><br><span class="line">&lt;ul&gt;	         定义无序列表。</span><br><span class="line">&lt;var&gt;	         定义文本的变量部分。</span><br><span class="line">&lt;video&gt;&lt;video&gt; 标签定义视频，比如电影片段或其他视频流。 <span class="comment">#New	</span></span><br><span class="line">&lt;wbr&gt;          规定在文本中的何处适合添加换行符。 <span class="comment">#New</span></span><br></pre></td></tr></table></figure>
<p>meta标签相关学习：HTML中的meta标签常用属性及其作用总结</p>
<h3 id="2、-块级元素、内联元素相关分类"><a href="#2、-块级元素、内联元素相关分类" class="headerlink" title="2、 块级元素、内联元素相关分类"></a>2、 块级元素、内联元素相关分类</h3><blockquote>
<p>各自的特点：</p>
<ol>
<li>块元素的特点：<br> a.占满整行<br> b.可以通过css改变宽高以及内外边距<br> d.可以容纳内联元素和其他块元素。</li>
<li>内联元素的特点：<br> a.不占满整行<br> b.内容决定宽高，不可以通过css改变宽高以及内外边距<br> d.内联元素只能容纳文本或者其他内联元素。</li>
</ol>
</blockquote>
<blockquote>
<p>常见的块元素：<br>  div p ul ol form  table h1 - h6 hr address  blockquote  center  dir dl fieldset isindex menu noframes noscript pre<br>  常见的内联元素：<br>  span input textarea a img label  sup strong sub u tt select br strike i abbr var  acronym  b  bdo  big  cite  code  dfn  em  font kbd q s samp small<br>  块级元素和内联元素之间的转换：</p>
<ol>
<li>display：block/inline-block/inline/none;</li>
<li>float<br>当把行内元素设置完float:left/right后，该行内元素的display属性会被赋予block值，且拥有浮动特性。行内元素去除了之间的莫名空白。</li>
<li>position<br>当为行内元素进行定位时，position:absolute与position:fixed.都会使得原先的行内元素变为块级元素。</li>
</ol>
</blockquote>
<h3 id="3、-DOM-Document-Object-Model-文档对象模型"><a href="#3、-DOM-Document-Object-Model-文档对象模型" class="headerlink" title="3、 DOM(Document Object Model) 文档对象模型"></a>3、 DOM(Document Object Model) 文档对象模型</h3><ul>
<li><p>DOM的全称是Document Object Model，文档对象模型。</p>
</li>
<li><p>DOM如何创建<br>它本质上是一种尝试将HTML文档的结构和内容转换为可供各种程序使用的对象模型。<br>DOM的对象结构由所谓的“节点树”表示。 它之所以被称为树是因为它可以被认为是具有单个父茎的树，其分枝成几个子枝，每个子枝可以具有叶子。 在这种情况下，父“stem”是根元素，子“branches”是嵌套元素，“leaves”是元素中的内容。</p>
</li>
</ul>
<ol>
<li><p>当HTML无效时<br> DOM是有效HTML文档的接口。 在创建DOM的过程中，浏览器可以纠正HTML代码中的一些无效。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">我们以此HTML文档为例：</span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    Hello, world!</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">该文档缺少和元素，这是有效HTML的要求。 如果我们查看生成的DOM树，我们将看到这已得到纠正：</span><br><span class="line">html</span><br><span class="line">    head</span><br><span class="line">    body</span><br><span class="line">        Hello, world!</span><br></pre></td></tr></table></figure>
</li>
<li><p>当JavaScript修改了DOM</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;&lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">    &lt;p style=&quot;display: none;&quot;&gt;How are you?&lt;/p&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">上面的DOM结构将包含 &lt;p&gt; 元素</span><br><span class="line">html</span><br><span class="line">    head</span><br><span class="line">    body</span><br><span class="line">        h1</span><br><span class="line">            Hello, world!</span><br><span class="line">        p</span><br><span class="line">            How are you?</span><br></pre></td></tr></table></figure>
<ul>
<li>使用:: before和:: after选择器创建的伪元素构成CSSOM和渲染树的一部分，但在技术上不是DOM的一部分。 这是因为DOM仅由源HTML文档构建，不包括应用于元素的样式。<br>尽管伪元素不是DOM的一部分，但它们仍在我们的devtools元素检查器中。<br>这就是为什么伪元素不能被Javascript直接获取到的原因，因为伪元素不是DOM的一部分。</li>
</ul>
</li>
</ol>
<blockquote>
<p>参考: <a href="https://juejin.im/post/5c01e2b051882518eb1f785a" target="_blank" rel="noopener">https://juejin.im/post/5c01e2b051882518eb1f785a</a><br>      <a href="https://blog.csdn.net/qq_29663071/article/details/50982822" target="_blank" rel="noopener">https://blog.csdn.net/qq_29663071/article/details/50982822</a></p>
</blockquote>
<h3 id="4、H5-带来了哪些新标签、新特性"><a href="#4、H5-带来了哪些新标签、新特性" class="headerlink" title="4、H5 带来了哪些新标签、新特性"></a>4、H5 带来了哪些新标签、新特性</h3><h4 id="1-常用新标签"><a href="#1-常用新标签" class="headerlink" title="1) 常用新标签"></a>1) 常用新标签</h4>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;header&gt; 语义 :定义页面的头部 页眉&lt;/header&gt;</span><br><span class="line">&lt;nav&gt; 语义 :定义导航栏 &lt;/nav&gt; </span><br><span class="line">&lt;footer&gt; 语义: 定义 页面底部 页脚&lt;/footer&gt;</span><br><span class="line">&lt;article&gt; 语义: 定义文章&lt;/article&gt;</span><br><span class="line">&lt;section&gt; 语义： 定义区域&lt;/section&gt;</span><br><span class="line">&lt;aside&gt; 语义： 定义其所处内容之外的内容 侧边&lt;/aside&gt;</span><br></pre></td></tr></table></figure>
<h4 id="2-datalist-标签定义选项列表。请与-input-元素配合使用该元素"><a href="#2-datalist-标签定义选项列表。请与-input-元素配合使用该元素" class="headerlink" title="2) datalist 标签定义选项列表。请与 input 元素配合使用该元素"></a>2) datalist 标签定义选项列表。请与 input 元素配合使用该元素</h4>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; value=&quot;请输入明星&quot; list=&quot;star&quot;/&gt;</span><br><span class="line">&lt;datalist id=&quot;star&quot;&gt;</span><br><span class="line">  &lt;option value=&quot;刘德华&quot;&gt;刘德华&lt;/option&gt;</span><br><span class="line">  &lt;option value=&quot;刘若英&quot;&gt;刘若英&lt;/option&gt;</span><br><span class="line">  &lt;option value=&quot;刘晓庆&quot;&gt;刘晓庆&lt;/option&gt;</span><br><span class="line">  &lt;option value=&quot;戚薇&quot;&gt;戚薇&lt;/option&gt;</span><br><span class="line">  &lt;option value=&quot;戚继光&quot;&gt;戚继光&lt;/option&gt;</span><br><span class="line">&lt;/datalist&gt;</span><br></pre></td></tr></table></figure>
<p>  <input type="text" value="请输入明星" list="star"><br>  <datalist id="star"><br>    <option value="刘德华">刘德华</option><br>    <option value="刘若英">刘若英</option><br>    <option value="刘晓庆">刘晓庆</option><br>    <option value="戚薇">戚薇</option><br>    <option value="戚继光">戚继光</option><br>  </datalist></p>
<h4 id="3-fieldset-元素可将表单内的相关元素分组，打包-legend-搭配使用"><a href="#3-fieldset-元素可将表单内的相关元素分组，打包-legend-搭配使用" class="headerlink" title="3) fieldset 元素可将表单内的相关元素分组，打包 legend 搭配使用"></a>3) fieldset 元素可将表单内的相关元素分组，打包 legend 搭配使用</h4>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;fieldset&gt;</span><br><span class="line">  &lt;legend&gt;用户登录&lt;/legend&gt;</span><br><span class="line">  标题</span><br><span class="line">  用户名: &lt;input type=&quot;text&quot; /&gt;</span><br><span class="line">  密　码: &lt;input type=&quot;password&quot; /&gt;</span><br><span class="line">&lt;/fieldset&gt;</span><br></pre></td></tr></table></figure>
<p>  <fieldset><br>    <legend>用户登录</legend><br>    标题<br>    用户名: <input type="text"><br>    密　码: <input type="password"><br>  </fieldset><br><br></p>
<h4 id="4-新增的input-type属性值"><a href="#4-新增的input-type属性值" class="headerlink" title="4) 新增的input type属性值"></a>4) 新增的input type属性值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入邮箱格式 email**** &lt;input type=&quot;email&quot; /&gt;</span><br><span class="line">输入手机号码格式 tel**** &lt;input type=&quot;tel&quot; /&gt;</span><br><span class="line">输入url格式 url**** &lt;input type=&quot;url&quot; /&gt;</span><br><span class="line">输入数字格式 number**** &lt;input type=&quot;number&quot; /&gt;</span><br><span class="line">搜索框（体现语义化） search**** &lt;input type=&quot;search&quot; /&gt;</span><br><span class="line">自由拖动滑块 range**** &lt;input type=&quot;range&quot; /&gt;</span><br><span class="line">小时分钟 time**** &lt;input type=&quot;time&quot; /&gt;</span><br><span class="line">年月日 date**** &lt;input type=&quot;date&quot; /&gt;</span><br><span class="line">时间 datetime**** &lt;input type=&quot;datetime&quot; /&gt;</span><br><span class="line">月年month**** &lt;input type=&quot;month&quot; /&gt;</span><br><span class="line">星期 年 week**** &lt;input type=&quot;week&quot; /&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>常用新属性<br>占位符 当用户输入的时候 里面的文字消失 删除所有文字，自动返回 placeholder<strong><strong> <input type="text" placeholder="请输入用户名"><br>规定当页面加载时 input 元素应该自动获得焦点 autofocus</strong></strong> <figure class="highlight bash"><figcaption><span><input type< span></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">多文件上传 multiple**** &lt;input <span class="built_in">type</span>=<span class="string">"file"</span> multiple /&gt;</span><br><span class="line">规定表单是否应该启用自动完成功能 有2个值，一个是on 一个是off on 代表记录已经输入的值 1.autocomplete 首先需要提交按钮 &lt;br /&gt;2.这个表单您必须给他名字autocomplete****</span><br><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> autocomplete=<span class="string">"off"</span> /&gt;</span><br><span class="line">必填项 内容不能为空 required**** &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> required /&gt;</span><br><span class="line">规定激活（使元素获得焦点）元素的快捷键 采用 alt + s的形式 accesskey**** &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> accesskey=<span class="string">"s"</span> /&gt;</span><br><span class="line"></span><br><span class="line">输入邮箱格式 email**** &lt;input <span class="built_in">type</span>=<span class="string">"email"</span> /&gt;</span><br><span class="line">输入手机号码格式 tel**** &lt;input <span class="built_in">type</span>=<span class="string">"tel"</span> /&gt;</span><br><span class="line">输入url格式 url**** &lt;input <span class="built_in">type</span>=<span class="string">"url"</span> /&gt;</span><br><span class="line">输入数字格式 number**** &lt;input <span class="built_in">type</span>=<span class="string">"number"</span> /&gt;</span><br><span class="line">搜索框（体现语义化） search**** &lt;input <span class="built_in">type</span>=<span class="string">"search"</span> /&gt;</span><br><span class="line">自由拖动滑块 range**** &lt;input <span class="built_in">type</span>=<span class="string">"range"</span> /&gt;</span><br><span class="line">小时分钟 time**** &lt;input <span class="built_in">type</span>=<span class="string">"time"</span> /&gt;</span><br><span class="line">年月日 date**** &lt;input <span class="built_in">type</span>=<span class="string">"date"</span> /&gt;</span><br><span class="line">时间 datetime**** &lt;input <span class="built_in">type</span>=<span class="string">"datetime"</span> /&gt;</span><br><span class="line">月年month**** &lt;input <span class="built_in">type</span>=<span class="string">"month"</span> /&gt;</span><br><span class="line">星期 年 week**** &lt;input <span class="built_in">type</span>=<span class="string">"week"</span> /&gt;</span><br><span class="line">常用新属性 (占位符 当用户输入的时候 里面的文字消失 删除所有文字，自动返回)placeholder**** &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> placeholder=<span class="string">"请输入用户名"</span> /&gt;</span><br><span class="line">规定当页面加载时 input 元素应该自动获得焦点 autofocus**** &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> autofocus /&gt;</span><br><span class="line">多文件上传 multiple**** &lt;input <span class="built_in">type</span>=<span class="string">"file"</span> multiple /&gt;</span><br><span class="line">规定表单是否应该启用自动完成功能 有2个值，一个是on 一个是off on 代表记录已经输入的值 1.autocomplete 首先需要提交按钮 &lt;br /&gt;2.这个表单您必须给他名字autocomplete****</span><br><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> autocomplete=<span class="string">"off"</span> /&gt;</span><br><span class="line">必填项 内容不能为空 required**** &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> required /&gt;</span><br><span class="line">规定激活（使元素获得焦点）元素的快捷键 采用 alt + s的形式 accesskey**** &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> accesskey=<span class="string">"s"</span> /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#### 5) 多媒体标签</span></span><br><span class="line">- embed：标签定义嵌入的内容</span><br><span class="line">  embed可以用来插入各种多媒体，格式可以是 Midi、Wav、AIFF、AU、MP3等等。url为音频或视频文件及其路径，可以是相对路径或绝对路径。</span><br><span class="line"></span><br><span class="line">- 多媒体 audio</span><br><span class="line">  autoplay 自动播放</span><br><span class="line">  controls 是否显不默认播放控件</span><br><span class="line">  loop 循环播放 如果这个属性不写 默认播放一次 loop 或者 loop = “loop” 表示无限循环</span><br><span class="line">  由于版权等原因，不同的浏览器可支持播放的格式是不一样的</span><br><span class="line">  &lt;<span class="built_in">source</span>\&gt; 标签允许您规定可替换的视频/音频文件供浏览器根据它对媒体类型或者编解码器的支持进行选择</span><br><span class="line"></span><br><span class="line">- 多媒体 video</span><br><span class="line">  autoplay 自动播放</span><br><span class="line">  controls 是否显示默认播放控件</span><br><span class="line">  loop 循环播放</span><br><span class="line">  width 设置播放窗口宽度</span><br><span class="line">  height 设置播放窗口的高度</span><br><span class="line">  由于版权等原因，不同的浏览器可支持播放的格式是不一样的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#### 6) CSS3 新增选择器</span></span><br><span class="line"><span class="comment">##### 6.1)  结构(位置)伪类选择器（CSS3)</span></span><br><span class="line">:first-child :选取属于其父元素的首个子元素的指定选择器</span><br><span class="line">:last-child :选取属于其父元素的最后一个子元素的指定选择器</span><br><span class="line">:nth-child(n) ： 匹配属于其父元素的第 N 个子元素，不论元素的类型</span><br><span class="line">:nth-last-child(n) ：选择器匹配属于其元素的第 N 个子元素的每个元素，不论元素的类型，从最后一个子元素开始计数。n 可以是数字、关键词或公式</span><br><span class="line"></span><br><span class="line"><span class="comment">##### 6.2) 属性选择器</span></span><br></pre></td></tr></table></figure></p>
<p>  div[class^=font] {   # class^=font 表示 font 开始位置就行了</p>
<pre><code>color: pink;
</code></pre><p>  }<br>  div[class$=footer] { # class$=footer 表示 footer 结束位置就行了</p>
<pre><code>color: skyblue;
</code></pre><p>  }<br>  div[class<em>=tao] { # class</em>=tao *= 表示tao 在任意位置都可以</p>
<pre><code>color: green;
</code></pre><p>  }</p>
<p>  <div class="font12">属性选择器</div><br>  <div class="font12">属性选择器</div><br>  <div class="font24">属性选择器</div><br>  <div class="font24">属性选择器</div><br>  <div class="font24">属性选择器</div><br>  <div class="24font">属性选择器123</div><br>  <div class="sub-footer">属性选择器footer</div><br>  <div class="jd-footer">属性选择器footer</div><br>  <div class="news-tao-nav">属性选择器</div><br>  <div class="news-tao-header">属性选择器</div><br>  <div class="tao-header">属性选择器</div></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  &lt;style&gt;</span><br><span class="line">    div[class^=font] &#123;</span><br><span class="line">      color: pink;</span><br><span class="line">    &#125;</span><br><span class="line">    div[class$=footer] &#123;</span><br><span class="line">      color: skyblue;</span><br><span class="line">    &#125;</span><br><span class="line">    div[class*=tao] &#123;</span><br><span class="line">      color: green;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line"></span><br><span class="line">  &lt;div class = &quot;font12&quot;&gt;属性选择器&lt;/div&gt;</span><br><span class="line">  &lt;div class = &quot;font12&quot;&gt;属性选择器&lt;/div&gt;</span><br><span class="line">  &lt;div class = &quot;font24&quot;&gt;属性选择器&lt;/div&gt;</span><br><span class="line">  &lt;div class = &quot;font24&quot;&gt;属性选择器&lt;/div&gt;</span><br><span class="line">  &lt;div class = &quot;font24&quot;&gt;属性选择器&lt;/div&gt;</span><br><span class="line">  &lt;div class = &quot;24font&quot;&gt;属性选择器123&lt;/div&gt;</span><br><span class="line">  &lt;div class = &quot;sub-footer&quot;&gt;属性选择器footer&lt;/div&gt;</span><br><span class="line">  &lt;div class = &quot;jd-footer&quot;&gt;属性选择器footer&lt;/div&gt;</span><br><span class="line">  &lt;div class = &quot;news-tao-nav&quot;&gt;属性选择器&lt;/div&gt;</span><br><span class="line">  &lt;div class = &quot;news-tao-header&quot;&gt;属性选择器&lt;/div&gt;</span><br><span class="line">  &lt;div class = &quot;tao-header&quot;&gt;属性选择器&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">##### 6.3) 伪元素选择器（CSS3)</span><br><span class="line">E::first-letter文本的第一个单词或字（如中文、日文、韩文等）</span><br><span class="line">E::first-line 文本第一行；</span><br><span class="line">E::selection 可改变选中文本的样式；</span><br><span class="line">E::before和E::after</span><br><span class="line">在E元素内部的开始位置和结束位创建一个元素，该元素为行内元素，且必须要结合content属性使用。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>div::before {<br> content:”开始”;<br>}<br>div::after {<br> content:”结束”;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* E:after、E:before 在旧版本里是伪元素，CSS3的规范里“:”用来表示伪类，“::”用来表示伪元素，但是在高版本浏览器下E:after、E:before会被自动识别为E::after、E::before，这样做的目的是用来做兼容处理。</span><br><span class="line">注意: 伪元素:before和:after添加的内容默认是inline元素**；这个两个伪元素的content属性，表示伪元素的内容,设置:before和:after时必须设置其content属性，否则伪元素就不起作用。</span><br><span class="line"></span><br><span class="line">##### 6.4) border-box，设置计算盒子大小的方式。</span><br><span class="line">可以分成两种情况：</span><br><span class="line">  1. box-sizing: content-box; 盒子大小为 width + padding + border content-box:此值为其默认值，其让元素维持W3C的标准Box Mode</span><br><span class="line">  2. box-sizing: border-box;  盒子大小为 width 就是说 padding 和 border 是包含到width里面的</span><br><span class="line">  注：上面的标注的width指的是CSS属性里设置的width: length，content的值是会自动调整的。</span><br><span class="line"></span><br><span class="line">##### 6.5)  transition</span><br><span class="line">transition: 要过渡的属性 花费时间 运动曲线 何时开始; 如果有多组属性变化，还是用逗号隔开。</span><br><span class="line">- transition-property 规定应用过渡的 CSS 属性的名称。</span><br><span class="line">- transition-duration 定义过渡效果花费的时间。默认是 0。</span><br><span class="line">- transition-timing-function 规定过渡效果的时间曲线。默认是 &quot;ease&quot;。</span><br><span class="line">- transition-delay 规定过渡效果何时开始。默认是 0。</span><br><span class="line"></span><br><span class="line">如果想要所有的属性都变化过渡， 写一个all 就可以</span><br><span class="line"></span><br><span class="line">##### 6.6) 2D变形 transform</span><br><span class="line">- 移动 translate(x, y)水平方向和垂直方向同时移动（也就是X轴和Y轴同时移动） translateX(x)仅水平方向移动（X轴移动） translateY(Y)仅垂直方向移动（Y轴移动）</span><br><span class="line">- 缩放 scale(X,Y)使元素水平方向和垂直方向同时缩放（也就是X轴和Y轴同时缩放） scaleX(x)元素仅水平方向缩放（X轴缩放） scaleY(y)元素仅垂直方向缩放（Y轴缩放）</span><br><span class="line">- 旋转 rotate(deg), 可以对元素进行旋转，正值为顺时针，负值为逆时针；</span><br><span class="line">- transform-origin可以调整元素转换变形的原点</span><br><span class="line">- 倾斜 skew(deg, deg)</span><br><span class="line"></span><br><span class="line">##### 6.7) 3D变形 transform</span><br><span class="line">- rotatex():沿着x轴进行旋转 x左边是负的，右边是正的</span><br><span class="line">- rotateY():沿着y轴进行旋转 y 上面是负的， 下面是正的</span><br><span class="line">- rotateZ():沿着z轴进行旋转 z 里面是负的， 外面是正的</span><br><span class="line">- translate3d(x,y,z)</span><br><span class="line">[注意]其中，x和y可以是长度值，也可以是百分比，百分比是相对于其本身元素水平方向的宽度和垂直方向的高度和；z只能设置长度值</span><br><span class="line"></span><br><span class="line">backface-visibility:backface-visibility 属性定义当元素不面向屏幕时是否可见</span><br><span class="line"></span><br><span class="line">##### 6.8) 动画 animation</span><br><span class="line">animation:动画名称 动画时间 运动曲线 何时开始 播放次数 是否反方向;</span><br><span class="line">@keyframes 动画名称 &#123;</span><br><span class="line"> from&#123; 开始位置 &#125;  0%</span><br><span class="line"> to&#123; 结束 &#125;  100%</span><br><span class="line">&#125;</span><br><span class="line">animation-iteration-count:infinite; 无限循环播放</span><br><span class="line">animation-play-state:paused; 暂停动画&quot;</span><br><span class="line"></span><br><span class="line">参考：http://www.w3school.com.cn/html5/index.asp</span><br><span class="line">参考：http://www.w3school.com.cn/css3/index.asp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 5、DHTML的掌握 到 HTML5 API盘点</span><br><span class="line">一、简介</span><br><span class="line">DHTML 不是 W3C 标准</span><br><span class="line">DHTML 指动态 HTML（Dynamic HTML）。</span><br><span class="line">DHTML 不是由万维网联盟（W3C）规定的标准。DHTML 是一个营销术语 - 被网景公司（Netscape）和微软公司用来描述 4.x 代浏览器应当支持的新技术。</span><br><span class="line">DHTML 是一种用来创建动态站点的技术组合物。</span><br><span class="line">对大多数人来说，DHTML 意味着 HTML 4.0、样式表以及 JavaScript 的结合物。</span><br><span class="line">W3C 曾讲过：“动态HTML是一个被某些厂商用来描述可使文档动态性更强的HTML、样式表以及脚本的结合物的术语。”</span><br><span class="line">So, 这个题目有点老。。。那我们来介绍下html5吧。。。</span><br><span class="line"></span><br><span class="line">HTML5简介</span><br><span class="line">HTML5是HTML最新的修订版本，2014年10月由万维网联盟（W3C）完成标准制定。</span><br><span class="line"></span><br><span class="line">HTML5的设计目的是为了在移动设备上支持多媒体。</span><br><span class="line"></span><br><span class="line">HTML5 简单易学。</span><br><span class="line"></span><br><span class="line">HTML5 是如何起步的？</span><br><span class="line">HTML5 是 W3C 与 WHATWG 合作的结果，WHATWG 指 Web Hypertext Application Technology Working Group。</span><br><span class="line"></span><br><span class="line">WHATWG 致力于 web 表单和应用程序，而 W3C 专注于 XHTML 2.0。在 2006 年，双方决定进行合作，来创建一个新版本的 HTML。</span><br><span class="line"></span><br><span class="line">HTML5 中的一些有趣的新特性：</span><br><span class="line"></span><br><span class="line">1、用于绘画的 canvas 元素</span><br><span class="line"></span><br><span class="line">2、用于媒介回放的 video 和 audio 元素</span><br><span class="line"></span><br><span class="line">3、对本地离线存储的更好的支持</span><br><span class="line"></span><br><span class="line">4、新的特殊内容元素，比如 article、footer、header、nav、section</span><br><span class="line"></span><br><span class="line">5、新的表单控件，比如 calendar、date、time、email、url、search</span><br><span class="line"></span><br><span class="line">下面介绍一下常用的html api</span><br><span class="line">1、Canvas</span><br><span class="line">Canvas本质上是一个位图画步。</span><br><span class="line">使用canvas编程，首先要获取其上下文（context）。接着在上下文中执行动作，最后将这些动作应用到上下文中。可以将canvas的这种编辑方式想象成数据库事务：开发人员先发起一个事务，然后执行某些操作，最后提交事务。</span><br><span class="line"></span><br><span class="line">html</span><br><span class="line"></span><br><span class="line">&lt;canvas id=&quot;diagonal&quot; style=&quot;border:1px solid;&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">js</span><br><span class="line"></span><br><span class="line">function drawDiagonal()&#123;</span><br><span class="line">     //取的canvas元素及其绘图上下文</span><br><span class="line">     var canvas = document.getElementById(‘diagonal’);</span><br><span class="line">     var context = canvas.getContext(&apos;2d&apos;);</span><br><span class="line"> </span><br><span class="line">     // 用绝对坐标来创建一条路径</span><br><span class="line">     context.beginPath();</span><br><span class="line">     context.moveTo(70,140);</span><br><span class="line">     context.lineTo(140,70);</span><br><span class="line"> </span><br><span class="line">     // 将这条线绘制到canvas上</span><br><span class="line">     context.stroke();</span><br><span class="line">&#125;</span><br><span class="line">window.addEventListener(&apos;load&apos;,drawDiagonal,true);</span><br><span class="line">2、Audio和Video</span><br><span class="line">html5中的多媒体支持。</span><br><span class="line"></span><br><span class="line">&lt;audio id=&quot;clickSound&quot;&gt;</span><br><span class="line">    &lt;source src=&quot;a.ogg&quot;&gt;</span><br><span class="line">    &lt;source src=&quot;b.mp3&quot;&gt;</span><br><span class="line">&lt;/audio&gt;</span><br><span class="line"> </span><br><span class="line">&lt;button id=&quot;toggle&quot; onclick=&quot;toggleSound()&quot;&gt;play&lt;/button&gt;</span><br><span class="line">function toggleSound() &#123;</span><br><span class="line">    var music = document.getElementById(&apos;clickSound&apos;);</span><br><span class="line">    var toggle = document.getElementById(&apos;toggle&apos;);</span><br><span class="line"> </span><br><span class="line">    if(music.paused)&#123;</span><br><span class="line">        music.play();</span><br><span class="line">        toggle.innerHTML = &apos;Pause&apos;;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        music.pause();</span><br><span class="line">        toggle.innerHTML = &apos;Play&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">3、Geolocation</span><br><span class="line">请求一个位置信息，如果用户同意，浏览器就会返回位置信息，该位置信息是通过支持HTML5地理定位功能的底层设备提供给浏览器。位置信息由纬度／经度坐标和一些其他的元数据组成。有了这些位置信息就可以构建引人注意目的位置感知类应用程序。</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var x=document.getElementById(&quot;demo&quot;);</span><br><span class="line">function getLocation()</span><br><span class="line">  &#123;</span><br><span class="line">  if (navigator.geolocation)</span><br><span class="line">    &#123;</span><br><span class="line">    navigator.geolocation.getCurrentPosition(showPosition);</span><br><span class="line">    &#125;</span><br><span class="line">  else&#123;x.innerHTML=&quot;Geolocation is not supported by this browser.&quot;;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">function showPosition(position)</span><br><span class="line">  &#123;</span><br><span class="line">  x.innerHTML=&quot;Latitude: &quot; + position.coords.latitude +</span><br><span class="line">  &quot;&lt;br /&gt;Longitude: &quot; + position.coords.longitude;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4、Web Workers</span><br><span class="line"></span><br><span class="line">HTML5 Web Workers可以让Web 应用程序具备后台处理能力，它对多线程的支持非常好，因此，使用了HTML5的Javascript应用程序可以充分利用多核CPU带来的优势。</span><br><span class="line"></span><br><span class="line">将耗时长的任务分配给HTML5 Web Workers执行，可以避免弹出脚本运行缓慢的警告。</span><br><span class="line"></span><br><span class="line">Web Workers不能直接访问Web 页面和DOM API。</span><br><span class="line"></span><br><span class="line">Web Workers的另一个用途是监听由后台服务器广播的新闻消息，收到后台服务的消息后，将其显示在Web页面上。</span><br><span class="line"></span><br><span class="line">5、requestAnimationFrame</span><br><span class="line">浏览器可以优化并行的动画动作，更合理的重新排列动作序列，并把能够合并的动作放在一个渲染周期内完成，从而呈现出更流畅的动画效果。比如，通过requestAnimationFrame()，JS动画能够和CSS动画/变换或SVG SMIL动画同步发生。另外，如果在一个浏览器标签页里运行一个动画，当这个标签页不可见时，浏览器会暂停它，这会减少CPU，内存的压力，节省电池电量。6、</span><br><span class="line"></span><br><span class="line">6、websocket</span><br><span class="line">WebSocket作为HTML5一种新的协议，实现了浏览器与服务器的双向通讯。在 WebSocket API 中，浏览器和服务器只需要要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。</span><br><span class="line"></span><br><span class="line">7、应用程序缓存</span><br><span class="line">HTML5 的 Web storage API 采用了离线缓存，会生成一个清单文件（manifest file)，这个清单文件实质就是一系列的URL列表文件，这些URL分别指向页面当中的html,css,javascript,图片等相关内容。当使用离线应用时，应用会引入这一清单文件，浏览器会读取这一文件，下载相应的文件，并将其缓存到本地。使得这些web应用能够脱离网络使用，而用户在离线时的更改也同样会映射到清单文件中，并在重新连线之后将更改返回应用，工作方式与我们现在所使用的网盘有着异曲同工之处。</span><br><span class="line"></span><br><span class="line">首先，需要在页面头加入manifest属性：</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html manifest = &quot;cache.manifest&quot;&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">然后cache.manifest文件的书写方式为：</span><br><span class="line"></span><br><span class="line">CACHE MANIFEST</span><br><span class="line">#v0.11</span><br><span class="line"> </span><br><span class="line">CACHE:</span><br><span class="line"> </span><br><span class="line">js/app.js</span><br><span class="line">css/style.css</span><br><span class="line"> </span><br><span class="line">NETWORK:</span><br><span class="line">resourse/logo.png</span><br><span class="line"> </span><br><span class="line">FALLBACK:</span><br><span class="line">/ /offline.html</span><br><span class="line">离线存储的manifest一般由三个部分组成:</span><br><span class="line">1、CACHE:表示需要离线存储的资源列表，由于包含manifest文件的页面将被自动离线存储，所以不需要把页面自身也列出来。</span><br><span class="line"></span><br><span class="line">2、NETWORK:表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在CACHE和NETWORK中有一个相同的资源，那么这个资源还是会被离线存储，也就是说CACHE的优先级更高。</span><br><span class="line"></span><br><span class="line">3、FALLBACK:表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问offline.html。</span><br><span class="line"></span><br><span class="line">参考资料：</span><br><span class="line"></span><br><span class="line">http://www.w3school.com.cn/html5/index.asp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 三、 JS相关</span><br><span class="line">### 1. JS 基本数据类型的掌握、类型判断、常见用法</span><br><span class="line">    js中有六种数据类型，Number,String,Boolean,Undefined,Null 和 Object。es6中新加了一种基本数据类型，Symbol。</span><br><span class="line">    三大引用类型：Object、Array、function</span><br><span class="line"></span><br><span class="line">    类型判断常规方法主要有四种：</span><br><span class="line">    1) typeof</span><br><span class="line">      当操作数为null、[]、object时，都是object</span><br><span class="line">      Tip: 6大原始类型Null、Undefined、String、Number、Boolean和Symbol。</span><br><span class="line">    </span><br><span class="line">    2) instanceof</span><br><span class="line">        instanceof操作符主要用来检查构造函数的原型是否在对象的原型链上。</span><br><span class="line"></span><br><span class="line">    3） Object.prototype.toString</span><br><span class="line">        利用toString方法基本上可以解决所有内置对象类型的判断：</span><br><span class="line">        ``` bash</span><br><span class="line">        function type (obj) &#123;</span><br><span class="line">          return Reflect.apply(Object.prototype.toString, obj, []).replace(/^\[object\s(\w+)\]$/, &apos;$1&apos;).toLowerCase()</span><br><span class="line">        &#125;</span><br><span class="line">        type(new String(&apos;123&apos;)) // string</span><br></pre></td></tr></table></figure></p>
<pre><code>4） construcor
    · 实际上我们也可以通过constructor属性来达到类型判断的效果。
    · 但是在实际情况下，constructor属性可以被随意修改，而且你在原型继承中，很容易忽略掉constructor的正确指向：
    <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Rabbit (name) &#123;</span><br><span class="line">  Animal.call(this, name)</span><br><span class="line">&#125;</span><br><span class="line">Rabbit.prototype = Object.create(Animal.prototype);</span><br><span class="line">// 需要手动设置constructor的正确指向</span><br><span class="line">Rabbit.prototype.constructor = Rabbit;</span><br><span class="line">const rabbit = new Rabbit(<span class="string">'1'</span>);</span><br><span class="line">rabbit.constructor === Rabbit // <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</code></pre><h3 id="2-变量的声明、定义，闭包"><a href="#2-变量的声明、定义，闭包" class="headerlink" title="2. 变量的声明、定义，闭包"></a>2. 变量的声明、定义，闭包</h3><ul>
<li><p>在 JavaScript 中创建变量通常称为”声明”变量。</p>
</li>
<li><p>ES2015(ES6) 新增加了 let 和 const。</p>
<ul>
<li>let 声明的变量只在 let 命令所在的代码块内有效；<pre><code>不可以在使用后声明，没有变量提升；
</code></pre></li>
<li>const 用于声明一个或多个常量，声明时必须有初始值。<pre><code>一旦声明，常量的值就不能修改。
</code></pre></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">使用 var 关键字：</span><br><span class="line">var i = 5;</span><br><span class="line"><span class="keyword">for</span> (var i = 0; i &lt; 10; i++) &#123; // 一些代码... &#125; // 这里输出 i 为 10</span><br><span class="line"></span><br><span class="line">使用 <span class="built_in">let</span> 关键字：</span><br><span class="line">var i = 5;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; 10; i++) &#123; // 一些代码... &#125; // 这里输出 i 为 5</span><br></pre></td></tr></table></figure>
<p>  在第一个实例中，使用了 var 关键字，它声明的变量是全局的，包括循环体内与循环体外。<br>  在第二个实例中，使用 let 关键字， 它声明的变量作用域只在循环体内，循环体外的变量不受影响。</p>
</li>
<li><p>变量提升<br>JavaScript 中，var 关键字定义的变量可以在使用后声明，也就是变量可以先使用再声明（JavaScript 变量提升）。<br>let 关键字定义的变量则不可以在使用后声明，也就是变量需要先声明再使用。</p>
</li>
<li><p>变量作用域<br>变量作用域两种：全局变量、局部变量。js中函数内部可以读取全局变量，函数外部不能读取函数内部的局部变量。</p>
</li>
<li><p>闭包<br>能够读取其他函数内部变量的函数。 或简单理解为定义在一个函数内部的函数，内部函数持有外部函数内变量的引用。</p>
<p>闭包用途<br>1、读取函数内部的变量<br>2、让这些变量的值始终保持在内存中。不会再f1调用后被自动清除。<br>3、方便调用上下文的局部变量。利于代码封装。<br>原因：f1是f2的父函数，f2被赋给了一个全局变量，f2始终存在内存中，f2的存在依赖f1，因此f1也始终存在内存中，不会在调用结束后，被垃圾回收机制回收。</p>
</li>
</ul>
<h3 id="3、-数组、字符串、对象、函数的常⻅操作方法以及深浅拷贝"><a href="#3、-数组、字符串、对象、函数的常⻅操作方法以及深浅拷贝" class="headerlink" title="3、 数组、字符串、对象、函数的常⻅操作方法以及深浅拷贝"></a>3、 数组、字符串、对象、函数的常⻅操作方法以及深浅拷贝</h3><p>一、数组</p>
<ol>
<li>length 是Array的实例属性。返回或设置一个数组中的元素个数。该值是一个无符号 32-bit 整数，并且总是大于数组最高项的下标。</li>
<li>concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。</li>
<li>filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 </li>
<li>find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。</li>
<li>forEach() 方法对数组的每个元素执行一次提供的函数。</li>
<li>includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。</li>
<li>indexOf() 方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。</li>
<li>join() 方法将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。</li>
<li>map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</li>
<li>push() 方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度。</li>
<li>slice() 方法返回一个新的数组对象，这一对象是一个由 begin和 end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。</li>
<li>splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。</li>
</ol>
<p>二、字符串</p>
<ol>
<li>length 属性表示一个字符串的长度。</li>
<li>charAt() 方法从一个字符串中返回指定的字符。</li>
<li>charCodeAt() 方法返回0到65535之间的整数，表示给定索引处的UTF-16代码单元 (在 Unicode 编码单元表示一个单一的 UTF-16 编码单元的情况下，UTF-16 编码单元匹配 Unicode 编码单元。但在——例如 Unicode 编码单元 &gt; 0x10000 的这种——不能被一个 UTF-16 编码单元单独表示的情况下，只能匹配 Unicode 代理对的第一个编码单元) 。如果你想要整个代码点的值，使用 codePointAt()。</li>
<li>indexOf() 方法返回调用  String 对象中第一次出现的指定值的索引，开始在 fromIndex进行搜索。</li>
<li>slice() 方法提取一个字符串的一部分，并返回一新的字符串。</li>
<li>substr() 方法返回一个字符串中从指定位置开始到指定字符数的字符。<br>尽管 String.prototype.substr(…) 没有严格被废弃 (as in “removed from the Web standards”), 但它被认作是遗留的函数并且可以的话应该避免使用。它并非JavaScript核心语言的一部分，未来将可能会被移除掉。如果可以的话，使用 substring() 替代它.</li>
<li>substring() 方法返回一个字符串在开始索引到结束索引之间的一个子集, 或从开始索引直到字符串的末尾的一个子集。</li>
<li>toLowerCase() 会将调用该方法的字符串值转为小写形式，并返回。</li>
<li>toUpperCase() 将调用该方法的字符串值转换为大写形式，并返回。</li>
<li>padStart() 方法用另一个字符串填充当前字符串(重复，如果需要的话)，以便产生的字符串达到给定的长度。填充从当前字符串的开始(左侧)应用的,常见应用（时间格式的补零操作，2019-09-17），右侧填充有相对应的padEnd方法</li>
</ol>
<p>三、对象</p>
<ol>
<li>Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</li>
<li>Object.defineProperties() 方法直接在一个对象上定义新的属性或修改现有属性，并返回该对象。</li>
<li>Object.entries()方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for…in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。</li>
<li>Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for…in 循环遍历该对象时返回的顺序一致 。如果对象的键-值都不可枚举，那么将返回由键组成的5. hasOwnProperty() 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是是否有指定的键）</li>
</ol>
<p>四、函数</p>
<ol>
<li>apply() 方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。</li>
<li>bind()方法创建一个新的函数，在bind()被调用时，这个新函数的this被bind的第一个参数指定，其余的参数将作为新函数的参数供调用时使用。</li>
<li>call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。</li>
</ol>
<p>五、深拷贝、浅拷贝</p>
<p>JSON方法最常用的实现深拷贝的方式，直接看例子：<br>var obj1 = { a: { b: 1 } };<br>var obj2 = JSON.parse(JSON.stringfy(obj1));</p>
<p>这种方法很简单而且好用，但是有一点点瑕疵，它会抛弃对象的constructor。也就是深拷贝之后，不管这个对象原来的构造函数是什么，在深拷贝之后都会变成Object。<br>而且这种方法能正确处理的对象只有 Number, String, Boolean, Array，即那些能够被JSON直接表示的数据结构。RegExp对象或者function是无法通过这种方式深拷贝。<br>同时，也可以直接使用lodash等函数库去实现深拷贝。</p>
<h3 id="4、-正则匹配表达式"><a href="#4、-正则匹配表达式" class="headerlink" title="4、 正则匹配表达式"></a>4、 正则匹配表达式</h3><p>正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript 中，正则表达式也是对象。这些模式被用于 RegExp 的 exec 和 test 方法, 以及 String 的 match、replace、search 和 split 方法。<br>你可以使用以下两种方法之一构建一个正则表达式：<br>使用一个正则表达式字面量，其由包含在斜杠之间的模式组成，如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const regex1 = /ab+c/;</span><br><span class="line">const regex2 = /^[a-zA-Z]+[0-9]*\W?_$/gi;</span><br></pre></td></tr></table></figure></p>
<p>在加载脚本后，正则表达式字面值提供正则表达式的编译。当正则表达式保持不变时，使用此方法可获得更好的性能。<br>或者调用RegExp对象的构造函数，如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const regex1 = new reg(<span class="string">"ab+c"</span>);</span><br><span class="line">const regex2 =  new reg(<span class="string">"^[a-zA-Z]+[0-9]*\W?_$"</span>, gi);</span><br><span class="line">const regex3 =  new reg(/^[a-zA-Z]+[0-9]*\W?_$/, gi);</span><br></pre></td></tr></table></figure></p>
<p>使用构造函数提供正则表达式的运行时编译。使用构造函数，当你知道正则表达式模式将会改变，或者你不知道模式，并从另一个来源，如用户输入。</p>
<p>常用的正则表达式特殊字符如下：</p>
<ul>
<li><p>\<br>匹配将依照下列规则：</p>
<ul>
<li>在非特殊字符之前的反斜杠表示下一个字符是特殊的，不能从字面上解释。例如，前面没有’\’的’b’通常匹配小写’b’，无论它们出现在哪里。如果加了’\’,这个字符变成了一个特殊意义的字符，意思是匹配一个字符边界。</li>
<li>反斜杠也可以将其后的特殊字符，转义为字面量。例如，模式 /a<em>/ 代表会匹配 0 个或者多个 a。相反，模式 /a\</em>/ 将 ‘<em>‘ 的特殊性移除，从而可以匹配像 “a</em>“ 这样的字符串。</li>
<li>使用 new RegExp(“pattern”) 的时候不要忘记将 \ 进行转义，因为 \ 在字符串里面也是一个转义字符。</li>
</ul>
</li>
<li><p>^<br>匹配输入的开始。如果多行标志被设置为true，那么也匹配换行符后紧跟的位置。<br>例如，/^A/ 并不会匹配 “an A” 中的 ‘A’，但是会匹配 “An E” 中的 ‘A’。<br>当 ‘^’ 作为第一个字符出现在一个字符集合模式时，它将会有不同的含义。</p>
</li>
<li><p>$<br>匹配输入的结束。如果多行标示被设置为true，那么也匹配换行符前的位置。<br>例如，/t$/ 并不会匹配 “eater” 中的 ‘t’，但是会匹配 “eat” 中的 ‘t’。</p>
</li>
<li><p>*<br>匹配前一个表达式0次或多次。等价于 {0,}。<br>例如，/bo*/会匹配 “A ghost boooooed” 中的 ‘booooo’ 和 “A bird warbled” 中的 ‘b’，但是在 “A goat grunted” 中将不会匹配任何东西。</p>
</li>
<li><p>+<br>匹配前面一个表达式1次或者多次。等价于 {1,}。<br>例如，/a+/匹配了在 “candy” 中的 ‘a’，和在 “caaaaaaandy” 中所有的 ‘a’。</p>
</li>
<li><p>x|y<br>匹配‘x’或者‘y’。<br>例如，/green|red/匹配“green apple”中的‘green’和“red apple”中的‘red’</p>
</li>
<li><p>[xyz]<br>一个字符集合。匹配方括号中的任意字符，包括转义序列。你可以使用破折号（-）来指定一个字符范围。对于点（.）和星号（*）这样的特殊符号在一个字符集中没有特殊的意义。他们不必进行转义，不过转义也是起作用的。<br>例如，[abcd] 和[a-d]是一样的。他们都匹配”brisket”中的‘b’,也都匹配“city”中的‘c’。/[a-z.]+/ 和/[\w.]+/与字符串“test.i.ng”匹配。</p>
</li>
<li><p>[^xyz]<br>一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。<br>例如，[^abc] 和 [^a-c] 是一样的。他们匹配”brisket”中的‘r’，也匹配“chop”中的‘h’。</p>
</li>
<li><p>\d<br>匹配一个数字。 等价于[0-9]。<br>例如， /\d/ 或者 /[0-9]/ 匹配”B2 is the suite number.”中的’2’。</p>
</li>
</ul>
<h3 id="5、-DOM-相关触发事件、节点操作以及事件相关"><a href="#5、-DOM-相关触发事件、节点操作以及事件相关" class="headerlink" title="5、 DOM 相关触发事件、节点操作以及事件相关"></a>5、 DOM 相关触发事件、节点操作以及事件相关</h3><ul>
<li><p>什么是DOM事件流？<br>想象画在一张纸上的一组同心圆。如果把手指放在圆心上，那么手指指向的不仅仅是一个圆，而是纸上的所有圆。所以如果点击了某个按钮，点击事件不仅仅发生在这个按钮上，整个页面也被点击了。<br>事件流包括三个阶段: 事件捕获(capturing phase)、目标事件(target phase)、事件冒泡(bubbling phase)。<br>发生的顺序是：事件捕获阶段 –&gt; 目标事件阶段 –&gt; 事件冒泡阶段</p>
</li>
<li><p>什么是事件冒泡？<br>事件开始时由最具体的元素(目标元素)接收，然后逐级向上传播。<br>所谓事件冒泡就是事件像泡泡一样从最开始生成的地方一层一层往上冒，比如上图中a标签为事件目标，点击a标签后同时也会触发p、li上的点击事件，一层一层向上直至最外层的html或document。下面是代码示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"box"</span>&gt;</span><br><span class="line">  &lt;a id=<span class="string">"child"</span>&gt;事件冒泡&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  var box = document.getElementById(<span class="string">'box'</span>),</span><br><span class="line">      child = document.getElementById(<span class="string">'child'</span>);</span><br><span class="line">  </span><br><span class="line">  child.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      alert(<span class="string">'我是目标事件'</span>);</span><br><span class="line">  &#125;, <span class="literal">false</span>);</span><br><span class="line">  </span><br><span class="line">  box.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      alert(<span class="string">'事件冒泡至DIV'</span>);</span><br><span class="line">  &#125;, <span class="literal">false</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>上面的代码运行后我们点击a标签，首先会弹出’我是目标事件’提示，然后又会弹出’事件冒泡至DIV’的提示，这便说明了事件自内而外向上冒泡了。<br>那么我们如何阻止事件冒泡呢？这里就涉及事件的Event对象中的stopPropagation方法，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">child.addEventListener(<span class="string">'click'</span>, <span class="keyword">function</span>(e) &#123;</span><br><span class="line">  alert(<span class="string">'我是目标事件'</span>);</span><br><span class="line">  e.stopPropagation();</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>什么是事件捕获？<br>事件按 window -&gt; document -&gt; html -&gt; body -&gt; … -&gt; 目标元素 的方向向下层元素传递。<br>和事件冒泡相反，事件捕获是自上而下执行，我们只需要将addEventListener的第三个参数改为true就行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"box"</span>&gt;</span><br><span class="line">  &lt;a id=<span class="string">"child"</span>&gt;事件冒泡&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  var box = document.getElementById(<span class="string">'box'</span>),</span><br><span class="line">    child = document.getElementById(<span class="string">'child'</span>);</span><br><span class="line">  </span><br><span class="line">  child.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    alert(<span class="string">'我是目标事件'</span>);</span><br><span class="line">  &#125;, <span class="literal">true</span>);</span><br><span class="line">  </span><br><span class="line">  box.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    alert(<span class="string">'事件冒泡至DIV'</span>);</span><br><span class="line">  &#125;, <span class="literal">true</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>DOM事件对象汇总: <a href="https://www.runoob.com/jsref/dom-obj-event.html" target="_blank" rel="noopener">https://www.runoob.com/jsref/dom-obj-event.html</a></p>
</li>
<li><p>鼠标事件<br>在用鼠标触发事件时，主要的事件属性包含鼠标的位置和按键的状态，比如：clientX和clientY指定了鼠标在窗口坐标中的位置，button和which指定了按下的鼠标键是哪个。</p>
<p>onmouseenter:  当鼠标指针移动到元素上时触发<br>onmouseleave：当鼠标移出元素时触发<br>onmouseover：鼠标移到某元素上<br>onmouseout： 鼠标从某元素移开<br>onmouseenter 和 onmouseover 都是移动到元素上时触发，但是区别是onmouseenter移动到子元素上时也会再次触发并且还会再次冒泡到父元素，而onmouseover 只触发一次，当移动到元素的子元素时不会在有再触发也不会在冒泡,</p>
</li>
</ul>
<p>function moveFn(event) {<br>    console.log(event.screenX) // 获取鼠标基于屏幕的X轴坐标<br>    console.log(event.screenY) // 获取鼠标基于屏幕的Y轴坐标<br>    console.log(event.clientX) // 获取鼠标基于浏览器窗口的X轴坐标<br>    console.log(event.clientY) // 获取鼠标基于浏览器窗口的Y轴坐标<br>    console.log(event.pageX) // 获取鼠标基于文档的X轴坐标<br>    console.log(event.pageY) // 获取鼠标基于文档的Y轴坐标<br>}</p>
<p>function clickFn(event) {<br>    console.log(event.button) // 获取鼠标按下的键。非IE浏览器中0为鼠标左键，1为鼠标中键，2为鼠标右键<br>    console.log(event.which) // 获取指定事件上哪个键盘键或鼠标按钮被按下<br>}</p>
<p>document.addEventListener(‘mouseover’, moveFn, false);<br>document.addEventListener(‘click’, clickFn, false);<br>键盘事件<br>在用键盘触发事件时，主要的事件属性包含键盘的按键keyCode和是否按下特殊键，比如：keyCode指定了按下键的键码值，ctrlKey指定是否按下了ctrl键。</p>
<p>function keyFn(event) {<br>    console.log(event.keyCode); // 获取按下键的键码值<br>    console.log(event.ctrlKey); // 获取是否按下了ctrl键<br>    console.log(event.shiftKey); // 获取是否按下了shift键<br>    console.log(event.altKey); // 获取是否按下了alt键<br>    console.log(event.metaKey); // 获取是否按下了meta键<br>}</p>
<p>document.addEventListener(‘keyup’, keyFn, false);</p>
<p>常用DOM节点查找API<br>document.getElementById ：根据ID查找元素，大小写敏感，如果有多个结果，只返回第一个；</p>
<p>document.getElementsByClassName ：根据类名查找元素，多个类名用空格分隔，返回一个 HTMLCollection 。注意兼容性为IE9+（含）。另外，不仅仅是document，其它元素也支持 getElementsByClassName 方法；</p>
<p>document.getElementsByTagName ：根据标签查找元素， * 表示查询所有标签，返回一个 HTMLCollection 。</p>
<p>document.getElementsByName ：根据元素的name属性查找，返回一个 NodeList 。</p>
<p>document.querySelector ：返回单个Node，IE8+(含），如果匹配到多个结果，只返回第一个。</p>
<p>document.querySelectorAll ：返回一个 NodeList ，IE8+(含）。</p>
<p>document.forms ：获取当前页面所有form，返回一个 HTMLCollection ；</p>
<p>节点创建API<br>1、createElement 创建元素: 通过 createElement 创建的元素并不属于 document 对象，它只是创建出来，并未添加到html文档中，要调用 appendChild 或 insertBefore 等方法将其添加到HTML文档中。</p>
<p>2、createTextNode 创建文本节点</p>
<p>3、cloneNode 克隆节点:  node.cloneNode(true/false) ，它接收一个bool参数，用来表示是否复制子元素。</p>
<p>节点修改API<br>1、appendChild</p>
<p>2、insertBefore</p>
<p>3、insertAdjacentHTML</p>
<p>4、Element.insertAdjacentElement()</p>
<p>5、removeChild</p>
<p>6、replaceChild</p>
<p>参考：<a href="https://www.kancloud.cn/webxiaoma/javascript/710903#Event_93" target="_blank" rel="noopener">https://www.kancloud.cn/webxiaoma/javascript/710903#Event_93</a><br>参考：<a href="https://segmentfault.com/a/1190000007082623" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007082623</a><br>参考：<a href="https://www.cnblogs.com/season-huang/p/4322451.html" target="_blank" rel="noopener">https://www.cnblogs.com/season-huang/p/4322451.html</a></p>
<h3 id="6、对于基础的-Window、Document对象概念的掌握、使⽤"><a href="#6、对于基础的-Window、Document对象概念的掌握、使⽤" class="headerlink" title="6、对于基础的 Window、Document对象概念的掌握、使⽤"></a>6、对于基础的 Window、Document对象概念的掌握、使⽤</h3><p>[ Window对象 ] [ Document对象 ]<br>Window对象<br>代表浏览器中一个打开的窗口</p>
<p>对象属性<br>　　window //窗口自身<br>　　window.self //引用本窗户window=window.self<br>　　window.name //为窗口命名<br>　　window.location //URL地址，配备布置这个属性可以打开新的页面</p>
<p>对象方法<br>　　window.alert(“text”) //提示信息会话框<br>　　window.confirm(“text”) //确认会话框<br>　　window.prompt(“text”) //要求键盘输入会话框<br>　　window.setIntervel(“action”,time) //每一隔指定的时间(毫秒)就执行一次操作<br>　　window.clearInterval() //清除时间配备布置作用就是终止轮回<br>　　window.setTimeout(action,time) //隔了指定的时间(毫秒)执行一次操作<br>　　window.open() //打开新的窗口<br>　　window.close() //关闭窗口</p>
<p>成员对象<br>　　window.event<br>　　window.document //见document对象详解<br>　　window.history<br>　　window.screen<br>　　window.navigator<br>　　window.external<br>　　————————————————– ——————-<br>window.history对象<br>　　window.history.length //浏览过的页面数<br>　　history.back() //后退<br>　　history.forward() //前进<br>　　history.go(i) //前进或后退到历史记录的第i个页面  i&gt;0前进, i&lt;0 后退<br>　   ————————————————- ——————-<br>window.screen对象<br>    　window.screen.width //屏幕宽度<br>　　window.screen.height //屏幕高度<br>　　window.screen.colorDepth //屏幕色深<br>　　window.screen.availWidth //可用宽度<br>　　window.screen.availHeight //可用高度(除去任务栏的高度)<br>　　————————————————– ——————-<br>window.external对象<br>　　window.external.AddFavorite(“地址”,”标题” ) //把网站新增到保藏夹<br>　　————————————————– ——————-<br>window.navigator对象<br>　　window.navigator.appCodeName //浏览器代码名<br>　　window.navigator.appName //浏览器应用程序名<br>　　window.navigator.appMinorVersion //浏览器补丁版本<br>　　window.navigator.cpuClass //cpu类型 x86<br>　　window.navigator.platform //操作体系类型 win32<br>　　window.navigator.plugins<br>　　window.navigator.opsProfile<br>　　window.navigator.userProfile<br>　　window.navigator.systemLanguage //客户体系语言 zh-cn简体中文<br>　　window.navigator.userLanguage //用户语言,同上<br>　　window.navigator.appVersion //浏览器版本<br>　　window.navigator.userAgent<br>　　window.navigator.onLine //用户否在线<br>　　window.navigator.cookieEnabled //浏览器是否撑持cookie<br>　　window.navigator.mimeTypes</p>
<p>Document对象<br>代表整个HTML文档，可用来访问页面中所有元素</p>
<p>常用对象方法</p>
<p>document.write()                      //动态向页面写入内容<br>document.createElement(Tag)           //创建一个html标签对象<br>document.getElementById(ID)           //获得指定ID值的对象<br>document.getElementsByName(Name)      //获得指定Name值的对象<br>document.body.appendChild(oTag)</p>
<p>body-主体子对象</p>
<p>document.body.link              //未点击过的链接颜色<br>document.body.alink             //激活链接(焦点在此链接上)的颜色<br>document.body.vlink             //已点击过的链接颜色<br>document.body.text              //文本色<br>document.body.innerText         //设置<body>…</body>之间的文本<br>document.body.innerHTML         //设置<body>…</body>之间的HTML代码<br>document.body.topMargin         //页面上边距<br>document.body.background        //背景图片<br>document.body.appendChild(oTag) //动态生成一个HTML对象</p>
<p>常用对象事件</p>
<p>documeny.location.reload()          //刷新网页<br>document.location.reload(URL)       //打开新的网页<br>document.location.assign(URL)       //打开新的网页<br>document.location.replace(URL)      //打开新的网页<br>location-位置子对象</p>
<p>document.location.hash          // #号后的部分<br>document.location.host          // 域名+端口号<br>document.location.hostname      // 域名<br>document.location.href          // 完整URL<br>document.location.pathname      // 目录部分<br>document.location.port          // 端口号<br>document.location.protocol      // 网络协议(http:)<br>document.location.search        // ?号后的部分</p>
<h3 id="7、原型对象、原型链的相关概念"><a href="#7、原型对象、原型链的相关概念" class="headerlink" title="7、原型对象、原型链的相关概念"></a>7、原型对象、原型链的相关概念</h3><p>原型对象<br>1.1 理解原型对象<br>1) 函数的prototype属性<br>　　1. 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)<br>　　2. 原型对象中有一个属性constructor, 它指向函数对象</p>
<p>2) 操作原型对象<br>　　1. 可以通过prototype属性找到原型对象，并可以给该对象添加属性和方法(通常是添加方法)<br>　　2. 作用: 函数的所有实例对象自动拥有原型中的属性(方法)</p>
<p>1.2 显示原型对象和隐式原型对象<br>1) 概念<br>　　1. 每个函数function都有一个prototype，即显式原型<br>　　2. 每个实例对象都有一个<strong>proto</strong>，可称为隐式原型</p>
<p>看下面一段代码来理解原型：</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>var Person = function(name){<br>    this.name = name;<br>}</p>
<p>Person.prototype.sayHi = function(){<br>    console.log(“Hello! I am “ + this.name + “.”);<br>}</p>
<p>var joe = new Person(“joe”);<br>var john = new Person(“john”);</p>
<p>joe.sayHi();    //Hello! I am joe.<br>john.sayHi();   //Hello! I am john.<br>从上面的代码可以看出来，原型（Person）定义了一些公用的属性和方法；利用原型（Person）创建出来的新对象实例（joe和john对象）会共享原型（Person）的所有属性和方法。</p>
<p>把代码修改一下：</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>var Person = function(name){<br>    this.name = name;<br>}</p>
<p>var joe = new Person(“joe”);<br>var john = new Person(“john”);</p>
<p>Person.prototype.sayHi = function(){<br>    console.log(“Hello! I am “ + this.name + “.”);<br>}</p>
<p>joe.sayHi();    //Hello! I am joe.<br>john.sayHi();   //Hello! I am john.<br>这次把新创建的对象（joe和John）提前到原型（Person）的sayHi方法定义之前，并使用严格模式。原型（Person）的sayHi方法依然会被共享出去，所以原型（Person）的属性和方法总是被原型实例所共享。</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>var Person = function(name){<br>    this.name = name;<br>}</p>
<p>Person.prototype.sayHi = function(){<br>    console.log(“Hello! I am “ + this.name + “.”);<br>}</p>
<p>var joe = new Person(“joe”);<br>var john = new Person(“john”);</p>
<p>joe.sayHi();    //Hello! I am joe.<br>john.sayHi();   //Hello! I am john.</p>
<p>joe.getName = function(){<br>    console.log(this.name);<br>}</p>
<p>joe.getName();    //joe<br>john.getName;   //undefined<br>john.getName();   //报错</p>
<p>也正是因为这样对象的使用才能更加灵活、更加易于扩展。</p>
<p> 原型链<br>1)  概念</p>
<ol>
<li>访问一个对象的属性时，先在自身属性中查找，找到返回</li>
<li>如果没有, 再沿着<strong>proto</strong>这条链向上查找, 找到返回</li>
<li>如果最终没找到, 返回undefined</li>
<li><strong>proto</strong>这条原型查找链就是原型链: 隐式原型</li>
</ol>
<p>2)  作用</p>
<p> 查找对象的属性(方法)</p>
<p>3)  原型链_属性问题</p>
<ol>
<li>读取对象的属性值时: 会自动到原型链中查找</li>
<li>设置对象的属性值时: 不会查找原型链, 如果当前对象中没有此属性, 直接添加此属性并设置其值</li>
<li>方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上</li>
</ol>
<p>在上面的代码中，执行console.log(joe.<strong>proto</strong>)后在控制台可以看到输出了原型（Person），然后继续执行console.log(Person.<strong>proto</strong>)，控制台打印的结果是function(){}，为什么Person的原型是function呢？这是因为Person是一个构造函数，它的本质就是一个函数。在javascript中函数是一等对象。</p>
<p>现在用箭头符号来表示上面原型创建的过程：</p>
<p>代码<br>1<br>2<br>3<br>joe.<strong>proto</strong>  =&gt;  Person,</p>
<p>Person.<strong>proto</strong>  =&gt;  function(){}</p>
<p>由此总结，原型链记录了原型对象创建的整个过程，因此，我给原型链添加一个概念：原型链是原型对象创建过程的历史记录。</p>
<p>参考：<a href="https://www.cnblogs.com/jofun/p/8746511.html" target="_blank" rel="noopener">https://www.cnblogs.com/jofun/p/8746511.html</a></p>
<h3 id="8、-this绑定、概念掌握"><a href="#8、-this绑定、概念掌握" class="headerlink" title="8、 this绑定、概念掌握"></a>8、 this绑定、概念掌握</h3><p>学习 this 的第一步就是明白 this 既不是指向函数自身也不指向函数的作用域。this 实际上是在函数被调用时发生的绑定，它指向什么地方完全取决于函数在哪里被调用。</p>
<p>默认绑定</p>
<p>在 javascript 中 ，最常用的函数调用类型就是独立函数调用，因此可以把这条规则看作是无法应用其他规则时的默认规则。如果在调用函数的时候，函数不带任何修饰，也就是“光秃秃”的调用，那就会应用默认绑定规则, 默认绑定的指向的是全局作用域。</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7</p>
<p>function sayLocation() {<br> console.log(this.atWhere)<br>}</p>
<p>var atWhere = “I am in global”</p>
<p>sayLocation() // 默认绑定，this绑定在全局对象,输出 “I am in global”</p>
<p>再看一个例子</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10</p>
<p>var name = “global”<br>function person() {<br> console.log(this.name) // (1) “global”<br>  person.name = ‘inside’<br> function sayName() {<br>  console.log(this.name) // (2) “global” 不是 “inside”<br> }<br> sayName() // 在person函数内部执行sayName函数,this指向的同样是全局的对象<br>}<br>person()</p>
<p>在这个例子中，person 函数在全局作用域中被调用，因此第(1)句中的 this 就绑定在了全局对象上（在浏览器中是是window，在node中就是global）,因此第(1)句自然输出的是一个全局对象的 name 属性，当然就是”global”了。sayName函数在person函数内调用，即使这样第(2)句中的this指代的仍然是全局对象，即使 person 函数设置了 name 属性。</p>
<p>这就是默认绑定规则,它是 javascript 中最常见的一种函数调用模式，this 的绑定规则也是四种绑定规则中最简单的一种，就是绑定在全局作用域上。</p>
<p>默认绑定里的严格模式</p>
<p>在 javascript 中，如果使用了严格模式，则 this 不能绑定到全局对象。还是以第一个例子，只不过这次加上了严格模式声明</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7</p>
<p>‘use strict’<br>function sayLocation() {<br> console.log(this.atWhere)<br>}<br>var atWhere = “I am in global”<br>sayLocation()<br>// Uncaught TypeError: Cannot read property ‘atWhere’ of undefined</p>
<p>可以看出，在严格模式下，把 this 绑定到全局对象上时，实际上绑定的是 undefined ,因此上面这段代码会报错。</p>
<p>隐式绑定</p>
<p>当函数在调用时，如果函数有所谓的“落脚点”,即有上下文对象时，隐式绑定规则会把函数中的 this 绑定到这个上下文对象。如果觉得上面这段话不够直白的话，还是来看代码。</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14</p>
<p>function say() {<br> console.log(this.name)<br>}<br>var obj1 = {<br> name: “zxt”,<br> say: say<br>}</p>
<p>var obj2 = {<br> name: “zxt1”,<br> say: say<br>}<br>obj1.say() // zxt<br>obj2.say() // zxt1</p>
<p>很简单是不是。在上面这段代码中，obj1 , obj2 就是所谓的 say 函数的落脚点，专业一点的说法就是上下文对象，当给函数指定了这个上下文对象时，函数内部的this 自然指向了这个上下文对象。这也是很常见的一种函数调用模式。</p>
<p>隐式绑定时丢失上下文</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10</p>
<p>function say() {<br> console.log(this.name)<br>}<br>var name = “global”<br>var obj = {<br> name: “inside”,<br> say: say<br>}<br>var alias = obj.say // 设置一个简写 (1)<br>alias() // 函数调用 输出”global” (2)</p>
<p>可以看到这里输出的是 ”global“ ，为什么就和上例中不一样，我们明明只是给 obj.say 换了个名字而已？<br>首先我们来看上面第(1)句代码，由于在 javascript 中，函数是对象，对象之间是引用传递，而不是值传递。因此，第(1)句代码只是 alias = obj.say = say ，也就是 alias = say ，obj.say 只是起了一个桥梁的作用，alias 最终引用的是 say 函数的地址，而与 obj 这个对象无关了。这就是所谓的”丢失上下文“。最终执行 alias 函数，只不过简单的执行了say函数，输出”global”。</p>
<p>显式绑定</p>
<p>显式绑定，顾名思义，显示地将this绑定到一个上下文，javascript中，提供了三种显式绑定的方法，apply,call,bind。apply和call的用法基本相似，它们之间的区别是：</p>
<p>apply(obj,[arg1,arg2,arg3,…] 被调用函数的参数以数组的形式给出<br>call(obj,arg1,arg2,arg3,…) 被调用函数的参数依次给出<br>而bind函数执行后，返回的是一个新函数。下面以代码说明。</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18</p>
<p>// 不带参数<br>function speak() {<br>  console.log(this.name)<br>}</p>
<p>var name = “global”<br>var obj1 = {<br>  name: ‘obj1’<br>}<br>var obj2 = {<br>  name: ‘obj2’<br>}</p>
<p>speak() // global 等价于speak.call(window)<br>speak.call(window)</p>
<p>speak.call(obj1) // obj1<br>speak.call(obj2) // obj2</p>
<p>因此可以看出，apply, call 的作用就是给函数绑定一个执行上下文，且是显式绑定的。因此，函数内的this自然而然的绑定在了 call 或者 apply 所调用的对象上面。</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17</p>
<p>// 带参数<br>function count(num1, num2) {<br>  console.log(this.a * num1 + num2)<br>}</p>
<p>var obj1 = {<br>  a: 2<br>}<br>var obj2 = {<br>  a: 3<br>}</p>
<p>count.call(obj1, 1, 2) // 4<br>count.apply(obj1, [1, 2]) // 4</p>
<p>count.call(obj2, 1, 2) // 5<br>count.apply(obj2, [1, 2]) // 5</p>
<p>上面这个例子则说明了 apply 和 call 用法上的差异。<br>而 bind 函数，则返回一个绑定了指定的执行上下文的新函数。还是以上面这段代码为例</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20</p>
<p>// 带参数<br>function count(num1, num2) {<br>  console.log(this.a * num1 + num2)<br>}</p>
<p>var obj1 = {<br>  a: 2<br>}</p>
<p>var bound1 = count.bind(obj1) // 未指定参数<br>bound1(1, 2) // 4</p>
<p>var bound2 = count.bind(obj1, 1) // 指定了一个参数<br>bound2(2) // 4</p>
<p>var bound3 = count.bind(obj1, 1, 2) // 指定了两个参数<br>bound3() //4</p>
<p>var bound4 = count.bind(obj1, 1, 2, 3) // 指定了多余的参数,多余的参数会被忽略<br>bound4() // 4</p>
<p>所以，bind 方法只是返回了一个新的函数，这个函数内的this指定了执行上下文，而返回这个新函数可以接受参数。</p>
<p>new 绑定</p>
<p>最后要讲的一种 this 绑定规则，是指通过 new 操作符调用构造函数时发生的 this 绑定。首先要明确一点的是，在 javascript 中并没有其他语言那样的类的概念。构造函数也仅仅是普通的函数而已，只不过构造函数的函数名以大写字母开头，也只不过它可以通过 new 操作符调用而已.</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12</p>
<p>function Person(name,age) {<br>  this.name = name<br>  this.age = age<br>  console.log(“我也只不过是个普通函数”)<br>}<br>Person(“zxt”,22) // “我也只不过是个普通函数”<br>console.log(name) // “zxt”<br>console.log(age) // 22</p>
<p>var zxt = new Person(“zxt”,22) // “我也只不过是个普通函数”<br>console.log(zxt.name) // “zxt”<br>console.log(zxt.age) // 22</p>
<p>上面这个例子中，首先定义了一个 Person 函数，既可以普通调用，也可以以构造函数的形式的调用。当普通调用时，则按照正常的函数执行，输出一个字符串。 如果是通过一个new操作符,则构造了一个新的对象。那么，接下来我们再看看两种调用方式， this 分别绑定在了何处首先普通调用时，前面已经介绍过，此时应用默认绑定规则，this绑定在了全局对象上，此时全局对象上会分别增加 name 和 age 两个属性。当通过new操作符调用时，函数会返回一个对象，从输出结果上来看 this 对象绑定在了这个返回的对象上。<br>因此，所谓的new绑定是指通过new操作符来调用函数时，会产生一个新对象，并且会把构造函数内的this绑定到这个对象上。<br>事实上，在javascript中，使用new来调用函数，会自动执行下面的操作。</p>
<p>创建一个全新的对象<br>这个新对象会被执行原型连接<br>这个新对象会绑定到函数调用的this<br>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象<br>四种绑定的优先级</p>
<p>上面讲述了javascript中四种this绑定规则，这四种绑定规则基本上涵盖了所有函数调用情况。但是如果同时应用了这四种规则中的两种甚至更多，又该是怎么样的一个情况，或者说这四种绑定的优先级顺序又是怎么样的。<br>首先，很容易理解，默认绑定的优先级是最低的。这是因为只有在无法应用其他this绑定规则的情况下，才会调用默认绑定。那隐式绑定和显式绑定呢？还是上代码吧，代码可从来不会说谎。</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14</p>
<p>function speak() {<br>  console.log(this.name)<br>}</p>
<p>var obj1 = {<br>  name: ‘obj1’,<br>  speak: speak<br>}<br>var obj2 = {<br>  name: ‘obj2’<br>}</p>
<p>obj1.speak() // obj1 (1)<br>obj1.speak.call(obj2) // obj2 (2)</p>
<p>所以在上面代码中，执行了obj1.speak(),speak函数内部的this指向了obj1，因此(1)处代码输出的当然就是obj1，但是当显式绑定了speak函数内的this到obj2上，输出结果就变成了obj2，所有从这个结果可以看出显式绑定的优先级是要高于隐式绑定的。事实上我们可以这么理解obj1.speak.call(obj2)这行代码，obj1.speak只是间接获得了speak函数的引用，这就有点像前面所说的隐式绑定丢失了上下文。好，既然显式绑定的优先级要高于隐式绑定，那么接下来再来比较一下new 绑定和显式绑定。</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13</p>
<p>function foo(something) {<br>  this.a = something<br>}</p>
<p>var obj1 = {}<br>var bar = foo.bind(obj1) // 返回一个新函数bar，这个新函数内的this指向了obj1 (1)<br>bar(2) // this绑定在了Obj1上，所以obj1.a === 2<br>console.log(obj1.a)</p>
<p>var baz = new bar(3) // 调用new 操作符后，bar函数的this指向了返回的新实例baz (2)</p>
<p>console.log(obj1.a)<br>console.log(baz.a)</p>
<p>我们可以看到，在(1)处，bar函数内部的this原本指向的是obj1，但是在(2)处，由于经过了new操作符调用，bar函数内部的this却重新指向了返回的实例，这就可以说明new 绑定的优先级是要高于显式绑定的。<br>至此，四种绑定规则的优先级排序就已经得出了,分别是</p>
<p>new 绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定</p>
<p>箭头函数中的this绑定</p>
<p>箭头函数是ES6里一个重要的特性。<br>箭头函数的this是根据外层的（函数或者全局）作用域来决定的。函数体内的this对象指的是定义时所在的对象，而不是之前介绍的调用时绑定的对象。举一个例子</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10</p>
<p>var a = 1<br>var foo = () =&gt; {<br>  console.log(this.a) // 定义在全局对象中，因此this绑定在全局作用域<br>}</p>
<p>var obj = {<br>  a: 2<br>}<br>foo() // 1 ,在全局对象中调用<br>foo.call(obj) // 1,显示绑定，由obj对象来调用，但根本不影响结果</p>
<p>从上面这个例子看出，箭头函数的 this 强制性的绑定在了箭头函数定义时所在的作用域，而且无法通过显示绑定，如apply,call方法来修改。在来看下面这个例子</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32</p>
<p>// 定义一个构造函数<br>function Person(name,age) {<br>  this.name = name<br>  this.age = age<br>  this.speak = function (){<br>    console.log(this.name)<br>    // 普通函数（非箭头函数),this绑定在调用时的作用域<br>  }<br>  this.bornYear = () =&gt; {<br>    // 本文写于2016年，因此new Date().getFullYear()得到的是2016<br>    // 箭头函数，this绑定在实例内部<br>    console.log(new Date().getFullYear() - this.age)<br>    }<br>  }<br>}</p>
<p>var zxt = new Person(“zxt”,22)</p>
<p>zxt.speak() // “zxt”<br>zxt.bornYear() // 1994</p>
<p>// 到这里应该大家应该都没什么问题</p>
<p>var xiaoMing = {<br>  name: “xiaoming”,<br>  age: 18 // 小明永远18岁<br>}</p>
<p>zxt.speak.call(xiaoMing)<br>// “xiaoming” this绑定的是xiaoMing这个对象<br>zxt.bornYear.call(xiaoMing)<br>// 1994 而不是 1998,这是因为this永远绑定的是zxt这个实例</p>
<p>因此 ES6 的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 this ，具体来说就是，箭头函数会继承 外层函数调用的this绑定 ，而无论外层函数的this绑定到哪里。</p>
<p>小结</p>
<p>以上就是javascript中所有this绑定的情况，在es6之前，前面所说的四种绑定规则可以涵盖任何的函数调用情况，es6标准实施以后，对于函数的扩展新增了箭头函数，与之前不同的是，箭头函数的作用域位于箭头函数定义时所在的作用域。</p>
<p>而对于之前的四种绑定规则来说，掌握每种规则的调用条件就能很好的理解this到底是绑定在了哪个作用域。</p>
<h3 id="9、-异步的掌握和理解-宏任务、微任务、Promise、async-await"><a href="#9、-异步的掌握和理解-宏任务、微任务、Promise、async-await" class="headerlink" title="9、 异步的掌握和理解(宏任务、微任务、Promise、async-await)"></a>9、 异步的掌握和理解(宏任务、微任务、Promise、async-await)</h3><p>要了解异步我们首先要了解以下基本概念：</p>
<p>一、关于javascript<br>javascript是一门单线程语言，在最新的HTML5中提出了Web-Worker，但javascript是单线程这一核心仍未改变。</p>
<p>二、javascript事件循环<br>既然js是单线程，那就像只有一个窗口的银行，客户需要排队一个一个办理业务，同理js任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务也必须等着。</p>
<p>那么问题来了，假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？</p>
<p>因此聪明的程序员将任务分为两类：</p>
<p>1、同步任务</p>
<p>2、异步任务</p>
<p>当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。</p>
<p>而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。</p>
<p>三、js基本运行机制<br>1、同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。</p>
<p>2、当指定的事情完成时，Event Table会将这个函数移入Event Queue。</p>
<p>3、主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</p>
<p>上述过程会不断重复，也就是常说的Event Loop(事件循环)。流程如下图所示：</p>
<p>举个栗子：</p>
<p>let data = [];<br>$.ajax({<br>    url:<a href="http://www.javascript.com" target="_blank" rel="noopener">www.javascript.com</a>,<br>    data:data,<br>    success:() =&gt; {<br>        console.log(‘发送成功!’);<br>    }<br>})<br>console.log(‘代码执行结束’);<br>上面是一段简易的ajax请求代码：</p>
<p>1、ajax进入Event Table，注册回调函数success。</p>
<p>2、执行console.log(‘代码执行结束’)。</p>
<p>3、ajax事件完成，回调函数success进入Event Queue。</p>
<p>4、主线程从Event Queue读取回调函数success并执行。</p>
<p>那怎么知道主线程执行栈为空？</p>
<p>js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。</p>
<p>四、setTimeout<br>大名鼎鼎的setTimeout无需再多言，大家对他的第一印象就是异步可以延时执行，我们经常这么实现延时3秒执行：</p>
<p>setTimeout(() =&gt; {<br>    task()<br>},3000)<br>那如果是以下这种情况呢？</p>
<p>setTimeout(() =&gt; {<br>    task()<br>},3000)<br>sleep(10000000)<br>这个函数，是经过指定时间后，把要执行的任务(本例中为task())加入到Event Queue中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于3秒。</p>
<p>我们还经常遇到setTimeout(fn,0)这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？</p>
<p>答案是不会的，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。</p>
<p>举个栗子：</p>
<p>setTimeout(() =&gt; {<br>    console.log(‘1’)<br>}, 0);<br>console.log(‘2’);<br>// 2 1<br>关于setTimeout要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。</p>
<p>五、setInterval<br>setInterval上面说完了setTimeout，当然不能错过它的孪生兄弟setInterval。</p>
<p>他俩差不多，只不过后者是循环的执行。</p>
<p>对于执行顺序来说，setInterval会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。</p>
<p>唯一需要注意的一点是，对于setInterval(fn,ms)来说，我们已经知道不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入Event Queue。</p>
<p>一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了。这句话请读者仔细品味。</p>
<p>六、Promise与process.nextTick(callback)<br>Promise的定义和功能本文不再赘述，推荐阅读阮一峰老师的博客 <a href="http://es6.ruanyifeng.com/#docs/promise。" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/promise。</a></p>
<p>而process.nextTick(callback)类似node.js版的”setTimeout”，在事件循环的下一次循环中调用 callback 回调函数。</p>
<p>我们进入正题，除了广义的同步任务和异步任务，我们对任务有更精细的定义：</p>
<p>1、macro-task(宏任务)：包括整体代码script，setTimeout，setInterval</p>
<p>2、micro-task(微任务)：Promise，process.nextTick</p>
<p>不同类型的任务会进入对应的Event Queue，比如setTimeout和setInterval会进入相同的Event Queue。</p>
<p>事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。听起来有点绕，举个栗子：</p>
<p>setTimeout(function() {<br>    console.log(‘setTimeout’);<br>    resolve();<br>}, 0)<br>new Promise(function(resolve) {<br>    console.log(‘promise’);<br>}).then(function() {<br>    console.log(‘then’);<br>})<br>console.log(‘console’);<br>1、这段代码作为宏任务，进入主线程。</p>
<p>2、先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述)</p>
<p>3、接下来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue。</p>
<p>4、遇到console.log()，立即执行。</p>
<p>5、好啦，整体代码script作为第一个宏任务执行结束，看看有哪些微任务？</p>
<p>6、我们发现了then在微任务Event Queue里面，执行。</p>
<p>7、ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。</p>
<p>8、我们发现了宏任务Event Queue中setTimeout对应的回调函数，立即执行。</p>
<p>9、结束。</p>
<p>异步任务的执行流程如下图：</p>
<p>六、async-await<br>1、解决了什么问题?<br>async-await是promise和generator的语法糖，在async/await之前，我们有三种方式写异步代码：</p>
<p>1）嵌套回调</p>
<p>2）以Promise为主的链式回调</p>
<p>3）使用Generators</p>
<p>2、基本用法<br>// async/await<br>async getBooksByAuthorWithAwait(authorId) {<br>    const books = await bookModel.fetchAll();<br>    return books.filter(b =&gt; b.authorId === authorId);<br>}<br>上述代码就是async-await的基本使用形式。</p>
<p>3、async<br>用来表示函数是异步的，定义的函数会返回一个promise对象，可以使用then方法添加回调函数。</p>
<p>async function getNumber() {<br>    return 123;<br>}</p>
<p>getNumber().then(val =&gt; {<br>    console.log(val);// 123<br>}<br>若 async 定义的函数有返回值，return 123; 相当于Promise.resolve(123)</p>
<p>4、await<br>await 后面可以跟任何的JS 表达式。</p>
<p>虽然说 await 可以等很多类型的东西，但是它最主要的意图是用来等待 Promise 对象的状态被 resolved。</p>
<p>如果await的是 promise对象会造成异步函数停止执行并且等待 promise 的解决，如果等的是正常的表达式则立即执行。</p>
<p>***必须出现在 async 函数内部，不能单独使用。</p>
<p>举个栗子：await命令就可以让程序停顿指定的时间</p>
<p>function sleep(interval) {<br>  return new Promise(resolve =&gt; {<br>    setTimeout(resolve, interval);<br>  })<br>}</p>
<p>// 用法<br>async function one2FiveInAsync() {<br>  for(let i = 1; i &lt;= 5; i++) {<br>    console.log(i);<br>    await sleep(1000);<br>  }<br>}</p>
<p>one2FiveInAsync();<br>5、async-await 的陷阱（过于线性化）<br>虽然 await 能够使你的代码看起来像同步代码一样，但是一定要记住这些代码仍然是以异步的方式执行的，注意不要使代码过于线性化。</p>
<p>async getBooksAndAuthor(authorId) {<br>    const books = await bookModel.fetchAll();<br>    const author = await authorModel.fetch(authorId);<br>    return {<br>        author,<br>        books: books.filter(book =&gt; book.authorId === authorId),<br>    };<br>}<br>这段代码看起来逻辑上没有问题。然而是不正确的。</p>
<p>1）await bookModel.fetchAll() 将会等待 fetchAll() 执行完。</p>
<p>2）然后 await authorModel.fetch(authorId) 才会被执行</p>
<p>注意， authorModel.fetch(authorId) 并不依赖 bookModel.fetchAll() 的结果，实际上他们可以并行执行。然而，由于使用了 await 这两次调用就变成了串行的了，花费的总时间将会远超并行的方式。</p>
<p>以下是正确的使用方式：</p>
<p>async getBooksAndAuthor(authorId) {<br>    const bookPromise = bookModel.fetchAll();<br>    const authorPromise = authorModel.fetch(authorId);<br>    const book = await bookPromise;<br>    const author = await authorPromise;<br>    return {<br>        author,<br>        books: books.filter(book =&gt; book.authorId === authorId),<br>    };<br>}<br>或者更复杂的情况下，如果你想依次请求一个列表的内容，你必须依赖 promises：</p>
<p>async getAuthors(authorIds) {<br>    // WRONG, this will cause sequential calls<br>    // const authors = _.map(<br>    //   authorIds,<br>    //   id =&gt; await authorModel.fetch(id));<br>    // CORRECT<br>    const promises = _.map(authorIds, id =&gt; authorModel.fetch(id));<br>    const authors = await Promise.all(promises);<br>}<br>简而言之，你必须把这个工作流程看成是异步的，然后再尝试使用 await 以同步的方式去编写代码。</p>
<p>在复杂的流程下面，直接使用 promises 可能会更简单。</p>
<p>6、错误处理</p>
<p>使用 promises 的情况下，一个异步函数会返回两种可能的值：resolved 和 rejected。我们可以使用 .then() 来处理正常的情况 .catch() 处理异常情况。</p>
<p>然而对于 async/await 来说，异常处理可能会有点诡异。</p>
<p>1）try…catch</p>
<p>最标准的处理方式是使用 try…catch 表达式。当 await 一个函数调用的时候，任何 rejected 的值都会以异常的形式抛出来。这里有个例子：</p>
<p>class BookModel {<br>    fetchAll() {<br>        return new Promise((resolve, reject) =&gt; {<br>            window.setTimeout(() =&gt; {<br>                reject({‘error’: 400})<br>            }, 1000);<br>        });<br>    }<br>}<br>// async/await<br>async getBooksByAuthorWithAwait(authorId) {<br>    try {<br>        const books = await bookModel.fetchAll();<br>    } catch (error) {<br>        console.log(error);    // { “error”: 400 }<br>    }<br>}<br>2）使用 .catch</p>
<p>回忆一下 await 的功能：它会等待一个 promise 完成它的任务。同时请回忆一下， promise.catch() 也会返回一个 promise。因此我们可以像下面这样处理错误处理的方式：</p>
<p>let books = await bookModel.fetchAll()<br>    .catch((error) =&gt; {<br>        console.log(error);<br>    });<br>参考资料：</p>
<p><a href="https://juejin.im/post/59e85eebf265da430d571f89" target="_blank" rel="noopener">https://juejin.im/post/59e85eebf265da430d571f89</a></p>
<p><a href="https://juejin.im/post/5a6547d0f265da3e283a1df7?utm_medium=fe&amp;utm_source=weixinqun#heading-18" target="_blank" rel="noopener">https://juejin.im/post/5a6547d0f265da3e283a1df7?utm_medium=fe&amp;utm_source=weixinqun#heading-18</a></p>
<p><a href="https://juejin.im/post/5d116ae5518825328779c9d5" target="_blank" rel="noopener">https://juejin.im/post/5d116ae5518825328779c9d5</a></p>
<h3 id="10、-http、https协议-amp-amp-各层级关系-amp-amp-状态码"><a href="#10、-http、https协议-amp-amp-各层级关系-amp-amp-状态码" class="headerlink" title="10、 http、https协议&amp;&amp;各层级关系&amp;&amp;状态码"></a>10、 http、https协议&amp;&amp;各层级关系&amp;&amp;状态码</h3><p>一、HTTP<br>1、http概念<br>超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。 设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。通过HTTP或者HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。</p>
<p>HTTP是客户端浏览器或其他程序与Web服务器之间的应用层通信协议。</p>
<p>2、HTTP 特点<br>永远都是客户端发起请求，服务器回送响应 。<br>无状态的协议。 HTTP 是一种无状态协议。协议自身不对请求和响应之间的通信状态进行保存。<br>Cookie 管理状态。 Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。<br>URI 定位资源 HTTP 协议使用 URI 定位互联网上的资源。正是因为 URI 的特定功能，在互联网上任意位置的资源都能访问到。<br>持久连接</p>
<p>HTTP 协议的初始版本中，每进行一个 HTTP 通信都要断开一次 TCP 连接。比如使用浏览器浏览一个包含多张图片的 HTML 页面时，在发送请求访问 HTML 页面资源的同时，也会请求该 HTML 页面里包含的其他资源。因此，每次的请求都会造成无畏的 TCP 连接建立和断开，增加通信量的开销。 为了解决上述 TCP 连接的问题，HTTP/1.1 和部分 HTTP/1.0 想出了持久连接的方法。其特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。旨在建立一次 TCP 连接后进行多次请求和响应的交互。在 HTTP/1.1 中，所有的连接默认都是持久连接。</p>
<p>管线化<br>持久连接使得多数请求以管线化方式发送成为可能。以前发送请求后需等待并接收到响应，才能发送下一个请求。管线化技术出现后，不用等待亦可发送下一个请求。这样就能做到同时并行发送多个请求，而不需要一个接一个地等待响应了。 比如，当请求一个包含多张图片的 HTML 页面时，与挨个连接相比，用持久连接可以让请求更快结束。而管线化技术要比持久连接速度更快。请求数越多，时间差就越明显。</p>
<p>3、http协议层<br>HTTP（HyperText Transfer Protocol），超文本传输协议，是一个基于TCP实现的应用层协议。</p>
<p>4、HTTP工作过程<br>1）地址解析</p>
<p>如用客户端浏览器请求这个页面：localhost.com:8080/index.htm 从中分解出协议名、主机名、端口、对象路径等部分，对于我们的这个地址，解析得到的结果如下：</p>
<p>协议名：http<br>主机名：localhost.com<br>端口：8080<br>对象路径：/index.htm<br>复制代码<br>复制代码<br>在这一步，需要域名系统DNS解析域名,得主机的IP地址。</p>
<p>2）封装HTTP请求数据包</p>
<p>把以上部分结合本机自己的信息，封装成一个HTTP请求数据包</p>
<p>3）封装成TCP包，建立TCP连接（TCP的三次握手）</p>
<p>在HTTP工作开始之前，客户机（Web浏览器）首先要通过网络与服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接。这里是8080端口。</p>
<p>4）客户端向服务器发送请求命令</p>
<p>建立TCP连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。</p>
<p>5）服务器响应</p>
<p>服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。</p>
<p>实体消息是服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据.</p>
<p>6）服务器关闭TCP连接</p>
<p>一般情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接，然后如果客户端或者服务器在其头信息加入了这行代码 Connection:keep-alive ，TCP 连接在发送后将仍然保持打开状态，于是，客户端可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p>
<p>二、HTTPS<br>1、概念<br>超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。</p>
<p>HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。</p>
<p>HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p>
<p>简而言之: HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。</p>
<p>HTTPS比HTTP多了一层TLS/SSL协议</p>
<p>2、http与https区别<br>HTTP 是明文传输，HTTPS 通过 SSL\TLS 进行了加密<br>HTTP 的端口号是 80，HTTPS 是 443<br>HTTPS 需要到 CA 申请证书，一般免费证书很少，需要交费<br>HTTP 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</p>
<p>三、状态码<br>1xx：信息响应( Informational response)<br>简介：表示响应已被服务端接收、理解，但还需做进一步处理，该类型状态码往往是临时性的，因为马上将会变为以下状态之一：成功(2xx)、重定向(3xx)、异常或错误(4xx或5xx)</p>
<p>2XX：请求成功(Success)<br>简介：表示客户端发送的请求已成功被服务端接收、理解、接受</p>
<p>200 成功(ok)：标准的HTTP请求响应成功状态码，get请求中，响应将包含与请求对应的实体，post请求中，响应将包含实体的描述或实体的操作结果<br>202 已接受请求(Accepted)：服务端接受了请求，但还没处理，最终可能会成功、或不会被执行或禁止执行<br>204 无内容(No Content)：服务端成功处理了请求，但没返回任何内容<br>205 重置内容(Reset Content)：服务端成功处理了请求，但没返回任何内容，区别于204的是：该响应要求客户端重置文档视图。<br>206 部分内容(Partial Content)：服务端成功处理了请求的部分内容，该状态码一般用于HTTP下载工具的断点续传功能或多个下载的分段进行(如迅雷下载)<br>3XX：重定向(Redirection)<br>简介：表示客户端需要采取进一步的操作才能完成请求，该状态码常用于URL重定向，后续的请求地址在本次响应的Location域中指明</p>
<p>301 永久移动(Moved Permanently)：被请求资源已被永久的转移到新位置，并且将来对此资源的引用都应该使用它返回的URI之一，新的永久性URI将在Location域中返回。永远也别来烦我，去找张三吧。<br>302 临时移动(Found，原始短语为Moved Temporarily)：由于移动式临时的，客户端以后还是用原来的地址发送请求，新的临时URI将在Location域中返回<br>303 看其它(See Other)：请求的地址已经被移动，请求的对应地址可以在另一个URI上被找到<br>304 未修改(Not Modified)：表示当前资源的版本在根据请求头的If-Modified-Since和If-None-Match参数判断缓存后，资源未曾被修改，这样客户端不需要重新传新资源，客户端仍然使用上次下载的资源复件。<br>4XX：客户端错误(Client errors)<br>简介：表示错误情况可能是由客户端导致的，除非是一个HEAD请求，否则服务器应该把错误请求的详细解释实体抛出来阐述错误情况，这个错误信息应该告诉是临时的还是永久状况，该状态码适用于任何请求方法。客户端应该尽可能把错误实体展示给用户。</p>
<p>400 错误请求(Bad Request)：明显的客户端错误请求(如：语法缺陷，请求包过大、无效的请求消息片段、欺诈性请求路由)<br>401 未授权(Unauthorized)：类似于403 Forbidden错误，但不同的是该错误是指在特定的认证情况下，用户未能通过认证(如：登陆认证)<br>403 已拒绝(Forbidden)：该请求已被服务器验证为有效，但是服务器拒绝了它的操作，一般是因为用户没有取得对应资源的使用权。<br>404 未找到(Not Found)<br>405 方法不被允许(Method Not Allowed)：该请求方法不支持对需请求资源的访问。如：明明是需要post方法的，你却给我传了个get方法<br>406 请求无法接受(Not Acceptable)：请求资源的内容格式无法满足请求头中的要求，因而无法生成响应体，故无法接受，请求的格式由Content-type头重定义的媒体类型决定<br>408 请求超时(Request Timeout)：客户端没有在服务器预备等待的时间内完成一个请求的发送，客户端可以随时再次提交这一请求而无需进行任何更改。<br>409 冲突(Confict)：因为请求存在冲突无法处理，比如多人在线编辑工具出现的冲突<br>5XX：服务器错误(Server errors)<br>简介：表示服务端无法完成请求，该状态表示服务端在处理请求的过程中发生了错误或异常</p>
<p>500 内部服务错误(Internal Server Error)：通用错误消息，服务端遇到了一个未曾预料的情况(如：服务端可能没有使用try catch等错误处理机制来抓到并处理错误异常)，无法给出更具体的错误消息来解释 —— 我的错，但我不知道我错哪了<br>501 请求无法实现(Not implemented)：服务端不支持当前请求中所需的某个功能—— 臣妾做不到啊！<br>502 损坏的网关(Bad Gateway)：作为网关或代理工作的服务端尝试执行请求时，从上游服务器接收到无效的响应。<br>503 服务不可用(Service Unavailable)：由于临时的请求过载，导致服务端无法处理请求，该状况只是暂时的，并且会在一段时间后恢复，如果能预计延迟时间，那么响应中包含一个Retry-After头来标明延迟时间</p>
<h3 id="11、跨域知识的了解以及常见的跨域实现方法"><a href="#11、跨域知识的了解以及常见的跨域实现方法" class="headerlink" title="11、跨域知识的了解以及常见的跨域实现方法"></a>11、跨域知识的了解以及常见的跨域实现方法</h3><p>要明白什么是跨域之前，首先要明白什么是同源策略？</p>
<p>同源策略就是用来限制从一个源加载的文档或脚本与来自另一个源的资源进行交互。<br>如果协议、端口（如果指定了）和主机对于两个页面是相同的，则两个页面具有相同的源，也就是同源。也就是说，同源要同时满足以下3个条件：</p>
<p>协议相同<br>端口相同<br>主机相同<br>举个例子就一目了然了。我们来看下面的页面是否与 <a href="http://store.company.com/dir/index.html" target="_blank" rel="noopener">http://store.company.com/dir/index.html</a> 是同源的?</p>
<p>代码<br>1<br>2<br>3<br>4<br>5</p>
<ol>
<li><a href="http://store.company.com/dir/index2.html" target="_blank" rel="noopener">http://store.company.com/dir/index2.html</a> 同源</li>
<li><a href="http://store.company.com/dir2/index3.html" target="_blank" rel="noopener">http://store.company.com/dir2/index3.html</a> 同源 虽然在不同文件夹下</li>
<li><a href="https://store.company.com/secure.html" target="_blank" rel="noopener">https://store.company.com/secure.html</a> 不同源 不同的协议(https)</li>
<li><a href="http://store.company.com:81/dir/index.html" target="_blank" rel="noopener">http://store.company.com:81/dir/index.html</a> 不同源 不同的端口(81)</li>
<li><a href="http://news.company.com/dir/other.html" target="_blank" rel="noopener">http://news.company.com/dir/other.html</a> 不同源 不同的主机(news)<br>所以当面对跨域问题的时候，有什么解决方案呢？</li>
</ol>
<p>A. document.domain 方法<br>我们来看一个具体场景：有一个页面 <a href="http://www.example.com/a.html" target="_blank" rel="noopener">http://www.example.com/a.html</a> ，它里面有一个iframe，这个iframe的源是 <a href="http://example.com/b.html" target="_blank" rel="noopener">http://example.com/b.html</a> ，很显然它们是不同源的，所以我们无法在父页面中操控子页面的内容。<br>解决方案如下：</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br><!-- b.html --></p>
<script>
    document.domain = 'example.com';
</script>


<hr>
<!-- a.html -->
<script>
    document.domain = 'example.com';
    var iframe = document.getElementById('iframe').contentWindow.document;
    //后面就可以操作iframe里的内容了...
</script>
所以我们只要将两个页面的document.domain设置成一致就可以了，要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域。但是，这种方法只能解决主域相同的跨域问题。

B.window.name 方法
Window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。我们来看一个具体场景，在一个页面 example.com/a.html 中，我们想获取 data.com/data.html 中的数据，以下是解决方案：

代码
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
<!-- data.html -->
<script>
    window.name = 'data'; //这是就是我们需要通信的数据
</script>
-------------------------------------------------------

<!-- a.html -->
<html>
<head><meta name="generator" content="Hexo 3.8.0">
<script>
    function getData () {
        var iframe = document.getElementById('iframe');
        iframe.src = 'example.com/b.html'; // 这里让iframe与父页面同源
        iframe.onload = function () {
            var data = iframe.contentWindow.name; //在这里我们得到了跨域页面中传来的数据
        };
    }
</script>
</head>
<body>
</body>
</html>
C.JSONP 方法
JONSP(JSON with Padding)是JSON的一种使用模式。基本原理如下：

代码
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
<!-- a.html -->
<script>
    function dealData (data) {
        console.log(data);
    }
</script>
<script src="http://example.com/data.php?callback=dealData"></script>


<hr>
<p>&lt;?php<br>    $callback = $_GET[‘callback’];<br>    $data = ‘data’;<br>    echo $callback.’(‘.json_encode($data).’)’;<br>?&gt;</p>
<p>这时候在a.html中我们得到了一条js的执行语句dealData(‘data’)，从而达到了跨域的目的。所以JSONP的原理其实就是利用引入script不限制源的特点，把处理函数名作为参数传入，然后返回执行语句，仔细阅读以上代码就可以明白里面的意思了。<br>如果在jQuery中用JSONP的话就更加简单了：</p>
<p>代码<br>1<br>2<br>3<br>4<br>5</p>
<p><script><br>    $.getJSON(‘’<a href="http://example.com/data.php?callback=?&#39;">http://example.com/data.php?callback=?&#39;</a>, function (data) {<br>        console.log(data);<br>    });<br></script><br>注意jQuery会自动生成一个全局函数来替换callback=?中的问号，之后获取到数据后又会自动销毁，实际上就是起一个临时代理函数的作用。$.getJSON方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用JSONP的回调函数。</p>
<p>D.cors 方法</p>
<p>CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</p>
<p>E.postMessage 方法<br>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p>
<p>代码<br>1<br>2<br>3<br>4</p>
<ul>
<li>页面和其打开的新窗口的数据传递</li>
<li>多窗口之间消息传递</li>
<li>页面与嵌套的iframe消息传递</li>
<li>上面三个场景的跨域数据传递</li>
</ul>
<p>postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。</p>
<p>postMessage(message, targetOrigin, [transfer]);</p>
<p>代码<br>1<br>2<br>3</p>
<ul>
<li>message: 将要发送到其他 window的数据。</li>
<li>targetOrigin:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”*”（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。</li>
<li>transfer(可选)：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</li>
</ul>
<p>Eg. 接下来我们看个例子： <a href="http://localhost:3000/a.html" target="_blank" rel="noopener">http://localhost:3000/a.html</a> 页面向<a href="http://localhost:4000/b.html" target="_blank" rel="noopener">http://localhost:4000/b.html</a> 传递“你是谁”,然后后者传回”不告诉你”。</p>
<p>代码</p>
<p>// a.html</p>
<p>&lt;iframe src=“<a href="http://localhost:4000/b.html&quot;" target="_blank" rel="noopener">http://localhost:4000/b.html&quot;</a> frameborder=”0” id=”frame” onload=”load()”&gt; //等它加载完触发一个事件<br>//内嵌在 <a href="http://localhost:3000/a.html" target="_blank" rel="noopener">http://localhost:3000/a.html</a></p>
<p><script><br>    function load() {<br>        let frame = document.getElementById(‘frame’)<br>        frame.contentWindow.postMessage(‘你是谁’, ‘<a href="http://localhost:4000&#39;">http://localhost:4000&#39;</a>) //发送数据<br>        window.onmessage = function(e) {<br>        //接受返回数据<br>            console.log(e.data) //不告诉你<br>        }<br>    }<br></script><br>// b.html<br>window.onmessage = function(e) {<br>    console.log(e.data) // 你是谁<br>    e.source.postMessage(‘不告诉你’, e.origin)<br>}</p>
<p>参考：<a href="https://juejin.im/post/5c23993de51d457b8c1f4ee1" target="_blank" rel="noopener">https://juejin.im/post/5c23993de51d457b8c1f4ee1</a><br>参考：<a href="https://segmentfault.com/a/1190000013278814" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013278814</a><br>参考：<a href="https://blog.csdn.net/guoshenglong11/article/details/51953063" target="_blank" rel="noopener">https://blog.csdn.net/guoshenglong11/article/details/51953063</a></p>
<h3 id="12、-浏览器中的常见各类攻击手段"><a href="#12、-浏览器中的常见各类攻击手段" class="headerlink" title="12、 浏览器中的常见各类攻击手段"></a>12、 浏览器中的常见各类攻击手段</h3><p>常见的web攻击手段有 XSS攻击、CSRF攻击、SQL注入攻击…</p>
<p><em>XSS攻击
</em>CSRF攻击<br><em>SQL注入攻击
</em>文件上传漏洞<br><em>DDoS攻击
</em>其他攻击手段</p>
<p>XSS攻击<br>XSS（Cross Site Scripting）跨站脚本攻击，为了不与层叠样式表（CSS）混淆，故将跨站脚本攻击缩写为XSS。原理即在网页中嵌入恶意脚本，当用户打开网页时，恶意脚本便开始在用户浏览器上执行，以盗取客户端cookie、用户名、密码，甚至下载木马程式，危害可想而知。以一个表单输入举例说明：</p>
<p>代码<br>1</p>
<input type="text" name="firstname" value>


<p>倘若用户在表单中输入恶意脚本，即对输入做些处理，如：</p>
<p>代码<br>1</p>
<p><input type="text" name="firstname" value><script>alert(“longlong”)</script>&lt;!– “/&gt;</p>
<p>其实攻击的形式还有很多，比如将脚本伪装进URL，然后将URL进行URLEncode编码，当用户点击链接后，脚本就会被执行。</p>
<p>XSS防范：</p>
<p>之所以会发生XSS攻击，是因为用户输入的数据变成了代码， 因此需要对用户输入的数据进行HTML转义处理，将输出的“尖括号”、“单引号”、“引号”之类的特色符号进行转义。</p>
<p>HTML    HTML转义后的字符<br>&lt;    &lt;</p>
<blockquote>
<p>   &gt;<br>‘    &amp;<br>“    &quot;<br>CSRF攻击<br>CSRF攻击的全称跨站请求伪造（Cross Site Request Forgery），通过盗用用户的身份信息，以你的名义向第三方网站发起恶意请求，若转账、盗取账号、发信息、邮件。流程框图如下：</p>
</blockquote>
<p>所以CSRF攻击一般场景是：</p>
<p>1、用户登录受信站点A，生成本地cookie；<br>2、用户没有退出站点A，访问了恶意站点B。</p>
<p>CSRF攻击举例：</p>
<p>恶意转账</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>Get请求<br><a href="http://www.boc.com/transfer.do?accountNum=6233XXXX4324&amp;money=10000" target="_blank" rel="noopener">www.boc.com/transfer.do?accountNum=6233XXXX4324&amp;money=10000</a><br>参数说明<br>accountNum转账目标账号<br>money转账金额<br>如果银行系统利用上述接口转账，就用可能会被恶意网站攻击。当然上面仅是举例，银行安全等级不至于这么低，使用GET转账。比如银行升级接口为POST提交，当然这也不能解决根本的安全问题，黑客照样能够利用XSS漏洞植入恶意代码，请求转账接口。真实银行交易系统付款会有USB key、验证码、登陆密码、支付密码等一系列屏障，支付流程要复杂得多，安全系数也高很多。</p>
<p>CSRF攻击防御：</p>
<p>将cookie设置为HttpOnly<br>CSRF攻击很大程度是利用了浏览器的cookie，为了防止站内XSS漏洞，cookie设置HttpOnly属性，JS脚本就无法读取到cookie中的信息，避免攻击者伪造cookie的情况出现。<br>设置方式参考：<a href="https://www.cnblogs.com/relucent/p/4171478.html" target="_blank" rel="noopener">https://www.cnblogs.com/relucent/p/4171478.html</a></p>
<p>增加token</p>
<p>CSRF攻击之所以成功，主要是攻击中伪造了用户请求，而用户请求的验证信息都在cookie中，攻击者就可以利用cookie伪造请求通过安全验证。因此抵御CSRF攻击的关键就是，在请求中放入攻击者不能伪造的信息，并且信息不在cookie中。<br>鉴于此，开发人员可以在http请求中以参数的形式加一个token，此token在服务端生成，也在服务端校验，服务端的每次会话都可以用同一个token。如果验证token不一致，则认为至CSRF攻击，拒绝请求。 表单中增加一个隐藏域：</p>
<p>代码<br>1</p>
<p><input type="hidden" name="_token" value="tokenvalue"><br>在服务端session中添加token：</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>HttpSession session = request.getSession();<br>Object token = session.getAttribute(“_token”);<br>if(token == null || “”.equals(_token){<br>    session.setAttribute(“_token”,UUID.randomUUID().toString());<br>}<br>通过Referer识别</p>
<p>Http头中有一个字段Referer，它记录了Http请求来源地址。但是注意不要把Rerferer用在身份验证或者其他非常重要的检查上，因为Rerferer非常容易在客户端被改变。（火狐的一个插件RefControl修改Referer引用）</p>
<p>SQL注入攻击<br>SQL注入攻击就是把SQL命令伪装成正常的http请求参数，传递到服务端，欺骗服务器最终执行恶意的SQL命令，达到入侵目的。SQL注入攻击原理如下：</p>
<p>代码<br>1<br>2<br>3<br>String sql = “select * from user where nick = ‘“ + nickname + “‘ and password = ‘“ + password + “‘“;<br>Statement st = (Statement) conn.createStatement();<br>ResultSet rs = st.executeQuery(sql);<br>上述代码是校验用户名、密码是否有效，查询结果记录数大于0则表示有效。正常逻辑是用户名、密码匹配数据库记录；但攻击者会利用http参数进行SQL注入攻击，即password参数输入’ or ‘1’ = ‘1，导致SQL语句变为</p>
<p>代码<br>1<br>select * from user where nick = ‘zhangshan’ and password = ‘’ or ‘1’ = ‘1’;<br>上述语句的执行结果就相当于用户能够绕过登录验证。</p>
<p>SQL注入防范</p>
<p>使用预编译语句<br>Java原生的预编译语句为PreparedStatement，是Java.sql中的一个接口，继承自Statement。</p>
<p>SQL执行    说明<br>Statement    SQL语句（包含参数）会直接发给DBMS，编译后再执行<br>PreparedStatement    SQL语句（参数为占位符？）发给DBMS编译，DBMS直接运行编译后的SQL语句，参数会在执行阶段传入<br>使用ORM框架 ORM框架如MyBatis <a href="http://www.mybatis.org/mybatis-3/，在Mapper" target="_blank" rel="noopener">http://www.mybatis.org/mybatis-3/，在Mapper</a> XML配置的语句如下：</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6</p>
<p><select id="selectPerson" parametertype="int" resulttype="hashmap"><br>  SELECT * FROM PERSON WHERE ID = #{id}<br></select></p>
<p><select id="selectPerson" parametertype="int" resulttype="hashmap"><br>  SELECT * FROM PERSON WHERE ID = ${id}<br></select><br>有两种参数传递的方式：#{}、${}，两者的差异就在于，#是在预编译后，执行语句时再传递参数，$是先传递参数，然后再执行编译，再执行语句，SQL注入就是利用这种方式。</p>
<p>参考：<a href="https://blog.csdn.net/loongshawn/article/details/88047373" target="_blank" rel="noopener">https://blog.csdn.net/loongshawn/article/details/88047373</a><br>参考：<a href="https://blog.csdn.net/zou2ouzou/article/details/60888073" target="_blank" rel="noopener">https://blog.csdn.net/zou2ouzou/article/details/60888073</a></p>
<h3 id="13、关于-storage-和-cookie-的知识点，包括常见的缓存、存储机制"><a href="#13、关于-storage-和-cookie-的知识点，包括常见的缓存、存储机制" class="headerlink" title="13、关于 storage 和 cookie 的知识点，包括常见的缓存、存储机制"></a>13、关于 storage 和 cookie 的知识点，包括常见的缓存、存储机制</h3><p>Cookie<br>1.Cookie 的来源</p>
<p>Cookie 的本职工作并非本地存储，而是“维持状态”。 因为HTTP协议是无状态的，HTTP协议自身不对请求和响应之间的通信状态进行保存，通俗来说，服务器不知道用户上一次做了什么，这严重阻碍了交互式Web应用程序的实现。在典型的网上购物场景中，用户浏览了几个页面，买了一盒饼干和两瓶饮料。最后结帐时，由于HTTP的无状态性，不通过额外的手段，服务器并不知道用户到底买了什么，于是就诞生了Cookie。它就是用来绕开HTTP的无状态性的“额外手段”之一。服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器会话中的状态。</p>
<p>我们可以把Cookie 理解为一个存储在浏览器里的一个小小的文本文件，它附着在 HTTP 请求上，在浏览器和服务器之间“飞来飞去”。它可以携带用户信息，当服务器检查 Cookie 的时候，便可以获取到客户端的状态。</p>
<p>在刚才的购物场景中，当用户选购了第一项商品，服务器在向用户发送网页的同时，还发送了一段Cookie，记录着那项商品的信息。当用户访问另一个页面，浏览器会把Cookie发送给服务器，于是服务器知道他之前选购了什么。用户继续选购饮料，服务器就在原来那段Cookie里追加新的商品信息。结帐时，服务器读取发送来的Cookie就行了。</p>
<p>2.什么是Cookie及应用场景</p>
<p>Cookie指某些网站为了辨别用户身份而储存在用户本地终端上的数据(通常经过加密)。 cookie是服务端生成，客户端进行维护和存储。通过cookie,可以让服务器知道请求是来源哪个客户端，就可以进行客户端状态的维护，比如登陆后刷新，请求头就会携带登陆时response header中的set-cookie,Web服务器接到请求时也能读出cookie的值，根据cookie值的内容就可以判断和恢复一些用户的信息状态。</p>
<p>如上图所示，Cookie 以键值对的形式存在。<br>典型的应用场景有：</p>
<p>记住密码，下次自动登录。<br>购物车功能。<br>记录用户浏览数据，进行商品（广告）推荐。<br>3.Cookie的原理及生成方式</p>
<p>Cookie的原理</p>
<p>第一次访问网站的时候，浏览器发出请求，服务器响应请求后，会在响应头里面添加一个Set-Cookie选项，将cookie放入到响应请求中，在浏览器第二次发请求的时候，会通过Cookie请求头部将Cookie信息发送给服务器，服务端会辨别用户身份，另外，Cookie的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。<br>Cookie的生成方式主要有两种：</p>
<p>生成方式一：http response header中的set-cookie<br>我们可以通过响应头里的 Set-Cookie 指定要存储的 Cookie 值。默认情况下，domain 被设置为设置 Cookie 页面的主机名，我们也可以手动设置 domain 的值。</p>
<p>代码<br>1<br>Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2018 07:28:00 GMT;//可以指定一个特定的过期时间（Expires）或有效期（Max-Age）<br>当Cookie的过期时间被设定时，设定的日期和时间只与客户端相关，而不是服务端。</p>
<p>生成方式二：js中可以通过document.cookie可以读写cookie，以键值对的形式展示<br>例如我们在掘金社区控制台输入以下三句代码，便可以在Chrome 的 Application 面板查看生成的cookie:</p>
<p>代码<br>1<br>2<br>3<br>document.cookie=”userName=hello”<br>document.cookie=”gender=male”<br>document.cookie=’age=20;domain=.baidu.com’</p>
<p>从上图中我们可以得出：<br>Domain 标识指定了哪些域名可以接受Cookie。如果没有设置domain，就会自动绑定到执行语句的当前域。 如果设置为”.baidu.com”,则所有以”baidu.com”结尾的域名都可以访问该Cookie，所以在掘金社区上读取不到第三条代码存储Cookie值。</p>
<p>4.Cookie的缺陷</p>
<p>Cookie 不够大<br>Cookie的大小限制在4KB左右，对于复杂的存储需求来说是不够用的。当 Cookie 超过 4KB 时，它将面临被裁切的命运。这样看来，Cookie 只能用来存取少量的信息。此外很多浏览器对一个站点的cookie个数也是有限制的。这里需注意：各浏览器的cookie每一个name=value的value值大概在4k，所以4k并不是一个域名下所有的cookie共享的,而是一个name的大小。<br>过多的 Cookie 会带来巨大的性能浪费<br>Cookie 是紧跟域名的。同一个域名下的所有请求，都会携带 Cookie。大家试想，如果我们此刻仅仅是请求一张图片或者一个 CSS 文件，我们也要携带一个 Cookie 跑来跑去（关键是 Cookie 里存储的信息并不需要），这是一件多么劳民伤财的事情。Cookie 虽然小，请求却可以有很多，随着请求的叠加，这样的不必要的 Cookie 带来的开销将是无法想象的。<br>cookie是用来维护用户信息的，而域名(domain)下所有请求都会携带cookie，但对于静态文件的请求，携带cookie信息根本没有用，此时可以通过cdn（存储静态文件的）的域名和主站的域名分开来解决。<br>由于在HTTP请求中的Cookie是明文传递的，所以安全性成问题，除非用HTTPS。<br>5.Cookie与安全</p>
<p>对于 cookie 来说，我们还需要注意安全性。</p>
<p>HttpOnly 不支持读写，浏览器不允许脚本操作document.cookie去更改cookie， 所以为避免跨域脚本 (XSS) 攻击，通过JavaScript的 Document.cookie API无法访问带有 HttpOnly 标记的Cookie，它们只应该发送给服务端。如果包含服务端 Session 信息的 Cookie 不想被客户端 JavaScript 脚本调用，那么就应该为其设置 HttpOnly 标记。</p>
<p>代码<br>1<br>Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly<br>标记为 Secure 的Cookie只应通过被HTTPS协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过Cookie传输，因为Cookie有其固有的不安全性，Secure 标记也无法提供确实的安全保障。<br>为了弥补 Cookie 的局限性，让“专业的人做专业的事情”，Web Storage 出现了。<br>HTML5中新增了本地存储的解决方案—-Web Storage，它分成两类：sessionStorage和localStorage。这样有了WebStorage后，cookie能只做它应该做的事情了——作为客户端与服务器交互的通道，保持客户端状态。</p>
<p>LocalStorage<br>1.LocalStorage的特点</p>
<p>保存的数据长期存在，下一次访问该网站的时候，网页可以直接读取以前保存的数据。<br>大小为5M左右<br>仅在客户端使用，不和服务端进行通信<br>接口封装较好<br>基于上面的特点，LocalStorage可以作为浏览器本地缓存方案，用来提升网页首屏渲染速度(根据第一请求返回时，将一些不变信息直接存储在本地)。</p>
<p>2.存入/读取数据</p>
<p>localStorage保存的数据，以“键值对”的形式存在。也就是说，每一项数据都有一个键名和对应的值。所有的数据都是以文本格式保存。 存入数据使用setItem方法。它接受两个参数，第一个是键名，第二个是保存的数据。 localStorage.setItem(“key”,”value”); 读取数据使用getItem方法。它只有一个参数，就是键名。 var valueLocal = localStorage.getItem(“key”);<br>具体步骤，请看下面的例子：</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16</p>
<p><script><br>  if(window.localStorage){<br>    localStorage.setItem（’name’,’world’）<br>    localStorage.setItem（’gender’,’female’）<br> }<br></script></p>
<p><body><br>  <div id="name"></div><br>  <div id="gender"></div><br>  <script><br>    var name=localStorage.getItem(‘name’)<br>    var gender=localStorage.getItem(‘gender’)<br>    document.getElementById(‘name’).innerHTML=name<br>    document.getElementById(‘gender’).innerHTML=gender<br>  </script><br></body><br>3.使用场景</p>
<p>LocalStorage在存储方面没有什么特别的限制，理论上 Cookie 无法胜任的、可以用简单的键值对来存取的数据存储任务，都可以交给 LocalStorage 来做。<br>这里给大家举个例子，考虑到 LocalStorage 的特点之一是持久，有时我们更倾向于用它来存储一些内容稳定的资源。比如图片内容丰富的电商网站会用它来存储 Base64 格式的图片字符串：</p>
<p>sessionStorage<br>sessionStorage保存的数据用于浏览器的一次会话，当会话结束（通常是该窗口关闭），数据被清空；sessionStorage 特别的一点在于，即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的 sessionStorage 内容便无法共享；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。除了保存期限的长短不同，SessionStorage的属性和方法与LocalStorage完全一样。</p>
<p>1.sessionStorage的特点</p>
<p>会话级别的浏览器存储<br>大小为5M左右<br>仅在客户端使用，不和服务端进行通信<br>接口封装较好<br>基于上面的特点，sessionStorage 可以有效对表单信息进行维护，比如刷新时，表单信息不丢失。</p>
<p>2.使用场景</p>
<p>sessionStorage 更适合用来存储生命周期和它同步的会话级别的信息。这些信息只适用于当前会话，当你开启新的会话时，它也需要相应的更新或释放。比如微博的 sessionStorage就主要是存储你本次会话的浏览足迹：</p>
<p>lasturl 对应的就是你上一次访问的 URL 地址，这个地址是即时的。当你切换 URL 时，它随之更新，当你关闭页面时，留着它也确实没有什么意义了，干脆释放吧。这样的数据用 sessionStorage 来处理再合适不过。</p>
<p>3.sessionStorage 、localStorage 和 cookie 之间的区别</p>
<p>共同点：都是保存在浏览器端，且都遵循同源策略。<br>不同点：在于生命周期与作用域的不同<br>作用域：localStorage只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份localStorage数据。sessionStorage比localStorage更严苛一点，除了协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下:</p>
<p>生命周期：localStorage 是持久化的本地存储，存储在其中的数据是永远不会过期的，使其消失的唯一办法是手动删除；而 sessionStorage 是临时性的本地存储，它是会话级别的存储，当会话结束（页面被关闭）时，存储内容也随之被释放。<br>Web Storage 是一个从定义到使用都非常简单的东西。它使用键值对的形式进行存储，这种模式有点类似于对象，却甚至连对象都不是——它只能存储字符串，要想得到对象，我们还需要先对字符串进行一轮解析。<br>说到底，Web Storage 是对 Cookie 的拓展，它只能用于存储少量的简单数据。当遇到大规模的、结构复杂的数据时，Web Storage 也爱莫能助了。这时候我们就要清楚我们的终极大 boss——IndexedDB！</p>
<p>IndexedDB<br>IndexedDB 是一种低级API，用于客户端存储大量结构化数据(包括文件和blobs)。该API使用索引来实现对该数据的高性能搜索。IndexedDB 是一个运行在浏览器上的非关系型数据库。既然是数据库了，那就不是 5M、10M 这样小打小闹级别了。理论上来说，IndexedDB 是没有存储上限的（一般来说不会小于 250M）。它不仅可以存储字符串，还可以存储二进制数据。</p>
<p>1.IndexedDB的特点</p>
<p>键值对储存。<br>IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以”键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。<br>异步<br>IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。<br>支持事务。<br>IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。<br>同源限制<br>IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。<br>储存空间大<br>IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。<br>支持二进制储存。<br>IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。<br>2.IndexedDB的常见操作</p>
<p>在IndexedDB大部分操作并不是我们常用的调用方法，返回结果的模式，而是请求——响应的模式。</p>
<p>建立打开IndexedDB —-window.indexedDB.open(“testDB”)<br>这条指令并不会返回一个DB对象的句柄，我们得到的是一个IDBOpenDBRequest对象，而我们希望得到的DB对象在其result属性中</p>
<p>除了result，IDBOpenDBRequest接口定义了几个重要属性:</p>
<p>onerror: 请求失败的回调函数句柄<br>onsuccess:请求成功的回调函数句柄<br>onupgradeneeded:请求数据库版本变化句柄<br>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18</p>
<p><script><br>  function openDB(name){<br>    var request=window.indexedDB.open(name)//建立打开IndexedDB<br>    request.onerror=function (e){<br>      console.log(‘open indexdb error’)<br>    }<br>    request.onsuccess=function (e){<br>      myDB.db=e.target.result//这是一个 IDBDatabase对象，这就是IndexedDB对象<br>      console.log(myDB.db)//此处就可以获取到db实例<br>    }<br>  }<br>  var myDB={<br>    name:’testDB’,<br>    version:’1’,<br>    db:null<br>  }<br>  openDB(myDB.name)<br></script><br>控制台得到一个 IDBDatabase对象，这就是IndexedDB对象</p>
<p>关闭IndexedDB—-indexdb.close()</p>
<p>代码<br>1<br>2<br>3<br>function closeDB(db){<br>  db.close();<br>}<br>删除IndexedDB—-window.indexedDB.deleteDatabase(indexdb)</p>
<p>代码<br>1<br>2<br>3<br>function deleteDB(name) {<br>  indexedDB.deleteDatabase(name)<br>}<br>WebStorage、cookie 和 IndexedDB之间的区别</p>
<p>从上表可以看到，cookie 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 localStorage 和 sessionStorage 。对于不怎么改变的数据尽量使用 localStorage 存储，否则可以用 sessionStorage 存储。</p>
<p>总结下本文几个核心观点：</p>
<p>Cookie 的本职工作并非本地存储，而是“维持状态”<br>Web Storage 是 HTML5 专门为浏览器存储而提供的数据存储机制，不与服务端发生通信<br>IndexedDB 用于客户端存储大量结构化数据</p>
<p>参考：<a href="https://github.com/amandakelake/blog/issues/43" target="_blank" rel="noopener">https://github.com/amandakelake/blog/issues/43</a><br>参考：<a href="https://juejin.im/post/5c8e6fa8e51d453ec75168cd" target="_blank" rel="noopener">https://juejin.im/post/5c8e6fa8e51d453ec75168cd</a></p>
<h3 id="14、关于-Node-js-的常见用法和概念的掌握"><a href="#14、关于-Node-js-的常见用法和概念的掌握" class="headerlink" title="14、关于 Node.js 的常见用法和概念的掌握"></a>14、关于 Node.js 的常见用法和概念的掌握</h3><p>简介<br>Node是JavaScript语言的服务器运行环境。<br>所谓“运行环境”有两层意思：首先，JavaScript语言通过Node在服务器运行，在这个意义上，Node有点像JavaScript虚拟机；其次，Node提供大量工具库，使得JavaScript语言与操作系统互动（比如读写文件、新建子进程），在这个意义上，Node又是JavaScript的工具库。<br>Node内部采用Google公司的V8引擎，作为JavaScript语言解释器；通过自行开发的libuv库，调用操作系统资源。</p>
<p>安装与更新<br>访问官方网站nodejs.org或者github.com/nodesource/distributions，查看Node的最新版本和安装方法。<br>官方网站提供编译好的二进制包，可以把它们解压到/usr/local目录下面。</p>
<p>代码<br>1<br>$ tar -xf node-someversion.tgz<br>然后，建立符号链接，把它们加到$PATH变量里面的路径。</p>
<p>代码<br>1<br>2<br>$ ln -s /usr/local/node/bin/node /usr/local/bin/node<br>$ ln -s /usr/local/node/bin/npm /usr/local/bin/npm<br>下面是Ubuntu和Debian下面安装Deb软件包的安装方法。</p>
<p>代码<br>1<br>2<br>3<br>$ curl -sL <a href="https://deb.nodesource.com/setup_4.x" target="_blank" rel="noopener">https://deb.nodesource.com/setup_4.x</a> | sudo -E bash -<br>$ sudo apt-get install -y nodejs<br>$ apt-get install nodejs<br>安装完成以后，运行下面的命令，查看是否能正常运行。</p>
<p>代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node --version</span><br><span class="line"># 或者</span><br><span class="line">$ node -v</span><br></pre></td></tr></table></figure></p>
<p>更新node.js版本，可以通过node.js的n模块完成。</p>
<p>代码<br>1<br>2<br>$ sudo npm install n -g<br>$ sudo n stable</p>
<p>上面代码通过n模块，将node.js更新为最新发布的稳定版。<br>n模块也可以指定安装特定版本的node。</p>
<p>代码<br>1<br>$ sudo n 0.10.21</p>
<p>版本管理工具nvm<br>如果想在同一台机器，同时安装多个版本的node.js，就需要用到版本管理工具nvm。</p>
<p>代码<br>1<br>2<br>$ git clone <a href="https://github.com/creationix/nvm.git" target="_blank" rel="noopener">https://github.com/creationix/nvm.git</a> ~/.nvm<br>$ source ~/.nvm/nvm.sh<br>安装以后，nvm的执行脚本，每次使用前都要激活，建议将其加入~/.bashrc文件（假定使用Bash）。激活后，就可以安装指定版本的Node。</p>
<p>代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 安装最新版本</span><br><span class="line">$ nvm install node</span><br><span class="line"># 安装指定版本</span><br><span class="line">$ nvm install 0.12.1</span><br><span class="line"># 使用已安装的最新版本</span><br><span class="line">$ nvm use node</span><br><span class="line"># 使用指定版本的node</span><br><span class="line">$ nvm use 0.12</span><br></pre></td></tr></table></figure></p>
<p>nvm也允许进入指定版本的REPL环境。</p>
<p>代码<br>1<br>$ nvm run 0.12</p>
<p>如果在项目根目录下新建一个.nvmrc文件，将版本号写入其中，就只输入nvm use命令即可，不再需要附加版本号。<br>下面是其他经常用到的命令。</p>
<p>代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 查看本地安装的所有版本</span><br><span class="line">$ nvm ls</span><br><span class="line"># 查看服务器上所有可供安装的版本。</span><br><span class="line">$ nvm ls-remote</span><br><span class="line"># 退出已经激活的nvm，使用deactivate命令。</span><br><span class="line">$ nvm deactivate</span><br></pre></td></tr></table></figure>
<p>基本用法<br>安装完成后，运行node.js程序，就是使用node命令读取JavaScript脚本。<br>当前目录的demo.js脚本文件，可以这样执行。</p>
<p>代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node demo</span><br><span class="line"># 或者</span><br><span class="line">$ node demo.js</span><br></pre></td></tr></table></figure></p>
<p>使用-e参数，可以执行代码字符串。</p>
<p>代码<br>1<br>2<br>$ node -e ‘console.log(“Hello World”)’<br>Hello World</p>
<p>REPL环境<br>在命令行键入node命令，后面没有文件名，就进入一个Node.js的REPL环境（Read–eval–print loop，”读取-求值-输出”循环），可以直接运行各种JavaScript命令。</p>
<p>代码<br>1<br>2<br>3<br>4<br>$ node</p>
<blockquote>
<p>1+1<br>2</p>
</blockquote>
<p>如果使用参数 –use_strict，则REPL将在严格模式下运行。</p>
<p>代码<br>1<br>$ node –use_strict</p>
<p>REPL是Node.js与用户互动的shell，各种基本的shell功能都可以在里面使用，比如使用上下方向键遍历曾经使用过的命令。<br>特殊变量下划线（_）表示上一个命令的返回结果。</p>
<p>代码<br>1<br>2<br>3<br>4</p>
<blockquote>
<p>1 + 1<br>x = 1<br>1<br>var x = 1<br>在REPL中，如果运行一个表达式，会直接在命令行返回结果。如果运行一条语句，就不会有任何输出，因为语句没有返回值。</p>
</blockquote>
<p>代码<br>1<br>2<br>3</p>
<blockquote>
<p>x = 1<br>1<br>var x = 1<br>上面代码的第二条命令，没有显示任何结果。因为这是一条语句，不是表达式，所以没有返回值。</p>
</blockquote>
<p>异步操作<br>Node采用V8引擎处理JavaScript脚本，最大特点就是单线程运行，一次只能运行一个任务。这导致Node大量采用异步操作（asynchronous operation），即任务不是马上执行，而是插在任务队列的尾部，等到前面的任务运行完后再执行。由于这种特性，某一个任务的后续操作，往往采用回调函数（callback）的形式进行定义。</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>var isTrue = function(value, callback) {<br>  if (value === true) {<br>    callback(null, “Value was true.”);<br>  }<br>  else {<br>    callback(new Error(“Value is not true!”));<br>  }<br>}<br>上面代码就把进一步的处理，交给回调函数callback。<br>Node约定，如果某个函数需要回调函数作为参数，则回调函数是最后一个参数。另外，回调函数本身的第一个参数，约定为上一步传入的错误对象。</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>var callback = function (error, value) {<br>  if (error) {<br>    return console.log(error);<br>  }<br>  console.log(value);<br>}<br>上面代码中，callback的第一个参数是Error对象，第二个参数才是真正的数据参数。这是因为回调函数主要用于异步操作，当回调函数运行时，前期的操作早结束了，错误的执行栈早就不存在了，传统的错误捕捉机制try…catch对于异步操作行不通，所以只能把错误交给回调函数处理。</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>try {<br>  db.User.get(userId, function(err, user) {<br>    if(err) {<br>      throw err<br>    }<br>    // …<br>  })<br>} catch(e) {<br>  console.log(‘Oh no!’);<br>}<br>上面代码中，db.User.get方法是一个异步操作，等到抛出错误时，可能它所在的try…catch代码块早就运行结束了，这会导致错误无法被捕捉。所以，Node统一规定，一旦异步操作发生错误，就把错误对象传递到回调函数。</p>
<p>如果没有发生错误，回调函数的第一个参数就传入null。这种写法有一个很大的好处，就是说只要判断回调函数的第一个参数，就知道有没有出错，如果不是null，就肯定出错了。另外，这样还可以层层传递错误。</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>if(err) {<br>  // 除了放过No Permission错误意外，其他错误传给下一个回调函数<br>  if(!err.noPermission) {<br>    return next(err);<br>  }<br>}</p>
<p>全局对象和全局变量<br>Node提供以下几个全局对象，它们是所有模块都可以调用的。</p>
<p>global：表示Node所在的全局环境，类似于浏览器的window对象。需要注意的是，如果在浏览器中声明一个全局变量，实际上是声明了一个全局对象的属性，比如var x = 1等同于设置window.x = 1，但是Node不是这样，至少在模块中不是这样（REPL环境的行为与浏览器一致）。在模块文件中，声明var x = 1，该变量不是global对象的属性，global.x等于undefined。这是因为模块的全局变量都是该模块私有的，其他模块无法取到。<br>process：该对象表示Node所处的当前进程，允许开发者与该进程互动。<br>console：指向Node内置的console模块，提供命令行环境中的标准输入、标准输出功能。<br>Node还提供一些全局函数。</p>
<p>setTimeout()：用于在指定毫秒之后，运行回调函数。实际的调用间隔，还取决于系统因素。间隔的毫秒数在1毫秒到2,147,483,647毫秒（约24.8天）之间。如果超过这个范围，会被自动改为1毫秒。该方法返回一个整数，代表这个新建定时器的编号。<br>clearTimeout()：用于终止一个setTimeout方法新建的定时器。<br>setInterval()：用于每隔一定毫秒调用回调函数。由于系统因素，可能无法保证每次调用之间正好间隔指定的毫秒数，但只会多于这个间隔，而不会少于它。指定的毫秒数必须是1到2,147,483,647（大约24.8天）之间的整数，如果超过这个范围，会被自动改为1毫秒。该方法返回一个整数，代表这个新建定时器的编号。<br>clearInterval()：终止一个用setInterval方法新建的定时器。<br>require()：用于加载模块。<br>Buffer()：用于操作二进制数据。<br>Node提供两个全局变量，都以两个下划线开头。</p>
<p><strong>filename：指向当前运行的脚本文件名。
</strong>dirname：指向当前运行的脚本所在的目录。<br>除此之外，还有一些对象实际上是模块内部的局部变量，指向的对象根据模块不同而不同，但是所有模块都适用，可以看作是伪全局变量，主要为module, module.exports, exports等。</p>
<p>模块化结构<br>概述<br>Node.js采用模块化结构，按照CommonJS规范定义和使用模块。模块与文件是一一对应关系，即加载一个模块，实际上就是加载对应的一个模块文件。<br>require命令用于指定加载模块，加载时可以省略脚本文件的后缀名。</p>
<p>代码<br>1<br>2<br>3<br>var circle = require(‘./circle.js’);<br>// 或者<br>var circle = require(‘./circle’);<br>require方法的参数是模块文件的名字。它分成两种情况，第一种情况是参数中含有文件路径（比如上例），这时路径是相对于当前脚本所在的目录，第二种情况是参数中不含有文件路径，这时Node到模块的安装目录，去寻找已安装的模块（比如下例）。</p>
<p>代码<br>1<br>var bar = require(‘bar’);<br>有时候，一个模块本身就是一个目录，目录中包含多个文件。这时候，Node在package.json文件中，寻找main属性所指明的模块入口文件。</p>
<p>代码<br>1<br>2<br>3<br>4<br>{<br>  “name” : “bar”,<br>  “main” : “./lib/bar.js”<br>}<br>上面代码中，模块的启动文件为lib子目录下的bar.js。当使用require(‘bar’)命令加载该模块时，实际上加载的是./node_modules/bar/lib/bar.js文件。下面写法会起到同样效果。</p>
<p>代码<br>1<br>var bar = require(‘bar/lib/bar.js’)<br>如果模块目录中没有package.json文件，node.js会尝试在模块目录中寻找index.js或index.node文件进行加载。<br>模块一旦被加载以后，就会被系统缓存。如果第二次还加载该模块，则会返回缓存中的版本，这意味着模块实际上只会执行一次。如果希望模块执行多次，则可以让模块返回一个函数，然后多次调用该函数。</p>
<p>核心模块<br>如果只是在服务器运行JavaScript代码，用处并不大，因为服务器脚本语言已经有很多种了。Node.js的用处在于，它本身还提供了一系列功能模块，与操作系统互动。这些核心的功能模块，不用安装就可以使用，下面是它们的清单。</p>
<p>http：提供HTTP服务器功能。<br>url：解析URL。<br>fs：与文件系统交互。<br>querystring：解析URL的查询字符串。<br>child_process：新建子进程。<br>util：提供一系列实用小工具。<br>path：处理文件路径。<br>crypto：提供加密和解密功能，基本上是对OpenSSL的包装。<br>上面这些核心模块，源码都在Node的lib子目录中。为了提高运行速度，它们安装时都会被编译成二进制文件。<br>核心模块总是最优先加载的。如果你自己写了一个HTTP模块，require(‘http’)加载的还是核心模块。</p>
<p>自定义模块<br>Node模块采用CommonJS规范。只要符合这个规范，就可以自定义模块。<br>下面是一个最简单的模块，假定新建一个foo.js文件，写入以下内容。</p>
<p>代码<br>1<br>2<br>3<br>4<br>// foo.js<br>module.exports = function(x) {<br>    console.log(x);<br>};<br>上面代码就是一个模块，它通过module.exports变量，对外输出一个方法。</p>
<p>这个模块的使用方法如下。</p>
<p>代码<br>1<br>2<br>3<br>// index.js<br>var m = require(‘./foo’);<br>m(“这是自定义模块”);<br>上面代码通过require命令加载模块文件foo.js（后缀名省略），将模块的对外接口输出到变量m，然后调用m。这时，在命令行下运行index.js，屏幕上就会输出“这是自定义模块”。</p>
<p>代码<br>1<br>2<br>$ node index<br>这是自定义模块<br>module变量是整个模块文件的顶层变量，它的exports属性就是模块向外输出的接口。如果直接输出一个函数（就像上面的foo.js），那么调用模块就是调用一个函数。但是，模块也可以输出一个对象。下面对foo.js进行改写。</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>// foo.js<br>var out = new Object();<br>function p(string) {<br>  console.log(string);<br>}<br>out.print = p;<br>module.exports = out;<br>上面的代码表示模块输出out对象，该对象有一个print属性，指向一个函数。下面是这个模块的使用方法。</p>
<p>代码<br>1<br>2<br>3<br>// index.js<br>var m = require(‘./foo’);<br>m.print(“这是自定义模块”);<br>上面代码表示，由于具体的方法定义在模块的print属性上，所以必须显式调用print属性。</p>
<p>异常处理<br>Node是单线程运行环境，一旦抛出的异常没有被捕获，就会引起整个进程的崩溃。所以，Node的异常处理对于保证系统的稳定运行非常重要。<br>一般来说，Node有三种方法，传播一个错误。</p>
<p>使用throw语句抛出一个错误对象，即抛出异常。<br>将错误对象传递给回调函数，由回调函数负责发出错误。<br>通过EventEmitter接口，发出一个error事件。<br>try…catch结构<br>最常用的捕获异常的方式，就是使用try…catch结构。但是，这个结构无法捕获异步运行的代码抛出的异常。</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>try {<br>  process.nextTick(function () {<br>    throw new Error(“error”);<br>  });<br>} catch (err) {<br>  //can not catch it<br>  console.log(err);<br>}<br>try {<br>  setTimeout(function(){<br>    throw new Error(“error”);<br>  },1)<br>} catch (err) {<br>  //can not catch it<br>  console.log(err);<br>}<br>上面代码分别用process.nextTick和setTimeout方法，在下一轮事件循环抛出两个异常，代表异步操作抛出的错误。它们都无法被catch代码块捕获，因为catch代码块所在的那部分已经运行结束了。</p>
<p>一种解决方法是将错误捕获代码，也放到异步执行。</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>function async(cb, err) {<br>  setTimeout(function() {<br>    try {<br>      if (true)<br>        throw new Error(“woops!”);<br>      else<br>        cb(“done”);<br>    } catch(e) {<br>      err(e);<br>    }<br>  }, 2000)<br>}<br>async(function(res) {<br>  console.log(“received:”, res);<br>}, function(err) {<br>  console.log(“Error: async threw an exception:”, err);<br>});<br>// Error: async threw an exception: Error: woops!<br>上面代码中，async函数异步抛出的错误，可以同样部署在异步的catch代码块捕获。</p>
<p>这两种处理方法都不太理想。一般来说，Node只在很少场合才用try/catch语句，比如使用JSON.parse解析JSON文本。</p>
<p>回调函数<br>Node采用的方法，是将错误对象作为第一个参数，传入回调函数。这样就避免了捕获代码与发生错误的代码不在同一个时间段的问题。</p>
<p>代码<br>1<br>2<br>3<br>4<br>fs.readFile(‘/foo.txt’, function(err, data) {<br>  if (err !== null) throw err;<br>  console.log(data);<br>});<br>上面代码表示，读取文件foo.txt是一个异步操作，它的回调函数有两个参数，第一个是错误对象，第二个是读取到的文件数据。如果第一个参数不是null，就意味着发生错误，后面代码也就不再执行了。</p>
<p>下面是一个完整的例子。</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>function async2(continuation) {<br>  setTimeout(function() {<br>    try {<br>      var res = 42;<br>      if (true)<br>        throw new Error(“woops!”);<br>      else<br>        continuation(null, res); // pass ‘null’ for error<br>    } catch(e) {<br>      continuation(e, null);<br>    }<br>  }, 2000);<br>}<br>async2(function(err, res) {<br>  if (err)<br>    console.log(“Error: (cps) failed:”, err);<br>  else<br>    console.log(“(cps) received:”, res);<br>});<br>// Error: (cps) failed: woops!<br>上面代码中，async2函数的回调函数的第一个参数就是一个错误对象，这是为了处理异步操作抛出的错误。</p>
<p>EventEmitter接口的error事件<br>发生错误的时候，也可以用EventEmitter接口抛出error事件。</p>
<p>代码<br>1<br>2<br>3<br>var EventEmitter = require(‘events’).EventEmitter;<br>var emitter = new EventEmitter();<br>emitter.emit(‘error’, new Error(‘something bad happened’));<br>使用上面的代码必须小心，因为如果没有对error事件部署监听函数，会导致整个应用程序崩溃。所以，一般总是必须同时部署下面的代码。</p>
<p>代码<br>1<br>2<br>3<br>emitter.on(‘error’, function(err) {<br>  console.error(‘出错：’ + err.message);<br>});</p>
<p>uncaughtException事件<br>当一个异常未被捕获，就会触发uncaughtException事件，可以对这个事件注册回调函数，从而捕获异常。</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>var logger = require(‘tracer’).console();<br>process.on(‘uncaughtException’, function(err) {<br>  console.error(‘Error caught in uncaughtException event:’, err);<br>});<br>try {<br>  setTimeout(function(){<br>    throw new Error(“error”);<br>  },1);<br>} catch (err) {<br>  //can not catch it<br>  console.log(err);<br>}<br>只要给uncaughtException配置了回调，Node进程不会异常退出，但异常发生的上下文已经丢失，无法给出异常发生的详细信息。而且，异常可能导致Node不能正常进行内存回收，出现内存泄露。所以，当uncaughtException触发后，最好记录错误日志，然后结束Node进程。</p>
<p>代码<br>1<br>2<br>3<br>4<br>process.on(‘uncaughtException’, function(err) {<br>  logger.log(err);<br>  process.exit(1);<br>});<br>unhandledRejection事件<br>iojs有一个unhandledRejection事件，用来监听没有捕获的Promise对象的rejected状态。</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>var promise = new Promise(function(resolve, reject) {<br>  reject(new Error(“Broken.”));<br>});<br>promise.then(function(result) {<br>  console.log(result);<br>})<br>上面代码中，promise的状态变为rejected，并且抛出一个错误。但是，不会有任何反应，因为没有设置任何处理函数。</p>
<p>只要监听unhandledRejection事件，就能解决这个问题。</p>
<p>代码<br>1<br>2<br>3<br>process.on(‘unhandledRejection’, function (err, p) {<br>  console.error(err.stack);<br>})<br>需要注意的是，unhandledRejection事件的监听函数有两个参数，第一个是错误对象，第二个是产生错误的promise对象。这可以提供很多有用的信息。</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>var http = require(‘http’);<br>http.createServer(function (req, res) {<br>  var promise = new Promise(function(resolve, reject) {<br>    reject(new Error(“Broken.”))<br>  })<br>  promise.info = {url: req.url}<br>}).listen(8080)<br>process.on(‘unhandledRejection’, function (err, p) {<br>  if (p.info &amp;&amp; p.info.url) {<br>    console.log(‘Error in URL’, p.info.url)<br>  }<br>  console.error(err.stack)<br>})<br>上面代码会在出错时，输出用户请求的网址。</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>Error in URL /testurl<br>Error: Broken.<br>  at /Users/mikeal/tmp/test.js:9:14<br>  at Server.<anonymous> (/Users/mikeal/tmp/test.js:4:17)<br>  at emitTwo (events.js:87:13)<br>  at Server.emit (events.js:169:7)<br>  at HTTPParser.parserOnIncoming [as onIncoming] (_http_server.js:471:12)<br>  at HTTPParser.parserOnHeadersComplete (_http_common.js:88:23)<br>  at Socket.socketOnData (_http_server.js:322:22)<br>  at emitOne (events.js:77:13)<br>  at Socket.emit (events.js:166:7)<br>  at readableAddChunk (_stream_readable.js:145:16)<br>命令行脚本<br>node脚本可以作为命令行脚本使用。</anonymous></p>
<p>代码<br>1<br>$ node foo.js<br>上面代码执行了foo.js脚本文件。</p>
<p>foo.js文件的第一行，如果加入了解释器的位置，就可以将其作为命令行工具直接调用。</p>
<p>代码<br>1</p>
<p>#!/usr/bin/env node<br>调用前，需更改文件的执行权限。</p>
<p>代码<br>1<br>2<br>$ chmod u+x foo.js<br>$ ./foo.js arg1 arg2 …<br>作为命令行脚本时，console.log用于输出内容到标准输出，process.stdin用于读取标准输入，child_process.exec()用于执行一个shell命令。</p>
<p>参考：<a href="https://javascript.ruanyifeng.com/nodejs/basic.html" target="_blank" rel="noopener">https://javascript.ruanyifeng.com/nodejs/basic.html</a><br>参考：<a href="https://segmentfault.com/a/1190000005892501" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005892501</a></p>
<h2 id="二、CSS相关"><a href="#二、CSS相关" class="headerlink" title="二、CSS相关"></a>二、CSS相关</h2><h3 id="1、-CSS-常⻅见属性的应⽤用包括属性继承等概念的掌握"><a href="#1、-CSS-常⻅见属性的应⽤用包括属性继承等概念的掌握" class="headerlink" title="1、 CSS 常⻅见属性的应⽤用包括属性继承等概念的掌握"></a>1、 CSS 常⻅见属性的应⽤用包括属性继承等概念的掌握</h3><p>CSS教程<br><a href="https://www.runoob.com/css/css-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/css/css-tutorial.html</a></p>
<p>flex布局<br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p>
<p>CSS属性继承<br>概念: 指我们设置上级(父级)的CSS样式，上级（父级）及以下的子级（下级）都具有此属性。一般只有文字文本具有继承特性，如文字大小、文字加粗、文字颜色、字体等。</p>
<p>有继承性的属性<br>1、字体系列属性</p>
<p>font：组合字体</p>
<p>font-family：规定元素的字体系列</p>
<p>font-weight：设置字体的粗细</p>
<p>font-size：设置字体的尺寸</p>
<p>font-style：定义字体的风格</p>
<p>font-variant：设置小型大写字母的字体显示文本，这意味着所有的小写字母均会被转换为大写，但是所有使用小型大写字体的字母与其余文本相比，其字体尺寸更小。</p>
<p>font-stretch：对当前的 font-family 进行伸缩变形。所有主流浏览器都不支持。</p>
<p>font-size-adjust：为某个元素规定一个 aspect 值，这样就可以保持首选字体的 x-height。</p>
<p>2、文本系列属性</p>
<p>text-indent：文本缩进</p>
<p>text-align：文本水平对齐</p>
<p>line-height：行高</p>
<p>word-spacing：增加或减少单词间的空白（即字间隔）</p>
<p>letter-spacing：增加或减少字符间的空白（字符间距）</p>
<p>text-transform：控制文本大小写</p>
<p>direction：规定文本的书写方向</p>
<p>color：文本颜色</p>
<p>3、元素可见性：visibility</p>
<p>4、表格布局属性：caption-side、border-collapse、border-spacing、empty-cells、table-layout</p>
<p>5、列表布局属性：list-style-type、list-style-image、list-style-position、list-style</p>
<p>6、生成内容属性：quotes</p>
<p>7、光标属性：cursor</p>
<p>8、页面样式属性：page、page-break-inside、windows、orphans</p>
<p>9、声音样式属性：speak、speak-punctuation、speak-numeral、speak-header、speech-rate、volume、voice-family、pitch、pitch-range、stress、richness、、azimuth、elevation</p>
<p>无继承性的属性<br>1、display：规定元素应该生成的框的类型</p>
<p>2、文本属性：</p>
<p>vertical-align：垂直文本对齐</p>
<p>text-decoration：规定添加到文本的装饰</p>
<p>text-shadow：文本阴影效果</p>
<p>white-space：空白符的处理</p>
<p>unicode-bidi：设置文本的方向</p>
<p>3、盒子模型的属性：width、height、margin 、margin-top、margin-right、margin-bottom、margin-left、border、border-style、border-top-style、border-right-style、border-bottom-style、border-left-style、border-width、border-top-width、border-right-right、border-bottom-width、border-left-width、border-color、border-top-color、border-right-color、border-bottom-color、border-left-color、border-top、border-right、border-bottom、border-left、padding、padding-top、padding-right、padding-bottom、padding-left</p>
<p>4、背景属性：background、background-color、background-image、background-repeat、background-position、background-attachment</p>
<p>5、定位属性：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index</p>
<p>6、生成内容属性：content、counter-reset、counter-increment</p>
<p>7、轮廓样式属性：outline-style、outline-width、outline-color、outline</p>
<p>8、页面样式属性：size、page-break-before、page-break-after</p>
<p>9、声音样式属性：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during</p>
<p>所有元素可以继承的属性<br>1、元素可见性：visibility</p>
<p>2、光标属性：cursor</p>
<p>内联元素可以继承的属性<br>1、字体系列属性</p>
<p>2、除text-indent、text-align之外的文本系列属性</p>
<p>块级元素可以继承的属性<br>1、text-indent、text-align</p>
<p>BFC<br>块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视化CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</p>
<p>如何出发BFC?</p>
<p>根元素或包含根元素的元素<br>浮动元素（元素的 float 不是 none）<br>绝对定位元素（元素的 position 为 absolute 或 fixed）<br>行内块元素（元素的 display 为 inline-block）<br>表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值）<br>表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）<br>匿名表格单元格元素（元素的 display为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table）<br>overflow 值不为 visible 的块元素<br>display 值为 flow-root 的元素<br>contain 值为 layout、content或 strict 的元素<br>弹性元素（display为 flex 或 inline-flex元素的直接子元素）<br>网格元素（display为 grid 或 inline-grid 元素的直接子元素）<br>多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1）<br>column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。</p>
<p>参考链接<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/inheritance" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS/inheritance</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context</a></p>
<h3 id="2、CSS-中常⻅布局以及文本超长展示省略号"><a href="#2、CSS-中常⻅布局以及文本超长展示省略号" class="headerlink" title="2、CSS 中常⻅布局以及文本超长展示省略号"></a>2、CSS 中常⻅布局以及文本超长展示省略号</h3><p>一、文档流布局<br>最基本的布局方式，就是按照文档的顺序一个一个显示出来，块元素独占一行，行内元素共享一行</p>
<p>二、浮动布局<br>float : left | right</p>
<p>特点 :</p>
<ol>
<li>元素浮动之后不占据原来的位置(脱标)</li>
<li>浮动的盒子在一行上显示</li>
<li>行内元素浮动之后转换为行内块元素(不推荐使用,转行内元素还是用display:inline-block)</li>
</ol>
<p>作用 :</p>
<ol>
<li>文本绕图<br>2.制作导航<br>3.网页布局</li>
</ol>
<p>清除浮动<br>当父盒子没有定义高度,嵌套的盒子浮动后,下边的元素发生未知错误</p>
<p>clear : left | right | both</p>
<p>在最后一个浮动元素后添加标签.</p>
<p>三、定位布局<br>绝对定位</p>
<p>如果想为元素设置层模型中的绝对定位，需要设置position:absolute(表示绝对定位)，这条语句的作用将元素从文档流中拖出来，然后使用left、right、top、bottom属性相对于其最接近的一个具有定位属性的父包含块进行绝对定位。如果不存在这样的包含块，则相对于body元素，即相对于浏览器窗口，而其层叠顺序则通过z-index属性来定义。</p>
<p>相对定位</p>
<p>如果想为元素设置层模型中的相对定位，需要设置position:relative（表示相对定位），它通过left、right、top、bottom属性确定元素在正常文档流中的偏移位置。相对定位完成的过程是首先按static(float)方式生成一个元素，相对于以前的位置，移动方向和幅度由left、right、top、bottom属性确定，偏移前的位置保留不动。</p>
<p>固定定位</p>
<p>fixed：表示固定定位，与absolute定位类型类似，但它的相对移动的坐标是视图（屏幕内的网页窗口）本身。由于视图本身是固定的，它不会随浏览器窗口的滚动条滚动而变化，除非你在屏幕中移动浏览器窗口的屏幕位置，或改变浏览器窗口的显示大小，因此固定定位的元素会始终位于浏览器窗口内视图的某个位置，不会受文档流动影响，这与background-attachment:fixed;属性功能相同。以下代码可以实现相对于浏览器视图向右移动100px，向下移动50px。并且拖动滚动条时位置固定不变。</p>
<p>四、Flex布局<br>flex 的使用方法很简单，只需要将其 display 属性设置为 flex 就可以，也可以设置行内的 flex，记得 Webkit 内核的浏览器，必须加上 -webkit 前缀。注意，设为 Flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。</p>
<p>在使用 flex 的元素中，默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴开始的位置称为 main start，主轴结束的位置称为 main end。同理，交叉轴开始的位置称为 cross start，交叉轴结束的位置称为 cross end。在使用 flex 的子元素中，占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size。</p>
<p>父容器属性<br>父容器上有六个属性</p>
<p>flex-direction：主轴的方向。<br>flex-wrap：超出父容器子容器的排列样式。<br>flex-flow：flex-direction 属性和 flex-wrap 属性的简写形式。<br>justify-content：子容器在主轴的排列方向。<br>align-items：子容器在交叉轴的排列方向。<br>align-content：多根轴线的对齐方式。<br>flex-direction 属性<br>flex-direction 属性决定主轴的方向（主轴的方向不一定是水平的，这个属性就是设置主轴的方向，主轴默认是水平方向，从左至右，如果主轴方向设置完毕，那么交叉轴就不需要设置，交叉轴永远是主轴顺时针旋转 90°）。</p>
<p>flex-wrap 属性<br>flex-wrap 属性决定子容器如果在一条轴线排不下时，如何换行。</p>
<p>justify-content 属性<br>justify-content 属性定义了子容器在主轴上的对齐方式。</p>
<p>flex-flow 属性<br>flex-flow 属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap。</p>
<p>align-items 属性<br>align-items属性定义子容器在交叉轴上如何对齐。<br>具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p>
<p>align-content 属性<br>align-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>
<p>子容器属性<br>子容器也有 6 个属性：</p>
<p>order：子容器的排列顺序<br>flex-grow：子容器剩余空间的拉伸比例<br>flex-shrink：子容器超出空间的压缩比例<br>flex-basis：子容器在不伸缩情况下的原始尺寸<br>flex：子元素的 flex 属性是 flex-grow,flex-shrink 和 flex-basis 的简写<br>align-self<br>order 属性<br>order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0。</p>
<p>flex-grow 属性<br>flex-grow 属性定义子容器的伸缩比例。按照该比例给子容器分配空间。</p>
<p>flex-shrink 属性<br>flex-shrink 属性定义了子容器弹性收缩的比例。如图，超出的部分按 1:2 的比例从给子容器中减去。此属性要生效，父容器的 flex-wrap 属性要设置为 nowrap</p>
<p>flex-basis 属性<br>flex-basis 属性定义了子容器在不伸缩情况下的原始尺寸，主轴为横向时代表宽度，主轴为纵向时代表高度。</p>
<p>五、超长文本显示省略号<br>单行文本</p>
<p>多行文本</p>
<p>-webkit-line-clamp用来限制在一个块元素显示的文本的行数。 为了实现该效果，它需要组合其他的WebKit属性。</p>
<p>常见结合属性：</p>
<p>display: -webkit-box; 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 。</p>
<p>-webkit-box-orient 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 。</p>
<h3 id="3、-CSS的各种动画以及性能优化"><a href="#3、-CSS的各种动画以及性能优化" class="headerlink" title="3、 CSS的各种动画以及性能优化"></a>3、 CSS的各种动画以及性能优化</h3><p>容易混淆的几个CSS属性<br>animation (动画)</p>
<p>用于设置动画属性，他是一个简写的属性，包含6个属性<br>transition (过渡)    用于设置元素的样式过度，和animation有着类似的效果，但细节上有很大的不同<br>transform (变形)    用于元素进行旋转、缩放、移动或倾斜，和设置样式的动画并没有什么关系，就相当于color一样用来设置元素的“外表”<br>translate (移动)    translate只是transform的一个属性值，即移动<br>transition：property duration timing-function delay;<br>transition-property    设置过渡效果的CSS属性名称<br>transition-duration    完成过渡效果需要多少秒or毫秒<br>transition-timing-function    速度效果的速度曲线<br>transition-delay    过渡效果延迟多久开始<br>animation： name duration timing-function delay iteration-count direction play-state fill-mode;<br>name    用来调用@keyframes定义好的动画，与@keyframes定义的动画名称一致<br>duration    指定元素播放动画所持续的时间<br>timing-function    规定速度效果的速度曲线，是针对每一个小动画所在时间范围的变换速率<br>delay    定义在浏览器开始执行动画之前等待的时间，值整个animation执行之前等待的时间<br>iteration-count    定义动画的播放次数，可选具体次数或者无限(infinite)<br>direction    设置动画播放方向：normal(按时间轴顺序),reverse(时间轴反方向运行),alternate(轮流，即来回往复进行),alternate-reverse(动画先反运行再正方向运行，并持续交替运行)<br>play-state    控制元素动画的播放状态，通过此来控制动画的暂停和继续，两个值：running(继续)，paused(暂停)<br>fill-mode    控制动画结束后，元素的样式，有四个值：none(回到动画没开始时的状态)，forwards(动画结束后动画停留在结束状态)，backwords(动画回到第一帧的状态)，both(根据animation-direction轮流应用forwards和backwards规则)，注意与iteration-count不要冲突(动画执行无限次)<br>动画性能优化<br>动画为什么会卡顿？<br>现代的浏览器通常会有两个重要的执行线程，这2个线程协同工作来渲染一个网页：</p>
<p>主线程<br>合成线程<br>一般情况下，主线程负责：</p>
<p>运行JavaScript。<br>计算HTML 元素的 CSS 样式。<br>页面的布局<br>将元素绘制到一个或多个位图中<br>将这些位图交给合成线程<br>相应地，合成线程负责：</p>
<p>通过 GPU将位图绘制到屏幕上<br>通知主线程更新页面中可见或即将变成可见的部分的位图<br>计算出页面中哪部分是可见的<br>计算出当你在滚动页面时哪部分是即将变成可见的<br>当你滚动页面时将相应位置的元素移动到可视区域<br>长时间执行 JavaScript 或渲染一个很大的元素会阻塞主线程，在这期间，它将无法响应用户的交互。</p>
<p>相反，合成线程则会尽量去响应用户的交互。当一个页面发生变化时，合成线程会以每秒60 帧的间隔去不断重绘这个页面，即使这个页面不完整。</p>
<p>动画卡顿的解决方案<br>在使用css3 transtion做动画效果时，优先选择transform，尽量不要使用height，width，margin和padding。</p>
<p>为什么transform更加平滑？<br>在使用css3 transtion做动画效果时，transform实现的动画是与合成器线程相关的，不需要等待主线程样式计算或者 JS 执行，计算速度是很快的；而使用height，width，margin和padding时，导致布局和绘制的调整，主线程需要重新计算样式并且执行JS，计算速度自然就慢了。</p>
<p>性能消耗排名</p>
<p>性能消耗图，由此可见最受欢饮和性能最好的莫过于transform和opacity了。</p>
<p>其实呢，opacity和transform能解决的问题已经很多了，尽量少的使用其他的属性去进行动画制作</p>
<p>translate3d 开启GPU加速<br>在移动端，我们经常用到如上的CSS代码实现所谓的“硬件加速”，来提高动画的流畅度。在部分情况下，我们的CSS动画的确变的更加流畅。</p>
<p>但这个方法并不是万能药。当页面中加速的元素越来越多时，网页的性能便会下降。</p>
<p>参考<br><a href="http://sy-tang.github.io/2014/05/14/CSS%20animations%20and%20transitions%20performance-%20looking%20inside%20the%20browser/" target="_blank" rel="noopener">http://sy-tang.github.io/2014/05/14/CSS%20animations%20and%20transitions%20performance-%20looking%20inside%20the%20browser/</a></p>
<p><a href="https://juejin.im/post/5b137e6e51882513ac201dfb#heading-3" target="_blank" rel="noopener">https://juejin.im/post/5b137e6e51882513ac201dfb#heading-3</a></p>
<p><a href="https://juejin.im/post/5b6133a351882519d346853f#heading-4" target="_blank" rel="noopener">https://juejin.im/post/5b6133a351882519d346853f#heading-4</a></p>
<p><a href="https://div.io/topic/1348" target="_blank" rel="noopener">https://div.io/topic/1348</a></p>
<p><a href="http://zencode.in/14.CSS%E5%8A%A8%E7%94%BB%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html" target="_blank" rel="noopener">http://zencode.in/14.CSS%E5%8A%A8%E7%94%BB%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html</a></p>
<h3 id="4、关于-BFC-块级格式化上下文的理解以及触发-BFC-重新布局相关操作"><a href="#4、关于-BFC-块级格式化上下文的理解以及触发-BFC-重新布局相关操作" class="headerlink" title="4、关于 BFC 块级格式化上下文的理解以及触发 BFC 重新布局相关操作"></a>4、关于 BFC 块级格式化上下文的理解以及触发 BFC 重新布局相关操作</h3><p>BFC 定义<br>BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box（块级元素）参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干.</p>
<p>通俗地来说：创建了 BFC的元素就是一个独立的盒子，里面的子元素不会在布局上<br>影响外面的元素（里面怎么布局都不会影响外部），BFC任然属于文档中的普通流</p>
<p>BFC的生成：<br>知道了BFC怎么触发BFC<br>满足以下条件之一都可以触发BFC，变身为BFC</p>
<p>根元素<br>float属性不为none<br>position不为static和relative<br>overflow不为visible<br>display为inline-block, table-cell, table-caption, flex, inline-flex<br>你会发现BFC无处不在，只是自己用的时候不知道而已</p>
<p>BFC布局规则：<br>变身为BFC后有什么特性呢，以下：</p>
<p>内部的Box会在垂直方向，一个接一个地放置。<br>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠<br>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。<br>BFC的区域不会与float box重叠。<br>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。<br>计算BFC的高度时，浮动元素也参与计算<br>让我们建立一个BFC<br>HTML代码如下：</p>
<p><div class="container"><br>  Some Content here<br></div><br>我们可以用CSS为container容器附加上述条件,如overflow: scroll, overflow: hidden, display: flex, float: left, or display: table.尽管这些条件都能形成一个BFC，但是它们各自却有着不一样的表现：</p>
<p>display: table : 在响应式布局中会有问题</p>
<p>overflow: scroll : 可能会出现你不想要的滚动条</p>
<p>float: left: 使元素左浮动，并且其他元素对其环绕</p>
<p>overflow: hidden: 消除溢出部分</p>
<p>这么看来，建立BFC的最好方式莫过于overflow:hidden了：</p>
<p>.container {<br>  overflow: hidden;<br>}<br>在BFC中，块级元素又是怎么布局的呢？<br>W3C规范描述如下：</p>
<p>In a block formatting context, each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats).bfcbfc.jpg</p>
<p>简单的说：上图中所有属于BFC的box都默认左对齐，并且它们的左边距可以触及到容器container的左边。最后一个box，尽管它是浮动的，但它依然遵循这个原则。（BFC中的浮动下面会介绍）</p>
<p>－那么，BFC到底有什么卵用呢？</p>
<p>－实际上，真的特别有用</p>
<p>1.利用BFC可以消除Margin Collapse<br>在正常情况下，在一个容器内的所有box将会由上至下依次垂直排列，即我们所说的一个元素占一行，并切垂直相邻的距离(即margin)是由各自的margin决定的，而不是两个margin的叠加。</p>
<p>让我们看一个例子：红色的div包含三个绿色的p元素。</p>
<p>HTML代码：</p>
<p><div class="container"><br>  <p>Sibling 1</p><br>  <p>Sibling 2</p><br>  <p>Sibling 3</p><br></div><br>CSS代码：</p>
<p>.container {<br>  background-color: red;<br>  overflow: hidden; /<em> creates a block formatting context </em>/<br>}</p>
<p>p {<br>  background-color: lightgreen;<br>  margin: 10px 0;<br>}<br>理想情况下，我们会认为p标签之间的margin应该是它们的和(20px),但实际上却是10px.这其实是collapsing margins。</p>
<p>结果如下：</p>
<p>这似乎让人有点困惑，BFC导致了margin collapse，而现在又要用它来解决margin cllapse.但是始终要记住一点：只有当元素在同一个BFC中时，垂直方向上的margin<br>才会clollpase.如果它们属于不同的BFC，则不会有margin collapse.因此我们可以再建立一个BFC去阻止margin collpase的发生。</p>
<p>现在HTML变成：</p>
<p><div class="container"><br>  <p>Sibling 1</p><br>  <p>Sibling 2</p><br>  <div class="newBFC"><br>    <p>Sibling 3</p><br>  </div><br></div><br>CSS也有改变：</p>
<p>.container {<br>  background-color: red;<br>  overflow: hidden; /<em> creates a block formatting context </em>/<br>}</p>
<p>p {<br>  margin: 10px 0;<br>  background-color: lightgreen;<br>}</p>
<p>.newBFC {<br>  overflow: hidden;  /<em> creates new block formatting context </em>/<br>}<br>现在的结果为：</p>
<p>由于第二个p元素和第三个p元素属于不同的BFC，因此避免了margin collapse.</p>
<p>2.利用BFC去容纳浮动元素<br>我相信大家经常会遇到一个容器里有浮动元素，但是这个容器的高度却是0的场景，如下图：</p>
<p>看下面的例子：</p>
<p>HTML:</p>
<p><div class="container"><br>  <div>Sibling</div><br>  <div>Sibling</div><br></div><br>CSS:</p>
<p>.container {<br>  background-color: green;<br>}</p>
<p>.container div {<br>  float: left;<br>  background-color: lightgreen;<br>  margin: 10px;<br>}<br>结果：</p>
<p>在上边的情形中，container是不会有高度的，因为它包含了浮动元素。通常我们解决这个问题的办法是利用一个伪元素去实现clear fix，但是现在我们有了更好的解决办法，即利用BFC，因为它够容纳浮动元素的。<br>我们现在让container形成BFC规则，结果如下：</p>
<p>.container {<br>  overflow: hidden; /<em> creates block formatting context </em>/<br>  background-color: green;<br>}</p>
<p>.container div {<br>  float: left;<br>  background-color: lightgreen;<br>  margin: 10px;<br>}<br>结果：</p>
<p>3.利用BFC阻止文本换行<br>有时候，确切的说大多数情况(若没有特殊设置)，文本将会环绕浮动元素(如Figure 1),<br>但有时候这并不是我们期望的，我们想要的是Figure2。</p>
<p>往往可能大家都会选择利用margin－left来强行让p的容器有一个左边距，而距离恰好为Floated div的宽度，但现在我们可以利用BFC更好的解决这个问题。</p>
<p>首先让我们了解一下文本换行的原理吧：</p>
<p>在Figure1中，整个p元素实际上是处于上图中的黑色区域，p元素没有移动是因为它在浮动元素的下方。但实际上p作为行块级别的元素（相对于行内文本）却发生了移动，因为要给float元素’腾’位置，而随着文本的增加，文本高度超过浮动元素的部分则不会在水平方向上收缩内部距离，因此看起来像是环绕。</p>
<p>如图：</p>
<p>在解决这个问题之前，我们先来看一下W3C的规范在这方面的描述：</p>
<p>In a block formatting context, each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats).</p>
<p>W3C为这种情况提供了一个解决方案：unless the box establishes a new block formatting context，即为p建立BFC。</p>
<p>结果：</p>
<p>参考：<a href="https://www.sitepoint.com/understanding-block-formatting-contexts-in-css/" target="_blank" rel="noopener">https://www.sitepoint.com/understanding-block-formatting-contexts-in-css/</a></p>
<p>参考：<a href="https://www.cnblogs.com/Ry-yuan/p/8458809.html" target="_blank" rel="noopener">https://www.cnblogs.com/Ry-yuan/p/8458809.html</a></p>
<h3 id="5、-盒子模型"><a href="#5、-盒子模型" class="headerlink" title="5、 盒子模型"></a>5、 盒子模型</h3><p>一些基本概念<br>HTML的大多数元素都是块级(block)元素或行内(inline)元素</p>
<p>块级元素<br>默认情况下，块级元素会另起一行，并尽可能的充满整个容器。<br>块级元素可以包含行内元素和其他块级元素，相比于行内元素可以创建更复杂和大型的结构</p>
<p>块级元素列表：<br>html5新增的元素：<br>figcation：图文信息组标题 ，article：文章，figure：图文信息组<br>output：表单输出，aside：侧栏内容，footer：区段尾或页尾，audio：音频播放<br>video：视频播放，section：页面区段，canvas：画布、绘制图形，header：区段头或页头<br>hgroup：标题组，</p>
<p>address：联系方式信息，ol：有序列表，p：行，form：表单，pre：预格式化文本，blockqute：块引用<br>h1-h6：标题，table：表格，dd：列表中条目描述，dl：定义列表，div，hr：水平分割线</p>
<p>行内元素<br>行内元素不会另起一行只占据它对应的标签的边框所包含内容的空间，<br>只能包含数据和其他行内元素</p>
<p>行内元素列表<br>b，big，i，small，tt，<br>abbr，acronym，cite，code，dfn，em，kbd，strong，samp，var，<br>a，bdo，br，img，map，object，q，script，span，sub，sup，<br>button，input，label，select，textarea</p>
<p>块级元素和行内元素的区别<br>块级元素：<br>1.会另起一行，<br>2.可以设置width，height，margin，padding，border属性<br>3.默认宽度是容器的100%</p>
<p>行内元素：<br>1.和其他元素在同一行内<br>2.高度和宽度就是内容的高度和宽度<br>3.可以设置margin-left和margin-right属性，无法设置margin-top和margin-bottom属性<br>4.border和padding可以设置，但是border-top和padding-top到页面顶部后就不再增加</p>
<p>标准盒模型和IE盒模型<br>我们目前所学习的知识中，以标准盒子模型为准。</p>
<p>标准盒子模型：</p>
<p>IE盒子模型：</p>
<p>盒子中的区域<br>一个盒子中主要的属性就5个：width、height、padding、border、margin。如下：</p>
<p>width和height：内容的宽度、高度（不是盒子的宽度、高度）</p>
<p>padding：内边距</p>
<p>border：边框</p>
<p>margin：外边距</p>
<p>CSS盒模型和IE盒模型的区别：</p>
<p>在 标准盒子模型中，width 和 height 指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。</p>
<p>IE盒子模型中，width 和 height 指的是内容区域+border+padding的宽度和高度。</p>
<p>注：Android中也有margin和padding的概念，意思是差不多的，如果你会一点Android，应该比较好理解吧。区别在于，Android中没有border这个东西，而且在Android中，margin并不是控件的一部分，我觉得这样做更合理一些，呵呵。</p>
<p><body>标签也有margin</body></p>
<p><body>标签有必要强调一下。很多人以为<body>标签占据的是整个页面的全部区域，其实是错误的，正确的理解是这样的：整个网页最大的盒子是<document>，即浏览器。而<body>是<document>的儿子。浏览器给<body>默认的margin大小是8个像素，此时<body>占据了整个页面的一大部分区域，而不是全部区域。来看一段代码。</body></body></document></body></document></body></body></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"> &lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;Generator&quot; content=&quot;EditPlus®&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;Author&quot; content=&quot;&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;Keywords&quot; content=&quot;&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;Description&quot; content=&quot;&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">    &lt;style type=&quot;text/css&quot;&gt; div&#123; width: 100px; height: 100px; border: 1px solid red; padding: 20px; margin: 30px; &#125; &lt;/style&gt;</span><br><span class="line"></span><br><span class="line"> &lt;/head&gt;</span><br><span class="line"></span><br><span class="line"> &lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div&gt;有生之年&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;狭路相逢&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"> &lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，我们对div标签设置了边距等信息。打开chrome，按住F12，显示效果如下：</p>
<p>认识width、height<br>一定要知道，在前端开发工程师眼中，世界中的一切都是不同的。</p>
<p>比如说，丈量稿纸，前端开发工程师只会丈量内容宽度：</p>
<p>下面这两个盒子，真实占有宽高，都是302*302：</p>
<p>盒子1：</p>
<pre><code>.box1{
    width: 100px;
    height: 100px;
    padding: 100px;
    border: 1px solid red;
}
</code></pre><p>盒子2：</p>
<pre><code>.box2{
    width: 250px;
    height: 250px;
    padding: 25px;
    border: 1px solid red;
}
</code></pre><p>真实占有宽度 = 左border + 左padding + width + 右padding + 右border</p>
<p>上面这两个盒子的盒模型图如下：</p>
<p>如果想保持一个盒子的真实占有宽度不变，那么加width的时候就要减padding。加padding的时候就要减width。因为盒子变胖了是灾难性的，这会把别的盒子挤下去。</p>
<p>认识padding<br>padding区域也有颜色<br>padding就是内边距。padding的区域有背景颜色，css2.1前提下，并且背景颜色一定和内容区域的相同。也就是说，background-color将填充所有border以内的区域。</p>
<p>效果如下：</p>
<p>padding有四个方向<br>padding是4个方向的，所以我们能够分别描述4个方向的padding。</p>
<p>方法有两种，第一种写小属性；第二种写综合属性，用空格隔开。</p>
<p>小属性的写法：</p>
<pre><code>padding-top: 30px;
padding-right: 20px;
padding-bottom: 40px;
padding-left: 100px;
</code></pre><p>综合属性的写法：(上、右、下、左)（顺时针方向，用空格隔开。margin的道理也是一样的）</p>
<p>padding:30px 20px 40px 100px;<br>如果写了四个值，则顺序为：上、右、下、左。</p>
<p>如果只写了三个值，则顺序为：上、右、下。??和右一样。</p>
<p>如果只写了两个值，比如说：</p>
<p>padding: 30px 40px;<br>则顺序等价于：30px 40px 30px 40px;</p>
<p>要懂得，用小属性层叠大属性。比如：</p>
<p>padding: 20px;<br>padding-left: 30px;<br>上面的padding对应盒子模型为：</p>
<p>下面的写法：</p>
<p>padding-left: 30px;<br>padding: 20px;<br>第一行的小属性无效，因为被第二行的大属性层叠掉了。</p>
<p>下面的题，会做了，说明你明白了。</p>
<p>一些题目<br>题目1：说出下面盒子真实占有宽高，并画出盒模型图。</p>
<pre><code>div{
    width: 200px;
    height: 200px;
    padding: 10px 20px 30px;
    padding-right: 40px;
    border: 1px solid #000;
}
</code></pre><p>答案：</p>
<p>题目2：说出下面盒子真实占有宽高，并画出盒模型图。</p>
<pre><code>div{
    width: 200px;
    height: 200px;
    padding-left: 10px;
    padding-right: 20px;
    padding:40px 50px 60px;
    padding-bottom: 30px;
    border: 1px solid #000;
}
</code></pre><p>答案：</p>
<p>padding-left:10px； 和padding-right:20px; 没用，因为后面的padding大属性，层叠掉了他们。</p>
<p>盒子模型如下：</p>
<p>题目3：现在给你一个盒子模型图，请写出代码，试着用最最简单的方法写。</p>
<p>答案：</p>
<pre><code>width:123px;
height:123px;
padding:20px 40px;
border:1px solid red;
</code></pre><p>题目4：现在给你一个盒子模型图，请写出代码，试着用最最简单的方法写。</p>
<p>答案：</p>
<pre><code>width:123px;
height:123px;
padding:20px;
padding-right:40px;
border:1px solid red;
</code></pre><p>一些元素，默认带有padding<br>一些元素，默认带有padding，比如ul标签。如下：</p>
<p>上图显示，不加任何样式的ul，也是有40px的padding-left。</p>
<p>所以，我们做站的时候，为了便于控制，总是喜欢清除这个默认的padding。</p>
<p>可以使用*进行清除：</p>
<pre><code>*{
    margin: 0;
    padding: 0;
}
</code></pre><p>但是，*的效率不高，所以我们使用并集选择器，罗列所有的标签（不用背，有专业的清除默认样式的样式表，今后学习）：</p>
<p>body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,textarea,p,blockquote,th,td{<br>    margin:0;<br>    padding:0;<br>}<br>认识border<br>border就是边框。边框有三个要素：像素（粗细）、线型、颜色。</p>
<p>颜色如果不写，默认是黑色。另外两个属性不写，要命了，显示不出来边框。</p>
<p>border-style<br>border的所有的线型如下：（我们可以通过查看CSS参考手册得到）</p>
<p>比如border:10px ridge red;这个属性，在chrome和firefox、IE中有细微差别：（因为可以显示出效果，因此并不是兼容性问题，只是有细微差别而已）</p>
<p>如果公司里面的设计师是处女座的，追求极高的页面还原度，那么不能使用css来制作边框。就要用到图片，就要切图了。</p>
<p>所以，比较稳定的border-style就几个：solid、dashed、dotted。</p>
<p>border拆分<br>border是一个大综合属性。比如说：</p>
<p>border:1px solid red;<br>就是把4个边框，都设置为1px宽度、线型实线、red颜色。</p>
<p>PS：小技巧：在sublime text中，为了快速输入border:1px solid red;这个属性，可以直接输入bd，然后选第二个后回车。</p>
<p>border属性是能够被拆开的，有两大种拆开的方式：</p>
<p>（1）按三要素拆开：border-width、border-style、border-color。（一个border属性是由三个小属性综合而成的）</p>
<p>（2）按方向拆开：border-top、border-right、border-bottom、border-left。</p>
<p>现在我们明白了：一个border属性，是由三个小属性综合而成的。如果某一个小属性后面是空格隔开的多个值，那么就是上右下左的顺序。举例如下：</p>
<p>border-width:10px 20px;<br>border-style:solid dashed dotted;<br>border-color:red green blue yellow;<br>效果如下：</p>
<p>（1）按三要素拆：</p>
<p>border-width:10px;    //边框宽度<br>border-style:solid;   //线型<br>border-color:red;     //颜色。<br>等价于：</p>
<p>border:10px solid red;<br>(2)按方向来拆：</p>
<p>border-top:10px solid red;<br>border-right:10px solid red;<br>border-bottom:10px solid red;<br>border-left:10px solid red;<br>等价于：</p>
<p>border:10px solid red;<br>（3）按三要素和方向来拆：(就是把每个方向的，每个要素拆开。3*4 = 12)</p>
<pre><code>border-top-width:10px;
border-top-style:solid;
border-top-color:red;
border-right-width:10px;
border-right-style:solid;
border-right-color:red;
border-bottom-width:10px;
border-bottom-style:solid;
border-bottom-color:red;
border-left-width:10px;
border-left-style:solid;
border-left-color:red;
</code></pre><p>等价于：</p>
<p>border:10px solid red;<br>工作中到底用什么？很简答：什么简单用什么。但要懂得，用小属性层叠大属性。举例如下：</p>
<p>为了实现上方效果，写法如下：</p>
<p>border:10px solid red;<br>border-right-color:blue;</p>
<p>为了实现上方效果，写法如下：</p>
<p>border:10px solid red;<br>border-style:solid dashed;<br>border可以没有：</p>
<p>border:none;<br>可以某一条边没有：</p>
<p>border-left: none;<br>也可以调整左边边框的宽度为0：</p>
<p>border-left-width: 0;<br>参考：<a href="https://www.cnblogs.com/smyhvae/p/7256371.html" target="_blank" rel="noopener">https://www.cnblogs.com/smyhvae/p/7256371.html</a></p>
<p>参考：<a href="https://www.cnblogs.com/sichaoyun/p/6761341.html" target="_blank" rel="noopener">https://www.cnblogs.com/sichaoyun/p/6761341.html</a></p>
<h3 id="6、-常见浮动场景、清除浮动的常见办法"><a href="#6、-常见浮动场景、清除浮动的常见办法" class="headerlink" title="6、 常见浮动场景、清除浮动的常见办法"></a>6、 常见浮动场景、清除浮动的常见办法</h3><p>一、清除浮动是用于什么场景？<br>父元素内部的子元素浮动后，会造成父元素的塌陷，父元素的高度为0，因而不会显示样式。</p>
<p>举个栗子<br>html</p>
<p><div class="outer"><br>  <div class="inner"></div><br></div><br>css</p>
<p>.outer{<br>  width:300px;<br>  border: 1px solid #ccc;<br>  background:red;<br>}<br>.inner{<br>  width:100px;<br>  height:100px;<br>  background: blue;<br>  float:left;<br>}<br>以上代码显示结果为  </p>
<p>期待的结果为</p>
<p>有时候，父级元素本来就是没有样式的，那么他塌陷不塌陷无所谓咯，不不不，图森破，如果父级元素后面还有元素，由于父级元素的塌陷，他们就会上来占据父级元素的位置，效果就是，子元素覆盖在了父级元素下面元素的上面。<br>所以，在需要应用父级元素的样式的时候，在不希望子元素覆盖父级下一个元素的时候，要清除浮动。</p>
<p>二、清除浮动常见办法<br>1、给父级div定义高度 </p>
<p>原理：给父级div定义固定高度（height），能解决父级DIV 无法获取高度得问题。</p>
<p>优点：代码简洁。</p>
<p>缺点：高度被固定死了，是适合内容固定不变的模块。</p>
<p>2、空元素追加法</p>
<p>html</p>
<p><div class="box-set"><br>    <div class="box">Box 1</div><br>    <div class="box">Box 2</div><br>    <div class="box">Box 3</div><br>    <div class="clean"></div><br></div><br>css</p>
<p>.box-set{<br>    background-color: #e8aaa9;<br>}<br>.box {<br>    background: #8ec63f;<br>    width: 200px;<br>    height: 100px;<br>    float: left;<br>    margin: 10px;<br>    box-shadow: 20px 20px 10px #555;<br>}<br>.clean{<br>    clear: both;<br>}<br>注意：一般情况下不会使用这一种方式来清除浮动。</p>
<p>优点：浏览器支持好。</p>
<p>缺点：会增加页面的标签，造成结构的混乱。</p>
<p>3、overflow为hidden、auto</p>
<p>html</p>
<p><div class="box-set"><br>    <div class="box">Box 1</div><br>    <div class="box">Box 2</div><br>    <div class="box">Box 3</div><br></div><br>css</p>
<p>.box-set{<br>    background-color: #e8aaa9;<br>    overflow: hidden;<br>}<br>.box {<br>    background: #8ec63f;<br>    width: 200px;<br>    height: 100px;<br>    float: left;<br>    margin: 10px;<br>    box-shadow: 20px 20px 10px #555;<br>}<br>原理：这个方法的关键在于触发了BFC。</p>
<p>优点：代码简介，不存在结构和语义化问题。</p>
<p>缺点：无法显示需要溢出的元素（亦不太推荐使用）。</p>
<p>3、父级div定义伪类:after 和 zoom</p>
<p>html</p>
<p><div class="box-set"><br>    <div class="box">Box 1</div><br>    <div class="box">Box 2</div><br>    <div class="box">Box 3</div><br></div><br>css</p>
<p>.box-set:after{<br>    content:””;//设置内容为空<br>    height:0;//高度为0<br>    line-height:0;//行高为0<br>    display:block;//将文本转为块级元素<br>    visibility:hidden;//将元素隐藏<br>    clear:both//清除浮动<br>}<br>.box-set{<br>    background-color: #e8aaa9;<br>     /<em>在IE6和7的浏览器中，加上“</em>zoom”属性来触发父元素的hasLayout的机制。<em>/
    </em>zoom: 1;<br>}<br>.box {<br>    background: #8ec63f;<br>    width: 200px;<br>    height: 100px;<br>    float: left;<br>    margin: 10px;<br>    box-shadow: 20px 20px 10px #555;<br>}<br>原理：IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE转有属性)可解决ie6，ie7浮动问题。</p>
<p>优点：结构和语义化完全正确,代码量也适中，可重复利用率（建议定义公共类）。</p>
<p>缺点：代码不是非常简洁。</p>
<p>总结：<br>通过上面的例子，我们不难发现清除浮动的方法可以分成两类：</p>
<p>一是利用 clear 属性，包括在浮动元素末尾添加一个带有 clear: both 属性的空 div 来闭合元素，其实利用 :after 伪元素的方法也是在元素末尾添加一个内容为一个点并带有 clear: both 属性的元素实现的。<br>二是触发浮动元素父元素的 BFC (Block Formatting Contexts, 块级格式化上下文)，使到该父元素可以包含浮动元素。</p>
<h3 id="7、文档流的理解和常见改变文档流的方法"><a href="#7、文档流的理解和常见改变文档流的方法" class="headerlink" title="7、文档流的理解和常见改变文档流的方法"></a>7、文档流的理解和常见改变文档流的方法</h3><p>一、什么是文档流？<br>将窗体自上而下分成一行一行，并在每行中按从左至右依次排放元素，称为文档流，也称为普通流。<br>这个应该不难理解，HTML中全部元素都是盒模型，盒模型占用一定的空间，依次排放在HTML中，形成了文档流。</p>
<p>二、什么是脱离文档流？<br>元素脱离文档流之后，将不再在文档流中占据空间，而是处于浮动状态（可以理解为漂浮在文档流的上方）。脱离文档流的元素的定位基于正常的文档流，当一个元素脱离文档流后，依然在文档流中的其他元素将忽略该元素并填补其原先的空间。</p>
<p>三、怎么脱离文档流？<br>1.float<br>使用float可以脱离文档流。注意！！！：使用float脱离文档流时，其他盒子会无视这个元素，但其他盒子内的文本依然会为这个元素让出位置，环绕在该元素的周围。<br>举个栗子：</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>&lt;!DOCTYPE html&gt;</p>
<p><html lang="en"></html></p>
<p><head><meta name="generator" content="Hexo 3.8.0"><br>    <meta charset="UTF-8"><br>    <title>Title</title><br>    <style><br>        .first {<br>            width: 200px;<br>            height: 200px;<br>            border: 3px solid red;<br>            float: left;<br>        }<br>        .second {<br>            width: 200px;<br>            height: 100px;<br>            border: 3px solid blue;<br>        }<br>    </style><br></head></p>
<p><body></body></p>
<p><div class="first">123</div></p>
<p><div class="second">456</div><br><br><br>运行效果：</p>
<p>这段代码中把红色的框设置为了左浮，所以红色的框称为了浮动状态（浮动在蓝色框的上面），而蓝色框占用了原来空色框的位置。注意到，蓝色框中的文本依然认为红色框存在，所以为红色框让出了位置。由于div是块状元素，所以456出现在下方。</p>
<p>2.absolute<br>absolute称为绝对定位，其实博主觉得应该称为相对定位，因为使用absolute脱离文档流后的元素，是相对于该元素的父类（及以上，如果直系父类元素不满足条件则继续向上查询）元素进行定位的，并且这个父类元素的position必须是非static定位的（static是默认定位方式）。<br>举个栗子：</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>&lt;!DOCTYPE html&gt;</p>
<p><html lang="en"></html></p>
<p><head><meta name="generator" content="Hexo 3.8.0"><br>    <meta charset="UTF-8"><br>    <title>Title</title><br>    <style><br>        .first {<br>            width: 200px;<br>            height: 200px;<br>            border: 3px solid red;<br>        }<br>        .second {<br>            width: 200px;<br>            height: 100px;<br>            border: 3px solid blue;<br>            position: absolute;<br>        }<br>        .third {<br>            width: 200px;<br>            height: 200px;<br>            border: 3px solid green;<br>        }<br>    </style><br></head></p>
<p><body></body></p>
<p><div class="first">123</div></p>
<p><div class="second">456</div></p>
<p><div class="third">789</div><br><br><br>运行效果：</p>
<p>通过把蓝色的框的position设置为absolute使蓝色的框变为浮动状态，可以看到绿色的框被蓝色的框遮挡。emmm…，看起来貌似没有问题，但是还记得前面说的absolute是相对谁定位的吗？相对非static元素的父级定位的，这里蓝框的父级就是html，所以应该是相对于html定位，但是代码中没有提供相对位置，所以只能浮动在原来该元素在文档流中的位置上方。</p>
<p>下面加上相对位置并把html以dotted的形式显示出来：</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>&lt;!DOCTYPE html&gt;</p>
<p><html lang="en"></html></p>
<p><head><meta name="generator" content="Hexo 3.8.0"><br>    <meta charset="UTF-8"><br>    <title>Title</title><br>    <style><br>        .first {<br>            width: 200px;<br>            height: 200px;<br>            border: 3px solid red;<br>        }<br>        .second {<br>            width: 200px;<br>            height: 100px;<br>            border: 3px solid blue;<br>            position: absolute;<br>            left: 0;<br>            top: 0;<br>        }<br>        .third {<br>            width: 200px;<br>            height: 200px;<br>            border: 3px solid green;<br>        }<br>        html {<br>            border: dotted;<br>        }<br>    </style><br></head></p>
<p><body></body></p>
<p><div class="first">123</div></p>
<p><div class="second">456</div></p>
<p><div class="third">789</div><br><br><br>运行结果：</p>
<p>结果很明显，蓝色的框遮住了html的点，所以当父级元素的position全是static的时候，absolute是相对于html来进行定位的。</p>
<p>下面举个相对于父级元素定位的栗子：</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>&lt;!DOCTYPE html&gt;</p>
<p><html lang="en"></html></p>
<p><head><meta name="generator" content="Hexo 3.8.0"><br>    <meta charset="UTF-8"><br>    <title>Title</title><br>    <style><br>        .first {<br>            width: 200px;<br>            height: 200px;<br>            border: 3px solid red;<br>            position: relative;<br>        }<br>        .second {<br>            width: 200px;<br>            height: 100px;<br>            border: 3px solid blue;<br>            position: absolute;<br>            left: 0;<br>            top: 0;<br>        }<br>        .third {<br>            width: 200px;<br>            height: 200px;<br>            border: 3px solid green;<br>        }<br>        html {<br>            border: dotted;<br>        }<br>    </style><br></head></p>
<p><body></body></p>
<p><div class="first"><br>    123<br>    <div class="second"><br>        456<br>    </div><br></div></p>
<p><div class="third"><br>    789<br></div><br><br><br>运行结果：</p>
<p>嗯，没问题，蓝色的框是相对红色的框进行定位的，具体来说是相对于border。（可以试一下改变红色框的margin和paddind看看会发生什么）。<br>注意：绝对定位的窗口一般都要设置相对距离，当你同时设置top和bottom的时候，只有top会生效，同理，同时设置left和right的时候，只有left会生效。</p>
<p>3.fixed<br>完全脱离文档流，相对于浏览器窗口进行定位。（相对于浏览器窗口就是相对于html）。</p>
<p>举个栗子：</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>&lt;!DOCTYPE html&gt;</p>
<p><html lang="en"></html></p>
<p><head><meta name="generator" content="Hexo 3.8.0"><br>    <meta charset="UTF-8"><br>    <title>Title</title><br>    <style><br>        .first {<br>            width: 200px;<br>            height: 200px;<br>            border: 3px solid red;<br>        }<br>        .second {<br>            width: 200px;<br>            height: 100px;<br>            border: 3px solid blue;<br>            position: fixed;<br>            right: 0;<br>            top: 0;<br>        }<br>        .third {<br>            width: 200px;<br>            height: 200px;<br>            border: 3px solid green;<br>        }<br>        html {<br>            border: dotted;<br>        }<br>    </style><br></head></p>
<p><body></body></p>
<p><div class="first">123</div></p>
<p><div class="second">456</div></p>
<p><div class="third">789</div><br><br><br>运行结果：</p>
<p>可以很明显的看出，蓝色的框是相对于html进行定位的。当然，如果不提供相对位置的话，蓝色的框会浮动在其原先在文档流中的位置上方。</p>
<p>Note：文档流是在body中的，body在html中，这个在代码结构中也体现出来了，下面的例子可以更直观的看出：</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>&lt;!DOCTYPE html&gt;</p>
<p><html lang="en"></html></p>
<p><head><meta name="generator" content="Hexo 3.8.0"><br>    <meta charset="UTF-8"><br>    <title>Title</title><br>    <style><br>        .first {<br>            width: 200px;<br>            height: 200px;<br>            border: 3px solid red;<br>        }<br>        .second {<br>            width: 200px;<br>            height: 100px;<br>            border: 3px solid blue;<br>        }<br>        .third {<br>            width: 200px;<br>            height: 200px;<br>            border: 3px solid green;<br>        }<br>        body {<br>            border: dotted red;<br>        }<br>        html {<br>            border: double black;<br>        }<br>    </style><br></head></p>
<p><body></body></p>
<p><div class="first">123</div></p>
<p><div class="second">456</div></p>
<p><div class="third">789</div><br><br><br>运行结果：</p>
<p>最后说一个半脱离文档流的方法，就是position：relative。下面说明一下为什么是半脱离文档流。</p>
<p>先看下面这段代码：</p>
<p>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>&lt;!DOCTYPE html&gt;</p>
<p><html lang="en"></html></p>
<p><head><meta name="generator" content="Hexo 3.8.0"><br>    <meta charset="UTF-8"><br>    <title>Title</title><br>    <style><br>        .first {<br>            width: 200px;<br>            height: 200px;<br>            border: 3px solid red;<br>        }<br>        .second {<br>            width: 200px;<br>            height: 100px;<br>            border: 3px solid blue;<br>            position: relative;<br>            top: 100px;<br>        }<br>        .third {<br>            width: 200px;<br>            height: 200px;<br>            border: 3px solid green;<br>        }<br>    </style><br></head></p>
<p><body></body></p>
<p><div class="first">123</div></p>
<p><div class="second">456</div></p>
<p><div class="third">789</div><br><br><br>运行结果：</p>
<p>可以看到，蓝色的框是浮动了，但是绿色的框却相对于蓝色的框原先在文档流中的位置进行了定位。这就是所谓的半脱离文档流，本体还在文档流中占有位置，但是却可以通过改变位置使其漂浮到其他的地方，其定位方式是相对其原先在文档流中的位置进行定位的。<br>注意：可以尝试改变蓝色框的margin和padding属性，看一下会发生什么。<br>关键就是知道蓝色框在原来的文档流占用位置，相对定位后还是在原来的位置占据文档流。（类似实体投影到另一个地方）。</p>
<p>以上就是脱离文档流的方法。</p>
<p>参考：<a href="https://pcxiaobai.com/design/front/20190205/454.html" target="_blank" rel="noopener">https://pcxiaobai.com/design/front/20190205/454.html</a></p>
<h3 id="8、-CSS3新增属性"><a href="#8、-CSS3新增属性" class="headerlink" title="8、 CSS3新增属性"></a>8、 CSS3新增属性</h3><p>选择器<br>CSS3中新添加了很多选择器，解决了很多之前需要用javascript才能解决的布局问题。</p>
<p>element1~element2: 选择前面有element1元素的每个element2元素。<br>[attribute^=value]: 选择某元素attribute属性是以value开头的。<br>[attribute$=value]: 选择某元素attribute属性是以value结尾的。<br>[attribute*=value]: 选择某元素attribute属性包含value字符串的。<br>E:first-of-type: 选择属于其父元素的首个E元素的每个E元素。<br>E:last-of-type: 选择属于其父元素的最后E元素的每个E元素。<br>E:only-of-type: 选择属于其父元素唯一的E元素的每个E元素。<br>E:only-child: 选择属于其父元素的唯一子元素的每个E元素。<br>E:nth-child(n): 选择属于其父元素的第n个子元素的每个E元素。<br>E:nth-last-child(n): 选择属于其父元素的倒数第n个子元素的每个E元素。<br>E:nth-of-type(n): 选择属于其父元素第n个E元素的每个E元素。<br>E:nth-last-of-type(n): 选择属于其父元素倒数第n个E元素的每个E元素。<br>E:last-child: 选择属于其父元素最后一个子元素每个E元素。<br>:root: 选择文档的根元素。<br>E:empty: 选择没有子元素的每个E元素（包括文本节点)。<br>E:target: 选择当前活动的E元素。<br>E:enabled: 选择每个启用的E元素。<br>E:disabled: 选择每个禁用的E元素。<br>E:checked: 选择每个被选中的E元素。<br>E:not(selector): 选择非selector元素的每个元素。<br>E::selection: 选择被用户选取的元素部分。</p>
<p>Transition,Transform和Animation<br>A.Transition<br>Transition可以在当元素从一种样式变换为另一种样式时为元素添加效果，而不用使用Flash动画或JavaScript。Transition有如下属性：</p>
<p>transition-property: 规定应用过渡的CSS属性的名称。<br>transition-duration: 规定完成过渡效果需要多长时间。<br>transition-delay: 规定过渡效果何时开始，默认是0。<br>transition-timing-function: 规定过渡效果的时间曲线，默认是”ease”，还有linear、ease-in、ease-out、ease-in-out和cubic-bezier等过渡类型。<br>transition: 简写属性，用于在一个属性中设置四个过渡属性。</p>
<p>B.Transform<br>Transform用来向元素应用各种2D和3D转换，该属性允许我们对元素进行旋转、缩放、移动或倾斜等操作。<br>变换类型 transform可以有各种变换类型，即属性值：</p>
<p>none: 定义不进行转换。<br>matrix(n,n,n,n,n,n): 定义2D转换，使用六个值的矩阵。<br>matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n): 定义3D转换，使用16个值的4x4矩阵。<br>translate(x,y): 定义2D位移转换。<br>translate3d(x,y,z): 定义3D位移转换。<br>translateX(x): 定义位移转换，只是用X轴的值。<br>translateY(y): 定义位移转换，只是用Y轴的值。<br>translateZ(z): 定义3D位移转换，只是用Z轴的值。<br>scale(x,y): 定义2D缩放转换。<br>scale3d(x,y,z): 定义3D缩放转换。<br>scaleX(x): 通过设置X轴的值来定义缩放转换。<br>scaleY(y): 通过设置Y轴的值来定义缩放转换。<br>scaleZ(z): 通过设置Z轴的值来定义3D缩放转换。<br>rotate(angle): 定义2D旋转，在参数中规定角度。<br>rotate3d(x,y,z,angle): 定义3D旋转。<br>rotateX(angle): 定义沿着X轴的3D旋转。<br>rotateY(angle): 定义沿着Y轴的3D旋转。<br>rotateZ(angle): 定义沿着Z轴的3D旋转。<br>skew(x-angle,y-angle): 定义沿着X和Y轴的2D倾斜转换。<br>skewX(angle): 定义沿着X轴的2D倾斜转换。<br>skewY(angle): 定义沿着Y轴的2D倾斜转换。<br>perspective(n): 为3D转换元素定义透视视图。<br>浏览器支持<br>Internet Explorer 10、Firefox、Opera 支持 transform 属性。<br>Internet Explorer 9 支持替代的 -ms-transform 属性（仅适用于 2D 转换）。<br>Safari 和 Chrome 支持替代的 -webkit-transform 属性（3D 和 2D 转换）。<br>Opera 只支持 2D 转换。</p>
<p>C.Animation<br>Animation让CSS拥有了可以制作动画的功能。使用CSS3的Animation制作动画我们可以省去复杂的js代码。使用方法大概如下：具体用法可以参考教程：CSS3 Animation。</p>
<p>边框<br>CSS3新增了三个边框属性，分别是border-radius、box-shadow和border-image。border-radius可以创建圆角边框，box-shadow可以为元素添加阴影，border-image可以使用图片来绘制边框。IE9+支持border-radius和box-shadow属性。Firefox、Chrome以及Safari支持所有新的边框属性。</p>
<p>背景<br>CSS3新增了几个关于背景的属性，分别是background-clip、background-origin、background-size和background-break。</p>
<p>A.background-clip<br>background-clip属性用于确定背景画区，有以下几种可能的属性：</p>
<p>background-clip: border-box; 背景从border开始显示<br>background-clip: padding-box; 背景从padding开始显示<br>background-clip: content-box; 背景显content区域开始显示<br>background-clip: no-clip; 默认属性，等同于border-box<br>通常情况，背景都是覆盖整个元素的，利用这个属性可以设定背景颜色或图片的覆盖范围。</p>
<p>B.background-origin<br>background-clip属性用于确定背景的位置，它通常与background-position联合使用，可以从 border、padding、content来计算background-position（就像background-clip）。</p>
<p>background-origin: border-box; 从border开始计算background-position<br>background-origin: padding-box; 从padding开始计算background-position<br>background-origin: content-box; 从content开始计算background-position<br>C.background-size<br>background-size属性常用来调整背景图片的大小，主要用于设定图片本身。有以下可能的属性：</p>
<p>background-size: contain; 缩小图片以适合元素（维持像素长宽比）<br>background-size: cover; 扩展元素以填补元素（维持像素长宽比）<br>background-size: 100px 100px; 缩小图片至指定的大小<br>background-size: 50% 100%; 缩小图片至指定的大小，百分比是相对包 含元素的尺寸<br>D.background-break<br>CSS3中，元素可以被分成几个独立的盒子（如使内联元素span跨越多行），background-break 属性用来控制背景怎样在这些不同的盒子中显示。</p>
<p>background-break: continuous; 默认值。忽略盒之间的距离（也就是像元素没有分成多个盒子，依然是一个整体一样）<br>background-break: bounding-box; 把盒之间的距离计算在内；<br>background-break: each-box; 为每个盒子单独重绘背景。<br>文字效果<br>A.word-wrap<br>CSS3中，word-wrap属性允许您允许文本强制文本进行换行，即这意味着会对单词进行拆分。所有主流浏览器都支持 word-wrap 属性。</p>
<p>B.text-overflow<br>它与word-wrap是协同工作的，word-wrap设置或检索当当前行超过指定容器的边界时是否断开转行，而 text-overflow则设置或检索当当前行超过指定容器的边界时如何显示。对于“text-overflow”属性，有“clip”和“ellipsis”两种可供选择。</p>
<p>C.text-shadow<br>CSS3中，text-shadow可向文本应用阴影。能够规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色。</p>
<p>D.text-decoration<br>CSS3里面开始支持对文字的更深层次的渲染，具体有三个属性可供设置：</p>
<p>text-fill-color: 设置文字内部填充颜色<br>text-stroke-color: 设置文字边界填充颜色<br>text-stroke-width: 设置文字边界宽度<br>box-sizing<br>box-sizing属性可设置的值有content-box、border-box和inherit。</p>
<p>content-box: padding和border不被包含在定义的width和height之内。对象的实际宽度等于设置的width值和border、padding之和，即 (Element width = width + border + padding)，此属性表现为标准模式下的盒模型。<br>border-box: padding和border被包含在定义的width和height之内。对象的实际宽度就等于设置的width值，即使定义有border和padding也不会改变对象的实际宽度，即 (Element width = width)，此属性表现为怪异模式下的盒模型。</p>
<p>参考：<a href="https://juejin.im/entry/595f1e3c5188250d914dd53c" target="_blank" rel="noopener">https://juejin.im/entry/595f1e3c5188250d914dd53c</a><br>参考：<a href="https://leohxj.gitbooks.io/front-end-database/html-and-css-basic/css3-news.html" target="_blank" rel="noopener">https://leohxj.gitbooks.io/front-end-database/html-and-css-basic/css3-news.html</a></p>
<h3 id="9、CSS3中媒体查询简述"><a href="#9、CSS3中媒体查询简述" class="headerlink" title="9、CSS3中媒体查询简述"></a>9、CSS3中媒体查询简述</h3><p>1.首先要了解一下什么是媒体查询<br>媒体查询可以让我们根据设备显示器的特性（如视口宽度、屏幕比例、设备方向：横向或纵向）为其设定CSS样式，媒体查询由媒体类型和一个或多个检测媒体特性的条件表达式组成。媒体查询中可用于检测的媒体特性有 width 、 height 和 color （等）。使用媒体查询，可以在不改变页面内容的情况下，为特定的一些输出设备定制显示效果。</p>
<p>2.如何在css中引入媒体查询<br>媒体查询写在CSS样式代码的最后，CSS是层叠样式表，在同一特殊性下，靠后的的样式会重叠前面的样式</p>
<p>3.常见Media使用示例<br>代码<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>/<em>媒体查询</em>/<br>/<em>当页面大于1200px 时，大屏幕，主要是PC 端</em>/<br>@media (min-width: 1200px) {<br>}<br>/<em>在992 和1199 像素之间的屏幕里，中等屏幕，分辨率低的PC</em>/<br>@media (min-width: 992px) and (max-width: 1199px) {</p>
<pre><code>#adver .center {
    width: 50%;
    margin: -10px 0 0 -25%;
}
main .center h2 {
    font-size: 40px;
}
</code></pre><p>}<br>/<em>在768 和991 像素之间的屏幕里，小屏幕，主要是PAD</em>/<br>@media (min-width: 768px) and (max-width: 991px) {</p>
<pre><code>#adver .center {
    width: 60%;
    margin: -10px 0 0 -30%;
}
#adver .search, #adver .button {
    font-size: 20px;
}
main .center h2 {
    font-size: 35px;
}
</code></pre><p>}<br>/<em>在480 和767 像素之间的屏幕里，超小屏幕，主要是手机</em>/<br>@media (min-width: 480px) and (max-width: 767px) {<br>    header, header .center, header .link {<br>        height: 45px;<br>    }<br>    header .logo, .sm-hidden,.sidebar,.md-hidden {<br>        display: none;<br>    }<br>    header .link {<br>        width: 100%;<br>        line-height: 45px;<br>    }</p>
<pre><code>#adver {
    padding: 45px 0 0 0;
}
#adver .center {
    width: 70%;
    height: 53px;
    margin: -10px 0 0 -35%;
}
#adver .search, #adver .button {
    height: 45px;
    font-size: 18px;
}
.sm-visible {
    display: block;
}
main .center h2 {
    font-size: 30px;
}
main .center p {
    font-size: 15px;
}
main figure {
    width: 49.2%;
}
</code></pre><p>}<br>/<em>在小于480 像素的屏幕，微小屏幕，更低分辨率的手机</em>/<br>@media (max-width: 479px) {<br>    header, header .center, header .link {<br>        height: 45px;<br>    }<br>    header .logo, .xs-hidden, .sm-hidden, .sidebar, .md-hidden  {<br>        display: none;<br>    }<br>    header .link {<br>        width: 100%;<br>        line-height: 45px;<br>    }<br>    header .link li {<br>        width: 25%;<br>    }</p>
<pre><code>#adver {
    padding: 45px 0 0 0;
}
#adver .center {
    width: 80%;
    height: 48px;
    margin: -10px 0 0 -40%;
}
#adver .search, #adver .button {
    height: 40px;
    font-size: 16px;
}
.sm-visible {
    display: block;
}
footer .bottom, footer .version {
    font-size: 13px;
}
main .center h2 {
    font-size: 26px;
}
main .center p {
    font-size: 14px;
}
main figure {
    width: 99%;
}
</code></pre><p>}</p>
<p>参考：<a href="https://www.jianshu.com/p/eb1123d5b20b" target="_blank" rel="noopener">https://www.jianshu.com/p/eb1123d5b20b</a><br>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/算法-面试题/" rel="tag"># 算法&面试题</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/12/09/前端算法题汇总/" rel="next" title="前端算法题汇总">
                <i class="fa fa-chevron-left"></i> 前端算法题汇总
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/03/24/20200324/" rel="prev" title="20200324">
                20200324 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/background10.jpg"
                alt="Lemon" />
            
              <p class="site-author-name" itemprop="name">Lemon</p>
              <p class="site-description motion-element" itemprop="description">乘风破浪</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、-HTML相关"><span class="nav-number">1.</span> <span class="nav-text">一、 HTML相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、-常⻅见标签类型以及用法以及-meta-中常⻅见属性的含义"><span class="nav-number">1.1.</span> <span class="nav-text">1、 常⻅见标签类型以及用法以及 meta 中常⻅见属性的含义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、-块级元素、内联元素相关分类"><span class="nav-number">1.2.</span> <span class="nav-text">2、 块级元素、内联元素相关分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、-DOM-Document-Object-Model-文档对象模型"><span class="nav-number">1.3.</span> <span class="nav-text">3、 DOM(Document Object Model) 文档对象模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、H5-带来了哪些新标签、新特性"><span class="nav-number">1.4.</span> <span class="nav-text">4、H5 带来了哪些新标签、新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-常用新标签"><span class="nav-number">1.4.1.</span> <span class="nav-text">1) 常用新标签</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-datalist-标签定义选项列表。请与-input-元素配合使用该元素"><span class="nav-number">1.4.2.</span> <span class="nav-text">2) datalist 标签定义选项列表。请与 input 元素配合使用该元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-fieldset-元素可将表单内的相关元素分组，打包-legend-搭配使用"><span class="nav-number">1.4.3.</span> <span class="nav-text">3) fieldset 元素可将表单内的相关元素分组，打包 legend 搭配使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-新增的input-type属性值"><span class="nav-number">1.4.4.</span> <span class="nav-text">4) 新增的input type属性值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-变量的声明、定义，闭包"><span class="nav-number">1.5.</span> <span class="nav-text">2. 变量的声明、定义，闭包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、-数组、字符串、对象、函数的常⻅操作方法以及深浅拷贝"><span class="nav-number">1.6.</span> <span class="nav-text">3、 数组、字符串、对象、函数的常⻅操作方法以及深浅拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、-正则匹配表达式"><span class="nav-number">1.7.</span> <span class="nav-text">4、 正则匹配表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5、-DOM-相关触发事件、节点操作以及事件相关"><span class="nav-number">1.8.</span> <span class="nav-text">5、 DOM 相关触发事件、节点操作以及事件相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6、对于基础的-Window、Document对象概念的掌握、使⽤"><span class="nav-number">1.9.</span> <span class="nav-text">6、对于基础的 Window、Document对象概念的掌握、使⽤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7、原型对象、原型链的相关概念"><span class="nav-number">1.10.</span> <span class="nav-text">7、原型对象、原型链的相关概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8、-this绑定、概念掌握"><span class="nav-number">1.11.</span> <span class="nav-text">8、 this绑定、概念掌握</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9、-异步的掌握和理解-宏任务、微任务、Promise、async-await"><span class="nav-number">1.12.</span> <span class="nav-text">9、 异步的掌握和理解(宏任务、微任务、Promise、async-await)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10、-http、https协议-amp-amp-各层级关系-amp-amp-状态码"><span class="nav-number">1.13.</span> <span class="nav-text">10、 http、https协议&amp;&amp;各层级关系&amp;&amp;状态码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11、跨域知识的了解以及常见的跨域实现方法"><span class="nav-number">1.14.</span> <span class="nav-text">11、跨域知识的了解以及常见的跨域实现方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12、-浏览器中的常见各类攻击手段"><span class="nav-number">1.15.</span> <span class="nav-text">12、 浏览器中的常见各类攻击手段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13、关于-storage-和-cookie-的知识点，包括常见的缓存、存储机制"><span class="nav-number">1.16.</span> <span class="nav-text">13、关于 storage 和 cookie 的知识点，包括常见的缓存、存储机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14、关于-Node-js-的常见用法和概念的掌握"><span class="nav-number">1.17.</span> <span class="nav-text">14、关于 Node.js 的常见用法和概念的掌握</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、CSS相关"><span class="nav-number">2.</span> <span class="nav-text">二、CSS相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、-CSS-常⻅见属性的应⽤用包括属性继承等概念的掌握"><span class="nav-number">2.1.</span> <span class="nav-text">1、 CSS 常⻅见属性的应⽤用包括属性继承等概念的掌握</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、CSS-中常⻅布局以及文本超长展示省略号"><span class="nav-number">2.2.</span> <span class="nav-text">2、CSS 中常⻅布局以及文本超长展示省略号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、-CSS的各种动画以及性能优化"><span class="nav-number">2.3.</span> <span class="nav-text">3、 CSS的各种动画以及性能优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、关于-BFC-块级格式化上下文的理解以及触发-BFC-重新布局相关操作"><span class="nav-number">2.4.</span> <span class="nav-text">4、关于 BFC 块级格式化上下文的理解以及触发 BFC 重新布局相关操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5、-盒子模型"><span class="nav-number">2.5.</span> <span class="nav-text">5、 盒子模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6、-常见浮动场景、清除浮动的常见办法"><span class="nav-number">2.6.</span> <span class="nav-text">6、 常见浮动场景、清除浮动的常见办法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7、文档流的理解和常见改变文档流的方法"><span class="nav-number">2.7.</span> <span class="nav-text">7、文档流的理解和常见改变文档流的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8、-CSS3新增属性"><span class="nav-number">2.8.</span> <span class="nav-text">8、 CSS3新增属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9、CSS3中媒体查询简述"><span class="nav-number">2.9.</span> <span class="nav-text">9、CSS3中媒体查询简述</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lemon</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
