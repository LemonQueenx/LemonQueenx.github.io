<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="js,">










<meta name="description" content="JavaScript，前端三大基础语言之一 第一章、 JS基础第一节、基础概念javaScript是单线程 、解释性、兼容于ECMA标准的脚本语言  浏览器是由外壳（Shell）和内核（kernel）组成，最重要的是内核（解析页面）。  渲染引擎（html、css）  JS引擎（执行js代码），目前最快的是Chrome的V8引擎。  其他模块   编译性语言：C    C++先把语言编译一遍，形成">
<meta name="keywords" content="js">
<meta property="og:type" content="article">
<meta property="og:title" content="js">
<meta property="og:url" content="http://yoursite.com/2019/03/29/js/index.html">
<meta property="og:site_name" content="立夏">
<meta property="og:description" content="JavaScript，前端三大基础语言之一 第一章、 JS基础第一节、基础概念javaScript是单线程 、解释性、兼容于ECMA标准的脚本语言  浏览器是由外壳（Shell）和内核（kernel）组成，最重要的是内核（解析页面）。  渲染引擎（html、css）  JS引擎（执行js代码），目前最快的是Chrome的V8引擎。  其他模块   编译性语言：C    C++先把语言编译一遍，形成">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-08-31T08:43:23.018Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="js">
<meta name="twitter:description" content="JavaScript，前端三大基础语言之一 第一章、 JS基础第一节、基础概念javaScript是单线程 、解释性、兼容于ECMA标准的脚本语言  浏览器是由外壳（Shell）和内核（kernel）组成，最重要的是内核（解析页面）。  渲染引擎（html、css）  JS引擎（执行js代码），目前最快的是Chrome的V8引擎。  其他模块   编译性语言：C    C++先把语言编译一遍，形成">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/03/29/js/">





  <title>js | 立夏</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">立夏</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-窝">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            窝
          </a>
        </li>
      
        
        <li class="menu-item menu-item-签">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-类">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-档">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-于">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/29/js/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lemon">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/background10.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="立夏">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">js</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-29T17:09:29+08:00">
                2019-03-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/1）前端-基础/" itemprop="url" rel="index">
                    <span itemprop="name">1）前端 - 基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>JavaScript，前端三大基础语言之一</p>
<h1 id="第一章、-JS基础"><a href="#第一章、-JS基础" class="headerlink" title="第一章、 JS基础"></a><font color="#DC143C">第一章、 JS基础</font></h1><h2 id="第一节、基础概念"><a href="#第一节、基础概念" class="headerlink" title="第一节、基础概念"></a><font color="#FF69B4">第一节、基础概念</font></h2><p><strong>javaScript是单线程 、解释性、兼容于ECMA标准的脚本语言</strong></p>
<blockquote>
<p>浏览器是由外壳（Shell）和内核（kernel）组成，最重要的是内核（解析页面）。<br>  渲染引擎（html、css）<br>  JS引擎（执行js代码），目前最快的是Chrome的V8引擎。<br>  其他模块</p>
</blockquote>
<ul>
<li>编译性语言：C    C++<br>先把语言编译一遍，形成一个新的文件，再执行。<br>执行速度快、跨平台性差</li>
<li>解释性语言：js    php     python<br>不需要编译成文件<br>跨平台性好、执行速度慢</li>
<li>java结合两者优点，效率折中，java通过javac编译成.class语言，在jvm(Java Virtual Machine，java虚拟机)中执行。</li>
</ul>
<blockquote>
<p><strong>ECMA标准</strong> - 为了取得技术优势，微软推出JScript，CEnvi推出ScriptEase，与javaScript一样可在浏览器中运行。为了统一规格，javascript兼容于ECMA（European Computer Manufacturers Association，欧洲计算机制造联合会）标准，因此也称为ECMAScript。</p>
</blockquote>
<blockquote>
<p>单线程<br>  js执行队列：js执行主线程 &lt;- task1,1ms &lt;- task2,2ms &lt;- task2,1ms &lt;- task1,1ms &lt;- task1,1ms</p>
</blockquote>
<h2 id="第二节、ECMAScript"><a href="#第二节、ECMAScript" class="headerlink" title="第二节、ECMAScript"></a><font color="#FF69B4">第二节、ECMAScript</font></h2><p>js三大部分：<br>  ECMAScript（描述了该语言和基本对象）<br>  DOM（文档对象模型，描述了处理网页内容的方法和接口）<br>  BOM（浏览器对象模型，描述与浏览器进行交互的方法和接口）</p>
<h3 id="一、引入"><a href="#一、引入" class="headerlink" title="一、引入"></a>一、引入</h3><p>行间样式（不过一般都不这样写）<br>页面内嵌&lt;script>&lt;/script>标签<br>外部引入&lt;script src = ‘xxx’>&lt;/script><br>（为符合W3C标准：结构、样式、行为相分离，通常会采用外部引入）</p>
<h3 id="二、基础语法"><a href="#二、基础语法" class="headerlink" title="二、基础语法"></a>二、基础语法</h3><h4 id="1-变量（variable）"><a href="#1-变量（variable）" class="headerlink" title="1. 变量（variable）"></a><strong>1. 变量（variable）</strong></h4><p>  1) 变量声明<br>     声明、赋值分解<br>     单一var声明<br>  2）命名规则<br>     1、变量名只能以英文字母、 _ 、 $开头<br>     2、变量名可以包括英文字母、 _ 、 $和数字<br>     3、不可以用系统的关键字、保留字作为变量名</p>
<blockquote>
<p>关键字<br>    var void if else switch case default do while try catch throw for continue break return in  delete typeof instanceof new this with finally function</p>
</blockquote>
<blockquote>
<p>保留字<br>    boolean const char byte double float int long short enum interface  static  private    protected package    public import class super extends throws debugger export implements abstract    final        goto    native     synchronized    transient volatile</p>
</blockquote>
<h4 id="2-值类型"><a href="#2-值类型" class="headerlink" title="2. 值类型"></a><strong>2. 值类型</strong></h4><p>  a. 不可改变的原始值（栈类型 stack）： number   string     Boolean    undefined    null<br>  b. 引用值（堆数据 heap）： function  object  array</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 以下两个值分别是什么？</span><br><span class="line">    var a = 1;</span><br><span class="line">    var b = 2;</span><br><span class="line">    var num1 = a,b;</span><br><span class="line">    var num2 = (a,b);</span><br><span class="line">2. 以下,x的最终值是什么？</span><br><span class="line">    var x = 1;</span><br><span class="line">    if (function f() &#123;&#125;) &#123;</span><br><span class="line">      x += typeof f;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-js语法基本规则"><a href="#3-js语法基本规则" class="headerlink" title="3. js语法基本规则"></a><strong>3. js语法基本规则</strong></h4><p>  语句后面用分号结束；<br>  书写格式要规范，“ + - = /”两边都应有空格；<br>  js语法错误会引发后续代码终止，但不会影响其他js代码块；</p>
<h4 id="4-js运算符"><a href="#4-js运算符" class="headerlink" title="4. js运算符"></a><strong>4. js运算符</strong></h4><h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><blockquote>
<p>运算操作符:</p>
<pre><code>+                        1）数字运算，字符串连接   2）任何数据+字符串都等于字符串
- * / % = ()             1）优先级“=”最弱  “()”较高
++ -- += -= /= *= %=
</code></pre></blockquote>
<blockquote>
<p>比较运算符: &gt; &lt; == &gt;= &lt;= != === !==  1）结果为boolean值</p>
</blockquote>
<blockquote>
<p>逻辑运算符: &amp;&amp; || ！ 1）结果为真实值</p>
</blockquote>
<blockquote>
<p>被认定为false的值: undefined null NaN ‘’ “” 0 false</p>
</blockquote>
<blockquote>
<p>typeof: number 、 string 、 boolean 、 undefined 、 object 、 function六种数据类型</p>
</blockquote>
  <font color="red">(null 、[] 、object -&gt; object)</font>

<h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><pre><code>1. 显示类型转换
    Number()
    String()
    Boolean()
    toString()
    parseInt()
    parseFloat()
2. 隐式类型转换
    isNaN()     被认定NaN:undefined 、 NaN 、{}
    ++ / --  + / -（一元正负）
    +
    *、/ %
    &amp;&amp; || !
    &lt;   &gt;   &lt;=   &gt;=
    ==   !=
3. 不发生类型转换
    === !==
</code></pre><p>  思考：</p>
<ol>
<li><p>请问以下c的值分别是什么？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;            var a = 0;              var a = 1;</span><br><span class="line">var b = 2;            var b = 2;              var b = 0;</span><br><span class="line">var c = a &amp;&amp; b;       var c = a &amp;&amp; b;         var c = a &amp;&amp; b;</span><br></pre></td></tr></table></figure>
</li>
<li><p>请问以下c的值分别是什么？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;            var a = 0;              var a = 1;</span><br><span class="line">var b = 2;            var b = 2;              var b = 0;</span><br><span class="line">var c = a || b;       var c = a || b;         var c = a || b;</span><br></pre></td></tr></table></figure>
</li>
<li><p>请问以下结果分别是什么？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = 0;                       var a = 0;             </span><br><span class="line">var b = 2;                       var b = 2;        </span><br><span class="line">a &lt; b &amp;&amp; document.write(b)       a &gt; b &amp;&amp; document.write(b)</span><br></pre></td></tr></table></figure>
</li>
<li><p>请问以下结果分别是什么？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NaN == NaN  [] == []  undefined == undefined  undefined == null</span><br></pre></td></tr></table></figure>
</li>
<li><p>请问以下的值分别是什么？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = 1 + 1 + <span class="string">'aini'</span> + 1 + 1;</span><br><span class="line">var b = 1 + 1 + <span class="string">'aini'</span> + ( 1 + 1 );</span><br></pre></td></tr></table></figure>
</li>
<li><p>请问以下结果是什么？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = 1 / 0;</span><br><span class="line">var b = 1 / 0;</span><br><span class="line">document.write(a - b);</span><br></pre></td></tr></table></figure>
</li>
<li><p>请问以下结果分别是什么？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = 0;                          var a = 0;</span><br><span class="line">var b = 10;                         var b = 10;</span><br><span class="line">b += a++;                           b += ++a;</span><br><span class="line">document.write(b,a);                document.write(b,a);</span><br></pre></td></tr></table></figure>
</li>
<li><p>请问以下结果分别是什么？<br>var a = ( 10 * 3 - 4 / 2 + 1 ) % 2,<br> b = 3;<br>b %= a;<br>document.write(a++, –b);</p>
</li>
<li>var a = 123; var b = 234;请交换a 和 b的值。</li>
</ol>
<h4 id="5-条件语句"><a href="#5-条件语句" class="headerlink" title="5. 条件语句"></a><strong>5. 条件语句</strong></h4><p>  if 、 if else 、 if else if<br>  for 、 while 、do while<br>  switch  case default<br>  break 、 continue</p>
<h4 id="6-引用值"><a href="#6-引用值" class="headerlink" title="6. 引用值"></a><strong>6. 引用值</strong></h4><p>1）数组<br>2）对象</p>
<blockquote>
<p>编程形式的区别：面向过程、面向对象</p>
</blockquote>
<p>3）函数</p>
<ol>
<li>函数声明、函数表达式</li>
<li><p>参数(形参、实参、实参列表)<br><font color="red">注意：形参、实参、实参列表（arguments）的映射关系。</font></p>
<blockquote>
<p>大加法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">BigAdd</span></span>() &#123;</span><br><span class="line">  var sum = 0;</span><br><span class="line">  <span class="keyword">for</span> (var i = 0 ; i &lt; arguments.length ; i++) &#123;</span><br><span class="line">    sum += arguments[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> sum; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>返回值<br>return什么，函数便等于什么（函数名用 <font color="red">小驼峰式</font> 写法）</p>
</li>
<li>作用域<br>定义：变量（变量作用域又称上下文）和函数生效（能被访问）的区域<br>全局变量、局部变量<br>作用域的访问顺序</li>
</ol>
<h3 id="三、复杂数据类型"><a href="#三、复杂数据类型" class="headerlink" title="三、复杂数据类型"></a>三、复杂数据类型</h3><h4 id="3-1）函数"><a href="#3-1）函数" class="headerlink" title="3.1）函数"></a>3.1）函数</h4><h5 id="1、预编译"><a href="#1、预编译" class="headerlink" title="1、预编译"></a>1、预编译</h5><p>  （规律）函数声明提升、变量声明提升<br>  （原理）预编译发生在执行的前一刻。一个函数执行，函数会先发生预编译，预编译过程中会产生执行期上下文对象。Activation Object 活动对象（AO）</p>
<blockquote>
<p>四部曲<br>    1、创建AO对象<br>    2、找形参和变量声明，将变量和形参名作为AO属性名，值为undefined<br>    3、将实参值和形参统一<br>    4、在函数体里面找函数声明，值赋予函数体<br>    <font color="red">* 每个函数最后都有一个return，当执行到这一步时，AO被处理掉，函数就不执行了。</font></p>
</blockquote>
<blockquote>
<p>全局也能预编译<br>    三步：<br>    1、创建GO（Global Object）对象<br>    2、找变量声明，将变量名作为GO属性名，值为undefined<br>    3、找函数声明，值赋予函数体</p>
</blockquote>
<h5 id="2、作用域"><a href="#2、作用域" class="headerlink" title="2、作用域"></a>2、作用域</h5><ul>
<li><p>[[scope]]：每个javascript函数都是一个对象，对象中有些属性我们可以访问，有些不可以，这些属性仅供javascript引擎存取，[[scope]]就是其中一个。[[scope]]指的就是我们所说的作用域，其中存储了运行期上下文的集合。</p>
</li>
<li><p>作用域链：[[scope]]中所存储的执行期上下文对象的集合，这个集合呈链式链接。我们把这个链式链接叫做作用域链。</p>
</li>
<li><p>运行期上下文：当函数执行时，会创建一个称为执行期上下文的内部对象。一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对象的执行期上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行期上下文，当函数执行完，执行上下文被销毁。</p>
</li>
<li><p>查找变量：从作用域链的顶端依次向下查找。</p>
</li>
</ul>
<h5 id="3、闭包"><a href="#3、闭包" class="headerlink" title="3、闭包"></a>3、闭包</h5><blockquote>
<p>当内部函数被保存到外部时，会生成闭包，闭包会导致原有作用域链不释放，造成内存泄露</p>
</blockquote>
<h6 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h6><p>a) 可以实现公有变量<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">函数累加器（公有变量）</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">a</span></span>()&#123;                               <span class="keyword">function</span> <span class="function"><span class="title">a</span></span>()&#123;</span><br><span class="line">  var num = 0;                                var num = 0;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">b</span></span>()&#123;                               <span class="keyword">function</span> <span class="function"><span class="title">b</span></span>()&#123;</span><br><span class="line">    console.log(++num);                          console.log(++num);</span><br><span class="line">  &#125;                                           &#125;</span><br><span class="line">  <span class="built_in">return</span>  b;                                  <span class="keyword">function</span> <span class="function"><span class="title">c</span></span>()&#123;</span><br><span class="line">&#125;                                                console.log(--num);</span><br><span class="line">var getCounter = a();                          &#125;</span><br><span class="line">getCounter();    ---&gt; 1                        <span class="built_in">return</span> [b,c];</span><br><span class="line">getCounter();    ---&gt; 2                      &#125;</span><br><span class="line">getCounter();    ---&gt; 3                      var getCounterArr = a();  </span><br><span class="line">                                             getCounterArr[0]();    ---&gt; 1   </span><br><span class="line">                                             getCounterArr[1]();    ---&gt; 0</span><br></pre></td></tr></table></figure></p>
<p>b) 可以做缓存<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">eater</span></span>()&#123;</span><br><span class="line">  var food = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">eat</span></span>()&#123;</span><br><span class="line">    console.log(food);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> buy(foods)&#123;</span><br><span class="line">    food = foods;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> &#123; eat: eat, buy: buy &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var person = eater();</span><br><span class="line">person.buy(<span class="string">'apple'</span>);</span><br><span class="line">person.eat();          ----&gt; <span class="string">'apple'</span></span><br></pre></td></tr></table></figure></p>
<p>c) 可以实现封装、属性私有化<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">wrapper</span></span>()&#123;</span><br><span class="line">  var slice = Array.prototype.slice;</span><br><span class="line">  ...很多变量</span><br><span class="line">  <span class="keyword">function</span> $()&#123;</span><br><span class="line">    ...很多变量</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">add</span></span>()&#123;...&#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">show</span></span>()&#123;...&#125;</span><br><span class="line">    ...很多函数</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> &#123;add: add,show: show...很多函数&#125;;</span><br><span class="line">&#125;</span><br><span class="line">var $ = wrapper();</span><br><span class="line">var obj = $();</span><br></pre></td></tr></table></figure></p>
<font color="red">注：闭包会大量占用内存资源（作用域链不释放），因此，能少用还是少用，要了解闭包的原理再使用，否则浪费内存。</font>

<h6 id="闭包的高级应用"><a href="#闭包的高级应用" class="headerlink" title="闭包的高级应用"></a>闭包的高级应用</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">test</span></span> () &#123;</span><br><span class="line">  var arr = [];</span><br><span class="line">  <span class="keyword">for</span> (var i = 0 ; i &lt; 10 ; i ++) &#123;</span><br><span class="line">    arr[i] = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">      console.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line">var outerArr = <span class="built_in">test</span>();</span><br><span class="line"><span class="keyword">for</span> (var j = 0 ; j &lt; 10 ; j++) &#123;</span><br><span class="line">  outerArr[j]();</span><br><span class="line">&#125;</span><br><span class="line">结果是10个10 ，这是为什么呢？</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">test</span></span>() &#123;</span><br><span class="line">  var arr = [];</span><br><span class="line">  <span class="keyword">for</span> (var i = 0 ; i &lt; 10 ; i++ ) &#123;</span><br><span class="line">    arr[i] =(<span class="keyword">function</span>(j)&#123;</span><br><span class="line">      console.log(j);</span><br><span class="line">    &#125;(i))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line">var outerArr = <span class="built_in">test</span>();</span><br><span class="line"><span class="keyword">for</span> (var j = 0 ; j &lt; 10 ; j++) &#123;</span><br><span class="line">  outerArr[j]();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4、立即执行函数"><a href="#4、立即执行函数" class="headerlink" title="4、立即执行函数"></a>4、立即执行函数</h5><ul>
<li><p>此类函数没有生命，在一次执行完后立即释放，适合做初始化工作。</p>
</li>
<li><p>写法：(function())<font color="red">w3c推荐</font>  或   (function)()</p>
<pre><code>函数声明❌  函数表达式✅
只有函数表达式+()才能执行（能被执行符号执行的表达式，执行一次，函数就被忽略，不能再使用）
</code></pre></li>
<li><p>+ - ！ &amp;&amp; ||可以是一个函数声明变成一个表达式<br>+function test(){}();          —&gt;可以执行，但是再test()会报错<br>true &amp;&amp; function test(){}();   —&gt;✅<br>false || function test(){}();  —&gt;✅</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jQuery中用到的就是闭包，立即执行函数和原型</span><br><span class="line">(<span class="function"><span class="title">function</span></span> ()&#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">jQuery</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> jQuery.prototype.init();</span><br><span class="line">  &#125;</span><br><span class="line">  jQuery.prototype.init = <span class="function"><span class="title">funtcion</span></span>()&#123;...&#125;</span><br><span class="line">  jQuery.prototype.init.prototype = jQuery.prototype;</span><br><span class="line"></span><br><span class="line">  window.$ = jQuery;</span><br><span class="line">&#125;())</span><br><span class="line">这样后续，$就替代jQuery。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-2）对象"><a href="#3-2）对象" class="headerlink" title="3.2）对象"></a>3.2）对象</h4><h5 id="1、对象"><a href="#1、对象" class="headerlink" title="1、对象"></a>1、对象</h5><h6 id="1）对象的创建方法"><a href="#1）对象的创建方法" class="headerlink" title="1）对象的创建方法"></a>1）对象的创建方法</h6><ul>
<li>字面量<ul>
<li>var obj = {}</li>
<li>缺点：每创建一次只对应一个对象，比较局限。</li>
</ul>
</li>
<li>构造函数<ul>
<li>系统自带：new Object(); Array(); Number(); Boolean; Date();</li>
<li>自定义 <font color="green">一般以一个函数为构造函数，函数名要大写</font></li>
</ul>
</li>
<li>Object.create(原型)方法</li>
</ul>
<h6 id="2）属性的增删改查"><a href="#2）属性的增删改查" class="headerlink" title="2）属性的增删改查"></a>2）属性的增删改查</h6><blockquote>
<p> 增 obj.attrValue = ‘hahaha’;<br>   删 delete obj.attrValue;<br>   改 obj.haha = ‘heihei’;   obj[haha] = ‘heihei’;  obj[‘haha’] = ‘heihei’;<br>   查 obj.haha   obj[haha]  obj[‘haha’]</p>
</blockquote>
<h6 id="3）包装类"><a href="#3）包装类" class="headerlink" title="3）包装类"></a>3）包装类</h6><p>   String();<br>   Boolean();<br>   Number();</p>
<h6 id="4）对象的枚举"><a href="#4）对象的枚举" class="headerlink" title="4）对象的枚举"></a>4）对象的枚举</h6><ol>
<li><p>for （ in ）<br>不仅可以遍历对象，还可以遍历数组</p>
</li>
<li><p>对象的枚举</p>
<ul>
<li><font color="red">hasOwnProperty</font><br>是否是对象自己的属性。只对自己对象的属性为true，对自己原型上的属性为false，其他更为false。</li>
<li><font color="red">for（ in ）</font><br>可以遍历自己及原型的属性。但是，当原型是系统的Object.prototype的时候不会遍历。</li>
<li><font color="red">in</font><br>是否是对象上或者原型链上的属性。换句话说，只要对象能调用的属性就是true。</li>
<li><font color="red">instanceof</font><br>浅：A是否是B构造函数的构造出来的<br>深：A原型链上有没有B的原型</li>
</ul>
</li>
</ol>
<h5 id="2、原型及原型链"><a href="#2、原型及原型链" class="headerlink" title="2、原型及原型链"></a>2、原型及原型链</h5><h6 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h6><blockquote>
<p>定义：原型是function对象的一个属性，它定义了构造函数制造出的对象的公共祖先，通过该构造函数产生的对象，可以继承该原型的属性和方法，原型也是对象。</p>
</blockquote>
<blockquote>
<p>每个构造函数都有原型prototype，prototype也是对象<br>  每个对象都有<strong>proto</strong>属性， __proto__ 的值就是构造函数的原型prototype<br>  prototype 下有个属性：constructor指向该对象的构造函数 或 该构造函数自己。</p>
</blockquote>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Factory</span></span>()&#123;&#125;</span><br><span class="line">Factory.prototype.name = <span class="string">'wang'</span></span><br><span class="line">var obj = new Factory();</span><br><span class="line"></span><br><span class="line">obj.__proto__                  ---&gt;      &#123;name: <span class="string">"wang"</span>, constructor: ƒ&#125;</span><br><span class="line">Factory.prototype              ---&gt;      &#123;name: <span class="string">"wang"</span>, constructor: ƒ&#125;</span><br><span class="line">obj.__proto__.constructor      ---&gt;       ƒ <span class="function"><span class="title">Factory</span></span>()&#123;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>1） 构造函数.prototype.属性  是增加或修改原型的属性<br>      构造函数.prototype = {…} 是重写，覆盖本来的原型<br>  2） 构造函数构造出的对象，在<font color="green">出生（定义）</font>时就知道了原型的地址。这时是谁就是谁，你可以给我的原型prototype增加或修改属性，但是如果你在我出生后在修改构造函数的原型，就和我没关系了。我的原型还是我出生时候的原型。</p>
</blockquote>
<h6 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h6><ul>
<li><font color="red">谁调用的方法，方法内部的this就指向谁，没人调用则指向全局对象（window）</font>
</li>
<li><font color="red">绝大多数对象的最终都会继承自Object.prototype</font>
</li>
<li><p><font color="red">Object.create(null)</font>，null创建出来的对象没有原型，NoPrototies</p>
</li>
</ul>
<h5 id="3、this指向问题"><a href="#3、this指向问题" class="headerlink" title="3、this指向问题"></a>3、this指向问题</h5><p>以下结果是什么，为什么？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var num = 123;</span><br><span class="line">num.toString();</span><br></pre></td></tr></table></figure></p>
<p>结果是”123”，因为原型链中从底部向顶部查找toString()方法，数字的Number包装类里就有toString()方法，所以没有继续找Object的toString()方法。</p>
<h6 id="1）-call的实现原理"><a href="#1）-call的实现原理" class="headerlink" title="1） call的实现原理"></a>1） call的实现原理</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myCall = <span class="keyword">function</span>(thisArg, ...args) &#123;</span><br><span class="line">  <span class="keyword">if</span> (typeof this !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    throw new TypeError(<span class="string">'error'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  thisArg = thisArg || window;</span><br><span class="line">  thisArg.func = this;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">let</span> fn = thisArg.func(...args);</span><br><span class="line">  delete thisArg.func;</span><br><span class="line">  <span class="built_in">return</span> fn;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="built_in">test</span>(params) &#123;</span><br><span class="line">  console.log(this.name, params);</span><br><span class="line">&#125;</span><br><span class="line">var name = <span class="string">'全局的名字'</span>;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  name: <span class="string">'obj的名字'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">test</span>(<span class="string">'测试参数-无人调用'</span>);                    ----&gt;    全局的名字   测试参数-无人调用</span><br><span class="line">test.call(obj, <span class="string">'测试参数-obj调用'</span>);          ----&gt;    obj的名字    测试参数-obj调用</span><br></pre></td></tr></table></figure>
<h6 id="2）apply的实现原理"><a href="#2）apply的实现原理" class="headerlink" title="2）apply的实现原理"></a>2）apply的实现原理</h6><p>apply的实现原理和call一样，只不过是传入的参数不同处理不同而已。<br>其实,apply应该还要校验：参数只能有两个，且第二个参数必须是数组，否则会报错。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//Function.prototype.apply = <span class="keyword">function</span>(thisArg,args)</span><br><span class="line">//去除参数的第一个值后执行这个添加的函数</span><br><span class="line">const res = thisArg.fn(...args);//只是参数处理不用，args这里只接受数组</span><br></pre></td></tr></table></figure></p>
<h6 id="3）bind的实现原理"><a href="#3）bind的实现原理" class="headerlink" title="3）bind的实现原理"></a>3）bind的实现原理</h6><p>将绑定函数当作构造函数使用，bind 提供的 this 指向无效，但是还是可以预设参数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Test3(a, b) &#123;</span><br><span class="line">  this.a = a;</span><br><span class="line">  this.b = b;</span><br><span class="line">&#125;</span><br><span class="line">Test3.prototype.add = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="built_in">return</span> this.a + this.b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不用 bind，正常来说这样处理</span></span><br><span class="line">var t1 = new Test3(1, 2);</span><br><span class="line">t1.add(); <span class="comment"># 3, this 指向 t1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 bind</span></span><br><span class="line">var NewTest3 = Test3.bind(null, 3);</span><br><span class="line">var t2 = new NewTest3(4);</span><br><span class="line">t2.add(); <span class="comment"># 7, this 指向 t2</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind = <span class="keyword">function</span> (oThis) &#123;</span><br><span class="line">  <span class="keyword">if</span>(typeof this !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    throw new TypeError(<span class="string">'Function.prototype.bind - what is trying to bebound is noe callable'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var aArgs = Array.prototype.slice.call(arguments, 1),</span><br><span class="line">      fToBind = this,</span><br><span class="line">      fNop = <span class="function"><span class="title">function</span></span> () &#123;&#125;,</span><br><span class="line">      fBound = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        <span class="comment"># 当通过new方法调用时，this就是fNop的一个实例</span></span><br><span class="line">        <span class="built_in">return</span> fToBind.apply(this instanceof fNop ? this : (oThis || this) , aArgs.concat(Array.prototype.slice.call(arguments)));</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">  fNop.prototype = this.prototype;</span><br><span class="line">  fBound.prototype = new fNop();</span><br><span class="line">  <span class="built_in">return</span> fBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>call 、 apply 和 bind的区别：<br>1）apply、call 都是直接执行调用函数，并让this执行第一个参数<br>              二者只是传参格式不同：call(obj,arguments1, arguments2…)<br>                                apply(obj,[arguments1, arguments2…])<br>2）bind绑定this后返回一个函数闭包，不直接执行。（将绑定函数当做构造函数使用，bind 提供的 this 指向无效，但是还是可以预设参数）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;var a = 12;this.sayA = function()&#123;console.log(this.a);&#125;&#125;</span><br><span class="line">var oTest = new test()</span><br><span class="line">oTest.sayA();   ---&gt; undefined</span><br></pre></td></tr></table></figure>
<p>阿里经典面试题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;222&apos;;</span><br><span class="line">var a = &#123;</span><br><span class="line">  name: &apos;111&apos;,</span><br><span class="line">  say: function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">a.say();</span><br><span class="line">var b = &#123;</span><br><span class="line">  name: &apos;333&apos;,</span><br><span class="line">  say: function (fun) &#123;</span><br><span class="line">    fun();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">b.say(a.say);</span><br><span class="line">b.say = a.say;</span><br><span class="line">b.say();</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;foo = 2; this.foo = 4; console.log(this.foo);&#125;</span><br><span class="line">test();</span><br><span class="line">new test();</span><br><span class="line"></span><br><span class="line">function test() &#123;this.foo = 4;foo = 2; console.log(this.foo);&#125;</span><br><span class="line">test();</span><br><span class="line">new test();</span><br></pre></td></tr></table></figure>
<p>先查AO。再查GO，<br>局部变量 - this - 全局</p>
<h5 id="4、继承发展史"><a href="#4、继承发展史" class="headerlink" title="4、继承发展史"></a>4、继承发展史</h5><p>1、传统形式：会沿着原型链一脉相承，继承父辈祖辈的所有属性，但是可能很多属性是没用的。</p>
<p>2、借用构造函数：不能继承借用构造函数的原型，每次构造函数都要多走一个函数。（call/apply）</p>
<p>3、共享原型：不能随便改动自己的原型</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Fathor</span></span> () &#123;...&#125;</span><br><span class="line">var oFather = new Father();</span><br><span class="line"></span><br><span class="line">Son.prototype = Fathor.prototype;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Son</span></span> () &#123;...&#125;</span><br><span class="line">var oSon = new Son();</span><br></pre></td></tr></table></figure>
<p>这样，共用属性都放在原型里，再共享原型（继承），但是，如果其中更改了Son的原型,这样Father的原型也随之改变（如：Son.prototype.name = ‘wang’;则Father.prototype.name也会如上）。这样的相互影响有时并不是我们想要的。</p>
<p>4、圣杯模式<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Father</span></span> () &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Son</span></span> () &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> inherit (target, origin) &#123;</span><br><span class="line">  var oFn = <span class="function"><span class="title">function</span></span> () &#123;&#125;;</span><br><span class="line">  oFn.prototype = origin.prototype;</span><br><span class="line">  target.prototype =  new oFn();</span><br><span class="line">&#125;</span><br><span class="line">inherit(Son,Father);</span><br><span class="line">var oSon = new Son();</span><br><span class="line">var oFather = new Father();</span><br><span class="line"></span><br><span class="line">Son.prototype.name = <span class="string">'wang'</span>;</span><br><span class="line">oSon.name          ----&gt;    <span class="string">'wang'</span></span><br><span class="line">oFather.name       ----&gt;    undefined</span><br></pre></td></tr></table></figure></p>
<h5 id="5、模块化开发"><a href="#5、模块化开发" class="headerlink" title="5、模块化开发"></a>5、模块化开发</h5><h6 id="1）-命名空间"><a href="#1）-命名空间" class="headerlink" title="1） 命名空间"></a>1） 命名空间</h6><ol>
<li>污染全局<br>是指你在a.js中var a = 10; 在 b.js中var a = 20; 如果你同事应用a.js和b.js，那么变量a就会冲突，究竟用a.js里的a还是b.js里的a。（不同的人开发难免会出现相同命名） </li>
<li>模块化开发<br>将一个完整的项目，分解成多个模块，不同的人开发不同的模块，最后协同整合。</li>
<li>命名空间<br>模块化开发的方式，很容易发生全局变量污染的问题，因此我们需要管理变量，可以采用命名空间的方式管理变量。</li>
</ol>
<h6 id="2）-匿名函数自执行-封闭作用域"><a href="#2）-匿名函数自执行-封闭作用域" class="headerlink" title="2） 匿名函数自执行 封闭作用域"></a>2） 匿名函数自执行 封闭作用域</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var jQuery = (<span class="function"><span class="title">function</span></span> () &#123;                     <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  <span class="comment"># AO -&gt; jQuery(功能)                             # AO -&gt; jQuery(功能)            </span></span><br><span class="line">  var slice=Array.prototype.slice;                var slice = Array.prototype.slice;</span><br><span class="line">  var toString=Object,prototype.toString;         var toString = Object,prototype.toString;</span><br><span class="line">  ...                                             ...</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">jQuery</span></span> ()&#123;...使用变量slice toString&#125;     <span class="keyword">function</span> <span class="function"><span class="title">jQuery</span></span> ()&#123;...使用变量slice toString&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">return</span> jQuery;                                   window.$ = jQuery;</span><br><span class="line">&#125;)();                                            &#125;)();</span><br><span class="line">匿名函数自执行+封闭作用域+闭包                        匿名函数自执行+封闭作用域</span><br><span class="line">使原有的AO不释放，通过<span class="built_in">return</span>赋给变量                  将jQuery赋给全局变量</span><br><span class="line">该变量有函数功能，但无法使用其中的变量                  该变量有函数功能，但无法使用其中的变量</span><br></pre></td></tr></table></figure>
<ul>
<li><p>测试：这种解决办法能有效管理变量，防止变量污染</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ctl.js                                           cst.js</span><br><span class="line">(<span class="function"><span class="title">function</span></span>()&#123;                                     (<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">  var name = <span class="string">'ctl'</span>;                                var name = <span class="string">'cst'</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">show</span></span> () &#123;                               var age = 18;</span><br><span class="line">    console.log(name,  age);                       <span class="keyword">function</span> <span class="function"><span class="title">show</span></span> () &#123;</span><br><span class="line">  &#125;                                                   console.log(name,  age);&#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="function"><span class="title">change</span></span>() &#123;                              <span class="keyword">function</span> <span class="function"><span class="title">change</span></span>() &#123;</span><br><span class="line">    name += <span class="string">'10'</span>;                                     name += <span class="string">'10'</span>;</span><br><span class="line">  &#125;                                                 &#125;</span><br><span class="line"></span><br><span class="line">  window.ctlMake = &#123;show: show, change: change&#125;;    window.cstMake = &#123;show: show, change: change&#125;;</span><br><span class="line">&#125;)();                                              &#125;)();</span><br><span class="line"></span><br><span class="line">index.html</span><br><span class="line">&lt;script src = <span class="string">'ctl.js'</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src = <span class="string">'cst.js'</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  cstMake.show();           -----&gt; <span class="string">"cst"</span></span><br><span class="line">  ctlMake.show();           -----&gt; 报错：age is not defined</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><font color="red">* 每一个功能入口就是执行自己的函数，调用自己的变量，不会相互污染。</font><br>PS：当然啦，现在的前端自动化构建工具是，就不用麻烦了。</p>
</li>
</ul>
<h6 id="3）-链式调用模式"><a href="#3）-链式调用模式" class="headerlink" title="3） 链式调用模式"></a>3） 链式调用模式</h6><p>思考问题：</p>
<ol>
<li>如何实现链式调用模式（模仿jquery）</li>
<li>obj.eat().drink().play().laugh().sleep();<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var mrDeng = &#123;</span><br><span class="line">  eat: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'eat'</span>);</span><br><span class="line">    reeturn this;</span><br><span class="line">  &#125;,</span><br><span class="line">  drink: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'drink'</span>);</span><br><span class="line">    reeturn this;</span><br><span class="line">  &#125;,</span><br><span class="line">  paly: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'paly'</span>);</span><br><span class="line">    reeturn this;</span><br><span class="line">  &#125;,</span><br><span class="line">  laugh: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'laugh'</span>);</span><br><span class="line">    reeturn this;</span><br><span class="line">  &#125;,</span><br><span class="line">  sleep: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'sleep'</span>);</span><br><span class="line">    reeturn this;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>jQuery有一个经典的使用方法：通过$()将标签选中，包装成一个对象（如$(‘div’)），这个对象中有很多方法。可以调用一些方法去操作你选中的那个标签，可.css()再。css()，链式调用<br>$(‘div’).css().css().attr().addClass();</p>
<h5 id="6、克隆"><a href="#6、克隆" class="headerlink" title="6、克隆"></a>6、克隆</h5><p>判断数据类型的四种方式：typeof toString instaceof contructor </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">浅克隆：</span><br><span class="line">function cloneFactory (copy, origin) &#123;</span><br><span class="line">  copy = copy || &#123;&#125;;</span><br><span class="line">  for (var props in origin) &#123;</span><br><span class="line">    copy[props] = origin[props];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">深克隆：</span><br><span class="line">function deepClone (copy, origin) &#123;</span><br><span class="line">  copy = copy || &#123;&#125;;</span><br><span class="line">  var arrStr = &apos;[Object Array]&apos;;</span><br><span class="line">  for (var props in origin) &#123;</span><br><span class="line">    if (origin[props] !== null &amp;&amp; (origin[props] === &apos;object&apos;) ) &#123;</span><br><span class="line">      if (Object.prototype.toString.call(origin[props]) === arrStr) &#123;</span><br><span class="line">        copy[props] = [];</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         copy[props] = &#123;&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      deepClone(copy[props], origin[props]);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      copy[props] = origin[props];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">深克隆优化版本：</span><br><span class="line">function deepCloneFactory(copy, origin) &#123;</span><br><span class="line">  copy = copy || &#123;&#125;;</span><br><span class="line">  var arr = [],obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  for (var props in origin) &#123;</span><br><span class="line">    if (origin[props] === copy[props]) &#123;</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    for (var attrs in copy) &#123;</span><br><span class="line">      if (attrs === props) &#123;</span><br><span class="line">        if (Object.prototype.toString.call(origin[props]) === &apos;[object Array]&apos;) &#123;</span><br><span class="line">          arr = copy[attrs];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          obj = copy[attrs];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (origin.hasOwnProperty(props)) &#123;</span><br><span class="line">      if (origin[props] !== null &amp;&amp; typeof origin[props] === &apos;object&apos;) &#123;</span><br><span class="line">        if (Object.prototype.toString.call(origin[props] === &apos;[object Array]&apos;)) &#123;</span><br><span class="line">          copy[props] = arr;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          copy[props] = obj;</span><br><span class="line">        &#125;</span><br><span class="line">        deepCloneFactory(copy[props], origin[props]);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        copy[props] = origin[props];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JSON.parse(JSON.stringify())</p>
<h4 id="3-3）数组"><a href="#3-3）数组" class="headerlink" title="3.3）数组"></a>3.3）数组</h4><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>1、创建方式<br>  1）new Array(length/content)<br>  2）字面量</p>
<p>2、数组的读和写<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr[num]               <span class="comment"># 不可溢出读</span></span><br><span class="line">arr[num] = xxx;        <span class="comment"># 可溢出读</span></span><br></pre></td></tr></table></figure></p>
<p>3、数组的常用方法</p>
<ol>
<li><p>改变原数组<br>push     尾部加值，改变原数组，返回数组长度<br>pop      尾部弹指，改变原数组，返回被弹出的值<br>shift    首部弹值，改变原数组，返回被弹出的值<br>unshift  首部加值，改变原数组，返回数组长度<br>splice   在数组任意位加或删，返回截取的数组<br>reverse  倒序<br>sort     只能排单位数字，可</p>
<pre><code>arr.sort(function(a,b) {
  return a-b;
})
</code></pre><p><font color="red">* 让有序数组输出乱序：</font> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3,4,5,6,7,8,9];</span><br><span class="line">console.log(arr.sort(() =&gt; Math.random()-0.5));</span><br></pre></td></tr></table></figure>
</li>
<li><p>不改变原数组<br>concat    返回连接后的数组，不改变原数组<br>join -&gt; split<br>toString<br>slice</p>
<p><font color="orange">forEach</font>  只是简单的将数组遍历，类似于军人接受检阅，但是检阅结束并不会返回任何东西，也不会改变原数组,forEach的返回永远是undefind<br><font color="orange">map</font>      可以比喻成去超市买东西，你拿了一个物品清单，然后服务员帮你拿好东西，返回给你一个物品的新数组，但是对清单原数组不发生改变<br><font color="orange">filter</font>   就是让男生排队身高高于180的就归入到新数组中，最后返回一个里面装着所有180+的男生的数组，不改变原数组<br><font color="orange">reduce</font>    主要是为了对所有数组进行累加，最后返回一个值，不改变原数组，类似让男生把排队把把身高加起来<br><font color="orange">find</font>     就是你去找人想找一个180的男生帮你去搬砖，只要找到第一个就停止遍历，因为只要找一个，为了减少无用的操作，虽然其他方法也能实现同样的要过，但是最好用find()</p>
</li>
</ol>
<h5 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h5><ol>
<li>可以利用属性名模拟数组的特性</li>
<li>可以动态的增长length属性</li>
<li>如果强行让类数组调用push方法，则会根据length属性值的位置进行属性的扩充</li>
</ol>
<ul>
<li>要有索引（数字）属性，必须有length属性，最好加上push可以向数组一样用。如果再加上splice，控制台输出和数组一样。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1. 问题1:</span><br><span class="line">  var obj = &#123;</span><br><span class="line">    2: &apos;a&apos;,</span><br><span class="line">    3: &apos;b&apos;,</span><br><span class="line">    length: 2,</span><br><span class="line">    push: Array.prototype.push</span><br><span class="line">  &#125;;</span><br><span class="line">  obj.push(&apos;c&apos;);</span><br><span class="line">  obj.push(&apos;d&apos;);</span><br><span class="line">  console.log(obj);  ---&gt; &#123;2: &quot;c&quot;, 3: &quot;d&quot;, length: 4, push: ƒ&#125;</span><br><span class="line"></span><br><span class="line">2. 问题2：编写方法对所有数据类型都能判断准确。</span><br><span class="line">  function myType (myVar) &#123;</span><br><span class="line">    var cache = &#123;</span><br><span class="line">      &apos;[object Number]&apos;: &apos;number-object&apos;,</span><br><span class="line">      &apos;[object String]&apos;: &apos;string-object&apos;,</span><br><span class="line">      &apos;[object Boolean]&apos;: &apos;bool-object&apos;,</span><br><span class="line">      &apos;[object Array]&apos;: &apos;array&apos;,</span><br><span class="line">      &apos;[object Object]&apos;: &apos;object&apos;,</span><br><span class="line">    &#125;;</span><br><span class="line">    if (myVar === null) &#123;</span><br><span class="line">      return &apos;null&apos;;</span><br><span class="line">    &#125; else if (typeof myVar === &apos;object&apos;) &#123;</span><br><span class="line">      return cache[Object.prototype.toString.call(myVar)];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return typeof myVar;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></p>
<h2 id="第三节、DOM"><a href="#第三节、DOM" class="headerlink" title="第三节、DOM"></a><font color="#FF69B4">第三节、DOM</font></h2><ul>
<li>什么是DOM？</li>
</ul>
<ol>
<li>DOM  –&gt; Document Object Model</li>
<li>DOM定义了表达和修改文档所需对象，定义了这些对象之间的行为和属性以及这些对象之间的关系。<br>DOM对象即为宿主对象，由浏览器厂商定义，用来操作html和css功能的一类对象的集合。<br>也有人称DOM是对HTML以及XML的标准编程接口。</li>
</ol>
<ul>
<li>为什么要有DOM？<br>js不能直接操作html标签，但是浏览器提供了一类对象，可以作为js操作html的桥梁。</li>
</ul>
<h3 id="一、基本操作"><a href="#一、基本操作" class="headerlink" title="一、基本操作"></a>一、基本操作</h3><h4 id="1-1）DOM节点"><a href="#1-1）DOM节点" class="headerlink" title="1.1）DOM节点"></a>1.1）DOM节点</h4><h5 id="对节点的查"><a href="#对节点的查" class="headerlink" title="对节点的查"></a>对节点的查</h5><h6 id="一、查看元素节点"><a href="#一、查看元素节点" class="headerlink" title="一、查看元素节点"></a>一、查看元素节点</h6><p>  document代表整个文档</p>
<p>  document.getElementById(); 元素id在ie8以下的浏览器，不取区分id大小写，而且也返回匹配name属性的元素。<br>  document.getElementsByClassName(); ie8及以下的ie版本中没有，可以多个class一起。<br>  document.getElementsByTagName();<br>  document.getElementsByName(); 需注意，只有部分标签name可生效（表单、表单元素、img、iframe）。<br>  querySelector(); css选择器，在ie7及以下的版本中没有。<br>  querySelectorAll(); css选择器，在ie7及以下的版本中没有。</p>
  <div class="post-warning">注：querySelector和querySelectorAll选出的元素不是实时的，是一个副本，一个快照。其他方法选出的dom都是实时的。<br>    1）querySelector()只返回一个<br>    2）querySelectorAll()返回所有但不更新<br>    3）其他返回所有并更新<br>  </div>

<h6 id="二、遍历节点树"><a href="#二、遍历节点树" class="headerlink" title="二、遍历节点树"></a>二、遍历节点树</h6><p>  parentNode 父节点（最顶端的parentNode是#document）<br>  childNodes 子节点们<br>  firstChild 第一个子节点<br>  lastChild  最后一个子节点<br>  nextSibling 后一个兄弟节点<br>  previousSibling 前一个兄弟节点</p>
<p>  节点类型：<br>  元素节点  – 1<br>  属性节点  – 2<br>  文本节点  – 3<br>  注释节点  – 8<br>  document – 9<br>  DocumentFragment – 11</p>
<p>  获取节点类型 nodeType</p>
<h6 id="三、基于元素节点树的遍历"><a href="#三、基于元素节点树的遍历" class="headerlink" title="三、基于元素节点树的遍历"></a>三、基于元素节点树的遍历</h6><p>  parentElement 返回当前元素的父节点<br>  children 只返回当前元素的元素子节点<br>  node.childElementCount === node.children.length 单签蒜素节点的子元素节点个数（IE不兼容）<br>  firstElementChild 返回第一个元素节点（IE不兼容）<br>  lastElementChild 返回最后一个元素节点（IE不兼容）<br>  nextElementSibling / previousElementSibling 返回后一个/前一个兄弟元素节点（IE不兼容）</p>
<h6 id="四、节点的属性和方法"><a href="#四、节点的属性和方法" class="headerlink" title="四、节点的属性和方法"></a>四、节点的属性和方法</h6><blockquote>
<p>属性：<br>  nodeName 元素的标签名，以大写形式表示，只读<br>  nodeValue Text节点或comment节点的文本内容，可读写<br>  nodeType 该节点的类型，只读<br>  style css属性，可读写<br>  attribute Element节点的属性集合(只有元素节点才有attribute，它是整个dom节点的属性集合，是一个类数组)</p>
</blockquote>
<blockquote>
<p>方法：<br>  Node.hasChildNodes();<br>  Node.setAttribute(‘attri-xxx’,’value-xxx’);<br>  Node.getAttribute(‘attri-xxx’);</p>
</blockquote>
<h5 id="对节点的增删改"><a href="#对节点的增删改" class="headerlink" title="对节点的增删改"></a>对节点的增删改</h5><blockquote>
<p>增<br>  document.createElement();<br>  document.createTextNode();<br>  document.creeateComment();<br>  document.createDocumentFragment();</p>
</blockquote>
<blockquote>
<p>插<br>  PARENTNODE.appendChild();<br>  PARENTNODE.insertBefore(a,b);</p>
</blockquote>
<blockquote>
<p>删<br>  parent.removeChild();</p>
</blockquote>
<blockquote>
<p>替换<br>  parent.replaceChild();</p>
</blockquote>
<h4 id="1-2-DOM树"><a href="#1-2-DOM树" class="headerlink" title="1.2) DOM树"></a>1.2) DOM树</h4>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DOM树：</span><br><span class="line"></span><br><span class="line">       - Document - HTMLDocument       - HTMLHeadElement </span><br><span class="line">      |                  - Text       |- HTMLBodyElement</span><br><span class="line">      |- CharactorData -|             |- HTMLTitleElement</span><br><span class="line">Node -|                  - Comment    |- HTMLParagraphElement</span><br><span class="line">      |- Element - HTMLElement ------ |- HTMLInputElement</span><br><span class="line">      |                                - ... etc</span><br><span class="line">       - Attr</span><br></pre></td></tr></table></figure>
<p>  Document是一个构造函数，但是用户不能new Document()创建新对象。<br>  document - HTMLDocument - Document:<br>  document是HTMLDocument构造函数的实例，原型是HTMLDocument.prototype。<br>  HTMLDocument.prototype也是对象，原型是Document.prototype。<br>  HTMLDocument.prototype.__proto__ -&gt; Document.prototype 构成原型链。</p>
  <div class="post-warning">观察DOM结构树，很容易发现，若在共有原型上加属性和方法，那么下面的构造函数的对象都可用。</div>

<blockquote>
</blockquote>
<pre><code>getElementById() 定义在Document.prototype上，即Element节点上不能使用。

getElementsByName() 定义在HTMLDocument.prototype上，即非html中的document意外不能使用（xml document Element）

getElementsByTagName() 定义在Document.prototype和Element.prototype上

Document.prototype上定义了documentElement属性，指代文档的根元素，在HTML文档中，他总是指代&lt; html&gt;&lt;\/html&gt;元素（只读不可写）。

HTMLDocument.prototype定义了一些常用的属性，body、head分别指代HTML文档中的&lt; body&gt;&lt;\/body&gt;&lt; head&gt;&lt;\/head&gt;标签。

getElementsByClassName()、querySelectorAll()、querySelectorAll、querySelector在Document，Element类中均有定义。
</code></pre><ul>
<li><p>节点的一些属性和方法<br>innerHTML<br>innerText(旧版本火狐不兼容)/textContent(老版本IE不兼容，主流浏览器一般用的都是innerText)</p>
<p>ele.setAttribute();<br>ele.getAttribute();</p>
</li>
</ul>
<h4 id="1-3-DOM基本操作"><a href="#1-3-DOM基本操作" class="headerlink" title="1.3) DOM基本操作"></a>1.3) DOM基本操作</h4><h5 id="日期对象"><a href="#日期对象" class="headerlink" title="日期对象"></a>日期对象</h5><blockquote>
<p>Date<br>var oDate = new Date();</p>
<p>// 获取<br>oDate.toString();<br>oDate.getFullYear(); 年<br>oDate.getMonth(); 月<br>oDate.getDate(); 日期<br>oDate.getDay(); 天数<br>oDate.getHours(); 时<br>oDate.getMinutes(); 分<br>oDate.getSeconds(); 秒<br>oDate.getMilliseconds(); 毫秒<br>oDate.getTime(); 自1970年1月1日至今的毫秒数</p>
<p>// 设置<br>oDate.setFullYear(); 年<br>oDate.setMonth(); 月<br>oDate.setDate(); 日期<br>oDate.setDay(); 天数<br>oDate.setHours(); 时<br>oDate.setMinutes(); 分<br>oDate.setSeconds(); 秒<br>oDate.setMilliseconds(); 毫秒<br>oDate.setTime(); 自1970年1月1日至今的毫秒数</p>
</blockquote>
<h5 id="js定时器"><a href="#js定时器" class="headerlink" title="js定时器"></a>js定时器</h5><p>  setInterval();<br>  setTimeout();<br>  clearInterval();<br>  clearTimeout();</p>
<p>  全局对象window上的方法，内部函数this指向window。</p>
<h5 id="查看滚动条的滚动距离"><a href="#查看滚动条的滚动距离" class="headerlink" title="查看滚动条的滚动距离"></a>查看滚动条的滚动距离</h5><p>  window.pageXOffset、window.pageXOffset (IE及IE8以下不兼容)<br>  document.body.scrollLeft、document.body.scrollTop (兼容性比较混乱)<br>  document.documentElement.scrollLeft、 document.documentElement.scrollTop (兼容性比较混乱)</p>
<h5 id="查看视口尺寸"><a href="#查看视口尺寸" class="headerlink" title="查看视口尺寸"></a>查看视口尺寸</h5><p>  window.innerWidth、window.innerHeight (IE及IE8以下不兼容)<br>  document.documentElement.clientWidth、document.documentElement.clientHeight (标准模式下，任意浏览器都兼容)<br>  document.body.clientWidth、 document.body.clientHeight (客户可视窗口，适用于怪异模式下的浏览器)</p>
<h5 id="查看元素的几何尺寸"><a href="#查看元素的几何尺寸" class="headerlink" title="查看元素的几何尺寸"></a>查看元素的几何尺寸</h5><p>  domEle.getBoundingClientRect(); </p>
<blockquote>
<p>兼容性好，该方法返回一个对象，对象里面有left、top、right、bottom等属性。left和top代表钙元素左上角的x和y坐标，right和bottom代表元素右下角的x，y坐标</p>
</blockquote>
<h5 id="查看元素尺寸"><a href="#查看元素尺寸" class="headerlink" title="查看元素尺寸"></a>查看元素尺寸</h5><p>  domEle.offsetWidth、domEle.offsetHeight</p>
<h5 id="查看元素位置"><a href="#查看元素位置" class="headerlink" title="查看元素位置"></a>查看元素位置</h5><p>  domEle.offsetLeft、 domEle.offsetTop</p>
<blockquote>
<p>对于无定位父级的元素，返回相对于文档的坐标。对于有定位的父级的元素，返回相对于最近的有定位的父级的坐标（无论是left还是margin-left等都是距离）。</p>
</blockquote>
<p>  domEle.offsetParent<br>  返回最近的有定位的父级，若无，返回body。body.offsetParent，返回null。</p>
<h5 id="让滚动条滚动"><a href="#让滚动条滚动" class="headerlink" title="让滚动条滚动"></a>让滚动条滚动</h5><p>  window上有三个方法：scroll() scrollTo() scrollBy()</p>
<h4 id="1-4）脚本化css"><a href="#1-4）脚本化css" class="headerlink" title="1.4）脚本化css"></a>1.4）脚本化css</h4><h5 id="读写元素css属性"><a href="#读写元素css属性" class="headerlink" title="读写元素css属性"></a>读写元素css属性</h5><p>  dom.style.prop 可读写样式，没有兼容性问题，碰到float这样的关键字属性，前面应加css。eg: float -&gt; cssFloat。<br>  复合属性必须拆解，组合单词变成小驼峰式写法。<br>  写入的值必须是字符串格式。</p>
<h5 id="查询计算样式"><a href="#查询计算样式" class="headerlink" title="查询计算样式"></a>查询计算样式</h5><p>  window.getComputedStyle(ele, null); 计算样式只读，返回的计算样式的值是绝对值，没有相对单位。（IE8及以下不兼容）</p>
<h5 id="查询样式"><a href="#查询样式" class="headerlink" title="查询样式"></a>查询样式</h5><p>  ele.currentStyle(了解就可以，现在都不用了，现在使用chrome会报错)</p>
<p><br><br><br><br><br><br><br></p>
<h3 id="二、事件"><a href="#二、事件" class="headerlink" title="二、事件"></a>二、事件</h3><h4 id="绑定事件处理函数"><a href="#绑定事件处理函数" class="headerlink" title="绑定事件处理函数"></a>绑定事件处理函数</h4><ul>
<li><p>ele.onxx = function (event) {};<br>兼容性好，基本等同于句柄。<br>但是一个元素的同一事件只能绑定一个处理程序。</p>
</li>
<li><p>ele.addEventListener(type, fn ,false);<br>IE9以下不兼容。<br>true：事件句柄在捕获阶段执行，false：事件句柄在冒泡阶段执行<br>一个元素的同一事件可以绑定多个处理程序，但是不能多次绑定同一处理程序。</p>
</li>
<li><p>ele.attacEvent(‘onxxx’, fn);<br>IE独有。<br>一个元素的同一事件可以绑定多个处理程序，但是不能多次绑定同一处理程序。</p>
</li>
</ul>
<blockquote>
<p>事件处理程序的运行环境（this）<br>  1、ele.onxx this指向dom元素本身<br>  2、ele.addEventListener this指向dom元素本身<br>  3、ele.attacEvent this指向window</p>
</blockquote>
<h4 id="解除事件处理函数"><a href="#解除事件处理函数" class="headerlink" title="解除事件处理函数"></a>解除事件处理函数</h4><p>  ele.onxxx = false / ‘’ / null;<br>  ele.removeEventListener(type, fn, false);<br>  ele.detachEvent(‘onxxx’, fn);</p>
  <div class="post-warning">注：若绑定匿名函数，则无法解除。</div>

<h4 id="事件冒泡-amp-捕获-gt-事件处理模型"><a href="#事件冒泡-amp-捕获-gt-事件处理模型" class="headerlink" title="事件冒泡&amp;捕获 -&gt; 事件处理模型"></a>事件冒泡&amp;捕获 -&gt; 事件处理模型</h4><ul>
<li><p>事件冒泡<br>结构上（非视觉上）嵌套关系的元素，会存在事件冒泡的功能，即同一事件，自子元素冒泡到父元素（自底向上）。</p>
</li>
<li><p>事件捕获<br>结构上（非视觉上）嵌套关系的元素，会存在事件捕获的功能，即同一事件，自父元素捕获至子元素（事件源元素）（自顶向下）。</p>
<p>触发顺序：先捕获后冒泡。<br>focus、blur、change、submit、reset、select等时间不冒泡。<br>IE没有捕获事件，就Chrome实现了捕获。</p>
</li>
</ul>
<p><br></p>
<ul>
<li><p>取消冒泡<br>W3C标准event.stopPropagation(); 但不支持IE9以下版本<br>IE独有event.cancelBubble = true;</p>
</li>
<li><p>阻止默认事件<br>默认事件 - 表单提交， a标签跳转， 右键菜单等<br>return false; 以对象属性的方式注册的事件才生效<br>event.preventDefault(); W3C标准，IE9以下不兼容<br>event.returnValue = false; 兼容IE</p>
<div class="post-warning">例如，我们来阻止【右键出菜单】这一默认事件：<br>  1、return false;是句柄方式阻止默认事件，只有用句柄的方式绑定事件，这种方式才好使。如以addEventListener注册的时间就不好使。<br>    document.oncontextmenu = function () { return false; }<br><br>  2、document.oncontextmenu = function (e) { e.preventDefault(); }<br><br>  3、document.oncontextmenu = function (e) { e.returnValue = false; }<br></div>



</li>
</ul>
<h4 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h4><ul>
<li>event || window.event（用于IE）</li>
<li>事件源对象：<strong>event.target</strong> 火狐只有这个、chrome两个都有<br><strong>event.srcElement</strong> IE只有这个，chrome两个都有</li>
</ul>
<h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><p>  利用事件冒泡和事件源对象进行处理<br>  优点：不需要循环所有的元素，一个一个绑定事件。当有新的子元素时不需要重新绑定事件。</p>
<h4 id="事件分类"><a href="#事件分类" class="headerlink" title="事件分类"></a>事件分类</h4><ul>
<li><strong>鼠标事件</strong><blockquote>
<p>click  mousedown  mousemove  mouseup  contextmenu<br>mouseover  mouseout  mouseenter mouseleave</p>
<ol>
<li>先 mousedown， 再mouseup， 最后click</li>
<li>鼠标移入: mouseover  mouseenter(es5新出的)<br>鼠标移出: mouseout   mouseleave(es5新出的)</li>
</ol>
<div class="post-warning">移动端，mousedown和mouseup就不好用了，而是用touchstart、touchmove、touchend</div>
</blockquote>
</li>
</ul>
<p><br></p>
<ul>
<li><p><strong>键盘事件</strong></p>
<blockquote>
<p>keydown   keypress   keyup </p>
<ol>
<li>先 keydown， 再keypress， 最后keyup</li>
<li>keydown和keypress的区别：keydown可以响应任意键盘按键，keypress只可以响应字符类键盘按键。</li>
</ol>
<div class="post-warning">1. keydown可以监听处理Fn辅助键之外的所有键（which：监测108个键子），keypress只能监听字符按键。<br><br>  2. 但是keydown记录不了字符类按键，不准。<br>     如果想监听字符类按键并区分大小写，用keypress，<br>     如果监听操作类按键，只用keydown。<br><br>  3. 二者各有优缺。keypress能识别键盘上的每一个键子，但是返回的数字我们不知道对应的哪个键子，得测。而且它只能测每个键子，如：shift+a-&gt;A,他就测不准，出现的是shift和A，这样说来，keypress更准确，keydown更广泛。<br></div>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.onkeypress = function (e) &#123;</span><br><span class="line">  console.log(e.key, String.fromCharCode(e.charCode));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br></p>
<ul>
<li><p><strong>文本操作事件</strong><br>input、 focus、 blur、 change</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> id=<span class="string">'inp'</span> /&gt;</span><br><span class="line"></span><br><span class="line">const oInp = document.getElementById(<span class="string">'inp'</span>);</span><br><span class="line">oInp.oninput = <span class="keyword">function</span> (e) &#123;</span><br><span class="line">  console.log(e.data, e.target.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>窗体操作事件</strong><br>scroll load</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.onscroll = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  console.log(window.pageXOffset + <span class="string">" "</span> +window.pageYOffset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">window.onload = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">  var oDiv = document.getElementsByTagName(<span class="string">'div'</span>)[0];</span><br><span class="line">  oDiv.style.width = <span class="string">'100px'</span>;</span><br><span class="line">  oDiv.style.height = <span class="string">'100px'</span>;</span><br><span class="line">  oDiv.style.backgroundColor = <span class="string">'orange'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样完全好使，但是为什么我们都不这样使用。因为无意义，速度慢。整个文档解析后，renderTree构建完成后，DOM所有文档图片信息下载完成后，整个页面完成后才能出发window.onload事件。</p>
<p>当然也有用处，用load我们知道什么时候页面加载完成，我们可以把“广告”之类的功能放在load中，页面加载完再显示广告，但绝不能把主程序放在load里。</p>
<p>js有DOMTree + css有CSSTree -&gt; 渲染树 renderTree</p>
</li>
</ul>
<p><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></p>
<h2 id="第四节、BOM"><a href="#第四节、BOM" class="headerlink" title="第四节、BOM"></a><font color="#FF69B4">第四节、BOM</font></h2><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><ol>
<li>定义：Browser Object Model（浏览器对象模型）</li>
<li>BOM对象：window、history、Nacigator、screen、location等</li>
</ol>
<div class="post-warning">注：由于浏览器厂商不同，BOM对象的兼容性极低，故我们一般只用其中的部分功能。</div>

<h3 id="二、BOM对象"><a href="#二、BOM对象" class="headerlink" title="二、BOM对象"></a>二、BOM对象</h3><h4 id="1-window对象"><a href="#1-window对象" class="headerlink" title="1. window对象"></a><font color="DodgerBlue">1. window对象</font></h4><blockquote>
<p>window对象代表浏览器中打开的窗口。 如果文档中包含框架（frame或iframe标签），浏览器会为文档创建一个window对象，并为每个框架创建一个额外的window对象。<br>注：没有应用于window对象的公开标准，不过所有浏览器都支持该对象。</p>
</blockquote>
<blockquote>
<p>window对象集合：frames[]<br>返回窗口中所有命名的框架，该集合是window对象的数组，每个window对象若窗口中含有一个框架或iframe或属性frames。length存放数组frames[]中含有的元素个数。<br>注：frames[]数组中引用的框架可能还包含框架，它们自己也具有frames[]数组</p>
</blockquote>
<h5 id="window对象的属性"><a href="#window对象的属性" class="headerlink" title="window对象的属性"></a>window对象的属性</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">closed          返回窗口是否已被关闭</span><br><span class="line">defaultStatus   设置或返回窗口状态栏中的默认文本</span><br><span class="line">document        对Document对象的只读引用，请参阅Document对象</span><br><span class="line"><span class="built_in">history</span>         对History对象的只读引用，请参阅History对象</span><br><span class="line">location        用于窗口或框架的Location对象，请参阅Location对象</span><br><span class="line">Navigator       对Navigator对象的只读引用，请参阅Navigator对象</span><br><span class="line">Screen          对Screen对象的只读引用，请参阅Screen对象</span><br><span class="line">innerheight     返回窗口文档显示区的高度</span><br><span class="line">innerwidth      返回窗口文档显示区的宽度</span><br><span class="line">length          设置或返回窗口中的框架数量</span><br><span class="line">name            设置或返回窗口的名称</span><br><span class="line">opener          返回对创建此窗口的窗口引用</span><br><span class="line">outerheight     返回窗口的外部高度（IE不支持）</span><br><span class="line">outerwidth      返回窗口的外部宽度（IE不支持）</span><br><span class="line">pageXOffset     设置或返回当前页面相对于窗口显示区左上角的x位置</span><br><span class="line">pageYOffset     设置或返回当前页面相对于窗口显示区左上角的y位置</span><br><span class="line">parent          返回父窗口</span><br><span class="line">window          window属性等价于self属性，它包含了对窗口自身的引用</span><br><span class="line">self            返回当前窗口的引用，等价于window属性</span><br><span class="line">status          设置窗口状态栏的文本</span><br><span class="line">top             返回最顶层的先辈窗口</span><br><span class="line">screenLeft      只读整数，声明了窗口的左上角在屏幕上的x坐标和y坐标</span><br><span class="line">screenTop       IE、Safari和Opera支持screenLeft和screenTop</span><br><span class="line">screenX         只读整数，声明了窗口的左上角在屏幕上的x坐标和y坐标</span><br><span class="line">screenY         FireFox和Safari支持screenX和screenY</span><br></pre></td></tr></table></figure>
<h5 id="window对象的方法"><a href="#window对象的方法" class="headerlink" title="window对象的方法"></a>window对象的方法</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">alert()          显示带有一段消息和一个确认按钮的警告框</span><br><span class="line">confirm()        显示带有一段消息以及确认按钮和去取消按钮的对话框</span><br><span class="line">createPopup()    创建一个pop-up窗口</span><br><span class="line"><span class="built_in">print</span>()          打印当前窗口的内容</span><br><span class="line">prompt()         显示可提示用户输入的对话框</span><br><span class="line">blur()           可把键盘焦点从顶层浏览器窗口移走</span><br><span class="line">focus()          把键盘焦点给予一个窗口</span><br><span class="line">setInterval()    按照指定的周期（以毫秒计算）来调用函数或计算表达式</span><br><span class="line">setTimeout()     在指定的好描述后调用函数或计算表达式</span><br><span class="line">clearInterval()  取消由setInterval()设置的interval</span><br><span class="line">clearTimeout()   取消由setTimeout()设置的timeout</span><br><span class="line">open()           打开一个新浏览器窗口</span><br><span class="line">close()          关闭浏览器窗口</span><br><span class="line">scrollBy()       按照指定的像素值来滚动内容</span><br><span class="line">scrollTo()       把内容滚动到指定的坐标</span><br><span class="line">moveBy()         可相对窗口的当前坐标吧它移动到一个指定的像素</span><br><span class="line">moveTo()         把窗口的左上角移动到指定位置</span><br><span class="line">resizeBy()       按照指定的像素调整窗口的大小</span><br><span class="line">resizeTo()       把窗口的大小调整到指定的宽度和高度</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="2-Navigator对象"><a href="#2-Navigator对象" class="headerlink" title="2. Navigator对象"></a><font color="DodgerBlue">2. Navigator对象</font></h4><blockquote>
<p>Navigator对象包含有关浏览器的信息。</p>
</blockquote>
<font color="blue">没有应用于Navigator对象的公开标准，不过所有浏览器都支持此对象</font>

<h5 id="Navigator对象集合：plugins"><a href="#Navigator对象集合：plugins" class="headerlink" title="Navigator对象集合：plugins[]"></a>Navigator对象集合：plugins[]</h5><p>返回对文档中所有嵌入式对象的引用该集合是一个Plugin对象的数组。其中的元素代表浏览器已经安装的插件，Plugin对象提供的是有关插件的信息。其中包括它所支持的MIME类型的列表。虽然plugins数组是由IE4定义的，但是在IE4中它却总是空的，因为IE4不支持插件和Plugin对象。</p>
<h5 id="Navigator对象属性"><a href="#Navigator对象属性" class="headerlink" title="Navigator对象属性"></a>Navigator对象属性</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">appCodeName       返回浏览器的代码名</span><br><span class="line">appMinorVersion   返回浏览器的次级版本</span><br><span class="line">appName           返回浏览器名称</span><br><span class="line">appVersion        返回浏览器的平台和版本信息</span><br><span class="line">browserLanguage   返回当前浏览器的语言</span><br><span class="line">cookieEnabled     返回指明浏览器中是否启用cookie的布尔值</span><br><span class="line">cpuClass          返回浏览器系统的CPU等级</span><br><span class="line">onLine            返回指明系统是否处于脱机模式的布尔值</span><br><span class="line">platform          返回运行浏览器的操作系统平台</span><br><span class="line">systemLanguage    返回OS使用的默认语言</span><br><span class="line">userLanguage      返回由客户机发送服务器的user-agent头部的值</span><br></pre></td></tr></table></figure>
<h5 id="Navigator对象方法"><a href="#Navigator对象方法" class="headerlink" title="Navigator对象方法"></a>Navigator对象方法</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javaEnabled()     规定浏览器是否启用java</span><br><span class="line">taintEnabled()    规定浏览器是否启用数据污点(data tainting)</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="3-Screen对象"><a href="#3-Screen对象" class="headerlink" title="3.Screen对象"></a><font color="DodgerBlue">3.Screen对象</font></h4><blockquote>
<p>Screen对象包含有瓜客户端显示屏幕的信息。</p>
</blockquote>
<p><br></p>
<h4 id="4-History对象"><a href="#4-History对象" class="headerlink" title="4. History对象"></a><font color="DodgerBlue">4. History对象</font></h4><blockquote>
<p>History对象包含用户（在浏览器窗口中）访问过的URL，是window对象的一部分。可通过window.history属性进行访问。<br>  <font color="blue">注：没有应用于History对象的公开标准，不过所有浏览器都支持它。</font></p>
</blockquote>
<h5 id="History对象属性"><a href="#History对象属性" class="headerlink" title="History对象属性"></a>History对象属性</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">length 返回浏览器历史列表中的数量</span><br></pre></td></tr></table></figure>
<h5 id="History对象方法"><a href="#History对象方法" class="headerlink" title="History对象方法"></a>History对象方法</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">back()     加载<span class="built_in">history</span>列表中的前一个URL</span><br><span class="line">forward()  加载<span class="built_in">history</span>列表中的下一个URL</span><br><span class="line">go()       加载<span class="built_in">history</span>列表中的某个具体页面</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="5-Location对象"><a href="#5-Location对象" class="headerlink" title="5. Location对象"></a><font color="DodgerBlue">5. Location对象</font></h4><blockquote>
<p>Location对象包含有关当前URL的信息，是window对象的一部分，可通过window.location属性来访问</p>
</blockquote>
<h5 id="Location对象属性"><a href="#Location对象属性" class="headerlink" title="Location对象属性"></a>Location对象属性</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hash</span>       设置或返回从<span class="comment">#号（#）开始的URL（锚）</span></span><br><span class="line">host       设置或返回主机名和当前URL的端口号</span><br><span class="line">hostname   设置或返回当前URL的主机名</span><br><span class="line">href       设置或返回完整的URL</span><br><span class="line">pathname   设置或返回当前URL的路径部分</span><br><span class="line">port       设置或返回当前URL的端口号</span><br><span class="line">protocol   设置或返回当前URL的协议</span><br><span class="line">search     设置或返回从问号（?）开始的URL（查询部分）</span><br></pre></td></tr></table></figure>
<h5 id="Location对象方法"><a href="#Location对象方法" class="headerlink" title="Location对象方法"></a>Location对象方法</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">assign()    加载新的文档</span><br><span class="line">reload()    重新加载当前文档</span><br><span class="line">replace()   用新的文档替换当前文档</span><br></pre></td></tr></table></figure>
<p><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></p>
<h2 id="第五节、零散知识点"><a href="#第五节、零散知识点" class="headerlink" title="第五节、零散知识点"></a><font color="red" size="5">第五节、零散知识点</font></h2><h3 id="1-正则表达式-RegExp（Regular-Expression）"><a href="#1-正则表达式-RegExp（Regular-Expression）" class="headerlink" title="1.正则表达式 RegExp（Regular Expression）"></a><font color="DodgerBlue">1.正则表达式 RegExp（Regular Expression）</font></h3><blockquote>
<p>正则表达式是匹配特殊字符或有特殊搭配原则的字符的最佳选择。</p>
</blockquote>
<h4 id="一、创建方式"><a href="#一、创建方式" class="headerlink" title="一、创建方式"></a>一、创建方式</h4><ol>
<li>直接量 (个人推荐直接量)<br>如：var reg = /^\d | \d$/igm;</li>
<li><p>new RegExp();<br>如：var reg = new RegExp(‘/^\\d | \\d$/‘);</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">注：① js字符串不许出现回车符号，但是“\\”代表转义字符。</span><br><span class="line">      如：var a = <span class="string">"aaa\</span></span><br><span class="line"><span class="string">                  bbb"</span>;</span><br><span class="line">      这样就不会报错了。</span><br><span class="line">     ②“\”代表转义字符，“\\\”代表\。“\\n”代表换行</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="二、基础语法-1"><a href="#二、基础语法-1" class="headerlink" title="二、基础语法"></a>二、基础语法</h4><blockquote>
<p>RegExp对象标识正则表达式，是对字符转执行 <strong>模式匹配</strong> 的强大工具。</p>
</blockquote>
<h5 id="1-compile-编译正则表达式"><a href="#1-compile-编译正则表达式" class="headerlink" title="1. compile  编译正则表达式"></a>1. compile  编译正则表达式</h5>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exec     检索字符串中指定的值，返回找到的值，并确定其位置</span><br><span class="line">test     检索字符串中指定的值，返回true或false， 例：reg.test(str)</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i        代表不区分大小写（执行对大小写不敏感的匹配） 例：/[abc]/i</span><br><span class="line">g        代表全局匹配(查找所有匹配，而非找到第一个匹配后停止)</span><br><span class="line">m        多行匹配</span><br></pre></td></tr></table></figure>
<h5 id="2-支持正则表达式的String对象的方法"><a href="#2-支持正则表达式的String对象的方法" class="headerlink" title="2. 支持正则表达式的String对象的方法"></a>2. 支持正则表达式的String对象的方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">search    检索与正则表达式相匹配的值</span><br><span class="line">match     找到一个或多个正则表达式的匹配 &lt;font color=&quot;red&quot;&gt;例：str.match(reg)&lt;/font&gt;</span><br><span class="line">replace   替换与正则表达式匹配的子串</span><br><span class="line">split     把字符串分割为字符串数组</span><br></pre></td></tr></table></figure>
<h5 id="3-查找某法范围内的字符"><a href="#3-查找某法范围内的字符" class="headerlink" title="3.  [] 查找某法范围内的字符"></a>3.  <strong>[]</strong> 查找某法范围内的字符</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[abc]     查找方括号之间的任何字符</span><br><span class="line">[^abc]    查找任何不在方括号之间的字符</span><br><span class="line">[0-9]     查找任何从0到9之间的数字</span><br><span class="line">[a-z]     查找任何从小写a到小写z之间的字符</span><br><span class="line">[A-Z]     查找任何从大写A到大写Z之间的字符</span><br><span class="line">[A-z]     查找任何从大写A到小写z之间的字符</span><br><span class="line">[adj]     查找给定集合内的任何字符</span><br><span class="line">[^dss]    查找给定集合外的任何字符</span><br><span class="line">(red|green|blue) 查找任何指定的选项</span><br></pre></td></tr></table></figure>
<h5 id="4-元字符-（Metacharacter）是有特殊含义的字符，简化操作。"><a href="#4-元字符-（Metacharacter）是有特殊含义的字符，简化操作。" class="headerlink" title="4. 元字符 （Metacharacter）是有特殊含义的字符，简化操作。"></a>4. <strong>元字符</strong> （Metacharacter）是有特殊含义的字符，简化操作。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.         查找单个字符，除了换行和行结束符</span><br><span class="line">\w        查找单词字符</span><br><span class="line">\W        查找非单词字符</span><br><span class="line">\d        查找数字字符</span><br><span class="line">\D        查找非数字字符</span><br><span class="line">\s        查找空白字符</span><br><span class="line">\S        查号非空白字符</span><br><span class="line">\b        查找单词边界</span><br><span class="line">\B        查找非单词边界</span><br><span class="line">\O        查找NUL字符</span><br><span class="line">\n        查找换行符</span><br><span class="line">\f        查找换页符</span><br><span class="line">\r        查找回车符</span><br><span class="line">\t        查找制表符</span><br><span class="line">\v        查找垂直制表符</span><br><span class="line">\xxx      查找以八进制数xxx规定的字符</span><br><span class="line">\xdd      查找以十六进制数dd规定的字符</span><br><span class="line">\uxxx     查找以十六极致xxxx规定的Unicode字符</span><br></pre></td></tr></table></figure>
<h5 id="5-正则匹配原则（贪心匹配原则）-量词"><a href="#5-正则匹配原则（贪心匹配原则）-量词" class="headerlink" title="5. 正则匹配原则（贪心匹配原则） 量词"></a>5. 正则匹配原则（贪心匹配原则） <strong>量词</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">n+         匹配任何包含至少一个n的字符串</span><br><span class="line">n*         匹配任何包含零个或多个n的字符串</span><br><span class="line">n?         匹配任何包含零个或一个n的字符串</span><br><span class="line">n&#123;x&#125;       匹配包含x个n的序列的字符串</span><br><span class="line">n&#123;x,y&#125;     匹配包含x至y个n的序列的字符串</span><br><span class="line">n&#123;x,&#125;      匹配包含至少x个n的字符串</span><br><span class="line">n$         匹配任何结尾为n的字符串</span><br><span class="line">^n         匹配任何开头为n的字符串</span><br><span class="line">?=n        匹配任何其后紧接指定字符串n的字符串</span><br><span class="line">?!n        匹配任何其后紧接非指定字符串n的字符串</span><br></pre></td></tr></table></figure>
<h5 id="6-RegExp对象属性"><a href="#6-RegExp对象属性" class="headerlink" title="6. RegExp对象属性"></a>6. RegExp对象属性</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ignoreCase  RegExp对象是否具有标志i</span><br><span class="line">global      RegExp对象是否具有标志g</span><br><span class="line">multiline   RegExp对象是否具有标志m</span><br><span class="line">lastIndex   一个整数，表示开始下一次匹配的字符位置</span><br><span class="line">source      正则表达式的原文本</span><br></pre></td></tr></table></figure>
<h4 id="三、进阶"><a href="#三、进阶" class="headerlink" title="三、进阶"></a>三、进阶</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. \2、\1 反向子表达式引用</span><br><span class="line">2. 正向预查功能 ?= </span><br><span class="line">   (?: )不记录该子表达式的内容</span><br></pre></td></tr></table></figure>
<h3 id="2-json"><a href="#2-json" class="headerlink" title="2.json"></a><font color="DodgerBlue">2.json</font></h3><p>json是一种传输数据的格式（以对象为模板，本质上就是对象，但用途有区别。对象就是本地使用的数据类型，json是用来传输数据的数据类型）</p>
<div class="border1"><font color="red">JSON.parse();</font> string -&gt; json<br><font color="red">JSON.stringify();</font> json -&gt; string</div>

<h3 id="3-异步加载js"><a href="#3-异步加载js" class="headerlink" title="3.异步加载js"></a><font color="DodgerBlue">3.异步加载js</font></h3><h4 id="一、js同步加载"><a href="#一、js同步加载" class="headerlink" title="一、js同步加载"></a>一、js同步加载</h4><ol>
<li>js加载的缺点：加载工具方法没必要阻塞文档，使得js加载会影响页面效率，一旦网速不好，那么整个网站将等待js加载而不进行后续渲染等工作。</li>
<li>js加载不能满足的需求：有些工具方法需要按需加载，用到时再加载，不用时不加载。</li>
<li>页面解析：加载一行，解析一行，遇到&lt; link &gt;标签，开启一个新线程，异步加载css。</li>
</ol>
<h4 id="二、js异步加载"><a href="#二、js异步加载" class="headerlink" title="二、js异步加载"></a>二、js异步加载</h4><ol>
<li><p>javascript异步加载的三种方案：<br> 1） defer异步加载，但要等到dom文档全部解析完才会被执行（只有IE能用。执行时不阻塞页面）</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">".../xxx.js"</span> defer/async&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p> 2） async异步加载，加载完就执行<br> （async只能加载外部脚本，不能将js写在script标签里，w3c标准。执行时不阻塞页面）<br> 3） 创建script，插入到DOM中，onload，兼容，加载完毕后callBack。( 按需加载 ）</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var cb = &#123;</span><br><span class="line">        <span class="built_in">test</span>:<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">            console.log(<span class="string">"回调函数"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> loadScript(url,callback)&#123;</span><br><span class="line">        var oScript = docuemnt.createElement(<span class="string">'script'</span>);</span><br><span class="line">        oScript.src=url;</span><br><span class="line">        <span class="keyword">if</span>(oScript.readyState)&#123;</span><br><span class="line">            oScript.onreadystatechange = <span class="function"><span class="title">function</span></span>()&#123;//IE</span><br><span class="line">                <span class="keyword">if</span>(oScript.readyState == <span class="string">'complete'</span> || oScript.readyState == <span class="string">'loaded'</span>)&#123;</span><br><span class="line">                    oScript.onreadystatechange = null;</span><br><span class="line">                    cb[callback]();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            oScript.onload = <span class="function"><span class="title">function</span></span>()&#123;//非IE</span><br><span class="line">                oScript.onload = null;</span><br><span class="line">                cb[callback]();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        document.body.appendChild(oScript);</span><br><span class="line">    &#125;</span><br><span class="line">    loadScript(<span class="string">"xxx.js"</span>,<span class="string">"test"</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="4-js加载时间线"><a href="#4-js加载时间线" class="headerlink" title="4.js加载时间线"></a><font color="DodgerBlue">4.js加载时间线</font></h3><ol>
<li>创建Document对象，开始解析页面。解析HTML元素和他们的文本内容后，添加Element对象和Text节点到文档中，这个阶段document.readyState = ‘loading’。</li>
<li>遇到link外部css，创建线程加载，并继续解析文档。</li>
<li>遇到script外部js并且没有设置defer或async，浏览器加载并阻塞，等待js加载完成并执行该脚本后，继续解析文档。</li>
<li>遇到script外部js并且有设置defer或async，浏览器创建线程加载，并继续解析文档。对于async属性，脚本加载完成后立即执行（异步禁止使用document.write）</li>
<li>遇到img等，先正常解析dom结构，然后浏览器开始加载src，并继续解析文档。</li>
<li>当文档解析完成，document.readyState=’interactive’（document.onreadystatechange）</li>
<li>文档解析完成后，所有设置有defer的脚本会按照顺序执行（注：与async不同，但同样禁止document.write）</li>
<li>document对象触发DOMContentloaded事件，这也标志着程序执行从同步脚本执行阶段，转换为事件驱动阶段（document.addEventListener）</li>
<li>当所有async的脚本加载完成并执行后、img等加载完成后，docuemnt.readyState = ‘complete’，window对象触发load事件。</li>
<li>从此，以异步响应方式处理用户输入，网络事件等。<br><font color="red">docuemnt.write()能清除文档流，故异步加载禁止使用document.write()</font><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    console.log(<span class="string">"1.开始解析页面，document.readyState的值为"</span>,document.readyState,<span class="string">", 2 3 4 5 解析html,css,js,img等"</span>);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    document.addEventListener(<span class="string">'DOMContentLoaded'</span>,<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        console.log(<span class="string">"8. document对象触发DOMContentloaded事件，这也标志着程序执行从同步脚本执行阶段，转换为事件驱动阶段（document.addEventListener）"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    document.onreadystatechange = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        <span class="keyword">if</span>(document.readyState == <span class="string">"interactive"</span>)&#123;</span><br><span class="line">            console.log(<span class="string">"6.当页面解析完成后，onreadystatechange事件中document.readyState变为"</span>,document.readyState,<span class="string">"，7.defer执行"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(document.readyState == <span class="string">"complete"</span>)&#123;</span><br><span class="line">            console.log(<span class="string">"9.onreadystatechange事件中document.readyState变为"</span>,document.readyState);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    document.addEventListener(<span class="string">'DOMContentLoaded'</span>,<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        console.log(<span class="string">"8. document对象触发DOMContentloaded事件，这也标志着程序执行从同步脚本执行阶段，转换为事件驱动阶段（document.addEventListener）"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    window.onload = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        console.log(<span class="string">"9.window对象触发load事件"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(<span class="string">"1.开始解析页面，document.readyState的值为"</span>,document.readyState,<span class="string">", 2 3 4 5 解析html,css,js,img等"</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><div></div></p>
<script>
    console.log("1.开始解析页面，document.readyState的值为",document.readyState,", 2 3 4 5 解析html,css,js,img等");
</script>
<script>
    document.addEventListener('DOMContentLoaded',function(){
        console.log("8. document对象触发DOMContentloaded事件，这也标志着程序执行从同步脚本执行阶段，转换为事件驱动阶段（document.addEventListener）");
    })
    document.onreadystatechange = function(){
        if(document.readyState == "interactive"){
            console.log("6.当页面解析完成后，onreadystatechange事件中document.readyState变为",document.readyState,"，7.defer执行");
        }else if(document.readyState == "complete"){
            console.log("9.onreadystatechange事件中document.readyState变为",document.readyState);
        }
    }
    document.addEventListener('DOMContentLoaded',function(){
        console.log("8. document对象触发DOMContentloaded事件，这也标志着程序执行从同步脚本执行阶段，转换为事件驱动阶段（document.addEventListener）");
    })
    window.onload = function(){
        console.log("9.window对象触发load事件");
    }
    console.log("1.开始解析页面，document.readyState的值为",document.readyState,", 2 3 4 5 解析html,css,js,img等");
</script>

<p><div class="border1">URL：<a href="https://www.baidu.com/s?ie-utf-88&amp;f=3&amp;rsv_bp=1" target="_blank" rel="noopener">https://www.baidu.com/s?ie-utf-88&amp;f=3&amp;rsv_bp=1</a></div></p>
<font color="red">资源定位符：</font>协议名(https)  主机名(域名 <a href="http://www.baidu.com&nbsp;&nbsp;路径(/s)&nbsp;&nbsp;参数名=参数值(ie-utf-88)" target="_blank" rel="noopener">www.baidu.com&nbsp;&nbsp;路径(/s)&nbsp;&nbsp;参数名=参数值(ie-utf-88)</a><br><br><font color="blue">DNS -&gt; IP -&gt; 服务端 -&gt; 客户端</font>





<h3 id="5-DOCTYPE"><a href="#5-DOCTYPE" class="headerlink" title="5.DOCTYPE"></a>5.DOCTYPE</h3><ol>
<li>渲染模式：标准模式、混杂模式（怪异模式）</li>
<li>三种标准模式的写法：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC <span class="string">"-//W3C//DTD HTML 4.01//EN"</span> <span class="string">"http://www.w3.org/TR/html4/strict.dtd"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD XHTML 1.0 Strict//EN"</span> <span class="string">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="6-for属性-gt-js中表示htmlFor"><a href="#6-for属性-gt-js中表示htmlFor" class="headerlink" title="6.for属性 -&gt; js中表示htmlFor"></a>6.<label>for属性 -&gt; js中表示htmlFor</label></h3><p>属性映射HTML属性，映射到Element属性<br>img图片预加载<br>byClassName自己定义的写法<br>Math.random和彩票程序（0-36的随机数）</p>
<h3 id="7-文档碎片"><a href="#7-文档碎片" class="headerlink" title="7.文档碎片"></a>7.文档碎片</h3><p>CDN<br>断点调试<br>typeof(new Array).<strong>proto</strong>.constructor();<br>forEach里不能用break</p>
<p><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></p>
<h1 id="第二章、-ES-6"><a href="#第二章、-ES-6" class="headerlink" title="第二章、 ES 6"></a><font color="#DC143C">第二章、 ES 6</font></h1><h2 id="第一节、-块级作用域"><a href="#第一节、-块级作用域" class="headerlink" title="第一节、 块级作用域"></a><font color="#FF69B4">第一节、 块级作用域</font></h2><blockquote>
<p>ES5，以function来划分作用域，但是{}却限定不了var的作用域。<br>ES6，增加了let和const，声明在{} -&gt; “function、if、for等”的变量作用域被限制在块级</p>
</blockquote>
<h3 id="let-和-const"><a href="#let-和-const" class="headerlink" title="let 和 const"></a>let 和 const</h3><blockquote>
<p>生命周期在块级作用域中<br>没有变量提升，不可重复声明<br>let声明变量，const声明常量</p>
</blockquote>
<ul>
<li>块级作用域的出现，实际山使用广泛的立即执行匿名函数不在必要了。防止变量污染。<br></li>
</ul>
<h2 id="第二节、-解构赋值"><a href="#第二节、-解构赋值" class="headerlink" title="第二节、 解构赋值"></a><font color="#FF69B4">第二节、 解构赋值</font></h2><h3 id="1-本质上属于模式匹配，也就是只要等号两边的模式相同，左边的变量就会被赋予对应的值。"><a href="#1-本质上属于模式匹配，也就是只要等号两边的模式相同，左边的变量就会被赋予对应的值。" class="headerlink" title="1. 本质上属于模式匹配，也就是只要等号两边的模式相同，左边的变量就会被赋予对应的值。"></a>1. 本质上属于模式匹配，也就是只要等号两边的模式相同，左边的变量就会被赋予对应的值。</h3>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var [a, b, c] = [1, 2, 3];                  // 1, 2, 3</span><br><span class="line"><span class="built_in">let</span> [foo, [[bar], bax]] = [1, [[2], 3]];    // 1, 2, 3</span><br></pre></td></tr></table></figure>
<h3 id="2-解构失败则为undefined，也存在不完全解构。"><a href="#2-解构失败则为undefined，也存在不完全解构。" class="headerlink" title="2. 解构失败则为undefined，也存在不完全解构。"></a>2. 解构失败则为undefined，也存在不完全解构。</h3>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const [a, b, c] = [1];       // 1, undefined, undefined  解构失败</span><br><span class="line"><span class="built_in">let</span> [foo, [[bar], bax]] = [1, [[2, 3], 4]];  // 1, 2, 4  不完全解构</span><br></pre></td></tr></table></figure>
<h3 id="3-赋默认值（只有右侧严格等于undefined的时候才生效）。"><a href="#3-赋默认值（只有右侧严格等于undefined的时候才生效）。" class="headerlink" title="3. 赋默认值（只有右侧严格等于undefined的时候才生效）。"></a>3. 赋默认值（只有右侧严格等于undefined的时候才生效）。</h3>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const [a, b=123, c] = [1];   // 1, 123, undefined</span><br><span class="line"><span class="built_in">let</span> [foo=1] = [null];        // null</span><br><span class="line"></span><br><span class="line">// 惰性求值</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span> () &#123; <span class="built_in">return</span> <span class="string">'abc'</span>; &#125;</span><br><span class="line"><span class="built_in">let</span> [a=fn()] = [1];          // 1</span><br><span class="line"><span class="built_in">let</span> [b=fn()] = [];           // <span class="string">'abc'</span></span><br></pre></td></tr></table></figure>
<h3 id="4-对象的解构赋值-按照属性名来决定"><a href="#4-对象的解构赋值-按照属性名来决定" class="headerlink" title="4. 对象的解构赋值(按照属性名来决定)"></a>4. 对象的解构赋值(按照属性名来决定)</h3><ul>
<li><p>注意：一个已声明的变量用于解构赋值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var x;</span><br><span class="line">&#123; x &#125; = &#123; x: 1 &#125;;    // Uncaught SyntaxError: Unexpected token <span class="string">'='</span></span><br><span class="line">                     // js引擎会将&#123;x&#125;理解成一个代码块，从而发生语法错误</span><br><span class="line">(&#123; x &#125; = &#123; x: 1 &#125;);  // ()将其转换为表达式，从而避免上述语法问题</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果变量名和属性名不一致，必须（属性名不是变量，我们可以理解成一种模式）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var &#123; foo: bar &#125; = &#123; foo: 1,  bar: 2 &#125;;</span><br><span class="line">foo;       // Uncaught ReferenceError: foo is not defined</span><br><span class="line">bar;       // 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>和数组的解构赋值一样，对象的解构赋值也可嵌套</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; P: [<span class="string">'hello'</span>, &#123;y: <span class="string">'world'</span>&#125;] &#125;;</span><br><span class="line">var &#123; P: [x, &#123;y&#125;] &#125; = obj;</span><br><span class="line"></span><br><span class="line">obj;      // &#123;P: Array(2)&#125;</span><br><span class="line">x;        // <span class="string">'hello'</span></span><br><span class="line">y;        // <span class="string">'world'</span></span><br><span class="line">P;        // Uncaught ReferenceError: P is not defined</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var &#123; x, y=x, z &#125; = &#123; x: 1 &#125;;</span><br><span class="line">x;       // 1</span><br><span class="line">y;       // 1</span><br><span class="line">z;       // undefined</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="5-字符串的解构赋值，字符串会转化成一个类数组的对象"><a href="#5-字符串的解构赋值，字符串会转化成一个类数组的对象" class="headerlink" title="5. 字符串的解构赋值，字符串会转化成一个类数组的对象"></a>5. 字符串的解构赋值，字符串会转化成一个类数组的对象</h3>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var [a,b,c,d,e,f] = <span class="string">"hello"</span>;</span><br><span class="line">var &#123; length: len &#125; = <span class="string">"hello"</span>;</span><br><span class="line">a;      // h</span><br><span class="line">b;      // e</span><br><span class="line">c;      // l</span><br><span class="line">d;      // l</span><br><span class="line">e;      // o</span><br><span class="line">f;      // undefined</span><br><span class="line">len;    // 5</span><br></pre></td></tr></table></figure>
<h3 id="6-数值和布尔值的解构赋值，如果等号右边是数值或者布尔值，则会先转为对象"><a href="#6-数值和布尔值的解构赋值，如果等号右边是数值或者布尔值，则会先转为对象" class="headerlink" title="6. 数值和布尔值的解构赋值，如果等号右边是数值或者布尔值，则会先转为对象"></a>6. 数值和布尔值的解构赋值，如果等号右边是数值或者布尔值，则会先转为对象</h3>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var &#123; toString: a &#125; = 123;</span><br><span class="line">var &#123; toString: b &#125; = <span class="literal">true</span>;</span><br><span class="line">a;                                 // ƒ <span class="function"><span class="title">toString</span></span>() &#123; [native code] &#125;</span><br><span class="line">b;                                 // ƒ <span class="function"><span class="title">toString</span></span>() &#123; [native code] &#125;</span><br><span class="line">a === Number.prototype.toString;   // <span class="literal">true</span></span><br><span class="line">b === Boolean.prototype.toString;  // <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="7-函数参数的解构赋值"><a href="#7-函数参数的解构赋值" class="headerlink" title="7. 函数参数的解构赋值"></a>7. 函数参数的解构赋值</h3>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="built_in">test</span>(&#123; x=0, y=0 &#125; = &#123;&#125;) &#123;</span><br><span class="line">  console.log([x ,y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">test</span>(&#123;x: 1, y: 2&#125;);  // [1, 2]</span><br><span class="line"><span class="built_in">test</span>(&#123;x: 1&#125;);        // [1, 0]</span><br><span class="line"><span class="built_in">test</span>(&#123;&#125;);            // [0, 0]</span><br><span class="line"><span class="built_in">test</span>();              // [0, 0]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> move(&#123; x, y &#125; = &#123;x: 0, y: 0&#125;) &#123;</span><br><span class="line">  console.log([x ,y]);</span><br><span class="line">&#125;</span><br><span class="line">move(&#123;x: 1, y: 2&#125;);  // [1, 2]</span><br><span class="line">move(&#123;x: 1&#125;);        // [1, undefined]</span><br><span class="line">move(&#123;&#125;);            // [undefined, undefined]</span><br><span class="line">move();              // [0, 0]</span><br></pre></td></tr></table></figure>
<h3 id="8-解构赋值的应用"><a href="#8-解构赋值的应用" class="headerlink" title="8. 解构赋值的应用"></a>8. 解构赋值的应用</h3><ul>
<li><p>交换变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">var b = 2;</span><br><span class="line">[a, b] = [b, a];</span><br><span class="line">a, b;            // 2, 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数参数的定义</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> fn (&#123;x=1, y, z&#125; = &#123;&#125;)&#123;console.log(x, y, z);&#125;</span><br><span class="line">fn();    // 1, undefined, undefined</span><br></pre></td></tr></table></figure>
</li>
<li><p>从函数中返回多个值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">example</span></span> () &#123;</span><br><span class="line">  <span class="built_in">return</span> [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line">const [a, b, c] = example();</span><br><span class="line">a, b, c           // 1, 2, 3</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>提交数据<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var jsonData = &#123;</span><br><span class="line">  id: 42,</span><br><span class="line">  status: 2000,</span><br><span class="line">&#125;;</span><br><span class="line">const &#123; id, status &#125; = jsonData;</span><br><span class="line">id, status;       // 42, 2000</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="第三节、-数组扩展"><a href="#第三节、-数组扩展" class="headerlink" title="第三节、 数组扩展"></a><font color="#FF69B4">第三节、 数组扩展</font></h2><h3 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h3><p>用于将两类对象转化为真正的数组</p>
<ol>
<li>类数组 （所谓类似数组的兑现个，本质上必须有length属性）</li>
<li>可遍历对象 （ES6新增Set和Map两种数据结构）</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var sameArr = &#123;</span><br><span class="line">  0: 1,</span><br><span class="line">  a: <span class="string">'b'</span>,</span><br><span class="line">  5: <span class="string">'c'</span>,</span><br><span class="line">  length: 6,</span><br><span class="line">  splice: <span class="function"><span class="title">function</span></span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">var arr = Array.from(sameArr);</span><br><span class="line"></span><br><span class="line">sameArr       // Object(6) [1, empty × 4, <span class="string">"c"</span>, a: <span class="string">"b"</span>, splice: ƒ]</span><br><span class="line">                 0: 1 5: <span class="string">"c"</span> a: <span class="string">"b"</span> length: 6 splice: ƒ ()__proto__: Object </span><br><span class="line"></span><br><span class="line">arr;          // [1, undefined, undefined, undefined, undefined, <span class="string">"c"</span>]</span><br><span class="line"></span><br><span class="line">sameArr.forEach(item =&gt; console.log(item)); // Uncaught TypeError: sameArr.forEach is not a <span class="keyword">function</span></span><br><span class="line"></span><br><span class="line">arr.forEach(item =&gt; console.log(item)); // 1  undefined undefined undefined undefined  c</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Array.from 还接受第二个参数，作用类似于数组的map方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = Array.from(sameArr, (item) =&gt; item + 123);</span><br><span class="line">arr;           // [124, NaN, NaN, NaN, NaN, <span class="string">"c123"</span>]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = new Array();            // [undefined * 10]</span><br><span class="line">var arr1 = Array.of(10, 2, 3);    // [10, 2, 3]</span><br></pre></td></tr></table></figure>
<h3 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin()"></a>copyWithin()</h3><p>  在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原来成员），然后返回当前数组，也就是说，copyWithin()方法会修改当前数组。</p>
<ul>
<li>接受三个参数：<br>target（必需）：从该位置开始替换数据<br>start（可选）：从该位置开始读取数据，默认为0，如果为负值，表示倒数。<br>end（可选）：到该位置前停止读取数据，默认等于数组长度，如果为负值，表示倒数。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];</span><br><span class="line">arr.copyWithin(0, 2, 4);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="find-和-findIndex"><a href="#find-和-findIndex" class="headerlink" title="find() 和 findIndex()"></a>find() 和 findIndex()</h3><ul>
<li>find       用于找出第一个符合条件的数组成员。没有则返回undefined。<br>findIndex  类似，返回第一个符合条件的数组成员的位置。没有则返回-1。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];</span><br><span class="line">var newArr = arr.find((item) =&gt; item &gt; 5);         // 6</span><br><span class="line">var newIndex = arr.findIndex((item) =&gt; item &gt; 5);  // 5</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h3><p>填充数组<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4, 5];</span><br><span class="line">arr.fill(<span class="string">'a'</span>);                // [<span class="string">"a"</span>, <span class="string">"a"</span>, <span class="string">"a"</span>, <span class="string">"a"</span>, <span class="string">"a"</span>]</span><br><span class="line">arr.fill(<span class="string">'a'</span>, 2);             // [1, 2, <span class="string">"a"</span>, <span class="string">"a"</span>, <span class="string">"a"</span>]</span><br><span class="line">arr.fill(<span class="string">'a'</span>, 2, 4);          // [1, 2, <span class="string">"a"</span>, <span class="string">"a"</span>, 5]</span><br></pre></td></tr></table></figure></p>
<h3 id="entries-keys-valueof"><a href="#entries-keys-valueof" class="headerlink" title="entries() keys() valueof()"></a>entries() keys() valueof()</h3><p>ES6提供三个新的方法 – entries, keys()和values() – 用于遍历数组。它们都返回一个遍历器对象，可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历,values()是对键值的遍历，entries()是对键值对的遍历。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 0 1</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> index of [<span class="string">'a'</span>, <span class="string">'b'</span>].keys()) &#123; console.log(index); &#125;</span><br><span class="line"></span><br><span class="line">// <span class="string">'a'</span> <span class="string">'b'</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> elem of [<span class="string">'a'</span>, <span class="string">'b'</span>].values()) &#123; console.log(elem); &#125;</span><br><span class="line"></span><br><span class="line">// 0 <span class="string">"a"</span>    1 <span class="string">"b"</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> [index, elem] of [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123; console.log(index, elem); &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h3><p>某个数组是否包含给定的值，与字符串的includes方法类似。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, NaN];</span><br><span class="line">console.log(arr.indexOf(<span class="string">'c'</span>));    // 2</span><br><span class="line">console.log(arr.indexOf(NaN));    // -1    NaN不等于NaN</span><br><span class="line">console.log(arr.includes(<span class="string">'c'</span>));   // <span class="literal">true</span></span><br><span class="line">console.log(arr.includes(NaN));   // <span class="literal">true</span>  includes没有这个问题</span><br></pre></td></tr></table></figure></p>
<h2 id="第四节、-对象扩展"><a href="#第四节、-对象扩展" class="headerlink" title="第四节、 对象扩展"></a><font color="#FF69B4">第四节、 对象扩展</font></h2><h3 id="1-属性"><a href="#1-属性" class="headerlink" title="1. 属性"></a>1. 属性</h3><p>ES6 允许直接写入变量和函数，作为对象的属性和方法。（ES6允许在对象中，只写属性名不写属性值，这时属性值等于属性名所代表的的变量）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123; name&#125;;                                 // &#123;name: <span class="string">""</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const name = <span class="string">'hahaha'</span>;</span><br><span class="line">const obj = &#123; name &#125;;                                // &#123;name: <span class="string">"hahaha"</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const name = <span class="function"><span class="title">function</span></span>()&#123;sonsole.log(<span class="string">'name:test'</span>);&#125;;</span><br><span class="line">const obj = &#123; name &#125;;                                // &#123;name: ƒ&#125;</span><br><span class="line"></span><br><span class="line">const obj = &#123; <span class="function"><span class="title">name</span></span>()&#123;console.log(<span class="string">'name:test'</span>);&#125; &#125;;   // &#123;name: ƒ&#125;</span><br></pre></td></tr></table></figure></p>
<p>属性表达式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const name = <span class="string">'test'</span>;</span><br><span class="line">const obj = &#123;             // &#123;<span class="built_in">test</span>: <span class="string">"haha"</span>, test1: <span class="string">"heihei"</span>, test2: <span class="string">"houhou"</span>&#125;</span><br><span class="line">  [name]: <span class="string">'haha'</span>,</span><br><span class="line">  [name+<span class="string">'1'</span>]: <span class="string">'heihei'</span>,</span><br><span class="line">  [name+<span class="string">'2'</span>]: <span class="string">'houhou'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-Object-is"><a href="#2-Object-is" class="headerlink" title="2. Object.is()"></a>2. Object.is()</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+0 === -0              // <span class="literal">true</span></span><br><span class="line">NaN === NaN            // <span class="literal">false</span></span><br><span class="line">Object.is(+0, -0);     // <span class="literal">false</span></span><br><span class="line">Object.is(NaN, NaN);   // <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="3-Object-assign"><a href="#3-Object-assign" class="headerlink" title="3. Object.assign()"></a>3. Object.assign()</h3><p>对象合并（浅拷贝）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const a = &#123; a: 1, b: <span class="string">'xxx'</span> &#125;;</span><br><span class="line">const b = &#123; b: <span class="string">'bbb'</span>, c: &#123; d: 1, e: 2 &#125; &#125;;</span><br><span class="line">const f = &#123; c: &#123; d: 2, e: 2, g: 3 &#125;, h: <span class="string">'hahaha'</span> &#125;;</span><br><span class="line"></span><br><span class="line">Object.assign(f, b, a);   // &#123;c: &#123;&#123;d: 1, e: 2&#125;&#125;, h: <span class="string">"hahaha"</span>, b: <span class="string">"xxx"</span>, a: 1&#125;</span><br></pre></td></tr></table></figure></p>
<font size="1">$.extend({}) 扩展<br>$.extend({}, {}) 浅拷贝<br>$.extend(true, {}, {}) 深拷贝</font>

<h3 id="4-Object-entries-Object-keys-Object-valueof"><a href="#4-Object-entries-Object-keys-Object-valueof" class="headerlink" title="4. Object.entries()  Object.keys()  Object.valueof()"></a>4. Object.entries()  Object.keys()  Object.valueof()</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123; b: <span class="string">'bbb'</span>, c: &#123; d: 1, e: 2 &#125; &#125;;</span><br><span class="line">  </span><br><span class="line">Object.keys(obj);      // [<span class="string">"b"</span>, <span class="string">"c"</span>]</span><br><span class="line">Object.values(obj);    // [<span class="string">"bbb"</span>, &#123;d: 1, e: 2&#125;]</span><br><span class="line">Object.entries(obj);   // [[<span class="string">"b"</span>, <span class="string">"bbb"</span>], [<span class="string">"c"</span>, &#123;d: 1, e: 2&#125;]]</span><br></pre></td></tr></table></figure>
<h3 id="5-Object-getPrototypeOf-Object-setPrototypeOf"><a href="#5-Object-getPrototypeOf-Object-setPrototypeOf" class="headerlink" title="5. Object.getPrototypeOf()   Object.setPrototypeOf()"></a>5. Object.getPrototypeOf()   Object.setPrototypeOf()</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123; a: 1 &#125;;</span><br><span class="line">const obj1 = &#123; b: <span class="function"><span class="title">function</span></span>()&#123;console.log(<span class="string">'bbb'</span>);&#125; &#125;;</span><br><span class="line"></span><br><span class="line">obj.__proto__ = obj1;</span><br><span class="line">Object.setPrototypeOf(obj, obj1);</span><br><span class="line"></span><br><span class="line">obj.b();                              // <span class="string">'bbb'</span></span><br><span class="line">Object.getPrototypeOf(obj);           // &#123;b: ƒ&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-扩展运算符-…"><a href="#6-扩展运算符-…" class="headerlink" title="6. 扩展运算符 …"></a>6. 扩展运算符 …</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1,2,3];</span><br><span class="line">const arr1 = [...arr, <span class="string">'c'</span>];      // [1, 2, 3, <span class="string">"c"</span>]</span><br></pre></td></tr></table></figure>
<h2 id="第五节、-函数扩展"><a href="#第五节、-函数扩展" class="headerlink" title="第五节、 函数扩展"></a><font color="#FF69B4">第五节、 函数扩展</font></h2><h3 id="1-扩展运算符-…"><a href="#1-扩展运算符-…" class="headerlink" title="1. 扩展运算符 …"></a>1. 扩展运算符 …</h3><p>ES6韵如rest参数（形式为“…变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const a = (...values) =&gt; &#123;console.log(values);&#125;</span><br><span class="line">a(1,2,3,4,5);     // [1,2,3,4,5]</span><br><span class="line"></span><br><span class="line">const a = (a, ...values) =&gt; &#123;console.log(values);&#125;</span><br><span class="line">a(1,2,3,4,5);     // [2,3,4,5]</span><br></pre></td></tr></table></figure></p>
<h3 id="2-箭头函数"><a href="#2-箭头函数" class="headerlink" title="2. 箭头函数"></a>2. 箭头函数</h3><ol>
<li>箭头函数内的this值不会改变<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">const id = 10;</span><br><span class="line">const fn = () =&gt; &#123;console.log(this.id);&#125;   // this指向window</span><br><span class="line">const obj = &#123; id: 20, fn &#125;;</span><br><span class="line">const obj1 = &#123; id: 30 &#125;;</span><br><span class="line">fn();                          // undefined</span><br><span class="line">obj.fn();                      // undefined</span><br><span class="line">obj.fn.call(obj1);             // undefined</span><br><span class="line"></span><br><span class="line">var id = 10;</span><br><span class="line">const fn = () =&gt; &#123;console.log(this.id);&#125;</span><br><span class="line">const obj = &#123; id: 20, fn &#125;;</span><br><span class="line">const obj1 = &#123; id: 30 &#125;;</span><br><span class="line">fn();                          // 10</span><br><span class="line">obj.fn();                      // 10</span><br><span class="line">obj.fn.call(obj1);             // 10</span><br><span class="line"></span><br><span class="line">var id = 10;</span><br><span class="line">const fn = () =&gt; &#123;this.id = 1; console.log(this.id);&#125;</span><br><span class="line">const obj = &#123; id: 20, fn &#125;;</span><br><span class="line">const obj1 = &#123; id: 30 &#125;;</span><br><span class="line">fn();                          // 1</span><br><span class="line">obj.fn();                      // 1</span><br><span class="line">obj.fn.call(obj1);             // 1</span><br><span class="line"></span><br><span class="line">const id = 10;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span> () &#123;console.log(this.id);&#125;</span><br><span class="line">const obj = &#123; id: 20, fn  &#125;;</span><br><span class="line">const obj1 = &#123; id: 30 &#125;;</span><br><span class="line">obj.fn();                      // 20</span><br><span class="line">obj.fn.call(obj1);             // 30</span><br><span class="line"></span><br><span class="line">const fn1 = obj.fn;</span><br><span class="line">fn1();                         // undefined</span><br><span class="line"></span><br><span class="line">const fn2 = obj.fn.bind(obj1);</span><br><span class="line">fn2();                         // 30</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>全局定义的const和let不会被挂载到全局对象（如window）下，而是存在于块作用域（Script）中。<br>我们可以用debugger在控制台测一下</p>
<p>这里不是太理解，埋个？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 定义时</span><br><span class="line">const id = 10;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span> () &#123;setTimeout(<span class="function"><span class="title">function</span></span>()&#123;console.log(this.id)&#125;, 0);&#125;       // undefined</span><br><span class="line">const obj1 = &#123; id: 30 &#125;;</span><br><span class="line">fn.call(obj1);</span><br><span class="line"></span><br><span class="line">const id = 10;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span> () &#123;setTimeout(()=&gt;console.log(this.id), 0);&#125;               // 30</span><br><span class="line">const obj1 = &#123; id: 30 &#125;;</span><br><span class="line">fn.call(obj1);</span><br></pre></td></tr></table></figure></p>
<h2 id="第六节、-类-class"><a href="#第六节、-类-class" class="headerlink" title="第六节、 类  class"></a><font color="#FF69B4">第六节、 类  class</font></h2><h3 id="class基本语法"><a href="#class基本语法" class="headerlink" title="class基本语法"></a>class基本语法</h3><blockquote>
<p>JS的传统方法是通过构造函数，定义并生成新对象。<br>构造函数的prototype属性，在ES6的类上面继续存在（事实上，类的所有方法都定义在类的prototype属性上）。<br>类的内部所有定义的方法都是不可枚举的。<br>类的实例共享一个原型对象。<br>class 的本质是 function。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123; // 不写默认为&#123;&#125;</span><br><span class="line">    this.name = <span class="string">'Person Class'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">operate</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">'laugh smile cry fire happy sad'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const child = new Person(); // Person &#123;name: <span class="string">"Person Class"</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="class的继承"><a href="#class的继承" class="headerlink" title="class的继承"></a>class的继承</h3><p>extends supor<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Ancestors &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    this.level = <span class="string">'Ancestors Class'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">create</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'Creating the world'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Person extends Ancestors &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    super();  // 必须</span><br><span class="line">    this.name = <span class="string">'Person Class'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">operate</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">'laugh smile cry fire happy sad'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const child = new Person(); // Person &#123;level: <span class="string">"Ancestors Class"</span>, name: <span class="string">"Person Class"</span>&#125;</span><br><span class="line">child.operate();            // 可调用</span><br><span class="line">child.create();             // 可调用</span><br></pre></td></tr></table></figure></p>
<h3 id="class的静态方法-static"><a href="#class的静态方法-static" class="headerlink" title="class的静态方法 static"></a>class的静态方法 static</h3><p>不需要实例化。 ES6 中规定，Class 内部只有静态方法，没有静态属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.name = &apos;Person Class&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  operate()&#123;</span><br><span class="line">    console.log(&apos;laugh smile cry fire happy sad&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  static originLook() &#123;</span><br><span class="line">    console.log(&apos;nature is new&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const child = new Person();</span><br><span class="line">child.originLook();       // Uncaught TypeError: child.originLook is not a function</span><br></pre></td></tr></table></figure></p>
<h2 id="第七节、-Set-和-Map"><a href="#第七节、-Set-和-Map" class="headerlink" title="第七节、 Set 和 Map"></a><font color="#FF69B4">第七节、 Set 和 Map</font></h2><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><blockquote>
<p> ES6提供了新的数据结构Set，类似于数组，但是成员的值都是唯一的，没有重复的值。<br> Set本身是构造函数，用来生成Set数据结构，Set函数可以接受数组（或类数组）作为参数，用来初始化。<br>可以用来去除数组中重复的成员。</p>
</blockquote>
<blockquote>
<p>Set.prototype.constructor： 构造函数，默认就是Set函数<br>Set.prototype.size：返回Set实例的成员总数</p>
</blockquote>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1,2,3,3,3,2,1];</span><br><span class="line">const a = new Set(arr);                // Set(3) &#123;1, 2, 3&#125; </span><br><span class="line">const b = Array.from(new Set(arr));    // [1, 2, 3]   将Set结构转换为数组，也算是一种数组去重的方法</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Set数据的四个操作方法：<br>add()<br>delete()<br>has()<br>clear()</p>
</li>
<li><p>Set数据的四个遍历方法：<br>keys()<br>values()<br>entries()<br>forEach()</p>
</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。</p>
<h4 id="Maps-和-Objects-的区别"><a href="#Maps-和-Objects-的区别" class="headerlink" title="Maps 和 Objects 的区别"></a>Maps 和 Objects 的区别</h4><p>  一个 Object 的键只能是字符串或者 Symbols，但一个 Map 的<strong>键可以是任意值</strong>。<br>  Map 中的键值是<strong>有序</strong>的（FIFO 原则），而添加到对象中的键则不是。<br>  Map 的键值对个数可以从 <strong>size</strong> 属性获取，而 Object 的键值对个数只能手动计算。<br>  Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。</p>
<h4 id="key-可以是字符串、对象"><a href="#key-可以是字符串、对象" class="headerlink" title="key 可以是字符串、对象"></a>key 可以是字符串、对象</h4><ul>
<li><p>key 可以是字符串</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myMap = new Map();</span><br><span class="line">var keyString = <span class="string">"a string"</span>; </span><br><span class="line">myMap.set(keyString, <span class="string">"和键'a string'关联的值"</span>);</span><br><span class="line">myMap.get(keyString);         // <span class="string">"和键'a string'关联的值"</span></span><br><span class="line">myMap.get(<span class="string">"a string"</span>);        // <span class="string">"和键'a string'关联的值"</span>,因为 keyString === <span class="string">'a string'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>key 是对象</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myMap = new Map();</span><br><span class="line">var keyObj = &#123;&#125;, </span><br><span class="line">myMap.set(keyObj, <span class="string">"和键 keyObj 关联的值"</span>);</span><br><span class="line">myMap.get(keyObj);             // <span class="string">"和键 keyObj 关联的值"</span></span><br><span class="line">myMap.get(&#123;&#125;);                 // undefined, 因为 keyObj !== &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>key 是函数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myMap = new Map();</span><br><span class="line">var keyFunc = <span class="function"><span class="title">function</span></span> () &#123;&#125;;</span><br><span class="line">myMap.set(keyFunc, <span class="string">"和键 keyFunc 关联的值"</span>);</span><br><span class="line">myMap.get(keyFunc);              // <span class="string">"和键 keyFunc 关联的值"</span></span><br><span class="line">myMap.get(<span class="function"><span class="title">function</span></span>() &#123;&#125;)         // undefined, 因为 keyFunc !== <span class="function"><span class="title">function</span></span> () &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>key 是 NaN<br><em>虽然NaN和任何值甚至和自己都不相等，但是NaN作为Map的键来说是没有区别的。</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myMap = new Map();</span><br><span class="line">myMap.set(NaN, <span class="string">"not a number"</span>);</span><br><span class="line">myMap.get(NaN);                   // <span class="string">"not a number"</span></span><br><span class="line">var otherNaN = Number(<span class="string">"foo"</span>);</span><br><span class="line">myMap.get(otherNaN);              // <span class="string">"not a number"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Set数据的四个操作方法："><a href="#Set数据的四个操作方法：" class="headerlink" title="Set数据的四个操作方法："></a>Set数据的四个操作方法：</h4><p>  add()<br>  delete()<br>  has()<br>  clear()</p>
<h4 id="Set数据的四个遍历方法："><a href="#Set数据的四个遍历方法：" class="headerlink" title="Set数据的四个遍历方法："></a>Set数据的四个遍历方法：</h4><p>  keys()<br>  values()<br>  entries()<br>  forEach()</p>
<h2 id="第八节、-Promise"><a href="#第八节、-Promise" class="headerlink" title="第八节、 Promise"></a><font color="#FF69B4">第八节、 Promise</font></h2><p>Promise是异步编程的一种解决方案。</p>
<h3 id="1、Promise-的含义"><a href="#1、Promise-的含义" class="headerlink" title="1、Promise 的含义"></a>1、Promise 的含义</h3><p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。</p>
<ul>
<li><p><strong>对象的状态不受外界影响。</strong> Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>
</li>
<li><p><strong>一旦状态改变，就不会再变，任何时候都可以得到这个结果</strong>。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。<br>注意，为了行文方便，本章后面的resolved统一只指fulfilled状态，不包含rejected状态。</p>
</li>
</ul>
<h3 id="2、基本用法"><a href="#2、基本用法" class="headerlink" title="2、基本用法"></a>2、基本用法</h3><p>ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。</p>
<h2 id="第九节、-Iterator"><a href="#第九节、-Iterator" class="headerlink" title="第九节、 Iterator"></a><font color="#FF69B4">第九节、 Iterator</font></h2><h2 id="第十节、-Symbol"><a href="#第十节、-Symbol" class="headerlink" title="第十节、 Symbol"></a><font color="#FF69B4">第十节、 Symbol</font></h2><!-- 




1. function和箭头函数的区别
> this的指向： 使用function定义的函数，this的指向随着调用环境的变化而变化的，而箭头函数中的this指向是固定不变的，一直指向的是定义函数的环境。
>
> 构造函数： function是可以定义构造函数的，而箭头函数是不行的。
>
> 变量提升： 由于js的内存机制，function的级别最高，而用箭头函数定义函数的时候，需要var(let const定义的时候更不必说)关键词，而var所定义的变量不能得到变量提升，故箭头函数一定要定义于调用之前！

 -->

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/js/" rel="tag"># js</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/03/29/css/" rel="next" title="css">
                <i class="fa fa-chevron-left"></i> css
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/04/15/React/" rel="prev" title="React">
                React <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/background10.jpg" alt="Lemon">
            
              <p class="site-author-name" itemprop="name">Lemon</p>
              <p class="site-description motion-element" itemprop="description">乘风破浪</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第一章、-JS基础"><span class="nav-number">1.</span> <span class="nav-text">第一章、 JS基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第一节、基础概念"><span class="nav-number">1.1.</span> <span class="nav-text">第一节、基础概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第二节、ECMAScript"><span class="nav-number">1.2.</span> <span class="nav-text">第二节、ECMAScript</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、引入"><span class="nav-number">1.2.1.</span> <span class="nav-text">一、引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、基础语法"><span class="nav-number">1.2.2.</span> <span class="nav-text">二、基础语法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-变量（variable）"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">1. 变量（variable）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-值类型"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">2. 值类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-js语法基本规则"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">3. js语法基本规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-js运算符"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">4. js运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#运算符"><span class="nav-number">1.2.2.4.1.</span> <span class="nav-text">运算符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#类型转换"><span class="nav-number">1.2.2.4.2.</span> <span class="nav-text">类型转换</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-条件语句"><span class="nav-number">1.2.2.5.</span> <span class="nav-text">5. 条件语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-引用值"><span class="nav-number">1.2.2.6.</span> <span class="nav-text">6. 引用值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、复杂数据类型"><span class="nav-number">1.2.3.</span> <span class="nav-text">三、复杂数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1）函数"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">3.1）函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、预编译"><span class="nav-number">1.2.3.1.1.</span> <span class="nav-text">1、预编译</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、作用域"><span class="nav-number">1.2.3.1.2.</span> <span class="nav-text">2、作用域</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、闭包"><span class="nav-number">1.2.3.1.3.</span> <span class="nav-text">3、闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#闭包的作用"><span class="nav-number">1.2.3.1.3.1.</span> <span class="nav-text">闭包的作用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#闭包的高级应用"><span class="nav-number">1.2.3.1.3.2.</span> <span class="nav-text">闭包的高级应用</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、立即执行函数"><span class="nav-number">1.2.3.1.4.</span> <span class="nav-text">4、立即执行函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2）对象"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">3.2）对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、对象"><span class="nav-number">1.2.3.2.1.</span> <span class="nav-text">1、对象</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1）对象的创建方法"><span class="nav-number">1.2.3.2.1.1.</span> <span class="nav-text">1）对象的创建方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2）属性的增删改查"><span class="nav-number">1.2.3.2.1.2.</span> <span class="nav-text">2）属性的增删改查</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3）包装类"><span class="nav-number">1.2.3.2.1.3.</span> <span class="nav-text">3）包装类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4）对象的枚举"><span class="nav-number">1.2.3.2.1.4.</span> <span class="nav-text">4）对象的枚举</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、原型及原型链"><span class="nav-number">1.2.3.2.2.</span> <span class="nav-text">2、原型及原型链</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#原型"><span class="nav-number">1.2.3.2.2.1.</span> <span class="nav-text">原型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#原型链"><span class="nav-number">1.2.3.2.2.2.</span> <span class="nav-text">原型链</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、this指向问题"><span class="nav-number">1.2.3.2.3.</span> <span class="nav-text">3、this指向问题</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1）-call的实现原理"><span class="nav-number">1.2.3.2.3.1.</span> <span class="nav-text">1） call的实现原理</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2）apply的实现原理"><span class="nav-number">1.2.3.2.3.2.</span> <span class="nav-text">2）apply的实现原理</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3）bind的实现原理"><span class="nav-number">1.2.3.2.3.3.</span> <span class="nav-text">3）bind的实现原理</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、继承发展史"><span class="nav-number">1.2.3.2.4.</span> <span class="nav-text">4、继承发展史</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5、模块化开发"><span class="nav-number">1.2.3.2.5.</span> <span class="nav-text">5、模块化开发</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1）-命名空间"><span class="nav-number">1.2.3.2.5.1.</span> <span class="nav-text">1） 命名空间</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2）-匿名函数自执行-封闭作用域"><span class="nav-number">1.2.3.2.5.2.</span> <span class="nav-text">2） 匿名函数自执行 封闭作用域</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3）-链式调用模式"><span class="nav-number">1.2.3.2.5.3.</span> <span class="nav-text">3） 链式调用模式</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6、克隆"><span class="nav-number">1.2.3.2.6.</span> <span class="nav-text">6、克隆</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3）数组"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">3.3）数组</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#数组"><span class="nav-number">1.2.3.3.1.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#类数组"><span class="nav-number">1.2.3.3.2.</span> <span class="nav-text">类数组</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第三节、DOM"><span class="nav-number">1.3.</span> <span class="nav-text">第三节、DOM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、基本操作"><span class="nav-number">1.3.1.</span> <span class="nav-text">一、基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1）DOM节点"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">1.1）DOM节点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#对节点的查"><span class="nav-number">1.3.1.1.1.</span> <span class="nav-text">对节点的查</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#一、查看元素节点"><span class="nav-number">1.3.1.1.1.1.</span> <span class="nav-text">一、查看元素节点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#二、遍历节点树"><span class="nav-number">1.3.1.1.1.2.</span> <span class="nav-text">二、遍历节点树</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#三、基于元素节点树的遍历"><span class="nav-number">1.3.1.1.1.3.</span> <span class="nav-text">三、基于元素节点树的遍历</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#四、节点的属性和方法"><span class="nav-number">1.3.1.1.1.4.</span> <span class="nav-text">四、节点的属性和方法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#对节点的增删改"><span class="nav-number">1.3.1.1.2.</span> <span class="nav-text">对节点的增删改</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-DOM树"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">1.2) DOM树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-DOM基本操作"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">1.3) DOM基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#日期对象"><span class="nav-number">1.3.1.3.1.</span> <span class="nav-text">日期对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#js定时器"><span class="nav-number">1.3.1.3.2.</span> <span class="nav-text">js定时器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#查看滚动条的滚动距离"><span class="nav-number">1.3.1.3.3.</span> <span class="nav-text">查看滚动条的滚动距离</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#查看视口尺寸"><span class="nav-number">1.3.1.3.4.</span> <span class="nav-text">查看视口尺寸</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#查看元素的几何尺寸"><span class="nav-number">1.3.1.3.5.</span> <span class="nav-text">查看元素的几何尺寸</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#查看元素尺寸"><span class="nav-number">1.3.1.3.6.</span> <span class="nav-text">查看元素尺寸</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#查看元素位置"><span class="nav-number">1.3.1.3.7.</span> <span class="nav-text">查看元素位置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#让滚动条滚动"><span class="nav-number">1.3.1.3.8.</span> <span class="nav-text">让滚动条滚动</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4）脚本化css"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">1.4）脚本化css</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#读写元素css属性"><span class="nav-number">1.3.1.4.1.</span> <span class="nav-text">读写元素css属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#查询计算样式"><span class="nav-number">1.3.1.4.2.</span> <span class="nav-text">查询计算样式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#查询样式"><span class="nav-number">1.3.1.4.3.</span> <span class="nav-text">查询样式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、事件"><span class="nav-number">1.3.2.</span> <span class="nav-text">二、事件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#绑定事件处理函数"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">绑定事件处理函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解除事件处理函数"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">解除事件处理函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#事件冒泡-amp-捕获-gt-事件处理模型"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">事件冒泡&amp;捕获 -&gt; 事件处理模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#事件对象"><span class="nav-number">1.3.2.4.</span> <span class="nav-text">事件对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#事件委托"><span class="nav-number">1.3.2.5.</span> <span class="nav-text">事件委托</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#事件分类"><span class="nav-number">1.3.2.6.</span> <span class="nav-text">事件分类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第四节、BOM"><span class="nav-number">1.4.</span> <span class="nav-text">第四节、BOM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、概述"><span class="nav-number">1.4.1.</span> <span class="nav-text">一、概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、BOM对象"><span class="nav-number">1.4.2.</span> <span class="nav-text">二、BOM对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-window对象"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">1. window对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#window对象的属性"><span class="nav-number">1.4.2.1.1.</span> <span class="nav-text">window对象的属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#window对象的方法"><span class="nav-number">1.4.2.1.2.</span> <span class="nav-text">window对象的方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Navigator对象"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">2. Navigator对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Navigator对象集合：plugins"><span class="nav-number">1.4.2.2.1.</span> <span class="nav-text">Navigator对象集合：plugins[]</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Navigator对象属性"><span class="nav-number">1.4.2.2.2.</span> <span class="nav-text">Navigator对象属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Navigator对象方法"><span class="nav-number">1.4.2.2.3.</span> <span class="nav-text">Navigator对象方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Screen对象"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">3.Screen对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-History对象"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">4. History对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#History对象属性"><span class="nav-number">1.4.2.4.1.</span> <span class="nav-text">History对象属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#History对象方法"><span class="nav-number">1.4.2.4.2.</span> <span class="nav-text">History对象方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-Location对象"><span class="nav-number">1.4.2.5.</span> <span class="nav-text">5. Location对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Location对象属性"><span class="nav-number">1.4.2.5.1.</span> <span class="nav-text">Location对象属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Location对象方法"><span class="nav-number">1.4.2.5.2.</span> <span class="nav-text">Location对象方法</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第五节、零散知识点"><span class="nav-number">1.5.</span> <span class="nav-text">第五节、零散知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-正则表达式-RegExp（Regular-Expression）"><span class="nav-number">1.5.1.</span> <span class="nav-text">1.正则表达式 RegExp（Regular Expression）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、创建方式"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">一、创建方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、基础语法-1"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">二、基础语法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-compile-编译正则表达式"><span class="nav-number">1.5.1.2.1.</span> <span class="nav-text">1. compile  编译正则表达式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-支持正则表达式的String对象的方法"><span class="nav-number">1.5.1.2.2.</span> <span class="nav-text">2. 支持正则表达式的String对象的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-查找某法范围内的字符"><span class="nav-number">1.5.1.2.3.</span> <span class="nav-text">3.  [] 查找某法范围内的字符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-元字符-（Metacharacter）是有特殊含义的字符，简化操作。"><span class="nav-number">1.5.1.2.4.</span> <span class="nav-text">4. 元字符 （Metacharacter）是有特殊含义的字符，简化操作。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-正则匹配原则（贪心匹配原则）-量词"><span class="nav-number">1.5.1.2.5.</span> <span class="nav-text">5. 正则匹配原则（贪心匹配原则） 量词</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-RegExp对象属性"><span class="nav-number">1.5.1.2.6.</span> <span class="nav-text">6. RegExp对象属性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、进阶"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">三、进阶</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-json"><span class="nav-number">1.5.2.</span> <span class="nav-text">2.json</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-异步加载js"><span class="nav-number">1.5.3.</span> <span class="nav-text">3.异步加载js</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、js同步加载"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">一、js同步加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、js异步加载"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">二、js异步加载</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-js加载时间线"><span class="nav-number">1.5.4.</span> <span class="nav-text">4.js加载时间线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-DOCTYPE"><span class="nav-number">1.5.5.</span> <span class="nav-text">5.DOCTYPE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-for属性-gt-js中表示htmlFor"><span class="nav-number">1.5.6.</span> <span class="nav-text">6.for属性 -&gt; js中表示htmlFor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-文档碎片"><span class="nav-number">1.5.7.</span> <span class="nav-text">7.文档碎片</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二章、-ES-6"><span class="nav-number">2.</span> <span class="nav-text">第二章、 ES 6</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第一节、-块级作用域"><span class="nav-number">2.1.</span> <span class="nav-text">第一节、 块级作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#let-和-const"><span class="nav-number">2.1.1.</span> <span class="nav-text">let 和 const</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第二节、-解构赋值"><span class="nav-number">2.2.</span> <span class="nav-text">第二节、 解构赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-本质上属于模式匹配，也就是只要等号两边的模式相同，左边的变量就会被赋予对应的值。"><span class="nav-number">2.2.1.</span> <span class="nav-text">1. 本质上属于模式匹配，也就是只要等号两边的模式相同，左边的变量就会被赋予对应的值。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-解构失败则为undefined，也存在不完全解构。"><span class="nav-number">2.2.2.</span> <span class="nav-text">2. 解构失败则为undefined，也存在不完全解构。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-赋默认值（只有右侧严格等于undefined的时候才生效）。"><span class="nav-number">2.2.3.</span> <span class="nav-text">3. 赋默认值（只有右侧严格等于undefined的时候才生效）。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-对象的解构赋值-按照属性名来决定"><span class="nav-number">2.2.4.</span> <span class="nav-text">4. 对象的解构赋值(按照属性名来决定)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-字符串的解构赋值，字符串会转化成一个类数组的对象"><span class="nav-number">2.2.5.</span> <span class="nav-text">5. 字符串的解构赋值，字符串会转化成一个类数组的对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-数值和布尔值的解构赋值，如果等号右边是数值或者布尔值，则会先转为对象"><span class="nav-number">2.2.6.</span> <span class="nav-text">6. 数值和布尔值的解构赋值，如果等号右边是数值或者布尔值，则会先转为对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-函数参数的解构赋值"><span class="nav-number">2.2.7.</span> <span class="nav-text">7. 函数参数的解构赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-解构赋值的应用"><span class="nav-number">2.2.8.</span> <span class="nav-text">8. 解构赋值的应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第三节、-数组扩展"><span class="nav-number">2.3.</span> <span class="nav-text">第三节、 数组扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Array-from"><span class="nav-number">2.3.1.</span> <span class="nav-text">Array.from()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Array-of"><span class="nav-number">2.3.2.</span> <span class="nav-text">Array.of()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#copyWithin"><span class="nav-number">2.3.3.</span> <span class="nav-text">copyWithin()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#find-和-findIndex"><span class="nav-number">2.3.4.</span> <span class="nav-text">find() 和 findIndex()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fill"><span class="nav-number">2.3.5.</span> <span class="nav-text">fill()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#entries-keys-valueof"><span class="nav-number">2.3.6.</span> <span class="nav-text">entries() keys() valueof()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#includes"><span class="nav-number">2.3.7.</span> <span class="nav-text">includes()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第四节、-对象扩展"><span class="nav-number">2.4.</span> <span class="nav-text">第四节、 对象扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-属性"><span class="nav-number">2.4.1.</span> <span class="nav-text">1. 属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Object-is"><span class="nav-number">2.4.2.</span> <span class="nav-text">2. Object.is()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Object-assign"><span class="nav-number">2.4.3.</span> <span class="nav-text">3. Object.assign()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Object-entries-Object-keys-Object-valueof"><span class="nav-number">2.4.4.</span> <span class="nav-text">4. Object.entries()  Object.keys()  Object.valueof()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Object-getPrototypeOf-Object-setPrototypeOf"><span class="nav-number">2.4.5.</span> <span class="nav-text">5. Object.getPrototypeOf()   Object.setPrototypeOf()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-扩展运算符-…"><span class="nav-number">2.4.6.</span> <span class="nav-text">6. 扩展运算符 …</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第五节、-函数扩展"><span class="nav-number">2.5.</span> <span class="nav-text">第五节、 函数扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-扩展运算符-…"><span class="nav-number">2.5.1.</span> <span class="nav-text">1. 扩展运算符 …</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-箭头函数"><span class="nav-number">2.5.2.</span> <span class="nav-text">2. 箭头函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第六节、-类-class"><span class="nav-number">2.6.</span> <span class="nav-text">第六节、 类  class</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#class基本语法"><span class="nav-number">2.6.1.</span> <span class="nav-text">class基本语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#class的继承"><span class="nav-number">2.6.2.</span> <span class="nav-text">class的继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#class的静态方法-static"><span class="nav-number">2.6.3.</span> <span class="nav-text">class的静态方法 static</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第七节、-Set-和-Map"><span class="nav-number">2.7.</span> <span class="nav-text">第七节、 Set 和 Map</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Set"><span class="nav-number">2.7.1.</span> <span class="nav-text">Set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map"><span class="nav-number">2.7.2.</span> <span class="nav-text">Map</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Maps-和-Objects-的区别"><span class="nav-number">2.7.2.1.</span> <span class="nav-text">Maps 和 Objects 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#key-可以是字符串、对象"><span class="nav-number">2.7.2.2.</span> <span class="nav-text">key 可以是字符串、对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Set数据的四个操作方法："><span class="nav-number">2.7.2.3.</span> <span class="nav-text">Set数据的四个操作方法：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Set数据的四个遍历方法："><span class="nav-number">2.7.2.4.</span> <span class="nav-text">Set数据的四个遍历方法：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第八节、-Promise"><span class="nav-number">2.8.</span> <span class="nav-text">第八节、 Promise</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、Promise-的含义"><span class="nav-number">2.8.1.</span> <span class="nav-text">1、Promise 的含义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、基本用法"><span class="nav-number">2.8.2.</span> <span class="nav-text">2、基本用法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第九节、-Iterator"><span class="nav-number">2.9.</span> <span class="nav-text">第九节、 Iterator</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第十节、-Symbol"><span class="nav-number">2.10.</span> <span class="nav-text">第十节、 Symbol</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lemon</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
